{
  "benchmark": "javaeval_xc",
  "lastest_eval": {
    "compile@1": 0.5688442211055277,
    "pass@1": 0.3331658291457287,
    "compile@3": 0.7240368509212728,
    "pass@3": 0.44258793969849203,
    "compile@5": 0.7786950626146605,
    "pass@5": 0.48450586264656625
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }"
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null)\n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            result = new Double(duration.getDuration().doubleValue() / task.getDuration().getDuration().doubleValue() * 100);\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            Number startValue = getStartValue(rowKey, columnKey);\n            Number endValue = getEndValue(rowKey, columnKey);\n            if (startValue != null && endValue != null) {\n                long diff = endValue.longValue() - startValue.longValue();\n                result = new Double((task.getProgress() / (double) diff) * 100);\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            Number startValue = getStartValue(rowKey, columnKey);\n            Number endValue = getEndValue(rowKey, columnKey);\n            if (startValue != null && endValue != null) {\n                long startTime = startValue.longValue();\n                long endTime = endValue.longValue();\n                long current = System.currentTimeMillis();\n                if (current > endTime) {\n                    result = new Double(1.0);\n                } else if (current >= startTime) {\n                    result = new Double((current - startTime) /\n                            ((double) (endTime - startTime)));\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            Number start = getStartValue(rowKey, columnKey);\n            Number end = getEndValue(rowKey, columnKey);\n            if (start != null && end != null) {\n                result = new Double((end.doubleValue() - start.doubleValue()) / (duration.getEnd().getTime() - duration.getStart().getTime()));\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null)\n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null)\n        {\n            double start = duration.getStart().getTime();\n            double end = duration.getEnd().getTime();\n            double now = System.currentTimeMillis();\n            if (now <= start)\n            {\n                result = new Double(0.0);\n            }\n            else if (now >= end)\n            {\n                result = new Double(100.0);\n            }\n            else\n            {\n                result = new Double(((now - start) / (end - start)) * 100);\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            Number startValue = getStartValue(rowKey, columnKey);\n            Number endValue = getEndValue(rowKey, columnKey);\n            result = new Integer(((Number) endValue).intValue() - ((Number) startValue).intValue());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null)\n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null)\n        {\n            TimePeriod actualDuration = task.getActualDuration();\n            if (actualDuration != null)\n            {\n                long start = duration.getStart().getTime();\n                long end = duration.getEnd().getTime();\n                long actualEnd = actualDuration.getEnd().getTime();\n                result = new Double((actualEnd - start) * 100.0 / (end - start));\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null)\n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null)\n        {\n            result = new Float(task.getPercentComplete() / task.getDuration().getDuration());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null)\n    {\n        Number duration = task.getDuration();\n        if (duration != null)\n        {\n            TimePeriod actual = task.getActual();\n            if (actual != null)\n            {\n                Number actualStart = new Long(actual.getStart().getTime());\n                Number durationStart = new Long(duration.getStart().getTime());\n                result = new Float((actualStart.longValue() - durationStart.longValue()) / duration.longValue());\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            double percentComplete = task.getPercentComplete();\n            result = new Double(percentComplete);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) return this;\n    int index = indexOf(str);\n    if (index >= 0) deleteImpl(index, index + str.length(), str.length());\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    for (int i = 0; i < size; i++) \n    {\n        if (buffer[i] == str.charAt(0)) \n        {\n            int j = 1;\n            while (j < str.length() && i + j < size && str.charAt(j) == buffer[i + j]) \n            {\n                j++;\n            }\n            if (j == str.length()) \n            {\n                deleteImpl(i, i + j, j);\n                return this;\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n\n    int index = indexOf(str);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    return replaceFirst(str, null);\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) \n        return this;\n    return replaceFirst(str, null);\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        for (int i = 0; i < size; i++) \n        {\n            if (buffer[i] == str.charAt(0)) \n            {\n                boolean match = true;\n                for (int j = 1; j < len; j++) \n                {\n                    if (buffer[i + j] != str.charAt(j)) \n                    {\n                        match = false;\n                        break;\n                    }\n                }\n                if (match) \n                {\n                    deleteImpl(i, i + len, len);\n                    return this;\n                }\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    return replaceFirst(str, null);\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, true);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, true);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, true);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, true);\n}\n\n// IteratorIterable\nclass IteratorIterable<E> implements Iterable<E>",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getRowDimension() == 1)\n    {\n        final double[][] d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++)\n        {\n            d[0][c] = m.getEntry(0, c);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else if (m.getColumnDimension() == 1)\n    {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++)\n        {\n            d[r][0] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else\n    {\n        return new DiagonalMatrix(m.getData());\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getRowDimension() != m.getColumnDimension()) {\n        throw new IllegalArgumentException(\"Input matrix must be square\");\n    }\n    double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[r][c] = r == c ? m.getEntry(r, c) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getRowDimension() != m.getColumnDimension()) {\n        return m.getColumnVector(0);\n    } else {\n        double[][] d = new double[1][m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[0][r] = m.getEntry(r, r);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) \n    {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) \n        {\n            d[r][0] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } \n    else \n    {\n        final double[][] d = new double[m.getColumnDimension()][1];\n        for (int r = 0; r < m.getColumnDimension(); r++) \n        {\n            d[r][0] = m.getEntry(r, r);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) \n    {\n        final int r = m.getRowDimension();\n        final double[][] d = new double[r][r];\n        for (int i = 0; i < r; i++) \n        {\n            d[i][i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) \n    {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) \n        {\n            d[r][0] = m.getEntry(r, r);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else \n    {\n        throw new IllegalArgumentException(\"Matrix is not square\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getRowDimension() == 1)\n    {\n        final double[][] d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[0][c] = m.getEntry(0, c);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else if (m.getColumnDimension() == 1)\n    {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else \n    {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][r] = m.getEntry(r, r);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getRowDimension() == 1)\n    {\n        return new Array1DRowRealMatrix(m.getColumnDimension(), m.getColumn(0));\n    }\n    else if (m.getColumnDimension() == 1)\n    {\n        return new Array1DRowRealMatrix(m.getRowDimension(), m.getRow(0));\n    }\n    else\n    {\n        return new DiagonalMatrix(m.getRowDimension()).setInplace(m);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final double[][] d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[0][c] = m.getEntry(c, c);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1)\n    {\n        final int size = m.getRowDimension();\n        final double[][] d = new double[size][size];\n        for (int r = 0; r < size; r++) {\n            d[r][r] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else if (m.getRowDimension() == m.getColumnDimension())\n    {\n        final int size = m.getRowDimension();\n        final double[][] d = new double[size][1];\n        for (int r = 0; r < size; r++) {\n            d[r][0] = m.getEntry(r, r);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n    else \n    {\n        throw new IllegalArgumentException(\"m must be a column matrix or a square matrix.\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getRowDimension() != m.getColumnDimension()) \n    {\n        RealMatrix result = new Array2DRowRealMatrix(m.getColumnDimension(), 1);\n        for (int r = 0; r < m.getColumnDimension(); r++) \n        {\n            result.setEntry(r, 0, m.getEntry(r, r));\n        }\n        return result;\n    } \n    else \n    {\n        return new DiagonalMatrix(m.getData());\n    }\n}"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null)\n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers()))\n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible())\n    {\n        field.setAccessible(true);\n    }\n    else\n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    }\n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null)\n    {\n        throw new IllegalArgumentException(\"Field is null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"Field is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    }\n    else\n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null)\n    {\n        throw new IllegalArgumentException(\"Field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers()))\n    {\n        throw new IllegalArgumentException(\"Field is not static\");\n    }\n    if (forceAccess && !field.isAccessible())\n    {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return field.get(null);\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) {\n            return dtz;\n        }\n\n        int millisOffset = parseOffset(id);\n        if (millisOffset != 0) {\n            return forOffsetMillis(millisOffset);\n        }\n\n        throw new IllegalArgumentException(\"Unrecognised ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n\n        DateTimeZone dtz = null;\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n\n        if (dtz != null) {\n            return dtz;\n        }\n\n        if (id.length() >= 6 && id.charAt(0) == '+' || id.charAt(0) == '-') {\n            int offsetMillis = parseOffset(id);\n            return forOffsetMillis(offsetMillis);\n        }\n\n        throw new IllegalArgumentException(\"Invalid time zone id: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null)\n        {\n            return getDefault();\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        int offset = parseOffset(id);\n        if (offset != -1) {\n            return forOffsetMillis(offset);\n        }\n        throw new IllegalArgumentException(\"Invalid time zone id: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null)\n        {\n            return getDefault();\n        }\n        if (id.equalsIgnoreCase(\"UTC\"))\n        {\n            return UTC;\n        }\n        if (!cZoneIdConversion.containsKey(id))\n        {\n            synchronized (cZoneIdConversion) \n            {\n                if (!cZoneIdConversion.containsKey(id)) \n                {\n                    String adjustedId = getConvertedId(id);\n                    if (adjustedId != null)\n                    {\n                        DateTimeZone dtz = cProvider.getZone(adjustedId);\n                        if (dtz == null)\n                        {\n                            dtz = cProvider.getZone(id);\n                        }\n                        if (dtz == null)\n                        {\n                            if (id.charAt(0) == '+')\n                            {\n                                try\n                                {\n                                    dtz = forOffsetMillis(parseOffset(id));\n                                }\n                                catch (IllegalArgumentException e)\n                                {\n                                    throw new IllegalArgumentException(\"Invalid time zone id: \" + id, e);\n                                }\n                            }\n                            else\n                            {\n                                throw new IllegalArgumentException(\"Invalid time zone id: \" + id);\n                            }\n                        }\n                        cZoneIdConversion.put(id, id);\n                    }\n                    else\n                    {\n                        cZoneIdConversion.put(id, id);\n                    }\n                }\n            }\n        }\n        return cZoneIdConversion.get(id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n\n        if (id.equals(\"UTC\")) \n        {\n            return UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) \n        {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) \n        {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) \n        {\n            return dtz;\n        }\n\n        int millisOffset = parseOffset(id);\n        if (millisOffset != Integer.MIN_VALUE) \n        {\n            return forOffsetMillis(millisOffset);\n        }\n\n        // Fall back to default if nothing else recognized\n        return getDefault();\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        if (id.equalsIgnoreCase(\"UTC\")) \n        {\n            return DateTimeZone.UTC;\n        }\n        int idx = id.indexOf('+');\n        if (idx == -1) \n        {\n            idx = id.indexOf('-');\n        }\n        if (idx != -1) \n        {\n            return forOffsetHoursMinutes(parseOffset(id.substring(0, idx)), parseOffset(id.substring(idx + 1)));\n        }\n        idx = id.indexOf(':');\n        if (idx != -1) \n        {\n            return forOffsetHoursMinutes(parseOffset(id.substring(0, idx)), parseOffset(id.substring(idx + 1)));\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone == null) \n        {\n            throw new IllegalArgumentException(\"Unknown time zone: \" + id);\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException\n    {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equalsIgnoreCase(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.equals(DateTimeZone.UTC.getID())) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        if (id.length() > 5) {\n            // Check for fixed offset format\n            try {\n                int offsetMillis = parseOffset(id);\n                return forOffsetMillis(offsetMillis);\n            } catch (RuntimeException e) {\n                // Ignore, not the expected format\n            }\n        }\n        throw new IllegalArgumentException(\"Invalid time zone id: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n\n        // Check for an offset.\n        int offset;\n        if ((offset = parseOffset(id)) != -1) {\n            return forOffsetMillis(offset);\n        }\n\n        // Check for a registered zone.\n        DateTimeZone result = cProvider.getZone(id);\n        if (result != null) {\n            return result;\n        }\n\n        // Check for a converted id.\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            result = cProvider.getZone(convId);\n            if (result != null) {\n                return result;\n            }\n        }\n\n        // Check for a known fixed offset id.\n        result = iFixedOffsetCache.get(id);\n        if (result != null) {\n            return result;\n        }\n\n        // Check for a known short id.\n        result = cZoneIdConversion.get(id);\n        if (result != null) {\n            return cProvider.getZone(result);\n        }\n\n        // Check for a fixed offset.\n        int millisOffset = parseOffset(id);\n        if (millisOffset != -1) {\n            return fixedOffsetZone(id, millisOffset);\n        }\n\n        // Not a recognized id.\n        throw new IllegalArgumentException(\"Unrecognized time zone id: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Try parsing a fixed offset zone.\n        try {\n            int millisOffset = parseOffset(id);\n            if (millisOffset != 0) {\n                return forOffsetMillis(millisOffset);\n            }\n        } catch (IllegalArgumentException e) {\n            // Ignore, will throw exception later if necessary.\n        }\n        \n        throw new IllegalArgumentException(\"Invalid time zone id: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        int len = id.length();\n        if (len == 3) {\n            if (!id.equals(\"UTC\")) {\n                throw new IllegalArgumentException(\"Unknown time zone id: \" + id);\n            }\n            return UTC;\n        }\n        int offset;\n        if (id.charAt(0) == '+') {\n            offset = parseOffset(id.substring(1));\n        } else {\n            offset = -parseOffset(id.substring(1));\n        }\n        if (offset <= -MAX_MILLIS || offset >= MAX_MILLIS) {\n            throw new IllegalArgumentException(\"Offset must be in the range -23:59:59.999 to +23:59:59.999\");\n        }\n\n        String trimmed = id.substring(0, len - 6);\n        if (trimmed.length() == 0) {\n            trimmed = \"Etc/GMT\";\n        }\n        return forOffsetMillis(offset).withZone(new DateTimeZone(trimmed));\n    }"
    ],
    [
      "private Dfp multiplyFast(final int x)  if (x == 1) {\n        return this;\n    }\n\n    if (x == 2) {\n        Dfp result = newInstance(this);\n        for (int i=0; i<mant.length; i++) {\n            result.mant[i] = mant[i]*2;\n            if (result.mant[i] >= RADIX) {\n                if (i == mant.length-1) {\n                    field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n                    result.nans = QNAN;\n                    return dotrap(DfpField.FLAG_OVERFLOW, MULTIPLY_TRAP, newInstance(x), result);\n                } else {\n                    result.mant[i+1]++;\n                    result.mant[i] -= RADIX;\n                }\n            }\n        }\n        return result;\n    }\n\n    if (x == 5) {\n        Dfp result = newInstance(this);\n        for (int i=0; i<mant.length; i++) {\n            result.mant[i] = mant[i]*5;\n            if (result.mant[i] >= RADIX) {\n                if (i == mant.length-1) {\n                    field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n                    result.nans = QNAN;\n                    return dotrap(DfpField.FLAG_OVERFLOW, MULTIPLY_TRAP, newInstance(x), result);\n                } else {\n                    result.mant[i+1]++;\n                    result.mant[i] -= RADIX;\n                }\n            }\n        }\n        return result;\n    }\n\n    if (x == 10) {\n        Dfp result = newInstance(this);\n        for (int i=0; i<mant.length; i++) {\n            result.mant[i] = mant[i]*10;\n            if (result.mant[i] >= RADIX) {\n                if (i == mant.length-1) {\n                    field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n                    result.nans = QNAN;\n}\n}\n}\n}",
      "private Dfp multiplyFast(final int x)  {\n    int rl = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = rl*RADIX + mant[i] * x;\n        final int rh = r / RADIX;\n        rl = r - rh * RADIX;\n        mant[i] = rh;\n    }\n\n    if (rl != 0) {\n        for (int i = mant.length; i < maxExponent-MIN_EXP+2; i++) {\n            mant[i] = rl;\n            rl = 0;\n        }\n    }\n\n    if (rl != 0) {\n        field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n    }\n\n    return this;\n}",
      "private Dfp multiplyFast(final int x)  // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        // handle special cases\n        if (nans != FINITE || x.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (x.isNaN()) {\n                return x;\n            }\n\n            if (nans == INFINITE && x.nans == FINITE && x.mant[mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(x);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n\n            if (x.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x.sign);\n                return result;\n            }\n        }\n\n        // create new result\n        Dfp result = newInstance(getZero());\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + mant[i];\n            final int rh = r / x;\n            rl = r - rh * x;\n            result.mant[i] = rh;\n        }\n\n        if (rl != 0) {\n            for (int i = 0; i < result.mant.length; i++) {\n                if (result.mant[i] != 0) {\n                    md = i;\n                    break;\n                }\n            }\n\n}",
      "private Dfp multiplyFast(final int x)  {\n        final int r = mant[0] * x;\n        int rl = r & 0xffff;\n        int rh = r >>> 16;\n        for (int i = 1; i < mant.length; i++) {\n            final int r = rl*RADIX + mant[i] * x + rh;\n            rl = r & 0xffff;\n            rh = r >>> 16;\n        }\n\n        Dfp result = newInstance(getZero());\n        result.shiftLeft();\n        result.mant[0] = (byte) rl;\n        if (rh != 0) {\n            excp = result.round(rh);\n        } else {\n            excp = 0;\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, new Dfp(field, x), result);\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n\tfinal int y = x & 0x0F;\n    final int shift = (x >>> 4) & 0x0F;\n\n    int result[] = new int[mant.length];\n\n    for (int i = 0; i < mant.length; i++) {\n        result[i] = mant[i] * y + shift * result[i] + (mant[i] >>> 4) * 0x0F;\n        shift = mant[i] >>> 4;\n    }\n\n    if (shift != 0) {\n        for (int i = 0; i < result.length; i++) {\n            result[i] += shift * result[i] + (mant[i] >>> 4) * 0x0F;\n        }\n    }\n\n    Dfp resultDfp = new Dfp(field);\n    resultDfp.exp = exp;\n    resultDfp.nans = nans;\n    resultDfp.sign = sign;\n    resultDfp.mant = result;\n\n    return resultDfp;\n}",
      "private Dfp multiplyFast(final int x)  {\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i]*x;\n            final int rh = r / RADIX;\n            rl = r - rh * RADIX;\n            result.mant[i] = rh;\n        }\n\n        if (rl != 0) {\n            if (exp == 0) {\n                exp = 1;\n            }\n            mant[0] += rl;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  // Handle special cases\n    if (nans != FINITE) {\n        if (isNaN()) {\n            return this;\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n    }\n\n    // Test for multiplication by zero\n    if (x == 0) {\n        field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n        Dfp result = newInstance(getZero());\n        result.sign = sign;\n        result.nans = INFINITE;\n        result = dotrap(DfpField.FLAG_DIV_ZERO, MULTIPLY_TRAP, getZero(), result);\n        return result;\n    }\n\n    Dfp result = newInstance(this);\n    int rl = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = rl*RADIX + result.mant[i];\n        final int rh = r * x;\n        rl = r - (rh >> 8); // shift right by 8 to get the lower 8 bits\n        result.mant[i] = (byte) rh;\n    }\n\n    if (rl != 0) {\n        // we have a carry, so we need to bump up the exponent\n        exp++;\n        int carry = rl;\n        for (int i = 0; i < mant.length; i++) {\n            final int r = result.mant[i];\n            final int rh = r + carry;\n            carry = rh >> 8; // shift right by 8 to get the carry\n            result.mant[i] = (byte) rh;\n        }\n    }\n\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, x, result);\n    }\n\n    return result;\n\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(getZero());\n\n    int rl = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = rl*RADIX + mant[i] * x;\n        final int rh = r / RADIX;\n        rl = r - rh * RADIX;\n        result.mant[i] = rh;\n    }\n\n    if (rl != 0) {\n        int i = 0;\n        while (i < mant.length && result.mant[i] == 0) {\n            i++;\n        }\n        if (i == mant.length) {\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            result.nans = QNAN;\n        } else {\n            System.arraycopy(result.mant, i, result.mant, 0, result.mant.length-i);\n            for (int j = result.mant.length-i; j < result.mant.length; j++) {\n                result.mant[j] = 0;\n            }\n        }\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n        int rl=0;\n\n        for (int i=mant.length-1; i>=0; i--)\n        {\n            final int r = rl*RADIX + mant[i]*x;\n            final int rh = r/RADIX;\n            rl = r - rh*RADIX;\n            mant[i] = rh;\n        }\n\n        if (rl != 0) \n        {\n            for (int i = mant.length; i < exp; i++) {\n                mant[i] = rl;\n                rl = 0;\n            }\n        }\n\n        if (exp > MAX_EXP) {\n            // Overflow\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return DfpField.FLAG_OVERFLOW;\n        }\n\n        if (n != 0) {\n            // Inexact\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return DfpField.FLAG_INEXACT;\n        }\n\n        return this;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + mant[i]*x;\n            final int rh = r / RADIX;\n            rl = r - rh * RADIX;\n            mant[i] = rh;\n        }\n        if (rl != 0) {\n            shiftLeft();\n            mant[mant.length-1] = rl;\n        }\n        excp = align(exp + Integer.numberOfTrailingZeros(mant[mant.length-1]));\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n    }"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n    if (map.isEmpty()) {\n        return (Map<K, V>) map;\n    }\n\n    final Map<K, V> result = new HashMap<K, V>(map.size());\n\n    for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n        result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n    }\n    return result;\n}",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n    if (map.isEmpty()) \n    {\n        return (Map<K, V>) map;\n    }\n    final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n    for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n    {\n        result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n    }\n    return result;\n}",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty())\n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedHashMap<>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n{\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedHashMap<K, V>(map.size());\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n{\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n    if (map.isEmpty()) {\n        return (Map<K, V>) map;\n    }\n    final Map<K, V> result = new LinkedHashMap<K, V>(map.size());\n\n    for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n        result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n    }\n    return result;\n}",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n    if (map.isEmpty()) \n    {\n        return (Map<K, V>) map;\n    }\n    final Map<K, V> result = new LinkedMap<>(map.size());\n\n    for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n    {\n        result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n    }\n    return result;\n}",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.func(IR.name(symbolName), IR.params(), null);\n  function.setJSType(exportedFunction.getJSType());\n  function.copyInformationFrom(exportedFunction);\n\n  List<String> params = new ArrayList<>();\n\n  // create a list of param names to use for warning messages\n  for (Node param = exportedFunction.getFirstChild(); param != null; param = param.getNext()) {\n    params.add(param.getString());\n  }\n\n  if (exportedFunction.getReturnType() == null) {\n    warning(JSError.MISSING_RETURN_TYPE, exportedFunction, \"missing return type\", params);\n    function.setReturnType(JSType.getVoidType());\n  } else {\n    function.setReturnType(exportedFunction.getReturnType());\n  }\n\n  warning(JSError.NO_FUNCTION_BODY, exportedFunction, \"missing function body\", params);\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  // Create an empty function with the same return type and parameter names.\n  Node emptyFunction = IR.function(\n      NodeUtil.newVarNode(exportedFunction.getSymbolName(), null),\n      IR.paramlist(),\n      NodeUtil.newBlockNode());\n  \n  // Set the function type based on the original function.\n  FunctionType functionType = new FunctionType(\n      null,\n      null,\n      NodeUtil.getJSTypeFromNode(exportedFunction),\n      NodeUtil.getJSTypeFromNode(exportedFunction.getFirstChild().getNext()),\n      true,\n      false);\n  emptyFunction.setJSType(functionType);\n  \n  return emptyFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node func = IR.function(IR.name(symbolName));\n\n    // Add any parameters the function may need to have a type attached\n    // to it.\n    for (Node child : exportedFunction.getFirstChild().children()) {\n      if (child.getType() == Node.VAR_ARGS_NAME ||\n          child.getType() == Node.OPT_ARG_NAME) {\n        func.addChildToBack(child.cloneNode());\n      }\n    }\n\n    if (exportedFunction.getReturnType() == Node.NO_TYPE) {\n      // Warn if the function does not have a return type.\n      System.out.println(\"Warning: function \" + symbolName +\n                       \" does not have a return type\");\n    }\n\n    return func;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node paramList = exportedFunction.getChild(1);\n    Node returnType = exportedFunction.getJSType();\n\n    if (paramList.isEmpty()) {\n        paramList = IR.paramlist(IR.name(\"arg\"));\n    }\n\n    if (returnType == null) {\n        returnType = IR.voidtype();\n    }\n\n    List<String> missingParams = new ArrayList<>();\n\n    for (Node param : paramList.children()) {\n        String paramName = param.getName();\n        if (paramName == null) {\n            missingParams.add(\"missing param name\");\n        } else if (paramName.equals(\"arguments\") || paramName.equals(\"caller\")) {\n            missingParams.add(\"reserved param name\");\n        }\n    }\n\n    if (!missingParams.isEmpty()) {\n        Compiler.report(\n            JSError.MISSING_PARAM_TYPES, exportedFunction,\n            \"missing param types: \" + missingParams.toString());\n    }\n\n    List<String> missingReturns = new ArrayList<>();\n\n    if (returnType.isVoidType()) {\n        missingReturns.add(\"missing return type\");\n    } else if (returnType.isUnionType()) {\n        for (Node child = returnType.getFirstChild();\n             child != null;\n             child = child.getNext()) {\n            if (child.isVoidType()) {\n                missingReturns.add(\"missing return type\");\n                break;\n            }\n        }\n    }\n\n    if (!missingReturns.isEmpty()) {\n        Compiler.report(\n            JSError.MISSING_RETURN_TYPES, exportedFunction,\n            \"missing return types: \" + missingReturns.toString());\n    }\n\n    Node externFunction = IR.func(\n        IR.name(\"extern_\" + exportedFunction.getName()),\n        paramList,\n        IR.block(NodeUtil.newExpr(IR.return_(IR.nullval()))));\n\n    externFunction.copyInformationFrom(exportedFunction);\n\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  // Get the function name and parameter list\n  Node nameNode = exportedFunction.getFirstChild();\n  Node paramList = exportedFunction.getLastChild();\n\n  // Create the extern function with the same name and parameter list\n  Node externFunction = NodeUtil.newFunction(\n      nameNode, paramList, NodeUtil.newEmptyBlock(), exportedFunction.getJSDocInfo(),\n      exportedFunction.getFlags(), exportedFunction.getSourcePosition(),\n      exportedFunction.getChangeTime());\n\n  // Set the return type to void if it's not specified\n  if (exportedFunction.getJSType() == null) {\n    externFunction.setJSType(JSType.createVoidType());\n  } else {\n    externFunction.setJSType(exportedFunction.getJSType().toMaybeFunctionType().getReturnType());\n  }\n\n  // Add a warning if the function is missing parameter or return types\n  if (paramList == null || paramList.isEmpty()) {\n    compiler.reportWarning(\n        JSError.MISSING_PARAMETER_OR_RETURN_TYPE,\n        externFunction,\n        \"Missing parameter or return type for exported function\");\n  }\n\n  return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  // Check for missing parameter or return types\n  if (exportedFunction.getJsDocInfo() == null) \n  {\n    // Create a warning here\n  }\n\n  Node func = IR.func(IR.name(exportedFunction.getName()), null, null, null, null);\n\n  // Copy the JSDocInfo from the original function\n  func.setJSDocInfo(exportedFunction.getJSDocInfo());\n\n  // Set the function type of the extern function to the same as the original function\n  func.setType(exportedFunction.getJSType());\n\n  // Set the location of the extern function to the same as the original function\n  func.setSourcePosition(exportedFunction.getSourcePosition());\n\n  return func;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  List<Node> params = new ArrayList<>();\n  for (Node param = exportedFunction.getFirstChild();\n       param != null;\n       param = param.getNext()) {\n    params.add(NodeUtil.copyNode(param));\n  }\n\n  Node returnType = exportedFunction.getJSType().getReturnType();\n  Node returnTypeNode = returnType != null ? NodeUtil.copyNode(returnType) : null;\n\n  return IR.func(\n      params,\n      returnTypeNode,\n      NodeUtil.newExpr(IR.string(symbolName)),\n      NodeUtil.newBlockStmtNode(false));\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node func = IR.func(\n        IR.name(symbolName), \n        IR.params(exportedFunction.getValue(\"params\")), \n        IR.block(new Node[] {}), \n        JSType.makeUnknownType(),\n        exportedFunction.getJSDocInfo());\n    // Warning: Function '...' is missing parameter types and may cause\n    // compatibility issues.\n    return func;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  // Create an empty function with the same parameter names as the original function\n  Node externFunction = NodeUtil.newFunction(\"extern_\" + exportedFunction.getName(), exportedFunction);\n  externFunction.setVarArgs(exportedFunction.isVarArgs());\n  externFunction.setOptionalArg(exportedFunction.isOptionalArg());\n  externFunction.setIsSyntheticBlock(exportedFunction.isSyntheticBlock());\n  externFunction.setDirectives(exportedFunction.getDirectives());\n  externFunction.addSuppression(JSCompiler.ExternExportsPass.WARNING_NO_PARAM_TYPES);\n  externFunction.addSuppression(JSCompiler.ExternExportsPass.WARNING_NO_RETURN_TYPE);\n  externFunction.setChangeTime(exportedFunction.getChangeTime());\n  return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node result;\n\n    Node nameNode = exportedFunction.getFirstChild();\n\n    // If it's a function expression, we need to wrap it in a function literal.\n    if (nameNode.isQualifiedName()) {\n      result = NodeUtil.newFunction(nameNode);\n    } else {\n      nameNode = NodeUtil.newName(\n          compiler.getCodingConvention(), \"\", nameNode);\n      result = NodeUtil.newFunction(nameNode, null);\n    }\n\n    // Create a new function type.\n    FunctionType functionType =\n        createFunctionTypeFromNodes(\n            exportedFunction, nameNode.getString(), exportedFunction.getJSDocInfo(), null);\n\n    result.setJSType(functionType);\n    result.setJSDocInfo(new JSDocInfo());\n\n    // Set the source position to the original function.\n    result.setSourcePosition(exportedFunction.getSourcePosition());\n\n    return result;\n}"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[] sigma = new double[params.length];\n    double[][] covariance = computeCovariances(params, covarianceSingularityThreshold);\n    for (int i = 0; i < covariance.length; i++) {\n        sigma[i] = FastMath.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[] errors = new double[params.length];\n        double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < errors.length; ++i) {\n            errors[i] = FastMath.sqrt(covar[i][i]);\n        }\n        return errors;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[] sigma = new double[params.length];\n        double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < sigma.length; ++i) {\n            sigma[i] = FastMath.sqrt(covar[i][i]);\n        }\n        return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[] sigma = new double[params.length];\n    double[][] covariance = computeCovariances(params, covarianceSingularityThreshold);\n    for (int i = 0; i < covariance.length; i++) {\n        sigma[i] = FastMath.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[] sigma = new double[params.length];\n        double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < sigma.length; ++i) {\n            sigma[i] = FastMath.sqrt(covar[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[] sigma = new double[params.length];\n    double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[] sigma = new double[params.length];\n    double[][] covariance = computeCovariances(params, covarianceSingularityThreshold);\n    for (int i = 0; i < sigma.length; i++) {\n        sigma[i] = FastMath.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[] sigma = new double[params.length];\n    double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n    for (int i = 0; i < sigma.length; ++i) {\n        sigma[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[] sigma = new double[params.length];\n    double[][] covariance = computeCovariances(params, covarianceSingularityThreshold);\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = FastMath.sqrt(covariance[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[] sigma = new double[params.length];\n        double[][] covariance = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < covariance.length; i++) {\n            sigma[i] = FastMath.sqrt(covariance[i][i]);\n        }\n        return sigma;\n    }"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    for (String priorVarName : priorVariables) {\n        if (priorVarName.equals(varName)) {\n            throw new IllegalArgumentException(\"Cyclic variable reference detected: \" + varName);\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName))\n    {\n        throw new IllegalArgumentException(\"Cyclic variable reference detected: \" + varName);\n    }\n    priorVariables.add(varName);\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName))\n    {\n        throw new IllegalArgumentException(\"Cyclic variable definition: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    for (int i = 0; i < priorVariables.size(); i++) {\n        if (varName.equals(priorVariables.get(i))) {\n            throw new IllegalArgumentException(\"Cyclic variable reference detected: \" + varName);\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    for (int i = priorVariables.size() - 1; i >= 0; i--) {\n        if (varName.equals(priorVariables.get(i))) {\n            throw new IllegalArgumentException(\"Cyclic variable reference: \" + varName);\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName))\n    {\n        // cyclic reference detected, throw exception\n        throw new IllegalArgumentException(\n                String.format(\"Cyclic reference detected: '%s' is defined in the variable stack\", varName));\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic variable substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    for (String name : priorVariables) {\n        if (name.equals(varName)) {\n            throw new IllegalArgumentException(\"Cyclic variable definition: \" + varName);\n        }\n    }\n    priorVariables.add(varName);\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    for (final String priorVariable : priorVariables) \n    {\n        if (priorVariable.equals(varName)) \n        {\n            throw new IllegalArgumentException(\n                    \"Cyclic variable substitution detected: \" + varName);\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic variable reference detected: \" + varName);\n    }\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : inputs) {\n        for (INPUT require : input.getRequires()) {\n            deps.put(require, input);\n        }\n    }\n\n    List<INPUT> sortedDeps = topologicalStableSort(roots, deps);\n    if (!sorted) {\n        return sortedDeps;\n    }\n\n    List<INPUT> result = Lists.newArrayList();\n    Set<INPUT> seen = Sets.newHashSet();\n    for (INPUT input : sortedDeps) {\n        if (!seen.contains(input)) {\n            result.add(input);\n            seen.add(input);\n        }\n    }\n    return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> dependencies = new ArrayList<>();\n    for (INPUT root : roots) \n    {\n        List<INPUT> rootDeps = new ArrayList<>();\n        rootDeps.add(root);\n        dependencies.addAll(findDependencies(rootDeps));\n    }\n\n    // Remove duplicates from the dependency list\n    Set<INPUT> uniqueDeps = new HashSet<>(dependencies);\n    dependencies.clear();\n    dependencies.addAll(uniqueDeps);\n\n    // Sort the dependencies in topological order\n    if (sorted) \n    {\n        Collections.sort(dependencies, new Comparator<INPUT>() \n        {\n}\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> sortedList = new ArrayList<>(roots);\n    Multimap<INPUT, INPUT> deps = ArrayListMultimap.create();\n\n    // Build dependency graph\n    for (INPUT input : inputs) {\n        for (String symbol : input.getRequires()) {\n            INPUT provider = provideMap.get(symbol);\n            if (provider != null) {\n                deps.put(provider, input);\n            }\n        }\n    }\n\n    // Find cycles and remove nodes involved\n    Set<INPUT> covered = new HashSet<>();\n    for (INPUT root : roots) {\n        if (!covered.contains(root)) {\n            List<INPUT> cycle = findCycle(root, new HashSet<>(), deps, covered);\n            if (cycle != null) {\n                for (INPUT node : cycle) {\n                    sortedList.remove(node);\n                }\n            }\n        }\n    }\n\n    // Perform topological sorting if needed\n    if (sorted) {\n        List<INPUT> result = topologicalStableSort(sortedList, deps);\n        sortedList.clear();\n        sortedList.addAll(result);\n    }\n\n    return Collections.unmodifiableList(sortedList);\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : inputs) {\n        for (INPUT other : inputs) {\n            if (input != other && other.getProvides().contains(input.getRequires().get(0))) {\n                deps.put(input, other);\n            }\n        }\n    }\n    List<INPUT> subgraph = new ArrayList<>();\n    for (INPUT root : roots) {\n        subgraph.add(root);\n    }\n    return topologicalStableSort(subgraph, deps);\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : inputs) {\n        for (String symbol : input.getRequires()) {\n            deps.put(input, provideMap.get(symbol));\n        }\n    }\n\n    List<INPUT> sortedDeps = topologicalStableSort(roots, deps);\n    if (!sorted) {\n      return sortedDeps;\n    }\n\n    // Reverse the dependencies to get the correct order.\n    List<INPUT> reversedDeps = Lists.newArrayList();\n    for (int i = sortedDeps.size() - 1; i >= 0; i--) {\n      reversedDeps.add(sortedDeps.get(i));\n    }\n    return reversedDeps;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : inputs) {\n        for (INPUT other : inputs) {\n            if (input != other && input.getProvides().equals(other.getRequires())) {\n                deps.put(input, other);\n            }\n        }\n    }\n    List<INPUT> subGraph = Lists.newArrayList();\n    List<INPUT> sortedDeps = topologicalStableSort(roots, deps);\n    for (INPUT root : sortedDeps) {\n        subGraph.clear();\n        subGraph.add(root);\n        subGraph = findCycle(subGraph, deps);\n        Collections.reverse(subGraph);\n        for (INPUT input : subGraph) {\n            if (!roots.contains(input)) {\n                sortedDeps.remove(input);\n                noProvides.add(input);\n            }\n        }\n    }\n    if (sorted) {\n        return sortedDeps;\n    } else {\n        return inputs;\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> inputsToProcess = new ArrayList<>(roots);\n    List<INPUT> sortedInputs = new ArrayList<>();\n\n    while (!inputsToProcess.isEmpty()) {\n        List<INPUT> currentLevelInputs = new ArrayList<>();\n\n        for (INPUT input : inputsToProcess) {\n            currentLevelInputs.add(input);\n\n            // Remove the input from the list to avoid processing it multiple times.\n            inputsToProcess.remove(input);\n        }\n\n        // Process the current level inputs.\n        List<INPUT> newDependencies = new ArrayList<>();\n        for (INPUT input : currentLevelInputs) {\n            newDependencies.addAll(input.getDependencies());\n        }\n\n        // Add new dependencies to the list, if not already present.\n        for (INPUT dependency : newDependencies) {\n            if (!sortedInputs.contains(dependency)) {\n                inputsToProcess.add(dependency);\n            }\n        }\n\n        // Add the current level inputs to the sorted list.\n        sortedInputs.addAll(currentLevelInputs);\n    }\n\n    // Sort the sorted inputs if required.\n    if (sorted) {\n        Collections.sort(sortedInputs, new Comparator<INPUT>() {\n}\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : inputs) {\n        for (INPUT other : inputs) {\n            if (input != other && input.getProvides().contains(other.getRequires().iterator().next())) {\n                deps.put(input, other);\n            }\n        }\n    }\n    List<INPUT> sortedList = topologicalStableSort(roots, deps);\n    if (!sorted) {\n      Collections.reverse(sortedList);\n    }\n    return sortedList;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> dependencies = new ArrayList<>();\n    for (INPUT root : roots) {\n        dependencies.add(root);\n    }\n    Map<INPUT, List<INPUT>> providesToDependencies = new HashMap<>();\n    for (INPUT dependency : dependencies) {\n        for (String provide : dependency.getProvides()) {\n            if (!providesToDependencies.containsKey(dependency)) {\n                providesToDependencies.put(dependency, new ArrayList<>());\n            }\n            List<INPUT> providesDependencies = providesToDependencies.get(dependency);\n            for (INPUT dependencyToProvide : dependencies) {\n                if (dependencyToProvide.getRequires().contains(provide)) {\n                    if (!providesDependencies.contains(dependencyToProvide)) {\n                        providesDependencies.add(dependencyToProvide);\n                    }\n                }\n            }\n        }\n    }\n    List<INPUT> result = new ArrayList<>();\n    for (INPUT dependency : dependencies) {\n        List<INPUT> providesDependencies = providesToDependencies.getOrDefault(dependency, new ArrayList<>());\n        result.addAll(providesDependencies);\n        if (!providesDependencies.isEmpty()) {\n            for (INPUT providesDependency : providesDependencies) {\n                if (!result.contains(dependency)) {\n                    result.add(dependency);\n                }\n            }\n        }\n    }\n    if (sorted) {\n        return topologicalStableSort(result, GraphUtils.makeDirectedGraph(result, (input) -> providesToDependencies.getOrDefault(input, new ArrayList<>())));\n    } else {\n        return result;\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> inputsToProcess = Lists.newArrayList(roots);\n    List<INPUT> result = Lists.newArrayList();\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n\n    while (!inputsToProcess.isEmpty()) {\n        INPUT current = inputsToProcess.remove(inputsToProcess.size() - 1);\n        result.add(current);\n\n        // Add current's requires to the graph.\n        for (String provide : current.getProvides()) {\n          INPUT required = maybeGetInputProviding(provide);\n          if (required != null) {\n            deps.put(current, required);\n          }\n        }\n\n        // Find any nodes in the subgraph that are not yet in the result set.\n        Set<INPUT> subgraph = deps.keySet();\n        subgraph.removeAll(result);\n\n        // Add them to the queue for processing.\n        inputsToProcess.addAll(subgraph);\n    }\n\n    // If sorted is true, return the list in topological sorted order.\n    if (sorted) {\n      return topologicalStableSort(result, deps);\n    } else {\n      return result;\n    }\n  }"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) \n    {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            lastWasGap = true;\n        } \n        else\n        {\n            if (lastWasGap) \n            {\n                buf[count++] = Character.toLowerCase(ch);\n            } \n            else\n            {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) \n    {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            lastWasGap = true;\n        }\n        else if (lastWasGap) \n        {\n            buf[count++] = Character.toLowerCase(ch);\n            lastWasGap = false;\n        }\n        else \n        {\n            buf[count++] = ch;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) \n    {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            lastWasGap = true;\n        } \n        else if (lastWasGap) \n        {\n            buf[count++] = Character.toLowerCase(ch);\n            lastWasGap = false;\n        } \n        else \n        {\n            buf[count++] = ch;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) \n    {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            lastWasGap = true;\n        }\n        else if (lastWasGap) \n        {\n            buf[count++] = Character.toLowerCase(ch);\n            lastWasGap = false;\n        }\n        else \n        {\n            buf[count++] = ch;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            if (!lastWasGap && Character.isUpperCase(buf[count - 1])) {\n                buf[count++] = Character.toLowerCase(ch);\n                lastWasGap = true;\n            } else {\n                lastWasGap = true;\n            }\n        } else {\n            if (lastWasGap) {\n                buf[count++] = Character.toUpperCase(ch);\n            } else {\n                buf[count++] = Character.toLowerCase(ch);\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buf[count++] = Character.toLowerCase(ch);\n            } else {\n                buf[count++] = Character.toLowerCase(ch);\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) \n    {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            lastWasGap = true;\n        } \n        else if (lastWasGap) \n        {\n            buf[count++] = Character.toLowerCase(ch);\n            lastWasGap = false;\n        } \n        else\n        {\n            buf[count++] = ch;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            if (!lastWasGap) {\n                buf[count++] = Character.toLowerCase(ch);\n                lastWasGap = true;\n            }\n        } else {\n            lastWasGap = false;\n            if (i == 0) {\n                buf[count++] = Character.toLowerCase(ch);\n            } else {\n                buf[count++] = ch;\n            }\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) \n    {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            lastWasGap = true;\n        } \n        else\n        {\n            if (lastWasGap) \n            {\n                buf[count++] = Character.toLowerCase(ch);\n            } else \n            {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buf[count++] = Character.toLowerCase(ch);\n            } else {\n                buf[count++] = Character.toTitleCase(ch);\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) \n    {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.field.getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.field.newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.field.newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n  Dfp result[] = new Dfp[2];\n  int sig = a.getExponent();\n  int splitIndex = (a.getField().getRadixDigits() / 2) * 4;\n  int splitIndex2 = splitIndex / 2;\n  Dfp num = a.newInstance();\n  Dfp den = a.newInstance();\n  num.setExponent(sig - splitIndex);\n  den.setExponent(sig + splitIndex2);\n  num.setMantissa(a.getMantissa(), splitIndex2, a.getMantissa().length - splitIndex2);\n  den.setMantissa(a.getMantissa(), 0, splitIndex2);\n  result[0] = num;\n  result[1] = den;\n  return result;\n\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n  Dfp result[] = new Dfp[2];\n  result[0] = a.newInstance();\n  result[1] = a.newInstance();\n\n  if (a.exp == Dfp.MIN_EXP) {\n\n    for (int i = 0; i < a.mant.length; i++) {\n      a.mant[i] = a.mant[i] >> 1;\n    }\n    a.exp--;\n\n  } else if (a.exp == Dfp.MAX_EXP) {\n\n    for (int i = a.mant.length - 1; i >= 0; i--) {\n      a.mant[i] = a.mant[i] << 1;\n    }\n    a.exp++;\n\n  }\n\n  for (int i = a.mant.length - 1; i >= 0; i--) {\n    if (a.mant[i] >= 0x3fffffff) {\n      result[0] = result[0].add(a.field.two.newInstance(a.field.getExp(i + 1)));\n      result[1] = result[1].add(a.field.two.newInstance(i + 1));\n      a.mant[i] -= 0x3fffffff;\n    } else if (a.mant[i] <= 0xbfc00000) {\n      result[0] = result[0].subtract(a.field.two.newInstance(a.field.getExp(i + 1)));\n      result[1] = result[1].subtract(a.field.two.newInstance(i + 1));\n      a.mant[i] += 0x3fffffff;\n    }\n  }\n\n  result[0] = result[0].add(a);\n\n  return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n\n    result[0] = a.newInstance();\n    result[1] = a.newInstance();\n\n    if (a.getExp() >= 0) {\n        if (a.getExp() % 2 == 1) {\n            result[1] = a.multiply(a.getTwo()).newInstance();\n        }\n    } else {\n        if (a.getExp() % 2 == -1) {\n            result[0] = a.multiply(a.getTwo()).newInstance();\n        }\n    }\n\n    result[0].setExp(a.getExp() / 2);\n    result[1].setExp(a.getExp() / 2);\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.field.getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.field.newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.field.newDfp(new String(buf));\n\n    return result;\n\n}",
      "protected static Dfp[] split(final Dfp a)  {\n\tDfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n\n}",
      "protected static Dfp[] split(final Dfp a)  {\n  Dfp result[] = new Dfp[2];\n  result[0] = a.newInstance(new String(a.toString()));\n  result[1] = a.newInstance(new String(a.toString()));\n  return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n\tDfp result[] = new Dfp[2];\n\tfinal int aRadixDigits = a.getRadixDigits();\n\tint leading = true;\n\tint sp = 0;\n\tint sig = 0;\n\n\tchar[] buf = new char[a.toString().length()];\n\n\tfor (int i = 0; i < buf.length; i++) {\n\t\tbuf[i] = a.toString().charAt(i);\n\n\t\tif (buf[i] >= '1' && buf[i] <= '9') {\n\t\t\tleading = false;\n\t\t}\n\n\t\tif (buf[i] == '.') {\n\t\t\tsig += (aRadixDigits - sig) % aRadixDigits;\n\t\t\tleading = false;\n\t\t}\n\n\t\tif (sig == (aRadixDigits / 2) * aRadixDigits) {\n\t\t\tsp = i;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n\t\t\tsig ++;\n\t\t}\n\t}\n\n\tresult[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n\tfor (int i = 0; i < buf.length; i++) {\n\t\tbuf[i] = a.toString().charAt(i);\n\t\tif (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n\t\t\tbuf[i] = '0';\n\t\t}\n\t}\n\n\tresult[1] = a.getField().newDfp(new String(buf));\n\n\treturn result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n  Dfp result[] = new Dfp[2];\n  int sig = a.getExponent();\n  int exp = a.getExponent() / 2;\n  int rem = a.getExponent() % 2;\n  Dfp base = a.getField().newDfp(a.getMant(), sig);\n  Dfp[] tmp = split(base);\n  result[0] = tmp[0].shiftLeft(exp).shiftRight(exp).add(tmp[1].shiftLeft(exp - rem).shiftRight(exp - rem));\n  result[1] = tmp[0].shiftLeft(exp + 1).shiftRight(exp + 1).add(tmp[1].shiftLeft(exp).shiftRight(exp));\n  return result;\n}"
    ],
    [
      "public String cssSelector()  {\n    if (hasAttr(\"id\") && !attr(\"id\").trim().isEmpty())\n        return \"#\" + attr(\"id\");\n    else {\n        StringBuilder result = new StringBuilder();\n        Element parent = parent();\n        if (parent != null) {\n            String parentSelector = parent.cssSelector();\n            if (parentSelector != null && !parentSelector.isEmpty())\n                result.append(parentSelector).append(\">\");\n        }\n        String tagName = tagName();\n        if (tagName != null && !tagName.isEmpty())\n            result.append(tagName);\n        if (classNames().size() > 0) {\n            for (String className: classNames()) {\n                result.append(\".\").append(className);\n            }\n        }\n        int childrenCount = parent != null ? parent.childElementsList().size() : 0;\n        int index = 0;\n        for (Element child : parent != null ? parent.childElementsList() : new ArrayList<Element>()) {\n            if (child == this) {\n                result.append(\":nth-child(\").append(++index).append(\")\");\n                break;\n            }\n            if (child.tagName().equalsIgnoreCase(tagName) && child.classNames().equals(classNames()))\n                index++;\n        }\n        return result.toString();\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null && !id().isEmpty()) \n    {\n        return \"#\" + id();\n    }\n    else \n    {\n        StringBuilder builder = new StringBuilder();\n        Elements parents = parents();\n        for (int i = parents.size() - 1; i >= 0; i--) \n        {\n            builder.append(parents.get(i).cssSelector()).append(\">\");\n        }\n        builder.append(tagName().toLowerCase());\n        for (String className : classNames()) \n        {\n            builder.append(\".\").append(className);\n        }\n        int childIndex = elementSiblingIndex();\n        if (childIndex != 0) \n        {\n            builder.append(\":nth-child(\").append(childIndex).append(\")\");\n        }\n        return builder.toString();\n    }\n}",
      "public String cssSelector()  {\n    if (hasAttr(\"id\") && !id().trim().isEmpty()) {\n        return \"#\" + attr(\"id\");\n    } else {\n        String path = \"\";\n        Element parent = parent();\n        if (parent != null) {\n            path = parent.cssSelector();\n        }\n        String tagName = getTag().getName();\n        List<Attribute> attrs = new ArrayList<Attribute>();\n        for (String attrName : getAttributes().asList()) {\n            attrs.add(getAttribute(attrName));\n        }\n        path += \" > \" + tagName;\n        for (Attribute attr : attrs) {\n            path += \".\" + attr.getKey().toLowerCase();\n        }\n        int nth = 1;\n        for (int i = 0; i < parent.childElementsList().size(); i++) {\n            Element sib = parent.childElementsList().get(i);\n            if (sib.equals(this)) {\n                path += \":nth-child(\" + nth + \")\";\n                break;\n            }\n            if (sib.tagName().equals(tagName)) {\n                nth++;\n            }\n        }\n        return path;\n    }\n}",
      "public String cssSelector()  {\n    if (hasAttr(\"id\"))\n        return \"#\" + attr(\"id\");\n\n    StringBuilder builder = new StringBuilder();\n\n    if (parentNode != null) \n        builder.append(parentNode.cssSelector()).append(\">\");\n\n    builder.append(tagName);\n\n    if (!classNames().isEmpty()) {\n        for (String className : classNames()) {\n            builder.append(\".\").append(className);\n        }\n    }\n\n    int index = elementSiblingIndex();\n    if (index > 0) {\n        builder.append(\":nth-child(\").append(index).append(\")\");\n    }\n\n    return builder.toString();\n}",
      "public String cssSelector()  {\n    if (hasAttr(\"id\") && !id().startsWith(\"#\")) {\n        return \"#\" + id();\n    } else {\n        String parentSelector = parentNode() != null ? parentNode().cssSelector() : \"\";\n        if (parentSelector.length() > 0 && !parentSelector.equals(\"#root\")) {\n            parentSelector += \" > \";\n        }\n        String tag = tagName().toLowerCase();\n        String classNames = classNames().stream().map(c -> \".\" + c).collect(Collectors.joining());\n        String nthChild = siblingElements().indexOf(this) + 1 + \":nth-child(\" + (siblingElements().size() + 1) + \")\";\n        return parentSelector + tag + classNames + nthChild;\n    }\n}",
      "public String cssSelector()  {\n    if (hasAttr(\"id\"))\n        return \"#\" + attr(\"id\");\n\n    StringBuilder selector = new StringBuilder();\n    Element parent = parent();\n\n    if (parent != null)\n    {\n        selector.append(parent.cssSelector()).append('>');\n    }\n\n    selector.append(tagName());\n\n    if (hasAttr(\"class\"))\n    {\n        String[] classes = attr(\"class\").split(\"\\\\s+\");\n        for (String clazz : classes)\n            selector.append(\".\").append(clazz);\n    }\n\n    int index = 0;\n    for (Element sib : parent.childElementsList())\n    {\n        if (sib == this)\n            break;\n        index++;\n    }\n\n    selector.append(':').append(index + 1);\n\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    if (id() != null && !id().equals(\"\")) \n        return \"#\" + id();\n\n    String parentSelector = parentNode == null ? \"\" : parent().cssSelector();\n\n    if (parentSelector.length() > 0) \n        return parentSelector + \"> \";\n\n    String selector = tagName();\n    if (classNames().size() > 0) \n        selector += \".\" + String.join(\".\", classNames());\n\n    int index = elementSiblingIndex();\n    if (index > -1) \n        selector += \":nth-child(\" + (index + 1) + \")\";\n\n    return selector;\n}",
      "public String cssSelector()  {\n    if (hasAttr(\"id\") && !id().isEmpty())\n        return \"#\" + attr(\"id\");\n    else\n    {\n        StringBuilder accum = new StringBuilder();\n        Elements parents = parents();\n        for (int i = 0; i < parents.size(); i++) \n        {\n            Element parent = parents.get(i);\n            accum.append(parent.tagName());\n            if (i != parents.size() - 1)\n                accum.append(\".\");\n        }\n        accum.append(\">\");\n        accum.append(tagName());\n        int index = elementSiblingIndex();\n        if (index >= 0)\n            accum.append(\":nth-child(\").append(++index).append(\")\");\n        return accum.toString();\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null && !id().isEmpty())\n        return \"#\" + id();\n    else {\n        String parentSelector = parentNode().cssSelector();\n        if (parentSelector == null)\n            return null;\n        else {\n            String uniqueSelector;\n            Elements siblings = parent().childElementsList();\n            int index = indexInList(this, siblings);\n            if (siblings.size() == 0)\n                uniqueSelector = tagName() + \":nth-child(1)\";\n            else\n                uniqueSelector = tagName() + \":nth-child(\" + (index+1) + \")\";\n\n            return parentSelector + \" > \" + uniqueSelector;\n        }\n    }\n}",
      "public String cssSelector()  {\n    if (hasAttr(\"id\"))\n        return \"#\" + attr(\"id\");\n    else if (parent() != null)\n        return parent().cssSelector() + '>' + tagName();\n    else\n        return tagName();\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n  switch (n.getType()) {\n    case Token.NOT:\n      return 2;\n    case Token.EQ:\n    case Token.NE:\n    case Token.SHEQ:\n    case Token.SHNE:\n      return 4;\n    case Token.AND:\n    case Token.OR:\n      return 5;\n    case Token.MUL:\n    case Token.DIV:\n    case Token.MOD:\n      return 6;\n    case Token.ADD:\n    case Token.SUB:\n      return 7;\n    case Token.LSH:\n    case Token.RSH:\n    case Token.URSH:\n      return 8;\n    case Token.LT:\n    case Token.GT:\n    case Token.LTE:\n    case Token.GTE:\n      return 9;\n    case Token.POW:\n      return 10;\n    case Token.QUESTION:\n      return 11;\n    case Token.CASE:\n    case Token.TRY:\n    case Token.WHILE:\n    case Token.DO:\n      return 12;\n    case Token.FOR:\n      return 13;\n    case Token.VAR:\n    case Token.CONST:\n    case Token.FUN:\n    case Token.RETURN:\n    case Token.EMPTY_BLOCK:\n    case Token.IF:\n      return 14;\n    case Token.BLOCK:\n      return 15;\n    case Token.WITH:\n      return 16;\n    case Token.LABEL:\n      return 17;\n    case Token.PARAM_LIST:\n      return 18;\n    case Token.NEW:\n      return 19;\n    case Token.CALL:\n      return 20;\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return 21;\n    case Token.SETPROP:\n      return 22;\n    case Token.DELETEPROP:\n      return 23;\n    case Token.IN:\n      return 24;\n    case Token.YIELD:\n      return 25;\n    case Token.REGEXP:\n      return 26;\n}\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = NAME_COST_ESTIMATE;\n  Node left = n.getFirstChild();\n  Node right = n.getLastChild();\n\n  while (left != null) {\n    switch (left.getType()) {\n      case Token.NOT:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n        cost += 1;\n        break;\n      case Token.OR:\n      case Token.XOR:\n      case Token.AND:\n        cost += 2;\n        break;\n      case Token.COND:\n        cost += 4;\n        break;\n      case Token.LBRACE:\n      case Token.RBRACE:\n        // ignore braces\n        break;\n      default:\n        cost += estimateCostOneLevel(left);\n    }\n    left = left.getNext();\n  }\n\n  while (right != null) {\n    switch (right.getType()) {\n      case Token.NOT:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n        cost += 1;\n        break;\n      case Token.OR:\n      case Token.XOR:\n      case Token.AND:\n        cost += 2;\n        break;\n      case Token.COND:\n        cost += 4;\n        break;\n      case Token.LBRACE:\n      case Token.RBRACE:\n        // ignore braces\n        break;\n      default:\n        cost += estimateCostOneLevel(right);\n    }\n    right = right.getPrevious();\n  }\n\n  if (n.getType() == Token.OR || n.getType() == Token.XOR ||\n      n.getType() == Token.AND || n.getType() == Token.COND) {\n    cost += PAREN_COST;\n  }\n\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  if (n.isFalse() || n.isTrue() || n.isNE() || n.isSHNE() || n.isEQ() || n.isSHEQ() || n.isAdd() || n.isAnd() || n.isOr())\n    return 1;\n  if (n.isArrayLit())\n    return NAME_COST_ESTIMATE + 2 + COMMA_COST * (n.getChildCount() - 1) + PAREN_COST * 2;\n  if (n.isString())\n    return NAME_COST_ESTIMATE + 2 + n.getString().length() + PAREN_COST * 2;\n  if (n.isNumber())\n    return NAME_COST_ESTIMATE + 2 + n.toString().length() + PAREN_COST * 2;\n  if (n.isCast())\n    return estimateCostOneLevel(n.getFirstChild()) + estimateCostOneLevel(n.getLastChild()) + estimateCostOneLevel(n.getChildAtIndex(1)) + 2 + COMMA_COST * (n.getChildCount() - 1) + PAREN_COST * 3;\n  if (n.isCall())\n    return estimateCostOneLevel(n.getFirstChild()) + estimateCostOneLevel(n.getLastChild()) + estimateCostOneLevel(n.getChildAtIndex(1)) + 2 + COMMA_COST * (n.getChildCount() - 1) + PAREN_COST * 3;\n  if (n.isUnaryMinus())\n    return estimateCostOneLevel(n.getFirstChild()) + 1;\n  if (n.isUnaryPlus())\n    return estimateCostOneLevel(n.getFirstChild()) + 1;\n  if (n.isUnaryNot())\n    return estimateCostOneLevel(n.getFirstChild()) + 1;\n  if (n.isInc())\n    return estimateCostOneLevel(n.getFirstChild()) + 2;\n  if (n.isDec())\n    return estimateCostOneLevel(n.getFirstChild()) + 2;\n  if (n.isDelProp())\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 1;\n    }\n    int cost = 2;\n    for (Node child : n.children()) {\n        cost += estimateCostOneLevel(child);\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  switch (n.getType()) {\n    case Token.NOT:\n      return 1;\n    case Token.LBRACE:\n    case Token.RBRACE:\n    case Token.LBRACK:\n    case Token.RBRACK:\n    case Token.LPAREN:\n    case Token.RPAREN:\n    case Token.ASSIGN:\n    case Token.OR:\n    case Token.AND:\n    case Token.XOR:\n    case Token.EQ:\n    case Token.NE:\n    case Token.SHEQ:\n    case Token.SHNE:\n    case Token.LT:\n    case Token.GT:\n    case Token.LTE:\n    case Token.GTE:\n    case Token.IN:\n    case Token.INSTANCEOF:\n    case Token.COND:\n    case Token.LABEL:\n    case Token.GOTO:\n    case Token.CONTINUE:\n    case Token.BREAK:\n    case Token.RETURN:\n    case Token.ADD:\n    case Token.SUB:\n    case Token.MUL:\n    case Token.DIV:\n    case Token.MOD:\n    case Token.BIT_AND:\n    case Token.BIT_OR:\n    case Token.BIT_XOR:\n    case Token.BIT_NOT:\n    case Token.SHL:\n    case Token.SHR:\n      return 2;\n    case Token.INC:\n    case Token.DEC:\n    case Token.VOID:\n      return 4;\n    case Token.FUNCTION:\n    case Token.VAR:\n    case Token.WHILE:\n    case Token.DO:\n    case Token.FOR:\n    case Token.IF:\n    case Token.SWITCH:\n    case Token.WITH:\n    case Token.TRY:\n    case Token.CATCH:\n    case Token.FINALLY:\n    case Token.EMPTY_BLOCK:\n      return 5;\n    case Token.NAME:\n      return NAME_COST_ESTIMATE;\n    case Token.NUMBER:\n      return 6;\n    case Token.STRING:\n      return ((StringNode) n).getString().length();\n    case Token.REGEXP:\n      return 7;\n    case Token.GETELEM:\n    case Token.PUTPROP:\n}\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  if (n.getType() == Token.NOT) \n  {\n    // The not operator adds two characters: one for the negation symbol and one for the\n    // space after it.\n    cost += 2;\n  } else if (TokenUtil.isParenthesized(n)) {\n    // Parentheses add 2 characters: one for the opening parenthesis and one for the\n    // closing parenthesis.\n    cost += 2;\n  }\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 1;\n    } else if (n.getType() == Token.CALL || n.getType() == Token.NEW || n.getType() == Token.INC || n.getType() == Token.DEC) {\n        return PAREN_COST + estimateCostOneLevel(n.getFirstChild());\n    } else {\n        int total = 0;\n        for (Node child : n.children()) {\n            total += estimateCostOneLevel(child);\n        }\n        return total;\n    }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  if (n.getType() == Token.NOT) {\n    cost += 2;\n    n = n.getFirstChild();\n  }\n  if (n.getType() == Token.LBRACE) {\n    for (Node child : n.children()) {\n      cost += estimateCostOneLevel(child);\n    }\n    cost += 2;\n  } else {\n    cost += 1;\n  }\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  switch (n.getType()) {\n    case Token.NOT:\n      return 2;\n    case Token.LBRACE:\n    case Token.LBRACK:\n    case Token.LParen:\n    case Token.RBRACE:\n    case Token.RBRACK:\n    case Token.RParen:\n    case Token.QMARK:\n    case Token.QUEST:\n      return 1;\n    case Token.VARARGS:\n    case Token.INC:\n    case Token.DEC:\n    case Token.ADD:\n    case Token.SUB:\n    case Token.MUL:\n    case Token.DIV:\n    case Token.MOD:\n    case Token.POW:\n    case Token.SHL:\n    case Token.SHR:\n    case Token.SHRU:\n    case Token.EQ:\n    case Token.NE:\n    case Token.SHEQ:\n    case Token.SHNE:\n    case Token.LT:\n    case Token.GT:\n    case Token.LTE:\n    case Token.GTE:\n    case Token.AND:\n    case Token.OR:\n    case Token.XOR:\n    case Token.BITAND:\n    case Token.BITOR:\n    case Token.BITXOR:\n    case Token.COND:\n    case Token.IN:\n    case Token.INSTANCEOF:\n    case Token.NEW:\n    case Token.VOID:\n    case Token.RETURN:\n    case Token.BREAK:\n    case Token.CONTINUE:\n    case Token.LABEL:\n    case Token.YIELD:\n    case Token.WITH:\n    case Token.THROWS:\n    case Token.TRY:\n    case Token.FINALLY:\n    case Token.GOTO:\n    case Token.SWITCH:\n    case Token.CASE:\n    case Token.DEFAULT:\n    case Token.FOR:\n    case Token.WHILE:\n    case Token.DO:\n    case Token.IF:\n    case Token.BLOCK:\n    case Token.FUNCTION:\n    case Token.PARAM_LIST:\n    case Token.EMPTY_BLOCK:\n    case Token.SCRIPT:\n    case Token.VAR:\n    case Token.ASSIGN:\n    case Token.ASSIGN_ADD:\n}\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  switch (n.getType()) {\n    case Token.NOT:\n      return 1 + estimateCostOneLevel(n.getFirstChild());\n    case Token.EQ:\n    case Token.NE:\n    case Token.SHEQ:\n    case Token.SHNE:\n    case Token.AND:\n    case Token.OR:\n    case Token.XOR:\n    case Token.COND:\n    case Token.QUESTION:\n    case Token.MUL:\n    case Token.DIV:\n    case Token.MOD:\n    case Token.ADD:\n    case Token.SUB:\n    case Token.LSH:\n    case Token.RSH:\n    case Token.URSH:\n    case Token.BITAND:\n    case Token.BITOR:\n    case Token.BITXOR:\n      return 2 + estimateCostOneLevel(n.getFirstChild())\n          + estimateCostOneLevel(n.getLastChild());\n    case Token.ASSIGN:\n    case Token.ASSIGN_ADD:\n    case Token.ASSIGN_SUB:\n    case Token.ASSIGN_MUL:\n    case Token.ASSIGN_DIV:\n    case Token.ASSIGN_MOD:\n    case Token.ASSIGN_LSH:\n    case Token.ASSIGN_RSH:\n    case Token.ASSIGN_URSH:\n    case Token.ASSIGN_BITAND:\n    case Token.ASSIGN_BITOR:\n    case Token.ASSIGN_BITXOR:\n    case Token.DEC:\n    case Token.INC:\n    case Token.INC_PRE:\n    case Token.DEC_PRE:\n      return 2 + estimateCostOneLevel(n.getFirstChild());\n    case Token.NEW:\n    case Token.GETELEM:\n    case Token.GETPROP:\n    case Token.CALL:\n    case Token.LABEL_DEF:\n    case Token.PARAM:\n    case Token.VAR:\n    case Token.EMPTY_BLOCK:\n      return 3;\n    case Token.NUMBER:\n    case Token.STRING:\n      return 4;\n    case Token.BOOLEAN:\n      return 5;\n    case Token.NULL:\n      return 6;\n    case Token.THIS:\n      return 7;\n    case Token.SUPER:\n      return 8;\n}\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    for (int i = 0; i < size / 2; i++) {\n        final char temp = buffer[i];\n        buffer[i] = buffer[size - i - 1];\n        buffer[size - i - 1] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    final int len = size;\n    if (len <= 1) {\n        return this;\n    }\n    final char[] buf = buffer;\n    for (int i = 0, j = len - 1; i < j; i++, j--) {\n        char tmp = buf[i];\n        buf[i] = buf[j];\n        buf[j] = tmp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    final int len = size;\n    for (int i = 0; i < len / 2; i++) \n    {\n        final char tmp = buffer[i];\n        buffer[i] = buffer[len - i - 1];\n        buffer[len - i - 1] = tmp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if(size > 1)\n    {\n        int i = 0;\n        int j = size - 1;\n        while(i < j) \n        {\n            char temp = buffer[i];\n            buffer[i] = buffer[j];\n            buffer[j] = temp;\n            i++;\n            j--;\n        }\n        \n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    final int len = size;\n    if (len > 0) \n    {\n        for (int i = 0, j = len - 1; i < j; i++, j--) \n        {\n            final char c = buffer[i];\n            buffer[i] = buffer[j];\n            buffer[j] = c;\n        }\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    for (int i = 0, j = size - 1; i < j; i++, j--) \n    {\n        char temp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    for (int i = 0; i < size / 2; i++) \n    {\n        final char tmp = buffer[size - i - 1];\n        buffer[size - i - 1] = buffer[i];\n        buffer[i] = tmp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    for (int i = 0, j = size - 1; i < j; i++, j--) {\n        final char tmp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = tmp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if(size <= 1) return this;\n    int start = 0;\n    int end = size - 1;\n    while(start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    final int len = size;\n    for (int i = 0; i < len / 2; i++) \n    {\n        final char tmp = buffer[i];\n        buffer[i] = buffer[len - i - 1];\n        buffer[len - i - 1] = tmp;\n    }\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n\tValidate.isTrue(offset >= 0, \"offset must be >= 0, was %s\", offset);\n    String text = getWholeText();\n    if (offset >= text.length()) {\n        throw new IllegalArgumentException(\"offset (\" + offset + \") must be < text length (\" + text.length() + \")\");\n    }\n    TextNode afterNode = new TextNode(text.substring(offset));\n    TextNode beforeNode = new TextNode(text.substring(0, offset));\n    parentNode.insertBefore(afterNode, this);\n    parentNode.insertBefore(beforeNode, afterNode);\n    parentNode.removeChild(this);\n    return afterNode;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > coreValue().length())\n        throw new IllegalArgumentException(\"Offset must be between 0 and \" + coreValue().length() + \", but was \" + offset);\n\n    String text = coreValue();\n    String beforeText = text.substring(0, offset);\n    String afterText = text.substring(offset);\n\n    TextNode beforeNode = new TextNode(beforeText);\n    TextNode afterNode = new TextNode(afterText);\n\n    parentNode().insertBefore(afterNode, this);\n    parentNode().removeChild(this);\n\n    return afterNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0 && offset <= value.length(), \"Offset must be between 0 and the length of the text node\");\n    String before = value.substring(0, offset);\n    String after = value.substring(offset);\n    TextNode beforeNode = new TextNode(before);\n    TextNode afterNode = new TextNode(after);\n    parentNode.insertBefore(afterNode, this.nextSibling());\n    parentNode.insertBefore(beforeNode, afterNode);\n    return afterNode;\n}",
      "public TextNode splitText(int offset)  {\n\t String text = text();\n\n\t if (offset >= 0 && offset < text.length()) \n\t {\n\t     String head = text.substring(0, offset);\n\t     String tail = text.substring(offset);\n\n\t     TextNode headNode = new TextNode(head);\n\t     TextNode tailNode = new TextNode(tail);\n\n\t     parent().insertBefore(this, tailNode);\n\n\t     return tailNode;\n\t }\n\n\t return null;\n}",
      "public TextNode splitText(int offset)  {\n\t String text = text();\n     if (offset < 0 || offset >= text.length()) \n     {\n         throw new IndexOutOfBoundsException(\"Offset must be between 0 and text length, but was: \" + offset);\n     }\n\n     TextNode prefixNode = new TextNode(text.substring(0, offset));\n     TextNode suffixNode = new TextNode(text.substring(offset));\n\n     parentNode().insertBefore(suffixNode, this.nextSibling());\n     parentNode().insertBefore(prefixNode, suffixNode);\n     return suffixNode;\n}",
      "public TextNode splitText(int offset)  {\n\tString text = text();\n    if (offset < 0 || offset >= text.length())\n        throw new IndexOutOfBoundsException(\"Offset (\" + offset + \") must be between 0 and text length (\" + text.length() + \").\");\n\n    TextNode siblingTextNode = new TextNode(text.substring(offset));\n    siblingTextNode.parent(this.parentNode);\n    siblingTextNode.nextSibling(this.nextSibling);\n    this.parent().replaceChild(siblingTextNode, this);\n\n    return siblingTextNode;\n}",
      "public TextNode splitText(int offset)  {\n\t String text = getWholeText();\n\t TextNode node = new TextNode(text.substring(offset));\n\t TextNode newnode = new TextNode(text.substring(0, offset));\n\t parentNode.insertBefore(newnode, this);\n\t parentNode.insertAfter(node, newnode);\n\t return node;\n}",
      "public TextNode splitText(int offset)  {\n\tTextNode textNode = new TextNode(value.substring(offset));\n\tTextNode newTextNode = new TextNode(value.substring(0, offset));\n\tparentNode().insertBefore(newTextNode, this);\n\tparentNode().insertBefore(textNode, this);\n\treturn textNode;\n}",
      "public TextNode splitText(int offset)  {\n\tTextNode firstNode = new TextNode(StringUtil.substring(value, 0, offset));\n\tTextNode secondNode = new TextNode(StringUtil.substring(value, offset));\n\tparentNode.insertBefore(this, firstNode);\n\tparentNode.insertBefore(secondNode, this);\n\tparentNode.removeChild(this);\n\treturn secondNode;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset <= 0) {\n        throw new IllegalArgumentException(\"offset must be greater than zero\");\n    }\n    if (offset >= coreValue().length()) {\n        throw new IllegalArgumentException(\"offset cannot be greater than the text length\");\n    }\n\n    String textBefore = coreValue().substring(0, offset);\n    String textAfter = coreValue().substring(offset);\n\n    TextNode beforeNode = new TextNode(textBefore);\n    TextNode afterNode = new TextNode(textAfter);\n\n    parent().insertBefore(this, afterNode);\n    parent().removeChild(this);\n\n    return afterNode;\n}"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[LONG];\n    putLong(value.longValue(), result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[LONG];\n    putLong(value.longValue(), result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[LONG];\n    putLong(value.longValue(), result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[LONG];\n    putLong(value.longValue(), result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[ZIP_EIGHT_BYTE_INTEGER_BYTE_LENGTH];\n        ByteUtils.toLittleEndian(result, value.longValue(), 0, ZIP_EIGHT_BYTE_INTEGER_BYTE_LENGTH);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[ZIP_LONG_BYTE_LENGTH];\n        putLong(value.longValue(), result, 0);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[ZIP_EIGHT_BYTE_INTEGER_BYTES];\n        ZipEightByteInteger.putLong(value.longValue(), result, 0);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[LONG];\n    putLong(value.longValue(), result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[LONG];\n    putLong(value.longValue(), result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[LONG];\n    putLong(value.longValue(), result, 0);\n    return result;\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set))\n        return str;\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final StringBuilder result = new StringBuilder();\n    final CharSet chars = CharSet.getInstance(set);\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            result.append(c);\n        }\n    }\n    return result.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}\n\n//-----------------------------------------------------------------------",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set))\n    {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return null;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set))\n    {\n        return str;\n    }\n    return modify(str, set, true);\n}"
    ],
    [
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric\");\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\"Matrix is not positive definite\");\n    }\n    return cachedL;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (hasComplexEigenvalues()) {\n        throw new MathUnsupportedOperationException(\"Can't compute square root of matrix with complex eigenvalues\");\n    }\n    RealMatrix sqrtM = squareRoot(cachedV.transpose());\n    sqrtM = sqrtM.scalarMultiply(Math.sqrt(2));\n    return sqrtM;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (hasComplexEigenvalues()) {\n        throw new MathUnsupportedOperationException(\"Matrix is not real, cannot compute square root\");\n    }\n    RealMatrix D = getD();\n    RealMatrix squareRoot = squareRoot(D);\n    for (int i = 0; i < squareRoot.getRowDimension(); i++) {\n        for (int j = 0; j < squareRoot.getColumnDimension(); j++) {\n            if (i != j) {\n                squareRoot.setEntry(i, j, 0);\n            }\n        }\n    }\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (hasComplexEigenvalues()) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric or positive definite.\");\n    }\n    RealMatrix squareRootMatrix = new LUDecomposition(cachedL).getSolver().getInverse();\n    return squareRootMatrix;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric() || !isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    return squareRoot(this.getSolver().getSolver().getMatrix());\n}",
      "public RealMatrix getSquareRoot()  {\n    if (hasComplexEigenvalues()) {\n        throw new MathUnsupportedOperationException();\n    }\n    return squareRoot(getSolver().getMatrixSolver().getMatrix());\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\"Matrix must be symmetric.\");\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\"Matrix must be positive definite.\");\n    }\n\n    RealMatrix L = cachedL;\n    if (L == null) {\n        // Construct L from L^T and set diagonal entries to square root of diagonal\n        // elements of L^T\n        double[][] lTData = this.lTData;\n        L = new Array2DRowRealMatrix(lTData.length);\n        for (int i = 0; i < lTData.length; i++) {\n            double diagonalElement = lTData[i][i];\n            L.setEntry(i, i, FastMath.sqrt(diagonalElement));\n        }\n        // Set off-diagonal elements of L to the corresponding elements in L^T\n        for (int i = 0; i < lTData.length; i++) {\n            for (int j = 0; j <= i; j++) {\n                L.setEntry(i, j, lTData[i][j]);\n            }\n        }\n        cachedL = L;\n    }\n\n    return L;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\"Matrix must be symmetric.\");\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\"Matrix must be positive definite.\");\n    }\n    return new DiagonalMatrix(main)\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric\");\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\"Matrix is not positive definite\");\n    }\n    return squareRoot(this);\n}",
      "public RealMatrix getSquareRoot()  {\n    if (hasComplexEigenvalues()) {\n        throw new MathUnsupportedOperationException();\n    }\n    return squareRoot(cachedV);\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // [databind#631]: Assign current value, to be accessible by custom deserializers\n        p.setCurrentValue(null);\n        \n        // Ok: must point to START_OBJECT or FIELD_NAME\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n            return (Map<Object,Object>) ctxt.handleUnexpectedToken(getMapClass(), p);\n        }\n        // 21-Apr-2017, tatu: Need separate methods to do proper merging\n        if (_standardStringKey) {\n            _readAndUpdateStringKeyMap(p, ctxt, null);\n            return null;\n        }\n        _readAndUpdate(p, ctxt, null);\n        return null;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_NULL) {\n            return _missingToken(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_STRING) {\n            String str = p.getText();\n            if (str.isEmpty()) {\n                return deserializeUsingPropertyBasedWithExternalTypeId(p, ctxt);\n            }\n            try {\n                return _deserializeOther(p, ctxt, t);\n            } catch (Exception e) {\n                return _deserializeUsingPropertyBased(p, ctxt);\n            }\n        }\n        if (t == JsonToken.START_OBJECT) {\n            return _deserializeUsingPropertyBased(p, ctxt);\n        }\n        if (t == JsonToken.START_ARRAY) {\n            return deserializeWithExternalTypeId(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            Number num = p.getDecimalValue();\n            try {\n                return _deserializeOther(p, ctxt, t);\n            } catch (Exception e) {\n                return num;\n            }\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            Number num = p.getDecimalValue();\n            try {\n                return _deserializeOther(p, ctxt, t);\n            } catch (Exception e) {\n                return num;\n            }\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return _deserializeUsingPropertyBased(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return _deserializeUsingPropertyBased(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            JsonDeserializer<?> deser = ctxt.getDeserializerProvider().getDeserializer(p.getCurrentToken(), p, ctxt);\n            if (deser != null) {\n                return deser.deserialize(p, ctxt);\n            }\n        }\n        return _deserializeUsingPropertyBased(p, ctxt);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        Object bean = _bean;\n        Set<String> ignorableProps = _ignorableProperties;\n        if (ignorableProps == null) {\n            ignorableProps = ctxt.getIgnoredPropertyNames();\n        }\n        String propName;\n        while ((propName = p.nextFieldName()) != null) {\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                try {\n                    prop.deserializeAndSet(p, ctxt, bean);\n                } catch (Exception e) {\n                    wrapAndThrow(e, bean, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, bean, propName);\n        }\n        return bean;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // [databind#631]: Assign current value, to be accessible by custom deserializers\n        p.setCurrentValue(null);\n        \n        if (t == JsonToken.START_OBJECT) {\n            // 21-Apr-2017, tatu: Need separate methods to do proper merging\n            if (_standardStringKey) {\n                _readAndUpdateStringKeyMap(p, ctxt, result);\n                return result;\n            }\n            _readAndUpdate(p, ctxt, result);\n            return result;\n        } else if (t == JsonToken.START_ARRAY) {\n            // 26-Oct-2016, tatu: Will fail, but let the original deserializer provide message\n            return _delegate.deserialize(p, ctxt, null);\n        }\n        // Handle null token: we need to return something\n        return _missingToken(p, ctxt);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // [databind#631]: Assign current value, to be accessible by custom deserializers\n        p.setCurrentValue(result);\n        \n        // Ok: must point to START_OBJECT or FIELD_NAME\n        JsonToken t = p.getCurrentToken();\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n            return (Map<Object,Object>) ctxt.handleUnexpectedToken(getMapClass(), p);\n        }\n        // 21-Apr-2017, tatu: Need separate methods to do proper merging\n        if (_standardStringKey) {\n            _readAndUpdateStringKeyMap(p, ctxt, result);\n            return result;\n        }\n        _readAndUpdate(p, ctxt, result);\n        return result;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // [databind#631]: Assign current value, to be accessible by custom deserializers\n        p.setCurrentValue(ctxt.getObjectInstance());\n\n        // Ok: must point to START_OBJECT or FIELD_NAME\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n            return ctxt.handleUnexpectedToken(getMapClass(), p);\n        }\n        // 21-Apr-2017, tatu: Need separate methods to do proper merging\n        if (_standardStringKey) {\n            _readAndUpdateStringKeyMap(p, ctxt, result);\n            return result;\n        }\n        _readAndUpdate(p, ctxt, result);\n        return result;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_STRING) {\n            if (_beanType.isAssignableFrom(String.class)) {\n                return p.getText();\n            } else {\n                throw new IllegalArgumentException(\"Invalid type: expected String or a subtype of it\");\n            }\n        } else if (t == JsonToken.VALUE_NUMBER_INT) {\n            if (_beanType.isAssignableFrom(Integer.class)) {\n                return p.getIntValue();\n            } else {\n                throw new IllegalArgumentException(\"Invalid type: expected Integer or a subtype of it\");\n            }\n        } else if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            if (_beanType.isAssignableFrom(Float.class)) {\n                return p.getFloatValue();\n            } else if (_beanType.isAssignableFrom(Double.class)) {\n                return p.getDoubleValue();\n            } else {\n                throw new IllegalArgumentException(\"Invalid type: expected Float or a subtype of it\");\n            }\n        } else if (t == JsonToken.VALUE_TRUE) {\n            if (_beanType.isAssignableFrom(Boolean.class)) {\n                return Boolean.TRUE;\n            } else {\n                throw new IllegalArgumentException(\"Invalid type: expected Boolean or a subtype of it\");\n            }\n        } else if (t == JsonToken.VALUE_FALSE) {\n            if (_beanType.isAssignableFrom(Boolean.class)) {\n                return Boolean.FALSE;\n            } else {\n                throw new IllegalArgumentException(\"Invalid type: expected Boolean or a subtype of it\");\n            }\n        } else if (t == JsonToken.VALUE_NULL) {\n            return null;\n        } else if (t == JsonToken.START_ARRAY) {\n            if (_beanType.isAssignableFrom(List.class)) {\n                List<Object> result = new ArrayList<>();\n                p.nextToken();\n                while (p.hasNext()) {\n                    result.add(p.readValue(Object.class));\n                }\n                return result;\n            } else {\n                throw new IllegalArgumentException(\"Invalid type: expected List or a subtype of it\");\n            }\n        } else if (t == JsonToken.START_OBJECT) {\n            if (_beanType.isAssignableFrom(Map.class)) {\n}\n}\n}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // [databind#631]: Assign current value, to be accessible by custom deserializers\n        p.setCurrentValue(null);\n        \n        if (t == JsonToken.START_ARRAY) {\n            return ctxt.readValue(p, _containerType);\n        } else if (t == JsonToken.START_OBJECT) {\n            return _deserializeFromObject(p, ctxt);\n        } else {\n            return deserializeIfNatural(p, ctxt, _containerType.getRawClass());\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.START_OBJECT) {\n            return deserialize(p, ctxt, _beanType.getValueType().getValueClass());\n        } else {\n            return deserializeUsingPropertyBased(p, ctxt);\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.START_OBJECT) {\n            return deserialize(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return deserializeFromNull(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return deserializeUsingPropertyBased(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_STRING) {\n            return deserializeFromObject(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT ||\n            t == JsonToken.VALUE_NUMBER_FLOAT ||\n            t == JsonToken.VALUE_TRUE ||\n            t == JsonToken.VALUE_FALSE) {\n            return deserialize(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return deserializeFromNull(p, ctxt);\n        }\n        if (t == JsonToken.START_ARRAY) {\n            if (isTypeIdPresent()) {\n                return deserializeWithExternalTypeId(p, ctxt);\n            } else {\n                return deserialize(p, ctxt);\n            }\n        }\n        return _missingToken(p, ctxt);\n    }"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0.0d;\n    for (int i = 0; i < sample1.length; i++)\n    {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0d;\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n == 0) {\n        throw new NoDataException();\n    }\n    for (int i = 0; i < n; i++) {\n        sum += (sample1[i] - sample2[i]);\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length)\n    {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0)\n    {\n        throw new NoDataException();\n    }\n    double sum = 0.0;\n    for (int i=0; i<sample1.length; i++)\n    {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0.0;\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0.0d;\n    for (int i = 0; i < sample1.length; i++)\n    {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n == 0) {\n        throw new NoDataException(\"Cannot compute sum of differences from empty arrays\");\n    }\n    double sum = 0d;\n    for (int i = 0; i < n; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    double sum = 0.0;\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    for (int i = 0; i < sample1.length; ++i) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0.0;\n    for (int i = 0; i < sample1.length; ++i) {\n        sum += (sample1[i] - sample2[i]);\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n == 0) {\n        throw new NoDataException(\"Cannot compute statistics on empty sample\");\n    }\n    double sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int currentSize = _size;\n        int newSize = currentSize + fullChunk.length;\n        Object[] result;\n        if (newSize <= SMALL_CHUNK) {\n            result = _freeBuffer;\n            if (result == null) {\n                result = new Object[SMALL_CHUNK];\n            } else if (result.length < newSize) {\n                result = new Object[newSize];\n            }\n            System.arraycopy(fullChunk, 0, result, currentSize, fullChunk.length);\n        } else {\n            result = new Object[newSize];\n            System.arraycopy(fullChunk, 0, result, currentSize, fullChunk.length);\n        }\n        _freeBuffer = null;\n        _size = newSize;\n        return result;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int size = fullChunk.length;\n        if (_size + size > MAX_CHUNK) {\n            throw new IllegalStateException(\"Cannot append full chunk, as it would exceed max allowed size\");\n        }\n        if (_freeBuffer == null || _freeBuffer.length < size) {\n            _freeBuffer = new Object[size];\n        }\n        System.arraycopy(fullChunk, 0, _freeBuffer, _size, size);\n        _size += size;\n        return _freeBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int totalSize = _size + fullChunk.length;\n        Object[] result = new Object[totalSize];\n        _copyTo(result, totalSize, fullChunk, fullChunk.length);\n        _reset();\n        return result;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int len = fullChunk.length;\n        if (_head == null) {\n            _head = new LinkedNode<Object[]>(fullChunk);\n            _tail = _head;\n        } else {\n            _tail._next = new LinkedNode<Object[]>(fullChunk);\n            _tail = _tail._next;\n        }\n        _size += len;\n        return _freeBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        final int newSize = fullChunk.length + _size;\n        if (newSize >= SMALL_CHUNK) {\n            Object[] newChunk = new Object[newSize];\n            if (_size > 0) {\n                System.arraycopy(_freeBuffer, 0, newChunk, 0, _size);\n            }\n            System.arraycopy(fullChunk, 0, newChunk, _size, fullChunk.length);\n            _freeBuffer = null;\n            _size = newSize;\n            return newChunk;\n        } else {\n            if (_freeBuffer == null) {\n                _freeBuffer = new Object[Math.max(12, _size)];\n            }\n            if (_size > 0) {\n                System.arraycopy(_freeBuffer, 0, _freeBuffer, fullChunk.length, _size);\n            }\n            System.arraycopy(fullChunk, 0, _freeBuffer, 0, fullChunk.length);\n            _size += fullChunk.length;\n            return _freeBuffer;\n        }\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int len = fullChunk.length;\n        int newSize = _size + len;\n        if (newSize > SMALL_CHUNK) {\n            int newCapacity = Math.max(MAX_CHUNK, newSize * 2);\n            Object[] newBuffer = new Object[newCapacity];\n            if (_size > 0) {\n                System.arraycopy(_head.getValue(), 0, newBuffer, 0, _size);\n            }\n            System.arraycopy(fullChunk, 0, newBuffer, _size, len);\n            _head = new LinkedNode<>(newBuffer);\n            _tail = _head;\n            _size = newSize;\n            _freeBuffer = null;\n            return newBuffer;\n        } else {\n            Object[] result = _freeBuffer;\n            if (result == null) {\n                result = new Object[SMALL_CHUNK];\n                _freeBuffer = result;\n            } else if (_freeBuffer.length < len) {\n                result = new Object[len];\n                System.arraycopy(_freeBuffer, 0, result, 0, _freeBuffer.length);\n                _freeBuffer = result;\n            }\n            if (_size > 0) {\n                System.arraycopy(_head.getValue(), 0, result, _freeBuffer.length - _size, _size);\n            }\n            System.arraycopy(fullChunk, 0, result, _freeBuffer.length - _size, len);\n            if (_size > 0) {\n                _head.setValue(result);\n            } else {\n                _head = new LinkedNode<>(result);\n            }\n            _tail = _head;\n            _size = newSize;\n            return result;\n        }\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int totalSize = _size + fullChunk.length;\n        if (_freeBuffer == null) {\n            _freeBuffer = new Object[Math.max(12, totalSize)];\n        } else {\n            if (_freeBuffer.length < totalSize) {\n                Object[] old = _freeBuffer;\n                _freeBuffer = new Object[Math.max(old.length * 2, totalSize)];\n                System.arraycopy(old, 0, _freeBuffer, 0, _size);\n            }\n        }\n        System.arraycopy(fullChunk, 0, _freeBuffer, _size, fullChunk.length);\n        int newSize = fullChunk.length;\n        _size = totalSize;\n        return _freeBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        final int fullChunkSize = fullChunk.length;\n        final int currentSize = _size;\n\n        // copy chunk into internal buffer, if possible\n        if ((_freeBuffer == null) || (_freeBuffer.length < fullChunkSize + currentSize)) {\n            _freeBuffer = new Object[Math.max(12, fullChunkSize + currentSize)];\n        }\n        System.arraycopy(fullChunk, 0, _freeBuffer, currentSize, fullChunkSize);\n\n        // update internal size\n        _size += fullChunkSize;\n\n        // return chunk we allocated for caller\n        return fullChunk;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int totalSize = fullChunk.length + _size;\n        if (totalSize <= SMALL_CHUNK) {\n            Object[] result = new Object[totalSize];\n            System.arraycopy(fullChunk, 0, result, 0, fullChunk.length);\n            if (_size > 0) {\n                System.arraycopy(_freeBuffer, 0, result, fullChunk.length, _size);\n            }\n            _reset();\n            return result;\n        } else if (totalSize <= MAX_CHUNK) {\n            Object[] result = new Object[totalSize];\n            if (_size > 0) {\n                System.arraycopy(_freeBuffer, 0, result, 0, _size);\n            }\n            System.arraycopy(fullChunk, 0, result, _size, fullChunk.length);\n            _reset();\n            return result;\n        } else {\n            Object[] result = new Object[totalSize];\n            int firstPartSize = Math.min(totalSize - MAX_CHUNK, MAX_CHUNK - _size);\n            if (firstPartSize > 0) {\n                System.arraycopy(_freeBuffer, 0, result, 0, firstPartSize);\n                int secondPartSize = totalSize - firstPartSize - MAX_CHUNK;\n                if (secondPartSize > 0) {\n                    System.arraycopy(fullChunk, 0, result, firstPartSize, secondPartSize);\n                    System.arraycopy(fullChunk, secondPartSize, result, firstPartSize + secondPartSize, MAX_CHUNK);\n                } else {\n                    System.arraycopy(fullChunk, 0, result, firstPartSize, secondPartSize);\n                }\n            } else {\n                System.arraycopy(fullChunk, 0, result, 0, totalSize - MAX_CHUNK);\n                System.arraycopy(fullChunk, totalSize - MAX_CHUNK, result, totalSize - MAX_CHUNK, MAX_CHUNK);\n            }\n            _reset();\n            return result;\n        }\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int fullChunkSize = fullChunk.length;\n        Object[] result = null;\n        int newSize = _size + fullChunkSize;\n\n        if (newSize <= SMALL_CHUNK) {\n            if (_freeBuffer != null) {\n                result = _freeBuffer;\n                System.arraycopy(fullChunk, 0, result, _size, fullChunkSize);\n            } else {\n                result = new Object[SMALL_CHUNK];\n                System.arraycopy(fullChunk, 0, result, 0, fullChunkSize);\n            }\n        } else if (newSize <= MAX_CHUNK) {\n            result = new Object[MAX_CHUNK];\n            System.arraycopy(fullChunk, 0, result, _size, fullChunkSize);\n        } else {\n            result = new Object[newSize];\n            Object[] temp = fullChunk;\n\n            while (temp.length < newSize) {\n                System.arraycopy(temp, 0, result, _size, temp.length);\n                _size += temp.length;\n                temp = resetAndStart(temp, temp.length);\n            }\n\n            System.arraycopy(temp, 0, result, _size, temp.length);\n            _size += temp.length;\n        }\n        return result;\n    }"
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    if (pattern == null) {\n        throw new IllegalArgumentException(\"Pattern must not be null\");\n    }\n    int length = pattern.length();\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    for (int i = 0; i < length; i++) {\n        char c = pattern.charAt(i);\n        if (c >= '0' && c <= '9') {\n            builder.appendLiteral(c);\n        } else {\n            switch (c) {\n            case 'c': // century (number)\n                builder.appendCenturyOfEra();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra();\n                break;\n            case 'x': // weekyear (number)\n                builder.appendWeekyear();\n                break;\n            case 'y': // year (number)\n                builder.appendYear();\n                break;\n            case 'Y': // year of era (number)\n                builder.appendYearOfEra();\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth();\n                break;\n            case 'h': // hour of day (number, 1..12)\n                builder.appendHourOfDay12();\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay();\n                break;\n            case 'k': // hour of day (1..24)\n                builder.appendHourOfDay24();\n                break;\n            case 'K': // hour of day (0..11)\n                builder.appendHourOfDay0To11();\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour();\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute();\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendMillisOfSecond();\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeekInMonth();\n                break;\n            case 'E': // day of week (text)\n                builder.appendDayOfWeekText();\n}\n}\n}\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    // ...\n    return new DateTimeFormatter(printer, parser);\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    if (pattern == null) {\n        throw new IllegalArgumentException(\"pattern must not be null\");\n    }\n    int len = pattern.length();\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    for (int i = 0; i < len; i++) {\n        char ch = pattern.charAt(i);\n        switch (ch) {\n        case 'G': { // era\n            appendPatternTo(builder, \"G\");\n            break;\n        }\n        case 'y': { // year\n            appendPatternTo(builder, \"yyyy\");\n            break;\n        }\n        case 'M': { // month of year\n            appendPatternTo(builder, \"MM\");\n            break;\n        }\n        case 'w': { // week of year\n            appendPatternTo(builder, \"ww\");\n            break;\n        }\n        case 'W': { // week of month\n            appendPatternTo(builder, \"W\");\n            break;\n        }\n        case 'd': { // day of month\n            appendPatternTo(builder, \"dd\");\n            break;\n        }\n        case 'E': { // day of week\n            appendPatternTo(builder, \"EEEE\");\n            break;\n        }\n        case 'F': { // day of week in month\n            appendPatternTo(builder, \"F\");\n            break;\n        }\n        case 'h': { // hour of day (1..12)\n            appendPatternTo(builder, \"hh\");\n            break;\n        }\n        case 'k': { // hour of day (1..24)\n            appendPatternTo(builder, \"kk\");\n            break;\n        }\n        case 'H': { // hour of day (0..23)\n            appendPatternTo(builder, \"HH\");\n            break;\n        }\n        case 'K': { // hour of day (0..11)\n            appendPatternTo(builder, \"KK\");\n            break;\n        }\n        case 'm': { // minute of hour\n            appendPatternTo(builder, \"mm\");\n            break;\n        }\n        case 's': { // second of minute\n            appendPatternTo(builder, \"ss\");\n            break;\n        }\n}\n}\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    if (pattern == null || pattern.isEmpty()) {\n        throw new IllegalArgumentException(\"Empty pattern\");\n    }\n    \n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    DateTimeFormatter formatter = builder.toFormatter();\n    return formatter;\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    // Check for valid characters in pattern.\n    for (int i = 0; i < pattern.length(); i++) {\n        char c = pattern.charAt(i);\n        if (c == 'c' || c == 'C' || c == 'x' || c == 'y' || c == 'Y' || c == 'M' || c == 'd' || c == 'h' || c == 'H' || c == 'k' || c == 'K' || c == 'm' || c == 's' || c == 'S' || c == 'e' || c == 'D' || c == 'F' || c == 'w' || c == 'W') {\n            continue;\n        }\n\n        if (c == 'a' || c == 'b' || c == 'g' || c == 'h' || c == 'i' || c == 'j' || c == 'k' || c == 'l' || c == 'm' || c == 'n' || c == 'o' || c == 'p' || c == 'r' || c == 's' || c == 't' || c == 'u' || c == 'v' || c == 'w' || c == 'x' || c == 'y') {\n            throw new IllegalArgumentException(\"Invalid character in pattern: \" + c);\n        }\n\n        if (c == 'E' || c == 'F' || c == 'G' || c == 'H' || c == 'K' || c == 'L' || c == 'M' || c == 'R' || c == 'S' || c == 'T' || c == 'U' || c == 'V' || c == 'W' || c == 'X' || c == 'Y' || c == 'Z') {\n            throw new IllegalArgumentException(\"Invalid character in pattern: \" + c);\n        }\n        \n        if (c == ';' || c == ':' || c == '.' || c == '[' || c == ']' || c == '\\'' || c == '\"' || c == ',' || c == '@') {\n            throw new IllegalArgumentException(\"Invalid character in pattern: \" + c);\n        }\n        \n        if (c == '#') {\n}\n}\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    // Create a StringBuilder to hold the rules.\n    StringBuilder buf = new StringBuilder(pattern.length() * 2);\n\n    // Split the pattern into tokens.\n    int start = 0;\n    int end = 0;\n    while (end < pattern.length()) {\n        char c = pattern.charAt(end);\n        switch (c) {\n        case 'c': // century (number)\n        case 'C': // century of era (number)\n        case 'x': // weekyear (number)\n        case 'y': // year (number)\n        case 'Y': // year of era (number)\n        case 'd': // day of month (number)\n        case 'h': // hour of day (number, 1..12)\n        case 'H': // hour of day (number, 0..23)\n        case 'm': // minute of hour (number)\n        case 's': // second of minute (number)\n        case 'S': // fraction of second (number)\n        case 'e': // day of week (number)\n        case 'D': // day of year (number)\n        case 'F': // day of week in month (number)\n        case 'w': // week of year (number)\n        case 'W': // week of month (number)\n        case 'k': // hour of day (1..24)\n        case 'K': // hour of day (0..11)\n        case 'M': // month of year (text and number)\n        case '\\'': // literal character\n            end++;\n            break;\n        case 'L': // long\n        case 'M': // medium\n        case 'S': // short\n            buf.append(pattern.charAt(end++));\n            break;\n        case 'z': // time zone\n            if (end == start) {\n                buf.append(c);\n                end++;\n            } else {\n                throw new IllegalArgumentException(\"Time zone pattern without time\");\n            }\n            break;\n        default:\n            throw new IllegalArgumentException(\"Invalid pattern character '\" + c + \"'\");\n        }\n    }\n    String rule = buf.toString();\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n}"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) \n    {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL_KEYWORD) \n    {\n      next();\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED_KEYWORD) \n    {\n      next();\n      return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.NAME) \n    {\n      return parseTypeName(token);\n    } else if (token == JsDocToken.LAMBDA) \n    {\n      return parseFunctionType(token);\n    } else if (token == JsDocToken.LP) \n    {\n      return parseUnionType(token);\n    } else if (token == JsDocToken.LC) \n    {\n      return parseRecordType(token);\n    } else if (token == JsDocToken.LB) \n    {\n      return parseArrayType(token);\n    } else \n    {\n      return reportGenericTypeSyntaxWarning();\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) \n  {\n    return newNode(Token.STAR);\n  }\n  else if (token == JsDocToken.NULL) \n  {\n    return newNode(Token.NULL);\n  }\n  else if (token == JsDocToken.UNDEFINED) \n  {\n    return newNode(Token.UNDEFINED);\n  }\n  else if (token == JsDocToken.STRING) \n  {\n    return newStringNode(stream.getString());\n  }\n  else if (token == JsDocToken.LAMBDA) \n  {\n    return parseFunctionType(next());\n  }\n  else if (token == JsDocToken.LP) \n  {\n    return parseUnionType(next());\n  }\n  else if (token == JsDocToken.LC) \n  {\n    return parseRecordType(next());\n  }\n  else if (token == JsDocToken.LB) \n  {\n    return parseArrayType(next());\n  }\n  else \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR)\n  {\n    return newNode(Token.STAR);\n  }\n  else if (token == JsDocToken.NULL)\n  {\n    return newNode(Token.NULL);\n  }\n  else if (token == JsDocToken.UNDEFINED)\n  {\n    return newNode(Token.UNDEFINED);\n  }\n  else if (token == JsDocToken.NAME)\n  {\n    return parseTypeName(next());\n  }\n  else if (token == JsDocToken.LAMBDA)\n  {\n    return parseFunctionType(next());\n  }\n  else if (token == JsDocToken.LP)\n  {\n    return parseUnionType(next());\n  }\n  else if (token == JsDocToken.LBRACE)\n  {\n    return parseRecordType(next());\n  }\n  else if (token == JsDocToken.LB)\n  {\n    return parseArrayType(next());\n  }\n  else\n  {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.STRING) {\n        String typeName = stream.getString();\n        int lineno = stream.getLineno();\n        int charno = stream.getCharno();\n        while (match(JsDocToken.EOL) &&\n               typeName.charAt(typeName.length() - 1) == '.') {\n            skipEOLs();\n            if (match(JsDocToken.STRING)) {\n                next();\n                typeName += stream.getString();\n            }\n        }\n        return newStringNode(typeName, lineno, charno);\n    } else if (token == JsDocToken.LAMBDA) {\n        return parseFunctionType(next());\n    } else if (token == JsDocToken.LP) {\n        return parseUnionType(next());\n    } else if (token == JsDocToken.LC) {\n        return parseRecordType(next());\n    } else if (token == JsDocToken.LB) {\n        return parseArrayType(next());\n    } else {\n        return reportGenericTypeSyntaxWarning();\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.NAME) {\n    return parseTypeName(next());\n  } else if (token == JsDocToken.LAMBDA) {\n    return parseFunctionType(next());\n  } else if (token == JsDocToken.LP) {\n    return parseUnionType(next());\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(next());\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(next());\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.STRING) {\n        String typeName = stream.getString();\n        int lineno = stream.getLineno();\n        int charno = stream.getCharno();\n        while (match(JsDocToken.EOL) &&\n               typeName.charAt(typeName.length() - 1) == '.') {\n            skipEOLs();\n            if (match(JsDocToken.STRING)) {\n                next();\n                typeName += stream.getString();\n            }\n        }\n        return newStringNode(typeName, lineno, charno);\n    } else if (token == JsDocToken.LT) {\n        return reportGenericTypeSyntaxWarning();\n    } else if (token == JsDocToken.LBRACE) {\n        return parseTypeExpression(next());\n    } else if (token == JsDocToken.QUESTIONMARK) {\n        return newNode(Token.QMARK);\n    } else if (token == JsDocToken.EXCLAMATIONMARK) {\n        return newNode(Token.BANG);\n    } else if (token == JsDocToken.LPAR) {\n        return parseFunctionType(next());\n    } else {\n        return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) \n    {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) \n    {\n        next();\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) \n    {\n        next();\n        return newNode(Token.UNDEFINED);\n    } else \n    {\n        Node typeNameNode = parseTypeName(token);\n        if (typeNameNode != null) \n        {\n            if (typeNameNode.getType() == Token.STRING && \n                typeNameNode.getString().equals(\"undefined\")) \n            {\n                typeNameNode = newNode(Token.UNDEFINED);\n            } else if (typeNameNode.getType() == Token.STRING && \n                typeNameNode.getString().equals(\"null\")) \n            {\n                typeNameNode = newNode(Token.NULL);\n            }\n        }\n        return typeNameNode;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) \n    {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) \n    {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) \n    {\n        return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.IDENTIFIER) \n    {\n        return newStringNode(token.toString());\n    } else if (token == JsDocToken.LAMBDA) \n    {\n        return parseFunctionType(next());\n    } else if (token == JsDocToken.LP) \n    {\n        return parseUnionType(next());\n    } else if (token == JsDocToken.LC) \n    {\n        return parseRecordType(next());\n    } else if (token == JsDocToken.LB) \n    {\n        return parseArrayType(next());\n    } else \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.NAME) {\n    String name = stream.getString();\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno();\n\n    if (name.equals(\"void\")) {\n      return newNode(Token.VOID, lineno, charno);\n    } else if (name.equals(\"any\")) {\n      return newNode(Token.ANY, lineno, charno);\n    } else {\n      return newStringNode(Token.NAME, name, lineno, charno);\n    }\n  } else if (token == JsDocToken.LAMBDA) {\n    return parseFunctionType(next());\n  } else if (token == JsDocToken.LBRACKET) {\n    return parseArrayType(next());\n  } else {\n    return reportGenericTypeSyntaxWarning();\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n      return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.NAME) {\n      String typeName = stream.getString();\n      int lineno = stream.getLineno();\n      int charno = stream.getCharno();\n      while (match(JsDocToken.EOL) &&\n          typeName.charAt(typeName.length() - 1) == '.') {\n        skipEOLs();\n        if (match(JsDocToken.STRING)) {\n          next();\n          typeName += stream.getString();\n        }\n      }\n      return newStringNode(typeName, lineno, charno);\n    } else if (token == JsDocToken.FUNCTION) {\n      return parseFunctionType(next());\n    } else if (token == JsDocToken.UNION) {\n      return parseUnionType(next());\n    } else if (token == JsDocToken.RECORD) {\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LBRACK) {\n      return parseArrayType(next());\n    } else {\n      return reportGenericTypeSyntaxWarning();\n    }\n  }"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new IllegalArgumentException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    if (indent == null) {\n      out.write(name);\n    } else {\n      newline();\n      out.write(indent);\n      out.write(name);\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    writeDeferredName();\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException(\"cannot call name() after name()\");\n    }\n    if (stack[stackSize - 1] == NONEMPTY_OBJECT) \n    {\n        throw new IllegalStateException(\"cannot call name() after value()\");\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n\n    writeDeferredName();\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    if (indent == null) {\n      out.append(name).append(':');\n    } else {\n      newline();\n      indent(true);\n      out.append(name).append(':');\n      indent(false);\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    if (stack[peek()] != BEGIN_OBJECT) {\n      throw new IllegalStateException();\n    }\n    this.deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new IllegalArgumentException(\"name must not be null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    writeDeferredName();\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException(\"Deferred name not allowed here.\");\n    }\n    beforeName();\n    out.append(name);\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new IllegalArgumentException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException(\"Cannot set name after calling beginArray() or beginObject()\");\n    }\n    this.deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    if (indent != null) {\n      newline();\n      for (int i = 0; i < stackSize; i++) {\n        out.write(indent);\n      }\n    }\n    out.write(name);\n    deferredName = name;\n    return this;\n}"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0)\n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element != null && element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element != null && element) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element != null) \n        {\n            if (element) \n            {\n                return Boolean.TRUE;\n            }\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element != null && element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n        if (array == null) \n        {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        }\n        if (array.length == 0) \n        {\n            throw new IllegalArgumentException(\"Array is empty\");\n        }\n        for (final Boolean element : array) \n        {\n            if (element != null)\n            {\n                if (element) \n                {\n                    return Boolean.TRUE;\n                }\n            }\n        }\n        return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element != null && element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        boolean result = false;\n        for (final Boolean element : array) {\n            if (element != null) {\n                result = result || element;\n            } else {\n                throw new IllegalArgumentException(\"The array must not contain any null elements\");\n            }\n        }\n        return result ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final StringBuilder initials = new StringBuilder();\n    final char[] buffer = str.toCharArray();\n    boolean startNewWord = true;\n    for (final char ch : buffer) {\n        if (isDelimiter(ch, delimiters)) {\n            startNewWord = true;\n        } else if (startNewWord) {\n            initials.append(ch);\n            startNewWord = false;\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean firstWord = true;\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (firstWord) {\n            sb.append(Character.toUpperCase(ch));\n            firstWord = false;\n        } else {\n            if (isDelimiter(ch, delimiters)) {\n                firstWord = true;\n            } else if (Character.isLowerCase(ch)) {\n                sb.append(Character.toUpperCase(ch));\n            }\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (delimiters == null) {\n        delimiters = new char[] {' '};\n    }\n\n    StringBuilder initials = new StringBuilder();\n    boolean capitalizeNext = true;\n\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n\n        if (isDelimiter(c, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            initials.append(Character.toUpperCase(c));\n            capitalizeNext = false;\n        } else {\n            initials.append(c);\n        }\n    }\n\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final StringBuilder buffer = new StringBuilder(str.length());\n    boolean capitalizeNext = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer.append(Character.toUpperCase(ch));\n            capitalizeNext = false;\n        } else {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final StringBuilder initials = new StringBuilder();\n    boolean newWord = true;\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            newWord = true;\n        } else {\n            if (newWord) {\n                initials.append(Character.toUpperCase(ch));\n                newWord = false;\n            }\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final StringBuilder initials = new StringBuilder();\n    boolean firstWord = true;\n    for (final String word : str.split(\"\\\\s+\")) {\n        if (firstWord) {\n            initials.append(Character.toUpperCase(word.charAt(0)));\n            firstWord = false;\n        } else if (isDelimiter(word.charAt(0), delimiters)) {\n            initials.append(Character.toUpperCase(word.charAt(1)));\n        } else {\n            initials.append(Character.toUpperCase(word.charAt(0)));\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final StringBuilder sb = new StringBuilder();\n    final char[] buffer = str.toCharArray();\n    boolean firstLetter = true;\n    for (final char ch : buffer) {\n        if (isDelimiter(ch, delimiters)) {\n            firstLetter = true;\n        } else if (firstLetter) {\n            sb.append(Character.toUpperCase(ch));\n            firstLetter = false;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean firstWord = true;\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            firstWord = true;\n        } else {\n            if (firstWord) {\n                sb.append(Character.toUpperCase(ch));\n                firstWord = false;\n            } else {\n                sb.append(Character.toLowerCase(ch));\n            }\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null)\n    {\n        return null;\n    }\n    if (delimiters == null) {\n        delimiters = new char[]{' '};\n    }\n    StringBuilder initials = new StringBuilder();\n    boolean wordStarted = false;\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            wordStarted = false;\n        } else {\n            if (!wordStarted) {\n                initials.append(Character.toUpperCase(ch));\n                wordStarted = true;\n            } else {\n                initials.append(ch);\n            }\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean firstWord = true;\n    StringBuilder initials = new StringBuilder();\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters) && !firstWord) {\n            initials.append(ch);\n        } else if (!isDelimiter(ch, delimiters)) {\n            initials.append(Character.toUpperCase(ch));\n            firstWord = false;\n        }\n    }\n    return initials.toString();\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null)\n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++)\n    {\n        Number n = data.getValue(r, column);\n        if (n != null)\n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    return new Point2D.Double(\n        (screenPoint.getX() - insets.left) / getScaleX(),\n        (screenPoint.getY() - insets.top) / getScaleY());\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    return new Point2D.Double((screenPoint.x - insets.left) / getScaleX(), (screenPoint.y - insets.top) / getScaleY());\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / getScaleX();\n    double y = (screenPoint.y - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    return new Point2D.Double((screenPoint.getX() - insets.left) / this.scaleX,\n                              (screenPoint.getY() - insets.top) / this.scaleY);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    int x = (int) ((screenPoint.getX() - insets.left) / this.scaleX);\n    int y = (int) ((screenPoint.getY() - insets.top) / this.scaleY);\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / getScaleX();\n    double y = (screenPoint.getY() - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    int x = (int) ((screenPoint.getX() - insets.left) / this.scaleX);\n    int y = (int) ((screenPoint.getY() - insets.top) / this.scaleY);\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / getScaleX();\n    double y = (screenPoint.y - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    return new Point2D.Double((screenPoint.x - insets.left) / getScaleX(),\n            (screenPoint.y - insets.top) / getScaleY());\n}"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n    final ParsePosition parsePosition = new ParsePosition(0);\n    final BigFraction result = parse(source, parsePosition);\n    if (parsePosition.getIndex() == 0)\n    {\n        throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n    }\n    return result;\n}",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n    final ParsePosition parsePosition = new ParsePosition(0);\n    final BigFraction result = parse(source, parsePosition);\n    if (parsePosition.getIndex() == 0) {\n        throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n    }\n    return result;\n}",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        ParsePosition parsePosition = new ParsePosition(0);\n        BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                parsePosition.getErrorIndex(),\n                BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        ParsePosition parsePosition = new ParsePosition(0);\n        BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                parsePosition.getErrorIndex(),\n                BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        ParsePosition parsePosition = new ParsePosition(0);\n        BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                parsePosition.getErrorIndex(),\n                BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source,\n                parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n    final ParsePosition parsePosition = new ParsePosition(0);\n    final BigFraction result = parse(source, parsePosition);\n    if (parsePosition.getIndex() == 0)\n    {\n        throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n    }\n    return result;\n}",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n    final ParsePosition parsePosition = new ParsePosition(0);\n    final BigFraction result = parse(source, parsePosition);\n    if (parsePosition.getIndex() == 0) {\n        throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n    }\n    return result;\n}"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>());\n    }\n\n    Set<E> set = new HashSet<>(list);\n    List<E> temp = new ArrayList<>(list.size());\n    list.clear();\n    ListOrderedSet<E> sl = new ListOrderedSet<>(set, temp);\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>();\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>();\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>();\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> os = new ListOrderedSet<E>();\n    os.addAll(temp);\n    return os;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(new HashSet<E>(), list);\n    }\n\n    final List<E> temp = new ArrayList<>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(new HashSet<E>(), list);\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<>(new HashSet<>(), list);\n    }\n\n    final List<E> temp = new ArrayList<>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<>(new HashSet<>(), list);\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>();\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>();\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n\n    // Create a new HashSet to store the unique elements\n    Set<E> uniqueElements = new HashSet<>();\n\n    // Iterate over the list and add elements to the set\n    for (E element : list) \n    {\n        uniqueElements.add(element);\n    }\n\n    // Create a new ArrayList to store the ordered elements\n    List<E> orderedElements = new ArrayList<>();\n\n    // Iterate over the set and add elements to the list\n    for (E element : uniqueElements) \n    {\n        orderedElements.add(element);\n    }\n\n    // Create a new ListOrderedSet with the unique and ordered elements\n    return new ListOrderedSet<>(uniqueElements, orderedElements);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n\n    final List<E> temp = new ArrayList<>(list);\n    list.clear();\n    final ListOrderedSet<E> orderedSet = new ListOrderedSet<>(list, new HashSet<E>());\n    orderedSet.addAll(temp);\n\n    return orderedSet;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n\n    // Create a new HashSet to store unique elements\n    Set<E> uniqueElements = new HashSet<>();\n\n    // Add elements from the list to the set\n    for (E element : list) \n    {\n        uniqueElements.add(element);\n    }\n\n    // Create a new ArrayList to store the unique elements in order\n    List<E> orderedList = new ArrayList<>(uniqueElements);\n\n    // Create and return a new ListOrderedSet object\n    return new ListOrderedSet<>(uniqueElements, orderedList);\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == null) {\n        throw new IllegalArgumentException(\"Null 'axis' argument.\");\n    }\n\n    Plot plot = getPlot();\n    if (plot == null) {\n        return axis.getDefaultAutoRange();\n    }\n\n    if (axis == this) {\n\n        // If auto-range is enabled, we need to ensure that zero is included.\n        if (isAutoRange() && getAutoRangeIncludesZero()) {\n            Range r = plot.getDataRange(this);\n            if (r == null) {\n                r = axis.getDefaultAutoRange();\n            }\n            double upper = r.getUpperBound();\n            double lower = r.getLowerBound();\n            lower = Math.min(lower, 0.0);\n            upper = Math.max(upper, 0.0);\n            return new Range(lower, upper);\n        }\n\n        // Otherwise, we just use the default auto-range.\n        return plot.getDataRange(this);\n\n    }\n    else {\n\n        // If auto-range is enabled, we need to ensure that zero is included.\n        if (axis.isAutoRange() && axis.getAutoRangeIncludesZero()) {\n            Range r = plot.getDataRange(axis);\n            if (r == null) {\n                r = axis.getDefaultAutoRange();\n            }\n            double upper = r.getUpperBound();\n            double lower = r.getLowerBound();\n            lower = Math.min(lower, 0.0);\n            upper = Math.max(upper, 0.0);\n            return new Range(lower, upper);\n        }\n\n        // Otherwise, we just use the default auto-range.\n        return plot.getDataRange(axis);\n\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (axis == this) {\n        result = Range.combine(this.range, getFixedRangeForSubplots());\n    }\n    else {\n        result = getFixedRangeForSubplots();\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == this)\n    {\n        if (isAutoRange()) \n        {\n            configure();\n        }\n        return super.getDataRange(axis);\n    }\n    else\n    {\n        Range result = null;\n        for (CategoryPlot subplot : getSubplots()) \n        {\n            Range r = subplot.getDataRange(axis);\n            if (r != null) \n            {\n                result = Range.combine(result, r);\n            }\n        }\n        return result;\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == this) \n    {\n        return super.getDataRange(axis);\n    } \n    else \n    {\n        Range result = null;\n        if (this.subplots != null) \n        {\n            Iterator iterator = this.subplots.iterator();\n            while (iterator.hasNext()) \n            {\n                CategoryPlot plot = (CategoryPlot) iterator.next();\n                Range r = plot.getDataRange(axis);\n                if (r != null) \n                {\n                    if (result == null) \n                    {\n                        result = r;\n                    } \n                    else \n                    {\n                        result = Range.combine(result, r);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == null) {\n        return null;\n    }\n\n    Range r = null;\n\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range plotRange = plot.getDataRange(axis);\n            if (r == null) \n            {\n                r = plotRange;\n            }\n            else \n            {\n                r = Range.combine(r, plotRange);\n            }\n        }\n    }\n\n    return r;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (axis == getRangeAxis()) {\n        result = getRange();\n    }\n    else {\n        Plot plot = axis.getPlot();\n        if (plot instanceof CategoryPlot) {\n            CategoryPlot categoryPlot = (CategoryPlot) plot;\n            if (categoryPlot == this) {\n                result = getRange();\n            }\n        }\n    }\n    if (result == null) {\n        result = new Range(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == this) {\n        Plot plot = getPlot();\n        if (plot == null) {\n            return getDefaultAutoRange();\n        }\n        else {\n            double lower = Double.NaN;\n            double upper = Double.NaN;\n            if (plot instanceof ValueAxisPlot) {\n                ValueAxisPlot vap = (ValueAxisPlot) plot;\n                Range r = vap.getDataRange(this);\n                if (r == null) {\n                    r = getDefaultAutoRange();\n                }\n                lower = r.getLowerBound();\n                upper = r.getUpperBound();\n            }\n            else {\n                Iterator iterator = this.subplots.iterator();\n                while (iterator.hasNext()) {\n                    CategoryPlot plot2 = (CategoryPlot) iterator.next();\n                    Range r = plot2.getDataRange(this);\n                    if (r != null) {\n                        lower = Math.min(lower, r.getLowerBound());\n                        upper = Math.max(upper, r.getUpperBound());\n                    }\n                }\n            }\n            if (!Double.isNaN(lower) && !Double.isNaN(upper)) {\n                if (getAutoRangeIncludesZero()) {\n                    lower = Math.min(lower, 0.0);\n                    upper = Math.max(upper, 0.0);\n                }\n                return new Range(lower, upper);\n            }\n        }\n    }\n    return null;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == null) {\n        throw new IllegalArgumentException(\"Null 'axis' argument.\");\n    }\n    if (this.subplots == null || this.subplots.isEmpty()) {\n        return Range.EMPTY_RANGE;\n    }\n    Range range = null;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext()) {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        Range tempRange = plot.getDataRange(axis);\n        if (tempRange == null) {\n            tempRange = Range.EMPTY_RANGE;\n        }\n        if (range == null) {\n            range = tempRange;\n        }\n        else {\n            range = Range.expand(range, tempRange);\n        }\n    }\n    return range;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (axis == getRangeAxis()) {\n        result = super.getDataRange(axis);\n    }\n    else {\n        for (CategoryPlot subplot : getSubplots()) {\n            Range r = subplot.getDataRange(axis);\n            if (result == null) {\n                result = r;\n            }\n            else {\n                result = result.combine(r);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (axis == getRangeAxis())\n    {\n        result = super.getDataRange(axis);\n    }\n    else\n    {\n        for (CategoryPlot subplot : getSubplots())\n        {\n            Range subplotRange = subplot.getDataRange(axis);\n            if (result == null)\n            {\n                result = subplotRange;\n            }\n            else\n            {\n                Range expanded = Range.expandToInclude(result, subplotRange);\n                result = expanded;\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = (Math.pow(10, val + 1.0) - 10.0) / 9.0; //invert adjustLog10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.pow(10, val + 1.0) - 10.0) / 9.0; //invert adjustLog10\n    }\n    else \n    {\n        res = Math.log10(val); // if >= 1 then use normal log10\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = (Math.pow(10, val + 1.0) - 10.0) / 9.0; //invert adjustLog10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.pow(10, val + 1.0) - 10.0) / 9.0; //invert adjustLog10\n    }\n    else \n    {\n        res = Math.log(val) / Math.log(10); // basic log10\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.pow(10, val + 1.0) - 10.0) / 9.0; //invert adjustLog10\n    }\n    else \n    {\n        res = Math.log10(val);\n    }\n    if (res < SMALL_LOG_VALUE) \n    {\n        res = SMALL_LOG_VALUE;\n    }\n    if (negFlag) \n    {\n        res = -res;\n    }\n    return res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = (Math.pow(10, val + 1.0) - 10.0) / 9.0; //invert adjustLog10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.pow(10, val + 1.0) - 10.0) / 9.0; //invert adjustLog10\n    }\n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.pow(10, val + 1.0) - 10.0) / 9.0; //invert adjustLog10\n    }\n    else \n    {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.pow(10, val + 1.0) - 10.0) / 9.0; //invert adjustLog10\n    }\n    else \n    {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.pow(10, val + 1.0) - 10.0) / 9.0; //invert adjustLog10\n    }\n    else \n    {\n        res = Math.log10(val);\n    }\n    if (negFlag) \n    {\n        return (-res);\n    }\n    else \n    {\n        return res;\n    }\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  if (cfg.isImplicitReturn(cfg.getEntry())\n      && cfg.isImplicitReturn(cfg.getImplicitReturn())) {\n    return true;\n  }\n  if (cfg.getEntry() == cfg.getImplicitReturn()) {\n    return false;\n  }\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  if (cfg.getEntry().getChildren().size() == 1 && cfg.getImplicitReturn().getChildren().size() == 1)\n  {\n    Node entryChild = cfg.getEntry().getSingleChild();\n    Node implicitReturnChild = cfg.getImplicitReturn().getSingleChild();\n    if (entryChild.isCall() && implicitReturnChild.isReturn())\n    {\n      return true;\n    }\n  }\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    if (!cfg.getImplicitReturn().isEnteringNewCfgNode()) {\n        return false;\n    }\n\n    if (cfg.getEntry().isEnteringNewCfgNode()) {\n        return true;\n    }\n\n    if (cfg.getEntry().getOptionalNodeComparator(true) == null) {\n        return false;\n    }\n\n    List<DiGraphNode<Node, ControlFlowGraph.Branch>> nodes = cfg.getNodes();\n    Collections.sort(nodes, cfg.getEntry().getOptionalNodeComparator(true));\n\n    for (DiGraphNode<Node, ControlFlowGraph.Branch> n : nodes) {\n        if (cfg.isImplicitReturn(n)) {\n            return true;\n        }\n    }\n\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  if (cfg.isImplicitReturn(cfg.getEntry())\n      && cfg.getEntry().getSuccessors().size() == 1) \n  {\n    return true;\n  }\n\n  if (cfg.getEntry().getSuccessors().size() > 2) \n  {\n    return false;\n  }\n\n  for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getEntry().getSuccessors()) \n  {\n    if (cfg.isImplicitReturn(node) && node.getSuccessors().isEmpty()) \n    {\n      return true;\n    }\n  }\n\n  for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : cfg.getEntry().getOutEdges()) \n  {\n    if (!edge.isConditional() && edge.getTarget().getSuccessors().size() == 1) \n    {\n      return false;\n    }\n  }\n\n  if (cfg.getEntry().getSuccessors().size() == 2) \n  {\n    for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : cfg.getEntry().getOutEdges()) \n    {\n      if (!edge.isConditional()) \n      {\n        return false;\n      }\n    }\n  }\n\n  if (!cfg.isImplicitReturn(cfg.getEntry())) \n  {\n    return false;\n  }\n\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // This optimization checks if all paths return.  If this is not true, then\n  // the code is guaranteed to throw an exception.  If this is true, then the code\n  // might throw an exception, but it might also return.  There is no way to\n  // tell which.  Therefore, we conservatively report that a return statement\n  // is missing.\n\n  // First, we check to see if there are any cycles in the CFG.  If there are, then\n  // all paths from the entry node to the implicit return node must visit the same\n  // node at least once.  This is because if there is a cycle, then there is\n  // no way to reach the implicit return node without visiting that node.\n\n  if (!cfg.hasCycle()) {\n    // If there are no cycles, then all paths from the entry node to the implicit\n    // return node must visit the same node at most once.  This is because if there\n    // are multiple paths, then all of them must visit the same node in order to\n    // reach the implicit return node.\n\n    return cfg.getOptionalNodeComparator(true).compare(cfg.getEntry(), cfg.getImplicitReturn()) == 0;\n  }\n\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // Check if there are any nodes in the CFG that are not functions.\n  if (!cfg.getEntry().isScript()) {\n    return false;\n  }\n\n  // Check if any of the functions in the CFG have a single return statement.\n  for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg) {\n    if (node.isScript()) {\n      continue;\n    }\n    if (!isReturnBlock(node)) {\n      return false;\n    }\n  }\n\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    if (cfg.getEntry().getAncestors().contains(cfg.getImplicitReturn())) \n    {\n        return true;\n    }\n    if (!cfg.getEntry().isBlock() || !cfg.getImplicitReturn().isBlock()) \n    {\n        return false;\n    }\n\n    List<Node> reachableBlockList = cfg.getReachableStatements(cfg.getEntry());\n\n    return reachableBlockList.size() == 1 && reachableBlockList.get(0) == cfg.getImplicitReturn();\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    if (!cfg.isImplicitReturn()) {\n        return false;\n    }\n\n    ControlFlowGraph<Node>.DiGraphNodeTraversalCallback callback =\n        new ControlFlowGraph.DiGraphNodeTraversalCallback() {\n}\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    if (!cfg.getEntry().isImplicitReturn()) {\n        return false;\n    }\n\n    for (ControlFlowGraph.Branch edge : cfg.getEntry().getOutEdges()) {\n        if (!cfg.isImplicitReturn(edge.getToNode())) {\n            return false;\n        }\n    }\n\n    for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getNodes()) {\n        if (cfg.isImplicitReturn(node)) {\n            for (ControlFlowGraph.Branch edge : node.getOutEdges()) {\n                if (!cfg.isImplicitReturn(edge.getToNode())) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    if (cfg.getEntry().equals(cfg.getImplicitReturn())) {\n        return true;\n    }\n    if (cfg.getEntry().getSuccessors().size() != 1) {\n        return false;\n    }\n    ControlFlowGraph.Branch edge = cfg.getEntry().getSuccessors().iterator().next();\n    if (!edge.isConditional()) {\n        return true;\n    }\n    return false;\n}"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x[] = new Dfp[2];\n    Dfp y[] = new Dfp[2];\n    Dfp c[] = new Dfp[2];\n    Dfp d[] = new Dfp[2];\n    double f[] = new double[2];\n    split(a[0], a[1], x);\n\n    // split(x, x);\n\n    // |x| >= 2\n    if (x[0] >= LN_MANT[LN_MANT.length - 1][0]) {\n        // use method 4 (accurate to O(1/x^8)\n        Dfp inv[] = new Dfp[2];\n        split(x[0], x[1], inv);\n        fastMath.reciprocal(inv, inv);\n\n        fastMath.mul(inv, inv, y);\n        fastMath.mul(inv, y, y);\n\n        d[0] = inv[0];\n        d[1] = inv[1];\n        c[0] = y[0];\n        c[1] = y[1];\n\n        fastMath.mul(c, c, c);\n        fastMath.mul(c, c, c);\n\n        f[0] = 0.25;\n        f[1] = 0;\n        fastMath.mul(f, c, d);\n\n        y[0] = x[0] - (0.5 + d[0]);\n        y[1] = x[1] - (d[1]);\n\n        fastMath.sub(y, y, c);\n        fastMath.mul(y, y, f);\n        fastMath.add(y, y, y);\n\n        return y;\n    }\n\n    // |x| < 2\n    Dfp p[] = new Dfp[2];\n    Dfp q[] = new Dfp[2];\n    Dfp r[] = new Dfp[2];\n    Dfp s[] = new Dfp[2];\n    Dfp t[] = new Dfp[2];\n    Dfp u[] = new Dfp[2];\n\n    fastMath.mul(x, x, p);\n    fastMath.mul(p, p, q);\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp x[] = new Dfp[2];\n    final Dfp y[] = new Dfp[2];\n\n    split(a[0], x);\n    split(a[1], y);\n\n    /* Set X = (x-1)/(x+1) */\n    x[0] += 1.0;\n    resplit(x);\n    splitReciprocal(x, y);\n    x[0] -= 2.0;\n    resplit(x);\n    splitMult(x, y, a);\n    x[0] = a[0];\n    x[1] = a[1];\n\n    /* Square X -> X2*/\n    splitMult(x, x, a);\n\n    final int xExponent = x[0].getExponent() - Dfp.ONE_POINT_FIVE_EXPONENT;\n    final int shift = Math.min(xExponent, Dfp.MAX_EXPONENT - Dfp.LN_MANT.length - 1);\n    final int index = xExponent - shift;\n\n    /* Use precomputed values if possible */\n    if (index >= 0 && index < Dfp.LN_MANT.length) {\n        split(Dfp.LN_MANT[index], y);\n        y[0].shiftLeft(shift);\n        y[1].shiftLeft(shift);\n    } else {\n        /* Otherwise, compute from series */\n        final double inv = 1 / (x[0].getSign() * x[0].getMantissa());\n        final double xx = x[0].getMantissa();\n\n        final double term = inv * inv;\n        final double factor = term * term;\n\n        double sum = term / 2;\n\n        for (int i = 3; i <= 7; i += 2) {\n            term *= factor;\n            sum += term / i;\n        }\n\n        y[0] = new Dfp(x[0].getSign(), xx * sum);\n        y[1] = new Dfp(x[1].getSign(), xx * (sum - factor / 9));\n\n        final Dfp one = new Dfp(1);\n        final Dfp two = new Dfp(2);\n}\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x[] = new Dfp[2];\n    Dfp y[] = new Dfp[2];\n    Dfp a0, a1, r;\n\n    a0 = a[0];\n    a1 = a[1];\n\n    /* Handle zero or negative numbers */\n    if (a1.isZero() || a1.isNegative()) {\n        x[0] = new Dfp(0);\n        x[1] = new Dfp(0);\n        return x;\n    }\n\n    /* Handle numbers between 0 and 2 */\n    if (a0.isZero() && a1.lessThan(Dfp.getExponent(2))) {\n        /* 0 < a < 2 */\n        double[] sm = LN_MANT[Dfp.getExponent(a) - Dfp.getExponent(1)];\n        a0 = a0.add(Dfp.getExponent(sm[0]));\n        a1 = a1.add(Dfp.getExponent(sm[1]));\n        x[0] = a0;\n        x[1] = a1;\n        return x;\n    }\n\n    /* Handle numbers larger than or equal to 2 */\n    /* x = (a-1)/(a+1) */\n    r = a0.add(Dfp.getExponent(1));\n    a0.subtract(Dfp.getExponent(1));\n    a0.reciprocal();\n    a1.add(Dfp.getExponent(1));\n    a1.reciprocal();\n    a0.add(a1);\n    a1.multiply(a0);\n\n    /* x = (a-1)/(a+1) */\n    x[0] = a0;\n    x[1] = a1;\n    return x;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] x = Dfp.split(a[0], a[1]);\n\n    // Set X = (x-1)/(x+1)\n    x[0].add(-1);\n    x[1].add(1);\n    Dfp[] a2 = Dfp.reciprocal(x);\n    x[0].add(2);\n    x[1].sub(a2[1]);\n\n    // Square X -> X2\n    Dfp[] x2 = new Dfp[2];\n    Dfp.multiply(x, x, x2);\n\n    // Compute ln(1+x) - ln(1-x)\n    final double[] LN_MANT = {\n        +0.0d,                   +0.0d,                   }, // 0\n        {+9.760860120877624E-4d,  -3.903230345984362E-11d, }, // 1\n        {+0.0019512202125042677d, -8.124251825289188E-11d, }, // 2\n        {+0.0029254043474793434d, -1.8374207360194882E-11d,}, // 3\n        {+0.0038986406289041042d, -2.1324678121885073E-10d,}, // 4\n        {+0.004870930686593056d,  -4.5199654318611534E-10d,}, // 5\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] y = new Dfp[2];\n    final Dfp a0 = a[0];\n    final Dfp a1 = a[1];\n    final int a0e = a0.getExponent();\n    final int a1e = a1.getExponent();\n\n    if (a0e >= a1e) {\n        final Dfp a0_1 = new Dfp(a0, -a1e - a0e);\n        y = slowLog(a0_1);\n        y[0] = y[0].shiftLeft(a0e - a1e - 1).add(a0);\n        y[1] = y[1].shiftLeft(a0e - a1e - 1).add(a1);\n    } else {\n        final Dfp a1_1 = new Dfp(a1, -a0e - a1e);\n        y = slowLog(a1_1);\n        y[0] = y[0].shiftLeft(a1e - a0e - 1).add(a1);\n        y[1] = y[1].shiftLeft(a1e - a0e - 1).add(a0);\n    }\n    return y;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp x[] = split(a[0]);\n    final Dfp y[] = split(a[1]);\n\n    // x+1 and x-1\n    final Dfp a0 = x[0].newInstance(x[0].getRadixDigits() - 1);\n    final Dfp a1 = x[0].newInstance(x[0].getRadixDigits() + 1);\n    a0.add(x[0]);\n    a1.sub(x[0]);\n    final Dfp b0 = y[0].newInstance(y[0].getRadixDigits() - 1);\n    final Dfp b1 = y[0].newInstance(y[0].getRadixDigits() + 1);\n    b0.add(y[0]);\n    b1.sub(y[0]);\n\n    // compute log(x+1) - log(x-1)\n    final Dfp c0 = a0.newInstance(a0.getRadixDigits() - 1);\n    final Dfp c1 = a0.newInstance(a0.getRadixDigits() + 1);\n    c0.add(a0);\n    c1.sub(a0);\n    final Dfp d0 = b0.newInstance(b0.getRadixDigits() - 1);\n    final Dfp d1 = b0.newInstance(b0.getRadixDigits() + 1);\n    d0.add(b0);\n    d1.sub(b0);\n    final Dfp e0 = c0.newInstance(c0.getRadixDigits() - 1);\n    final Dfp e1 = c0.newInstance(c0.getRadixDigits() + 1);\n    e0.mul(c0);\n    e1.mul(c0);\n    final Dfp f0 = d0.newInstance(d0.getRadixDigits() - 1);\n    final Dfp f1 = d0.newInstance(d0.getRadixDigits() + 1);\n    f0.mul(d0);\n    f1.mul(d0);\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] x = DfpMath.split(a);\n    x[0].add(1);\n    x[1].add(DfpMath.multiply(DfpMath.multiply(DfpMath.divide(x[0], x[1]), x[0], 5), x[1], 6));\n    return x;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x[] = new Dfp[2];\n    Dfp y[] = new Dfp[2];\n    Dfp a0, a1, x0, x1;\n\n    /* x = (a-1)/(a+1) */\n    a0 = a[0].subtract(Dfp.ONE);\n    a1 = a[1];\n    splitAdd(a0, a1, x);\n    a0 = a[0].add(Dfp.ONE);\n    a1 = a[1];\n    splitAdd(a0, a1, y);\n    splitDivide(x, y, x);\n\n    /* f(x) = ln(x) */\n    /* f'(x) = 1/x */\n\n    /* 1.0 / x */\n    a0 = x[0].negate();\n    a1 = x[1];\n    splitInvert(a0, a1, x);\n    x0 = x[0];\n    x1 = x[1];\n\n    /* 2x + 1/x */\n    a0 = x0.multiply(Dfp.TWO);\n    a1 = x1.multiply(Dfp.TWO);\n    a0 = a0.add(x0);\n    a1 = a1.add(x1);\n\n    /* -1/x */\n    a0 = x[0].negate();\n    a1 = x[1];\n    splitInvert(a0, a1, y);\n\n    /* -1/x^3 */\n    a0 = y[0].multiply(y[0]);\n    a1 = y[1].multiply(y[1]);\n    a0 = a0.multiply(y[0]);\n    a1 = a1.multiply(y[1]);\n\n    /* 6/x^5 */\n    a0 = y[0].multiply(y[0]);\n    a1 = y[1].multiply(y[1]);\n    a0 = a0.multiply(y[0]);\n    a1 = a1.multiply(y[1]);\n    a0 = a0.multiply(Dfp.SIX);\n    a1 = a1.multiply(Dfp.SIX);\n\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] y = new Dfp[2];\n    double x = a[0].d / a[1].d;\n    if (x >= C_LIMIT) {\n        // use method 4 (accurate to O(1/x^8)\n        double inv = 1 / (x * x);\n        //            1       1        1         1\n        // log(x) -  --- - ------ + ------- - -------\n        //           2 x   12 x^2   120 x^4   252 x^6\n        y[0] = new Dfp(FastMath.log(x) - 0.5 / x - inv * ((1.0 / 12) + inv * (1.0 / 120 - inv / 252)));\n        y[1] = new Dfp(a[1].d * (1.0 - (1.0 / 24) * inv - (1.0 / 720) * inv * inv));\n    } else {\n        if (x >= S_LIMIT) {\n            // use method 3 (accurate to O(1/x^6))\n            double inv = 1 / x;\n            //            2       1       1        1        1\n            // log(x) +  ----- + ------ - ----- - -----\n            //           3      6 x     20 x^3   70 x^4\n            y[0] = new Dfp(FastMath.log(x) + inv / 2 + inv / x * ((1.0 / 6) - inv / 20 + inv * inv / 70));\n            y[1] = new Dfp(a[1].d * (1.0 + (1.0 / 60) * inv + (1.0 / 140) * inv * inv - (1.0 / 252) * inv * inv * inv));\n        } else {\n            if (x > 1.0000000000001) {\n                // use method 2 (accurate to O(1/x^4))\n                double inv = 1 / x;\n}\n}\n}\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x[] = new Dfp[2];\n    Dfp y[] = new Dfp[2];\n\n    split(a[0], x);\n\n    /* Set X = (x-1)/(x+1) */\n    x[0] += 1.0;\n    resplit(x);\n    splitReciprocal(x, y);\n    x[0] -= 2.0;\n    resplit(x);\n    splitMult(x, y, y);\n    x[0] = y[0];\n    x[1] = y[1];\n\n    /* Square X -> X2*/\n    splitMult(x, x, x);\n\n    /* We know the result must be in the range [0, 2] */\n    /* Now we can use the fast method for small arguments */\n    if (x[0] < LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0]) {\n        /* Method 3 (accurate to O(1/x^6)) */\n        double inv = 1 / (x[0] * x[0]);\n        //            1       1        1         1\n        // log(x) -  --- - ------ + ------- - -------\n        //           2 x   12 x^2   120 x^4   252 x^6\n        x[0] = FastMath.log(x[0]) - 0.5 / x[0] - inv * ((1.0 / 12) + inv * (1.0 / 120 - inv / 252));\n        return x;\n    } else {\n        /* Method 4 (accurate to O(1/x^8)) */\n        double inv = 1 / (x[0] * x[0]);\n        //            1       1        1         1\n        // log(x) -  --- - ------ + ------- - -------\n        //           2 x   12 x^2   120 x^4   252 x^6\n}\n}"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) \n        {\n            throw new IllegalArgumentException(\"key and/or value cannot be null.\");\n        }\n        Collection<V> collection = getCollection(key);\n        if (collection == null)\n        {\n            return false;\n        }\n        if (collection.remove(value))\n        {\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null)\n            throw new NullPointerException(\"key and value must not be null\");\n        return getCollection((K) key).remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) throw new IllegalArgumentException(\"key cannot be null\");\n        if (value == null) throw new IllegalArgumentException(\"value cannot be null\");\n        final Collection<V> coll = getCollection(key);\n        if (coll == null || !coll.contains(value)) return false;\n        boolean result = coll.remove(value);\n        if (size(key) == 0) put(key, null);\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) \n        {\n            throw new NullPointerException(\"key cannot be null\");\n        }\n        if (value == null) \n        {\n            throw new NullPointerException(\"value cannot be null\");\n        }\n        Collection<V> coll = getCollection(key);\n        if (coll != null) \n        {\n            return coll.remove(value);\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) \n        {\n            throw new IllegalArgumentException(\"key and/or value cannot be null.\");\n        }\n        if (key instanceof K && value instanceof V)\n        {\n            final K k = (K) key;\n            final V v = (V) value;\n            final Collection<V> coll = getMap().get(k);\n            if (coll == null)\n            {\n                return false;\n            }\n            else\n            {\n                final Iterator<V> it = coll.iterator();\n                while (it.hasNext())\n                {\n                    final V object = it.next();\n                    if (object.equals(v))\n                    {\n                        it.remove();\n                        if (coll.size() == 0)\n                        {\n                            getMap().remove(k);\n                        }\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        // Check key and value are not null and not invalid\n        if (key == null || value == null) \n        {\n            throw new IllegalArgumentException(\"key or value is null.\");\n        }\n        \n        // Check if key exists in the map\n        if (!containsKey(key)) \n        {\n            return false;\n        }\n        \n        // Get the collection associated with the key\n        Collection<V> values = getCollection(key);\n        \n        // Remove the value from the collection\n        boolean removed = values.remove((V) value);\n        \n        // If the collection is empty, remove the key from the map\n        if (values.isEmpty()) \n        {\n            remove(key);\n        }\n        \n        return removed;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> collection = getCollection(key);\n        if (collection == null)\n        {\n            return false;\n        }\n        else if (!collection.contains(value))\n        {\n            return false;\n        }\n        else\n        {\n            return collection.remove(value);\n        }\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        // Check if the map contains the key\n        if (!containsKey(key)) \n        {\n            return false;\n        }\n\n        // Get the collection of values for the key\n        Collection<Object> values = get(key);\n\n        // Check if the value is present in the collection\n        if (!values.contains(value)) \n        {\n            return false;\n        }\n\n        // Remove the value from the collection\n        values.remove(value);\n\n        // If the collection is empty, remove the key from the map\n        if (values.isEmpty()) \n        {\n            remove(key);\n        }\n\n        return true;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        // Check if the value is not valid\n        if (value == null) \n        {\n            throw new NullPointerException(\"value cannot be null\");\n        }\n\n        // Check if the key is not valid\n        if (key == null) \n        {\n            throw new NullPointerException(\"key cannot be null\");\n        }\n\n        // Get the collection of values for the key\n        Collection<V> values = getCollection(key);\n\n        // Check if the collection exists\n        if (values == null) \n        {\n            return false;\n        }\n\n        // Remove the value from the collection\n        return values.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null)\n        {\n            throw new NullPointerException(\"key and/or value cannot be null\");\n        }\n        if (!(map.containsKey(key)))\n        {\n            return false;\n        }\n        Collection<V> values = getCollection(key);\n        if (values.contains(value))\n        {\n            values.remove(value);\n            if (values.size() == 0)\n            {\n                map.remove(key);\n            }\n            return true;\n        }\n        return false;\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node = IR.string(node.getString()).copyInformationFrom(node);\n  } else if (node.getType() == Token.STRING) {\n    node = IR.string(node.getString()).copyInformationFrom(node);\n    if (node.isQuotedString()) {\n      node = IR.string(node.getString()).copyInformationFrom(node);\n    } else {\n      node = IR.string(node.getString()).copyInformationFrom(node);\n    }\n  }\n  return node;\n}\n\n@Override\nNode processArrayLiteral(ArrayLiteral literalNode) {\n  if (literalNode.isDestructuring()) {\n    reportDestructuringAssign(literalNode);\n  }\n\n  Node node = newNode(Token.ARRAYLIT);\n  for (AstNode child : literalNode.getElements()) {\n    Node c = transform(child);\n    node.addChildToBack(c);\n  }\n  return node;\n}\n\n@Override\nNode processAssignment(Assignment assignmentNode) {\n  Node assign = processInfixExpression(assignmentNode);\n  Node target = assign.getFirstChild();\n  if (!validAssignmentTarget(target)) {\n    errorReporter.error(\n      \"invalid assignment target\",\n      sourceName,\n      target.getLineno(), \"\", 0);\n  }\n  return assign;\n}\n\n@Override\nNode processAstRoot(AstRoot rootNode) {\n  Node node = newNode(Token.SCRIPT);\n  for (com.google.javascript.rhino.head.Node child : rootNode) {\n    node.addChildToBack(transform((AstNode) child));\n  }\n  parseDirectives(node);\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  if (n.getType() == Token.NAME)\n  {\n    String name = n.toString();\n    if (isAllowedProp(name) || isReservedKeyword(name))\n    {\n      n = IR.string(name).srcref(n);\n    }\n    if (isGetterSetter(name) || isGetter(name) || isSetter(name))\n    {\n      reportGetterSetter(name, n);\n    }\n  }\n  return n;\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) \n    {\n        n.setType(Token.STRING);\n        n.setString(\"\");\n    }\n    return n;\n}",
      "private Node transformAsString(AstNode n)  {\n  if (n.getType() == Token.NAME) \n  {\n    Name name = new Name(n.getLineno(), n.getCharno(), n.getType(), n.getValue());\n    name.setPropListHeadForTesting(n.getPropListHeadForTesting());\n    name.setSideEffectFlags(n.getSideEffectFlags());\n    name.setChangeTime(n.getChangeTime());\n    name.setStaticSourceFile(n.getStaticSourceFile());\n    name.setInputId(n.getInputId());\n    return name;\n  }\n  else if (n.getType() == Token.STRING)\n  {\n    StringNode str = new StringNode(Token.STRING, n.getValue(), n.getLineno(), n.getCharno());\n    str.setPropListHeadForTesting(n.getPropListHeadForTesting());\n    str.setSideEffectFlags(n.getSideEffectFlags());\n    str.setChangeTime(n.getChangeTime());\n    str.setStaticSourceFile(n.getStaticSourceFile());\n    str.setInputId(n.getInputId());\n    return str;\n  }\n  else\n  {\n    return n;\n  }\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n\n  // If it was a name, convert it to a string literal.\n  if (node.getType() == Token.NAME) {\n    node = IR.string(node.getString()).srcref(n);\n  }\n  // If it was already a string literal, quote it.\n  else if (node.getType() == Token.STRING) {\n    node = IR.string(node.getString()).srcref(n);\n  }\n\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n\n    // Transform name tokens to string literals.\n    if (node.getType() == Token.NAME) {\n        node = IR.string(node.getString());\n    } else if (node.getType() == Token.STRING) {\n        String str = node.getString();\n        if (!str.startsWith(\"\\\"\") && !str.startsWith(\"'\")) {\n            str = \"\\\"\" + str + \"\\\"\";\n        }\n        node = IR.string(str);\n    }\n\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  if (n.getType() == Token.NAME) {\n    n = IR.string((String) n.getValue());\n  } else if (n.getType() == Token.STRING) {\n    n = IR.quotedString((String) n.getValue());\n  }\n  return n;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node = IR.string(node.getString());\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node = IR.string(node.getString());\n  } else if (node.getType() == Token.STRING) {\n    node = IR.string(node.getString());\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node = IR.string(node.getString());\n    } else if (node.getType() == Token.STRING) {\n        if (node.getString().startsWith(\"\\\"\")) {\n            node = IR.string(node.getString());\n        } else {\n            node = IR.string(\"\\\"\" + node.getString() + \"\\\"\");\n        }\n    } else {\n        errorReporter.error(\n          \"invalid assignment target\",\n          sourceName,\n          n.getLineno(), \"\", 0);\n    }\n    return node;\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, includedRows, category);\n    }\n\n    for (int row : includedRows) {\n        Number n = dataset.getValue(row, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            values.add(v + base);\n        }\n        else {\n            values.add(base);\n        }\n    }\n\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    Number n;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, dataset.getColumnIndex(category));\n    }\n    for (int row : includedRows) {\n        n = dataset.getValue(row, dataset.getColumnIndex(category));\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            values.add(new Double(v + base));\n        }\n        else {\n            values.add(new Double(base));\n        }\n    }\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    Number n;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int row : includedRows) {\n        n = dataset.getValue(row, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            result.add(v);\n        }\n    }\n    if (base >= 0) {\n        result.add(base);\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n\n    Number n;\n    double total = 0.0;\n\n    // Calculate the total for percentages\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category));\n    }\n\n    for (int row : includedRows) {\n        n = dataset.getValue(row, dataset.getColumnIndex(category));\n        if (n != null) {\n            double value = n.doubleValue();\n            if (asPercentages) {\n                value = value / total;\n            }\n\n            double previousHeight = getPreviousHeight(dataset, row,\n                    dataset.getColumnIndex(category));\n            result.add(new Double(previousHeight + value));\n        }\n        else {\n            result.add(new Double(base));\n        }\n    }\n\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    Number n;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int row : includedRows) {\n        n = dataset.getValue(row, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            result.add(v + base);\n        }\n        else {\n            result.add(base);\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    Number n;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, dataset.getColumnIndex(category));\n    }\n    for (int row : includedRows) {\n        n = dataset.getValue(row, dataset.getColumnIndex(category));\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            values.add(v + base);\n        }\n        else {\n            values.add(base);\n        }\n    }\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    Number n;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int row : includedRows) {\n        n = dataset.getValue(row, dataset.getColumnIndex(category));\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            result.add(v);\n        }\n        else {\n            result.add(0.0);\n        }\n    }\n    result.add(base);\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n\n    Number n;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, includedRows);\n    }\n\n    for (int row : includedRows) {\n        n = dataset.getValue(row, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            values.add(v);\n        }\n        else {\n            values.add(0.0);\n        }\n    }\n\n    // add the base value\n    values.add(base);\n\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n\n    double previousHeight = getPreviousHeight(dataset, column, category);\n\n    Number n;\n    double total = 0.0;\n    if (this.renderAsPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int row : includedRows) {\n        n = dataset.getValue(row, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            v += previousHeight;\n            if (this.renderAsPercentages) {\n                v = v / total;\n            }\n            result.add(v);\n        }\n        else {\n            result.add(Double.NaN);\n        }\n    }\n\n    result.add(base);\n\n    return result;\n\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList(includedRows.length);\n\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, dataset.getColumnIndex(category));\n    }\n\n    for (int row : includedRows) {\n        Number n = dataset.getValue(row, dataset.getColumnIndex(category));\n        if (n != null) {\n            double value = n.doubleValue();\n            if (asPercentages) {\n                value = value / total;\n            }\n            result.add(value);\n        }\n        else {\n            if (asPercentages) {\n                result.add(0.0);\n            }\n            else {\n                result.add(null);\n            }\n        }\n    }\n\n    // Now add the base value\n    result.add(base);\n\n    return result;\n}"
    ],
    [
      "private List<Element> childElementsList()  {\n    List<Element> childElements = shadowChildrenRef!=null? shadowChildrenRef.get():null;\n    if (childElements==null) {\n        childElements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                childElements.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(childElements);\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null)\n        shadowChildrenRef = new WeakReference<>(ensureChildNodes().stream().filter(Element.class::isInstance).map(Element.class::cast).collect(Collectors.toList()));\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    WeakReference<List<Element>> shadowChildrenRef = this.shadowChildrenRef;\n    List<Element> shadowChildren = shadowChildrenRef != null ? shadowChildrenRef.get() : null;\n    if (shadowChildren == null) {\n        shadowChildren = new ArrayList<>(childNodeSize());\n        for (Node child : childNodes) {\n            if (child instanceof Element) {\n                shadowChildren.add((Element) child);\n            }\n        }\n        this.shadowChildrenRef = new WeakReference<>(shadowChildren);\n    }\n    return shadowChildren;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        List<Element> children = new ArrayList<>(childNodeSize());\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element) children.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(children);\n    }\n    List<Element> children = shadowChildrenRef.get();\n    if (children == null) \n    {\n        children = new ArrayList<>(childNodeSize());\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element) children.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(children);\n    }\n    return children;\n}",
      "private List<Element> childElementsList()  {\n    WeakReference<List<Element>> shadowChildrenRef = this.shadowChildrenRef;\n    List<Element> shadowChildren = shadowChildrenRef != null ? shadowChildrenRef.get() : null;\n    if (shadowChildren == null) {\n        shadowChildren = new ArrayList<>(childNodeSize());\n        for (Node node : childNodes) {\n            if (node instanceof Element) {\n                shadowChildren.add((Element) node);\n            }\n        }\n        this.shadowChildrenRef = new WeakReference<>(shadowChildren);\n    }\n    return shadowChildren;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> childElements = shadowChildrenRef != null ? shadowChildrenRef.get() : null;\n    if (childElements == null) {\n        childElements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                childElements.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(childElements);\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null)\n    {\n        List<Element> childElements = new ArrayList<>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element)\n                childElements.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(childElements);\n    }\n    List<Element> childElements = shadowChildrenRef.get();\n    if (childElements == null)\n    {\n        childElements = new ArrayList<>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element)\n                childElements.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(childElements);\n    }\n    return childElements;\n}",
      "private List<Element> childElementsList()  {\n    WeakReference<List<Element>> shadowChildrenRef = this.shadowChildrenRef;\n    List<Element> shadowChildren = shadowChildrenRef != null ? shadowChildrenRef.get() : null;\n    if (shadowChildren == null) {\n        shadowChildren = new ArrayList<>(childNodeSize());\n        for (Node node : childNodes) {\n            if (node instanceof Element) {\n                shadowChildren.add((Element) node);\n            }\n        }\n        this.shadowChildrenRef = new WeakReference<>(shadowChildren);\n    }\n    return shadowChildren;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> children;\n\n    if (shadowChildrenRef != null) {\n        children = shadowChildrenRef.get();\n        if (children != null) {\n            return children;\n        }\n    }\n\n    List<Node> nodeChildren = childNodes;\n    children = new ArrayList<>(nodeChildren.size());\n    for (Node nodeChild : nodeChildren) {\n        if (nodeChild instanceof Element) {\n            children.add((Element) nodeChild);\n        }\n    }\n\n    shadowChildrenRef = new WeakReference<>(children);\n    return children;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) \n    {\n        shadowChildrenRef = new WeakReference<>(new ArrayList<>(childNodes.size()));\n    }\n\n    List<Element> children = shadowChildrenRef.get();\n    if (children == null || children.size() != childNodes.size()) \n    {\n        children = new ArrayList<>(childNodes.size());\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element) \n            {\n                children.add((Element) node);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(children);\n    }\n    \n    return children;\n}"
    ],
    [
      "private int getHash(final Object key)  {\n    int hash = (key == null) ? 0 : key.hashCode();\n    hash = hash & 0x7FFFFFFF;  // 32 bit hash, force positive\n    return hash % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    return Math.abs((key.hashCode() & 0x7FFFFFFF) % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    if (key == null) {\n        return 0;\n    }\n\n    int h = Math.abs(key.hashCode() & 0x7FFFFFFF);\n\n    h += (h >>> 27);\n    return h;\n}",
      "private int getHash(final Object key)  {\n    int hash = (key == null) ? 0 : key.hashCode();\n    hash += ~(hash >>> 16);\n    return hash & (buckets.length - 1);\n}",
      "private int getHash(final Object key)  {\n    if (key == null) {\n        return 0;\n    }\n\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = (key == null) ? 0 : System.identityHashCode(key);\n\n    hash += ((hash << 5) ^ hash);\n\n    return (hash & (buckets.length - 1));\n}",
      "private int getHash(final Object key)  {\n    int hash = (key == null) ? 0 : key.hashCode();\n    return (hash & 0x7FFFFFFF) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    if(key==null) return 0;\n    int hash = key.hashCode();\n    hash += ~(hash >>> 16);\n    hash *= 0x85ebca6b;\n    hash += ~(hash >>> 13);\n    hash *= 0xc2b2ae35;\n    hash += ~(hash >>> 16);\n    return hash & (buckets.length - 1);\n}",
      "private int getHash(final Object key)  {\n    if(key==null)\n    {\n        return 0;\n    }\n    int hash = Math.abs(key.hashCode() % buckets.length);\n\n    return hash;\n}",
      "private int getHash(final Object key)  {\n    if (key == null) {\n        return 0;\n    }\n    return Math.abs(key.hashCode() % buckets.length);\n}"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  throws OutOfRangeException, NumberIsTooSmallException {\n    if (k > m.getColumnDimension() - 1 || k < 0) {\n        throw new OutOfRangeException(\"Illegal k argument. k must be >= 0 and <= \" + (m.getColumnDimension() - 1));\n    }\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (c - r >= k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  throws OutOfRangeException, NumberIsTooSmallException {\n    if (k < 0) {\n        throw new NumberIsTooSmallException(\"k must be greater than or equal to 0.\");\n    }\n\n    final double[][] d = new double[m.getRowDimension()][Math.min(m.getColumnDimension(), m.getRowDimension())];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = Math.max(0, r - k); c < m.getColumnDimension(); c++) {\n            d[r][c] = m.getEntry(r, c);\n        }\n    }\n\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  throws OutOfRangeException, NumberIsTooSmallException {\n    if (k >= 0) {\n        throw new NumberIsTooSmallException(\"The diagonal position must be negative\");\n    }\n    final double[][] d = new double[m.getRowDimension()][Math.min(k, m.getColumnDimension() - k)];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < Math.min(k, m.getColumnDimension() - k); c++) {\n            d[r][c] = m.getEntry(r, c - k);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  throws OutOfRangeException, NumberIsTooSmallException {\n    if (k < 0) {\n        throw new NumberIsTooSmallException(\"k\", k, 0);\n    }\n    if (k >= m.getColumnDimension()) {\n        throw new OutOfRangeException(\"k\", k, 0, m.getColumnDimension() - 1);\n    }\n    final double[][] d = new double[m.getRowDimension()][Math.max(0, m.getColumnDimension() - k)];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < Math.max(0, m.getColumnDimension() - k); c++) {\n            d[r][c] = m.getEntry(r, c + k);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  throws OutOfRangeException, NumberIsTooSmallException {\n    if (k > m.getColumnDimension() - 1 || k < 0) {\n        throw new OutOfRangeException(\"k\", k, 0, m.getColumnDimension() - 1);\n    }\n    final double[][] d = new double[m.getRowDimension()][k + 1];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c <= k; c++) {\n            d[r][c] = m.getEntry(r, c);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    if (k == 0) {\n        return m;\n    }\n\n    final int r = m.getRowDimension();\n    final int c = m.getColumnDimension();\n    final double[][] d = new double[r][c];\n    for (int i = 0; i < r; i++) {\n        for (int j = Math.max(0, i - k); j < c && j <= i + k; j++) {\n            d[i][j] = m.getEntry(i, j);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    if (m.getColumnDimension() != m.getRowDimension()) {\n        throw new IllegalArgumentException(\"Only square matrices can be used with this method.\");\n    }\n    if (k >= m.getColumnDimension() || k < -m.getColumnDimension() + 1) {\n        throw new IllegalArgumentException(\"k must be between -n+1 and n-1, where n is the dimension of the matrix.\");\n    }\n    final double[][] d = new double[m.getRowDimension()][Math.min(m.getColumnDimension() - k, m.getRowDimension())];\n    for (int r = 0; r < d.length; r++) {\n        for (int c = 0; c < d[r].length; c++) {\n            d[r][c] = m.getEntry(r, c + k);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  throws OutOfRangeException, NumberIsTooSmallException {\n    if (k > 0) {\n        throw new OutOfRangeException(\"k must be non-positive.\");\n    }\n    if (m.getColumnDimension() != m.getRowDimension()) {\n        throw new NumberIsTooSmallException(\"Matrix must be square.\");\n    }\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c <= r + k; c++) {\n            d[r][c] = m.getEntry(r, c);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  throws OutOfRangeException, NumberIsTooSmallException {\n    if (k > 0) {\n        throw new NumberIsTooSmallException(\"k\");\n    }\n    if (k < -m.getColumnDimension() || k > m.getColumnDimension()) {\n        throw new OutOfRangeException(\"k\");\n    }\n    final double[][] d = new double[Math.max(0, m.getColumnDimension() - k)][Math.max(k, 0)];\n    for (int r = 0; r < d.length; r++) {\n        for (int c = 0; c < d[r].length; c++) {\n            d[r][c] = m.getEntry(r + k, c + k);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  throws NonSquareMatrixException {\n    if (m.getColumnDimension() != m.getRowDimension()) {\n        throw new NonSquareMatrixException(\"Upper triangular operation requires a square matrix.\");\n    }\n    final double[][] d = new double[m.getRowDimension()][Math.min(m.getColumnDimension(), m.getRowDimension() + k)];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < Math.min(m.getColumnDimension(), m.getRowDimension() + k); c++) {\n            if (r + k >= c) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "private boolean rebalanceRightShrunk()  { \nswitch (skew) \n{ \ncase LEFT_HIGH: \nskew = Skew.BALANCED; \nreturn true; \ncase RIGHT_HIGH: \nif (right.skew == Skew.RIGHT_HIGH) \n{ \nrotateCCW(); \nskew = Skew.BALANCED; \nleft.skew = Skew.BALANCED; \nreturn true; \n} \nelse if (right.skew == Skew.BALANCED) \n{ \nrotateCCW(); \nskew = Skew.LEFT_HIGH; \nleft.skew = Skew.RIGHT_HIGH; \nreturn false; \n} \nelse \n{ \nfinal Skew s = right.left.skew; \nright.rotateCW(); \nrotateCCW(); \nswitch (s) \n{ \ncase LEFT_HIGH: \nleft.skew = Skew.BALANCED; \nright.skew = Skew.RIGHT_HIGH; \nbreak; \ncase RIGHT_HIGH: \nleft.skew = Skew.LEFT_HIGH; \nright.skew = Skew.BALANCED; \nbreak; \ndefault: \nleft.skew = Skew.BALANCED; \nright.skew = Skew.BALANCED; \n} \nskew = Skew.BALANCED; \nreturn true; \n} \ndefault: \nskew = Skew.RIGHT_HIGH; \nreturn false; \n} \n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH: \n        {\n            skew = Skew.BALANCED; \n            return false;\n        }\n        case RIGHT_HIGH: \n        {\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n            } else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH: \n                    {\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    }\n                    case RIGHT_HIGH: \n                    {\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    }\n                    default: \n                    {\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                    }\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        }\n        default: \n        {\n            skew = Skew.RIGHT_HIGH; \n            return false;\n        }\n    }\n}",
      "private boolean rebalanceRightShrunk()  { \nswitch (skew) \n{ \ncase LEFT_HIGH: \nskew = Skew.BALANCED; \nreturn true; \ncase RIGHT_HIGH: \nif (right.skew == Skew.RIGHT_HIGH) \n{ \nrotateCCW(); \nskew = Skew.BALANCED; \nleft.skew = Skew.BALANCED; \nreturn true; \n} else if (right.skew == Skew.BALANCED) \n{ \nrotateCCW(); \nskew = Skew.LEFT_HIGH; \nleft.skew = Skew.RIGHT_HIGH; \nreturn false; \n} else \n{ \nfinal Skew s = right.left.skew; \nright.rotateCW(); \nrotateCCW(); \nswitch (s) \n{ \ncase LEFT_HIGH: \nleft.skew = Skew.BALANCED; \nright.skew = Skew.RIGHT_HIGH; \nbreak; \ncase RIGHT_HIGH: \nleft.skew = Skew.LEFT_HIGH; \nright.skew = Skew.BALANCED; \nbreak; \ndefault: \nleft.skew = Skew.BALANCED; \nright.skew = Skew.BALANCED; \n} \nskew = Skew.BALANCED; \nreturn true; \n} \ndefault: \nskew = Skew.RIGHT_HIGH; \nreturn false; \n} \n}",
      "private boolean rebalanceRightShrunk()  { \nswitch (skew) \n{ \ncase LEFT_HIGH: \nskew = Skew.BALANCED; \nreturn true; \ncase RIGHT_HIGH: \nif (right.skew == Skew.RIGHT_HIGH) \n{ \nrotateCCW(); \nskew = Skew.BALANCED; \nleft.skew = Skew.BALANCED; \nreturn true; \n} else if (right.skew == Skew.BALANCED) \n{ \nrotateCCW(); \nskew = Skew.LEFT_HIGH; \nleft.skew = Skew.RIGHT_HIGH; \nreturn false; \n} else \n{ \nfinal Skew s = right.left.skew; \nright.rotateCW(); \nrotateCCW(); \nswitch (s) \n{ \ncase LEFT_HIGH: \nleft.skew = Skew.BALANCED; \nright.skew = Skew.RIGHT_HIGH; \nbreak; \ncase RIGHT_HIGH: \nleft.skew = Skew.LEFT_HIGH; \nright.skew = Skew.BALANCED; \nbreak; \ndefault: \nleft.skew = Skew.BALANCED; \nright.skew = Skew.BALANCED; \n} \nskew = Skew.BALANCED; \nreturn true; \n} \ndefault: \nskew = Skew.RIGHT_HIGH; \nreturn false; \n} \n}",
      "private boolean rebalanceRightShrunk()  { \nswitch (skew) \n{ \ncase LEFT_HIGH: \nskew = Skew.BALANCED; \nreturn false; \ncase RIGHT_HIGH: \nif (right.skew == Skew.RIGHT_HIGH) \n{ \nrotateCCW(); \nskew = Skew.BALANCED; \nleft.skew = Skew.BALANCED; \n} \nelse if (right.skew == Skew.BALANCED) \n{ \nrotateCCW(); \nskew = Skew.LEFT_HIGH; \nleft.skew = Skew.RIGHT_HIGH; \nreturn false; \n} \nelse \n{ \nfinal Skew s = right.left.skew; \nright.rotateCW(); \nrotateCCW(); \nswitch (s) \n{ \ncase LEFT_HIGH: \nleft.skew = Skew.BALANCED; \nright.skew = Skew.RIGHT_HIGH; \nbreak; \ncase RIGHT_HIGH: \nleft.skew = Skew.LEFT_HIGH; \nright.skew = Skew.BALANCED; \nbreak; \ndefault: \nleft.skew = Skew.BALANCED; \nright.skew = Skew.BALANCED; \n} \nskew = Skew.BALANCED; \n} \nreturn true; \ndefault: \nskew = Skew.RIGHT_HIGH; \nreturn false; \n} \n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH: \n            skew = Skew.BALANCED;\n            return false;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n            }\n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            }\n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  { \n    switch (skew) \n    { \n        case LEFT_HIGH: \n            skew = Skew.BALANCED; \n            return false; \n        case RIGHT_HIGH: \n            if (right.skew == Skew.RIGHT_HIGH) \n            { \n                rotateCCW(); \n                skew      = Skew.BALANCED; \n                left.skew = Skew.BALANCED; \n            } else \n            { \n                final Skew s = right.left.skew; \n                right.rotateCW(); \n                rotateCCW(); \n                switch (s) \n                { \n                    case LEFT_HIGH: \n                        left.skew  = Skew.BALANCED; \n                        right.skew = Skew.RIGHT_HIGH; \n                        break; \n                    case RIGHT_HIGH: \n                        left.skew  = Skew.LEFT_HIGH; \n                        right.skew = Skew.BALANCED; \n                        break; \n                    default: \n                        left.skew  = Skew.BALANCED; \n                        right.skew = Skew.BALANCED; \n                } \n                skew = Skew.BALANCED; \n            } \n            return false; \n        default: \n            skew = Skew.RIGHT_HIGH; \n            return true; \n    } \n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH: \n        {\n            skew = Skew.BALANCED; \n            return false;\n        }\n        case RIGHT_HIGH: \n        {\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW(); \n                skew = Skew.BALANCED; \n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW(); \n                skew = Skew.LEFT_HIGH; \n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH: \n                    {\n                        left.skew = Skew.BALANCED; \n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    }\n                    case RIGHT_HIGH: \n                    {\n                        left.skew = Skew.LEFT_HIGH; \n                        right.skew = Skew.BALANCED;\n                        break;\n                    }\n                    default: \n                    {\n                        left.skew = Skew.BALANCED; \n                        right.skew = Skew.BALANCED;\n                    }\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        }\n        default: \n        {\n            skew = Skew.RIGHT_HIGH;\n            return false;\n        }\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    final int n = matrixT.length;\n    for (int i = startIdx; i < n - 1; i++) {\n        final double lhs = FastMath.abs(matrixT[i][i]) * (FastMath.abs(matrixT[i + 1][i + 1]) + FastMath.abs(matrixT[i + 2][i + 2]));\n        final double rhs = FastMath.abs(matrixT[i][i + 1]) * (FastMath.abs(matrixT[i + 1][i]) + FastMath.abs(matrixT[i + 2][i + 1]));\n        if (lhs < epsilon * rhs) {\n            return i;\n        }\n    }\n\n    return n - 1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double lhs, rhs;\n\n    for (int im = startIdx; im > 0; im--) {\n        final double z = matrixT[im][im];\n\n        // Compute the norms\n        lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) +\n                FastMath.abs(z) +\n                FastMath.abs(matrixT[im + 1][im + 1]));\n\n        // Check if the sub-diagonal element is small enough\n        if (lhs < epsilon * rhs) {\n            return im;\n        }\n    }\n\n    // No small sub-diagonal element found\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++) {\n        // Check for zero or negligible sub-diagonal element\n        if (FastMath.abs(matrixT[i][i - 1]) <= epsilon * norm) {\n            return i;\n        }\n    }\n\n    // No small sub-diagonal element found\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length - 2; i++) {\n        final double lhs = FastMath.abs(matrixT[i + 1][i]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[i][i]) +\n                FastMath.abs(z) +\n                FastMath.abs(matrixT[i + 2][i + 2]));\n\n        if (lhs < epsilon * rhs) {\n            return i;\n        }\n    }\n\n    return matrixT.length - 2;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int il = startIdx;\n    final int n = matrixT.length;\n\n    while (il < n - 2) {\n        final double lhs = FastMath.abs(matrixT[il][il + 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[il + 1][il + 1]) +\n                FastMath.abs(matrixT[il + 2][il + 2]) +\n                FastMath.abs(matrixT[il + 1][il + 2]));\n\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        il++;\n    }\n\n    return il;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int il = startIdx;\n    final int n = matrixT.length;\n\n    // Find the first sub-diagonal element with an absolute value less than a fraction of the L1 norm\n    for (int i = startIdx; i < n - 1; i++) {\n        final double z = matrixT[i][i];\n        final double r = matrixT[i + 1][i] * matrixT[i + 1][i] + z * z;\n        if (r <= epsilon * norm) {\n            il = i;\n            break;\n        }\n    }\n\n    return il;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int il = startIdx;\n    final int n = matrixT.length;\n\n    while (il < n) {\n        // Find the largest sub-diagonal element\n        int im = il;\n        for (int j = il + 1; j < n; j++) {\n            if (FastMath.abs(matrixT[j][j - 1]) > FastMath.abs(matrixT[im][im - 1])) {\n                im = j;\n            }\n        }\n\n        // Check if it's small enough\n        final double z = matrixT[im][im];\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) +\n                z +\n                FastMath.abs(matrixT[im + 1][im + 1]));\n\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        il++;\n    }\n\n    return il;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length - 1; i++) {\n        if (FastMath.abs(matrixT[i][i + 1]) < epsilon * norm) {\n            return i;\n        }\n    }\n\n    // No small sub-diagonal element found\n    return -1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    final int n = matrixT.length;\n    for (int i = startIdx; i < n - 1; i++) {\n        final double lhs = FastMath.abs(matrixT[i][i]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[i - 1][i - 1]) +\n                FastMath.abs(z) +\n                FastMath.abs(matrixT[i + 1][i + 1]));\n\n        if (lhs < epsilon * rhs) {\n            return i;\n        }\n    }\n\n    // no suitable small sub-diagonal element found\n    return startIdx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double lhs, rhs;\n\n    final int n = matrixT.length;\n    int im = startIdx;\n\n    while (im >= 0) {\n        final double z = matrixT[im][im];\n\n        // Calculate the RHS of the equation\n        rhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n\n        if (im == 0) {\n            // Special case: only one element left to check\n            lhs = FastMath.abs(z) + rhs;\n\n            if (lhs >= epsilon * rhs) {\n                im--;\n            } else {\n                break; // Found the small sub-diagonal element\n            }\n        } else {\n            // Calculate the LHS of the equation\n            lhs = FastMath.abs(matrixT[im - 1][im - 1]) * (FastMath.abs(hVec[0]) + FastMath.abs(z) + FastMath.abs(matrixT[im + 1][im + 1]));\n        }\n\n        // Check if the LHS is smaller than the RHS\n        if (lhs < epsilon * rhs) {\n            break; // Found the small sub-diagonal element\n        }\n\n        im--;\n    }\n\n    return im;\n}"
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;)\n    {\n        if (node.element.compareTo(reference) < 0)\n        {\n            if (node.right == null)\n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n        else\n        {\n            candidate = node;\n            if (node.left == null)\n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) >= 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;)\n    {\n        if (node.element.compareTo(reference) > 0)\n        {\n            if (node.left == null)\n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n        else\n        {\n            candidate = node;\n            if (node.right == null)\n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;)\n    {\n        if (node.element.compareTo(reference) < 0)\n        {\n            if (node.right == null)\n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n        else\n        {\n            candidate = node;\n            if (node.left == null)\n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0)\n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0)\n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0)\n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0)\n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) \n  {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) \n  {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null)\n    {\n        irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) \n  {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null)\n    {\n        irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null)\n    {\n        irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null)\n    {\n        irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    // Remove duplicates from the list\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    // Remove duplicates from the list\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<>(list);\n\n    return new SetUniqueList<>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    // Remove duplicates from the list\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<>(list);\n\n    // Create a SetUniqueList with the set and list\n    return new SetUniqueList<>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(set, list);\n}"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n    Node array = newNode(Token.LS);\n    if (!match(JsDocToken.RP)) {\n        Node expr;\n        do {\n            if (expr != null)\n            {\n                skipEOLs();\n                token = next();\n                Preconditions.checkState(token == JsDocToken.PIPE || token == JsDocToken.COMMA);\n\n                boolean isPipe = token == JsDocToken.PIPE;\n                if (isPipe && match(JsDocToken.PIPE))\n                {\n                    next();\n                }\n                skipEOLs();\n                token = next();\n            }\n            expr = parseTypeExpression(token);\n            if (expr == null)\n            {\n                return null;\n            }\n            array.addChildToBack(expr);\n        } while (match(JsDocToken.PIPE, JsDocToken.COMMA));\n\n        if (!match(JsDocToken.RP)) {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n        }\n        next();\n    }\n    return array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node array = newNode(Token.LBRACK);\n    if (token != JsDocToken.RP) {\n      do {\n        if (token == JsDocToken.ELLIPSIS) {\n          next();\n          array.addChildToBack(newStringNode(\"...\", token.getLineno(), token.getCharno()));\n        } else {\n          Node type = parseTypeExpression(token);\n          if (type == null) {\n            return null;\n          }\n          array.addChildToBack(type);\n        }\n\n        skipEOLs();\n        if (!match(JsDocToken.comma)) {\n          break;\n        }\n        next();\n        skipEOLs();\n        token = next();\n      } while (true);\n\n      if (!match(JsDocToken.RBRACK)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rbracket\");\n      }\n    }\n    next();\n    return array;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n  if (token != JsDocToken.LSquare) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lsquare\");\n  }\n  next();\n  Node typeList = parseElementTypeList(token);\n  if (typeList == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n  skipEOLs();\n  if (!match(JsDocToken.RSquare)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rsquare\");\n  }\n  next();\n  return newNode(Token.LSquare, typeList, token.getLineno(), token.getCharno());\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node array = newNode(Token.LS);\n    if (!match(JsDocToken.RP)) \n    {\n        do\n        {\n            if (token != JsDocToken.ELLIPSIS) \n            {\n                Node expr = parseTypeExpression(token);\n                if (expr == null) \n                {\n                    return null;\n                }\n                array.addChildToBack(expr);\n                if (token == JsDocToken.ELLIPSIS) \n                {\n                    if (array.getChildCount() > 1) \n                    {\n                        return reportTypeSyntaxWarning(\"msg.jsdoc.array.ellipsis.invalid\");\n                    }\n                    array.setProp(PropList.PROP_VARARGS_NAME, true);\n                }\n            }\n            skipEOLs();\n            token = next();\n        }\n        while (token == JsDocToken.COMMA);\n    }\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    return array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  return parseArrayTypeWithAlternate(token, null);\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node array = newNode(Token.LS);\n    if (token == JsDocToken.ELLIPSIS) {\n      next();\n      array.addChildToBack(newStringNode(token.getValue()));\n      if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n      }\n      next();\n      return array;\n    }\n    while (token != JsDocToken.RP) {\n      Node element = parseTypeExpression(token);\n      if (element == null) {\n        return null;\n      }\n      array.addChildToBack(element);\n      if (!match(JsDocToken.COMMA)) {\n        break;\n      }\n      next();\n      skipEOLs();\n      token = next();\n    }\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    return array;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Node array = newNode(Token.LB);\n    if (token == JsDocToken.ELLIPSIS) {\n        next();\n        skipEOLs();\n        if (!match(JsDocToken.RP)) {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n        }\n        next();\n        array.addChildToBack(newNumber(1));\n        array.addChildToBack(newNumber(1));\n        return array;\n    } else if (match(JsDocToken.RP)) {\n        next();\n        return array;\n    } else {\n        Node expr = parseTypeExpression(token);\n        if (expr != null) {\n            array.addChildToBack(expr);\n            while (match(JsDocToken.COMMA)) {\n                next();\n                skipEOLs();\n                expr = parseTypeExpression(next());\n                if (expr != null) {\n                    array.addChildToBack(expr);\n                } else {\n                    return null;\n                }\n            }\n        } else {\n            return null;\n        }\n        skipEOLs();\n        if (!match(JsDocToken.RP)) {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n        }\n        next();\n    }\n    return array;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  if (token != JsDocToken.LBRACK) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  Node arrayType = newNode(Token.LBRACK);\n\n  if (match(JsDocToken.ELLIPSIS)) {\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.RBRACK)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return wrapNode(Token.ELLIPSIS, IR.empty());\n  }\n\n  Node elementTypeList = parseElementTypeList(next());\n  if (elementTypeList == null) {\n    return null;\n  }\n  arrayType.addChildToBack(elementTypeList);\n\n  if (!match(JsDocToken.RBRACK)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n  next();\n\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node array = newNode(Token.LBRACK);\n    if (match(JsDocToken.ELLIPSIS)) {\n      array.addChildToBack(newNumberNode(Double.NaN));\n      next();\n    } else {\n      Node expr = null;\n      do {\n        if (expr != null) {\n          if (!match(JsDocToken.COMMA)) {\n            break;\n          }\n          next();\n          skipEOLs();\n        }\n        expr = parseTypeExpression(next());\n        if (expr != null) {\n          array.addChildToBack(expr);\n        }\n      } while (true);\n    }\n    skipEOLs();\n    if (!match(JsDocToken.RBRACK)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return array;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n  if (token != JsDocToken.LBRACK) \n  {\n     return reportGenericTypeSyntaxWarning();\n  }\n\n  Node arrayType = newNode(Token.LBRACK);\n  if (match(JsDocToken.LBRACK)) \n  {\n     skipEOLs();\n     Node elementType = parseTypeExpression(next());\n     if (elementType != null) \n     {\n        arrayType.addChildToBack(elementType);\n     }\n\n     while (match(JsDocToken.RBRACK)) \n     {\n       next();\n       skipEOLs();\n       elementType = parseTypeExpression(next());\n       if (elementType != null) \n       {\n          arrayType.addChildToBack(elementType);\n       }\n     }\n     if (!match(JsDocToken.LBRACK)) \n     {\n       return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rbracket\");\n     }\n  }\n\n  return arrayType;\n}"
    ],
    [
      "public Vector3D getAxis()  {\n    if ((q0 < -0.1) || (q0 > 0.1)) \n    {\n        return new Vector3D(q1, q2, q3);\n    }\n    else if (q0 < 0) \n    {\n        return new Vector3D(-q1, -q2, -q3);\n    }\n    else \n    {\n        return new Vector3D(q1, q2, q3);\n    }\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3).normalize();\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3).normalize();\n}",
      "public Vector3D getAxis()  {\n    if (q0 < -0.1 || q0 > 0.1) \n    {\n        return new Vector3D(q1, q2, q3).normalize();\n    } else if (q0 < 0) \n    {\n        return new Vector3D(q1, q2, q3).normalize().negate();\n    }\n    return new Vector3D(q1, q2, q3).normalize();\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3).normalize();\n}",
      "public Vector3D getAxis()  {\n    if ((q0 < -0.1) || (q0 > 0.1))\n    {\n        double sqrt = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n        return new Vector3D(q1 / sqrt, q2 / sqrt, q3 / sqrt);\n    }\n    else if (q0 < 0)\n    {\n        return new Vector3D(q1, q2, q3).negate();\n    }\n    return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    final double threshold = 0.6 * getNorm();\n    if (threshold == 0) \n    {\n        throw new MathArithmeticException(\"Cannot find orthogonal vector to zero vector\");\n    }\n\n    if (FastMath.abs(q1) <= threshold) \n    {\n        final double inverse = q2 * q2 + q3 * q3;\n        return new Vector3D(0, inverse, -inverse).normalize();\n    } else if (FastMath.abs(q2) <= threshold) \n    {\n        final double inverse = q1 * q1 + q3 * q3;\n        return new Vector3D(-inverse, 0, inverse).normalize();\n    } else \n    {\n        final double inverse = q1 * q1 + q2 * q2;\n        return new Vector3D(inverse, -inverse, 0).normalize();\n    }\n}",
      "public Vector3D getAxis()  {\n    final double squaredSine = q1*q1 + q2*q2 + q3*q3;\n    if (squaredSine == 0) \n    {\n        final double zero = 0.0;\n        return new Vector3D(zero, zero, zero);\n    } \n    else if (q0 < 0) \n    {\n        final double inverse = 1.0 / FastMath.sqrt(squaredSine);\n        return new Vector3D(q1*inverse, q2*inverse, q3*inverse);\n    }\n    else \n    {\n        final double inverse = 1.0 / FastMath.sqrt(squaredSine);\n        return new Vector3D(q1*inverse, q2*inverse, q3*inverse);\n    }\n}",
      "public Vector3D getAxis()  {\n    if ((q0 < -0.1) || (q0 > 0.1)) \n    {\n        return new Vector3D(q1, q2, q3);\n    } else if (q0 < 0) \n    {\n        return new Vector3D(-q1, -q2, -q3);\n    }\n    return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    if ((q0 < -0.1) || (q0 > 0.1)) \n    {\n        return new Vector3D(q1, q2, q3).normalize();\n    }\n    else if (q0 < 0)\n    {\n        return new Vector3D(q1, q2, q3).normalize().negate();\n    }\n    else \n    {\n        return new Vector3D(q1, q2, q3).normalize();\n    }\n}"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) {\n        final int b = bytes[i++];\n        if (b == ESCAPE_CHAR) {\n            final int c1 = bytes[i++];\n            final int c2 = bytes[i++];\n            final char ch1 = Character.toLowerCase((char)c1);\n            final char ch2 = Character.toLowerCase((char)c2);\n            final int value = Character.digit(ch1, RADIX) * RADIX + Character.digit(ch2, RADIX);\n            buffer.write(value);\n        } else {\n            if (b == '+') {\n                buffer.write(' ');\n            } else {\n                buffer.write(b);\n            }\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) {\n        final int b = bytes[i++];\n\n        if (b == ESCAPE_CHAR) {\n            final int c = bytes[i++];\n            if (c == '0') {\n                buffer.write('\\0');\n            } else if (c == '7') {\n                buffer.write('\\7');\n            } else if (c == '4') {\n                buffer.write('\\4');\n            } else if (c == '2') {\n                buffer.write('\\2');\n            } else if (c == '5') {\n                buffer.write('\\5');\n            } else if (c == '1') {\n                buffer.write('\\1');\n            } else if (c == '6') {\n                buffer.write('\\6');\n            } else if (c == '3') {\n                buffer.write('\\3');\n            } else {\n                throw new DecoderException(\"Invalid URL character sequence: %02X%02X\", b, c);\n            }\n        } else {\n            if (b == '+') {\n                buffer.write(' ');\n            } else {\n                final byte hex1 = Character.toLowerCase((char)b);\n                final byte hex2 = Character.toLowerCase((char)bytes[i++]);\n                if ((hex1 >= '0') && (hex1 <= '9')) {\n                    buffer.write((hex1 - '0') << 4);\n                } else if ((hex1 >= 'a') && (hex1 <= 'f')) {\n                    buffer.write((hex1 - 'a' + 10) << 4);\n                } else {\n                    throw new DecoderException(\"Invalid URL character sequence: %02X\", b);\n                }\n                if ((hex2 >= '0') && (hex2 <= '9')) {\n                    buffer.write(hex2 - '0');\n                } else if ((hex2 >= 'a') && (hex2 <= 'f')) {\n                    buffer.write(hex2 - 'a' + 10);\n                } else {\n}\n}\n}\n}\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    final BitSet decodedChars = new BitSet(256);\n    decodedChars.set(0, 128, true);\n    final BitSet hexChars = new BitSet(256);\n    hexChars.set('0', '9', true);\n    hexChars.set('A', 'F', true);\n    hexChars.set('a', 'f', true);\n    for (final byte c : bytes) {\n        int b = c;\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (b == '+') {\n            b = ' ';\n        } else if (b == '%') {\n            final byte b1 = bytes[++i];\n            final byte b2 = bytes[++i];\n            if (!hexChars.get(b1) || !hexChars.get(b2)) {\n                throw new DecoderException(\"Invalid hex character\");\n            }\n            b = (char) (((Character.digit(b1, RADIX) << 4) + Character.digit(b2, RADIX)) & 0xFF);\n        } else if (b >= 128 || !decodedChars.get(b)) {\n            throw new DecoderException(\"Invalid URL character\");\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            final int b = Character.digit((char) bytes[++i], RADIX) << 4;\n            final int b2 = Character.digit((char) bytes[++i], RADIX);\n            if (b >= 0 && b2 >= 0) {\n                try {\n                    buffer.write((byte) (b | b2));\n                } catch (final IOException e) {\n                    throw new DecoderException(\"Error writing decoded byte\", e);\n                }\n            } else {\n                throw new DecoderException(\"Illegal hex character in URL encoding\");\n            }\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int state = 0;\n    int b1 = 0;\n    for (final byte c : bytes) {\n        switch (state) {\n        case 0:\n            if (c == ESCAPE_CHAR) {\n                state = 1;\n            } else if (WWW_FORM_URL.get(c)) {\n                buffer.write(c);\n            }\n            break;\n        case 1:\n            if (c >= '0' && c <= '9') {\n                b1 = (b1 << 4) + (c - '0');\n                state = 2;\n            } else if (c >= 'A' && c <= 'F') {\n                b1 = (b1 << 4) + (c - 'A' + 10);\n                state = 2;\n            } else if (c >= 'a' && c <= 'f') {\n                b1 = (b1 << 4) + (c - 'a' + 10);\n                state = 2;\n            } else {\n                throw new DecoderException(\"Invalid URL character sequence\");\n            }\n            break;\n        case 2:\n            if (c >= '0' && c <= '9') {\n                b1 = (b1 << 4) + (c - '0');\n                buffer.write(b1);\n                state = 0;\n            } else if (c >= 'A' && c <= 'F') {\n                b1 = (b1 << 4) + (c - 'A' + 10);\n                buffer.write(b1);\n                state = 0;\n            } else if (c >= 'a' && c <= 'f') {\n                b1 = (b1 << 4) + (c - 'a' + 10);\n                buffer.write(b1);\n                state = 0;\n            } else {\n                throw new DecoderException(\"Invalid URL character sequence\");\n            }\n            break;\n        default:\n            break;\n        }\n    }\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    boolean escape = false;\n    int b;\n    for (final byte c : bytes) \n    {\n        b = c;\n        if (escape) \n        {\n            escape = false;\n            if (b == 't') \n            {\n                b = '\\t';\n            } else if (b == 'r') \n            {\n                b = '\\r';\n            } else if (b == 'n') \n            {\n                b = '\\n';\n            } else if (b == 'f') \n            {\n                b = '\\f';\n            } else if (b >= '0' && b <= '9') \n            {\n                b -= '0';\n            } else if (b >= 'A' && b <= 'F') \n            {\n                b -= 'A' - 10;\n            } else if (b >= 'a' && b <= 'f') \n            {\n                b -= 'a' - 10;\n            } else \n            {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n        } else if (b == ESCAPE_CHAR) \n        {\n            escape = true;\n            continue;\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    final boolean[] seenHexDigit = new boolean[2];\n    byte hexDigit = 0;\n    for (final byte c : bytes) {\n        final int b = c & 0xFF;\n        if (b == ESCAPE_CHAR) {\n            seenHexDigit[0] = false;\n            seenHexDigit[1] = false;\n        } else if (seenHexDigit[1]) {\n            hexDigit = (byte) ((hexDigit << 4) | Character.digit(b, RADIX));\n            seenHexDigit[1] = false;\n            buffer.write(hexDigit);\n        } else if (seenHexDigit[0]) {\n            hexDigit = (byte) (Character.digit(b, RADIX) << 4);\n            seenHexDigit[0] = false;\n        } else if ((b >= '0') && (b <= '9')) {\n            seenHexDigit[0] = true;\n        } else if ((b >= 'A') && (b <= 'F')) {\n            seenHexDigit[0] = true;\n        } else if ((b >= 'a') && (b <= 'f')) {\n            seenHexDigit[0] = true;\n        } else if (WWW_FORM_URL_SAFE.get(b)) {\n            buffer.write(b);\n        } else if ((b == '+') && (bytes.length > (bytes.length - 4))) {\n            buffer.write(' ');\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) {\n        final int b = bytes[i++];\n        if (b == ESCAPE_CHAR) {\n            int value = 0;\n            for (int shift = 0; shift <= 12; shift += 4) {\n                final int c = bytes[i++];\n                if (c >= '0' && c <= '9') {\n                    value |= ((c - '0') << shift);\n                } else if (c >= 'A' && c <= 'F') {\n                    value |= ((c - 'A' + 10) << shift);\n                } else if (c >= 'a' && c <= 'f') {\n                    value |= ((c - 'a' + 10) << shift);\n                } else {\n                    throw new DecoderException(\"Invalid URL encoding: \" + c);\n                }\n            }\n            if (value > 0x7f) {\n                throw new DecoderException(\"Invalid URL encoding: \" + value);\n            }\n            buffer.write(value);\n        } else if (b == '+') {\n            buffer.write(' ');\n        } else if (WWW_FORM_URL.get(b)) {\n            buffer.write(b);\n        } else {\n            throw new DecoderException(\"Invalid URL encoding: \" + b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    boolean escaped = false;\n    for (final byte b : bytes) {\n        if (escaped) {\n            final char c = (char)b;\n            if ('0' <= c && c <= '9') {\n                buffer.write((byte)(c - '0'));\n            } else if ('A' <= c && c <= 'F') {\n                buffer.write((byte)(c - 'A' + 10));\n            } else if ('a' <= c && c <= 'f') {\n                buffer.write((byte)(c - 'a' + 10));\n            } else {\n                throw new DecoderException(\"Invalid hex character in URL encoding\");\n            }\n            escaped = false;\n        } else {\n            if (b == ESCAPE_CHAR) {\n                escaped = true;\n            } else if (WWW_FORM_URL.get(b)) {\n                if (b == '+') {\n                    buffer.write(' ');\n                } else {\n                    buffer.write(b);\n                }\n            } else {\n                throw new DecoderException(\"Invalid URL character\");\n            }\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) {\n        final int b = bytes[i++];\n\n        if (b == ESCAPE_CHAR) {\n            final int c0 = Character.digit((bytes[i++] & 0xFF), RADIX);\n            final int c1 = Character.digit((bytes[i++] & 0xFF), RADIX);\n            if (c0 == -1 || c1 == -1) {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n            buffer.write((c0 << 4) | c1);\n        } else {\n            buffer.write(b);\n        }\n    }\n\n    return buffer.toByteArray();\n}"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  { \n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n\n    for (int i = 0; i < partial.size() - 1; i++) {\n        DateTimeFieldType currentFieldType = partial.getFieldType(i);\n        DurationField currentFieldDuration = currentFieldType.getDurationField();\n\n        DateTimeFieldType nextFieldType = partial.getFieldType(i + 1);\n        DurationField nextFieldDuration = nextFieldType.getRangeDurationField();\n\n        if (!currentFieldDuration.isSameUnit(nextFieldDuration)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  { \n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n\n    for (int i = 0; i < partial.size() - 1; i++) {\n        DateTimeFieldType currentFieldType = partial.getFieldType(i);\n        DurationField currentRangeField = currentFieldType.getRangeDurationField();\n        if (currentRangeField == null) {\n            continue;\n        }\n        int nextIndex = i + 1;\n        if (!currentRangeField.equals(partial.getFieldType(nextIndex).getRangeDurationField())) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    // Get the field types of the partial\n    DateTimeFieldType[] fieldTypes = partial.getFieldTypes();\n    // Iterate over the fields, skipping the last one\n    for (int i = 0; i < fieldTypes.length - 1; i++) {\n        // Get the range duration of the current field\n        DurationField rangeDuration = fieldTypes[i].getRangeDurationField();\n        // Get the unit of the next field\n        DurationField nextUnit = fieldTypes[i + 1].getDurationField().getUnit();\n        // If the range duration and unit are not equal, the partial is not contiguous\n        if (!rangeDuration.equals(nextUnit)) {\n            return false;\n        }\n    }\n    // If all fields have equal ranges, the partial is contiguous\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  { \n    if (partial == null) \n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    \n    int[] fields = partial.getFields();\n    for (int i = 0; i < fields.length - 1; i++) \n    { \n        ReadableInstant start = new Instant(partial.getChronology(), fields);\n        ReadableInstant end = new Instant(partial.getChronology(), fields);\n        end.set(fields[i], end.get(fields[i]) + 1);\n        Chronology chrono = partial.getChronology();\n        if (chrono.getRange(fields[i]).equals(chrono.getUnit(fields[i + 1])) == false)\n            return false;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  { \n    if (partial == null) \n        throw new IllegalArgumentException(\"Partial cannot be null\"); \n\n    List<DateTimeFieldType> fields = new ArrayList<>(partial.size()); \n\n    for (int i = 0; i < partial.size(); i++) \n        fields.add(partial.getFieldType(i)); \n    \n    for (int i = 0; i < fields.size() - 1; i++) { \n        if (fields.get(i).getRangeDurationField() != fields.get(i + 1).getUnit()) \n            return false; \n    } \n\n    return true; \n}",
      "public static final boolean isContiguous(ReadablePartial partial)  { \n    if (partial == null) \n    { \n        throw new IllegalArgumentException(\"Partial cannot be null\"); \n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) \n    { \n        DateTimeFieldType from = partial.getFieldType(i);\n        DateTimeFieldType to = partial.getFieldType(i + 1);\n        if (!from.getRange().equals(to.getUnit())) \n        { \n            return false; \n        } \n    }\n    return true; \n}",
      "public static final boolean isContiguous(ReadablePartial partial)  { \n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n\n    for (int i = 0; i < partial.size() - 1; i++) {\n        DateTimeFieldType currentFieldType = partial.getFieldType(i);\n        DurationField currentDurationField = currentFieldType.getDurationField();\n        if (currentDurationField == null) {\n            continue;\n        }\n\n        int nextIndex = i + 1;\n        DateTimeFieldType nextFieldType = partial.getFieldType(nextIndex);\n        DurationField nextDurationField = nextFieldType.getDurationField();\n        if (nextDurationField == null) {\n            continue;\n        }\n\n        if (!currentDurationField.getRangeUnit().equals(nextDurationField.getUnit())) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) {\n        Range range = partial.getField(i).getRange();\n        Range nextRange = partial.getField(i + 1).getRange();\n        if (!range.equals(nextRange)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  { \n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) {\n        if (partial.getField(i).getRangeDurationField() != partial.getField(i + 1).getDurationField()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  { \n    if (partial == null) \n        throw new IllegalArgumentException(\"Partial cannot be null\"); \n    int size = partial.size(); \n    for (int i = 0; i < size - 1; i++) \n    { \n        DurationField field = partial.getField(i).getRangeDurationField(); \n        if (field == null) \n            return false; \n        if (!field.equals(partial.getField(i+1).getRangeDurationField())) \n            return false; \n    } \n    return true; \n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<>(a, b);\n    for (O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<>(a, b);\n    for (O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<>(a, b);\n    for (O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> result = new HashSet<>();\n    for (final O element : a) {\n        result.add(element);\n    }\n    for (final O element : b) {\n        result.add(element);\n    }\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> result = new ArrayList<>();\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n        if (!result.contains(obj)) result.add(obj);\n    }\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> result = new ArrayList<>();\n    for (O element : a) {\n        if (!result.contains(element)) {\n            result.add(element);\n        }\n    }\n    for (O element : b) {\n        if (!result.contains(element)) {\n            result.add(element);\n        }\n    }\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> result = new ArrayList<>();\n    addAll(result, a);\n    addAll(result, b);\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> result = new ArrayList<>();\n    for (O element : a) {\n        result.add(element);\n    }\n    for (O element : b) {\n        result.add(element);\n    }\n    return result;\n}"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> paramDependencies = Lists.newArrayList();\n    if (params != null) {\n        for (Node param : params.getChildren()) {\n            paramDependencies.add(NodeUtil.createString(param.getString()));\n        }\n    }\n    return paramDependencies;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = Lists.newArrayList();\n  if (params != null) {\n    Node child = params.getFirstChild();\n    while (child != null) {\n      if (child.isString()) {\n        result.add(child);\n      }\n      child = child.getNext();\n    }\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = Lists.newArrayList();\n  if (params != null) {\n    for (Node param : params.children()) {\n      if (param.isString()) {\n        result.add(param);\n      } else {\n        throw new IllegalStateException(\"Expected string param: \" + param);\n      }\n    }\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = Lists.newArrayList();\n  Node n = params;\n  while (n != null) {\n    if (n.isString()) {\n      result.add(n);\n    }\n    n = n.getNext();\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = Lists.newArrayList();\n  Node child = params.getFirstChild();\n  while (child != null) {\n    if (child.isString()) {\n      result.add(child);\n    } else {\n      throw new IllegalArgumentException(\"Expected string as param list element\");\n    }\n    child = child.getNext();\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    if (params.isParamList()) {\n        for (Node param : params.children()) {\n            Node firstChild = param.getFirstChild();\n            if (firstChild != null) {\n                Node child = firstChild;\n                while (child != null) {\n                    if (child.isString()) {\n                        strings.add(child);\n                    }\n                    child = child.getNext();\n                }\n            }\n        }\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = new ArrayList<>();\n  if (params != null && params.isParamList()) {\n    Node param = params.getFirstChild();\n    while (param != null) {\n      Node stringNode = NodeUtil.getStringNode(param);\n      if (stringNode != null) {\n        result.add(stringNode);\n      }\n      param = param.getNext();\n    }\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = Lists.newArrayList();\n  Node cur = params.getFirstChild();\n  while (cur != null) {\n    if (cur.isString()) {\n      result.add(cur);\n    } else {\n      throw new IllegalStateException(\n          String.format(\"Invalid param list: expected string, but got %s\", cur));\n    }\n    cur = cur.getNext();\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    for (Node param : NodeUtil.getFunctionParameters(params)) \n    {\n        Node stringNode = new StringNode(Token.STRING, param.toString());\n        result.add(stringNode);\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = new ArrayList<>();\n  if (params.isParamList()) {\n    Node child = params.getFirstChild();\n    while (child != null) {\n      Node param = child;\n      if (param.isString()) {\n        String str = param.getString();\n        result.add(Node.newString(str));\n      } else {\n        throw new RuntimeException(\"Unexpected node: \" + param.getType());\n      }\n      child = param.getNext();\n    }\n  } else {\n    throw new RuntimeException(\"Expected PARAM_LIST node, but found: \" + params.getType());\n  }\n  return result;\n}"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0)\n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        final int strLen = str.length();\n        if (strLen >= width)\n        {\n            str.getChars(strLen - width, strLen, buffer, size);\n        }\n        else\n        {\n            final int padLen = width - strLen;\n            appendPadding(padLen, padChar);\n            str.getChars(0, strLen, buffer, size);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n        if (width > 0) \n        {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) \n                {\n                    buffer[size++] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size - padLen);\n            }\n        }\n        return this;\n    }",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size++] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size - padLen);\n            }\n        }\n        return this;\n    }",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n        if (width > 0) \n        {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n            final int strLen = str.length();\n            if (strLen >= width) \n            {\n                str.getChars(0, width, buffer, size);\n            }\n            else \n            {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) \n                {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n        if (width > 0) \n        {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null)\n            {\n                str = \"\";\n            }\n            final int strLen = str.length();\n            if (strLen >= width) \n            {\n                str.getChars(0, width, buffer, size);\n            }\n            else \n            {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) \n                {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        }\n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n        if (width > 0) \n        {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n            final int strLen = str.length();\n            if (strLen >= width) \n            {\n                str.getChars(0, width, buffer, size);\n            } \n            else \n            {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            if (str == null) {\n                str = \"\";\n            }\n            final int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, width, buffer, size);\n            } else {\n                final int padLen = width - strLen;\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + i] = padChar;\n                }\n                str.getChars(0, strLen, buffer, size + padLen);\n            }\n            size += width;\n        }\n        return this;\n    }",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        }\n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    return str.replaceFirst(str.substring(0, 1), Character.toLowerCase(str.charAt(0))+\"\");\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters.length == 0) \n    {\n        return str;\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < str.length(); i++) \n    {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n            sb.append(ch);\n        }\n        else if (capitalizeNext) \n        {\n            sb.append(Character.toTitleCase(ch));\n            capitalizeNext = false;\n        }\n        else \n        {\n            sb.append(Character.toLowerCase(ch));\n        }\n    }\n    return sb.toString();\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        str = str.toLowerCase();\n    }\n    StringBuffer sb = new StringBuffer(str.length());\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if ((i == 0 || isDelimiter(str.charAt(i - 1), delimiters)) &&\n            Character.isAlphabetic(c)) {\n            sb.append(Character.toTitleCase(c));\n        } else {\n            sb.append(Character.toLowerCase(c));\n        }\n    }\n    return sb.toString();\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n    String result = cZoneIdConversion.get(id);\n    if (result == null) {\n        int offset = parseOffset(id);\n        if (offset != 0) {\n            result = id.replace('Z', '0') + '+' + printOffset(offset);\n        } else {\n            result = id;\n        }\n        cZoneIdConversion.put(id, result);\n    }\n    return result;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    String result = cZoneIdConversion.get(id);\n    if (result == null) {\n        String newId;\n        if (id.startsWith(\"Etc/GMT\")) {\n            newId = \"Etc/UTC\";\n        } else if (id.startsWith(\"GMT\")) {\n            newId = \"UTC\";\n        } else {\n            newId = id.replace(\" \", \"_\");\n        }\n        result = cZoneIdConversion.putIfAbsent(id, newId, newId);\n        if (result == null) {\n            result = newId;\n        }\n    }\n    return result;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<>();\n    }\n    String convertedId = cZoneIdConversion.get(id);\n    if (convertedId == null) \n    {\n        String newId;\n        if (id.equals(\"GMT\")) \n        {\n            newId = \"UTC\";\n        } else if (id.equals(\"Local\")) \n        {\n            newId = \"Z\";\n        } else \n        {\n            newId = id.replace(\" \", \"\");\n        }\n        cZoneIdConversion.put(id, newId);\n        convertedId = newId;\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    String result = cZoneIdConversion.get(id);\n    if (result == null) {\n        result = id;\n        int offset = parseOffset(result);\n        if (offset != 0) {\n            result = fixedOffsetZone(id, offset).getID();\n        }\n        cZoneIdConversion.put(id, result);\n    }\n    return result;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<>();\n        cZoneIdConversion.put(\"GMT\", \"UTC\");\n        cZoneIdConversion.put(\"EST\", \"America/New_York\");\n        cZoneIdConversion.put(\"CST\", \"America/Chicago\");\n        cZoneIdConversion.put(\"MST\", \"America/Denver\");\n        cZoneIdConversion.put(\"PST\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"HST\", \"Pacific/Honolulu\");\n        cZoneIdConversion.put(\"AST\", \"America/Anchorage\");\n        cZoneIdConversion.put(\"NST\", \"America/St_Johns\");\n        cZoneIdConversion.put(\"IET\", \"Europe/Berlin\");\n        cZoneIdConversion.put(\"MET\", \"Europe/Madrid\");\n        cZoneIdConversion.put(\"EST5EDT\", \"America/New_York\");\n        cZoneIdConversion.put(\"CST6CDT\", \"America/Chicago\");\n        cZoneIdConversion.put(\"MST7MDT\", \"America/Denver\");\n        cZoneIdConversion.put(\"PST8PDT\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"HST9HST\", \"Pacific/Honolulu\");\n        cZoneIdConversion.put(\"AST4ADT\", \"America/Anchorage\");\n        cZoneIdConversion.put(\"NST3NST\", \"America/St_Johns\");\n        cZoneIdConversion.put(\"IET3IET\", \"Europe/Berlin\");\n        cZoneIdConversion.put(\"MET3MET\", \"Europe/Madrid\");\n    }\n    return cZoneIdConversion.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) {\n        cZoneIdConversion = new HashMap<>();\n        for (String oldId : cAvailableIDs) {\n            cZoneIdConversion.put(oldId, fixedOffsetZone(oldId, parseOffset(oldId)).getID());\n        }\n    }\n    return cZoneIdConversion.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    String result = cZoneIdConversion.get(id);\n    if (result == null) {\n        int offset = parseOffset(id);\n        result = id + \":\" + offset;\n        cZoneIdConversion.put(id, result);\n    }\n    return result;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return id;\n    }\n    String result = cZoneIdConversion.get(id);\n    if (result == null) {\n        int offset;\n        try {\n            offset = parseOffset(id);\n        } catch (IllegalArgumentException ex) {\n            return id;\n        }\n        result = fixedOffsetZone(id, offset).getID();\n        cZoneIdConversion.put(id, result);\n    }\n    return result;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    String result = cZoneIdConversion.get(id);\n    if (result == null) {\n        DateTimeZone zone = DateTimeZone.forID(id);\n        result = zone.getID();\n        cZoneIdConversion.put(id, result);\n    }\n    return result;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    String converted = cZoneIdConversion.get(id);\n    if (converted != null) {\n        return converted;\n    }\n    int offset = parseOffset(id);\n    if (offset == 0) {\n        return id;\n    }\n    DateTimeZone zone = DateTimeZone.forOffsetMillis(offset);\n    DateTimeFormatter formatter = DateTimeFormatter.forPattern(\"Z\");\n    converted = formatter.print(zone.getOffset(Instant.now()));\n    cZoneIdConversion.put(id, converted);\n    return converted;\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        final RealMatrix weightMatrixSqrt = squareRoot(weightMatrix);\n        final int nR = rows;\n        final int nC = cols;\n        final RealMatrix weightedJacobian = weightMatrixSqrt.operate(jF.value(params));\n        final double[] residualsWeights = weightMatrixSqrt.getColumnVector(0).getData();\n        final double[] currentPoint = point;\n        final double[] currentObjective = computeObjectiveValue(currentPoint);\n        final double[] currentResiduals = computeResiduals(currentObjective);\n        final double[] b = new double[nC];\n        for (int i = 0; i < nR; ++i) {\n            final double[] grad   = weightedJacobian.getRow(i);\n            final double weight   = residualsWeights[i];\n            final double residual = currentResiduals[i];\n\n            // compute the normal equation\n            final double wr = weight * residual;\n            for (int j = 0; j < nC; ++j) {\n                b[j] += wr * grad[j];\n            }\n        }\n        return weightedJacobian.operate(b);\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    final RealMatrix weightMatrix = getWeight();\n    if (weightMatrix.getRowDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n    }\n    if (weightMatrix.getColumnDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n    }\n\n    // Diagonal of the weight matrix.\n    final double[] residualsWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n\n    final double[] currentPoint = getStart();\n    final int nC = currentPoint.length;\n\n    // iterate until convergence is reached\n    PointVectorValuePair current = null;\n    for (boolean converged = false; !converged;) {\n        incrementIterationCount();\n\n        // evaluate the objective function and its jacobian\n        PointVectorValuePair previous = current;\n        // Value of the objective function at \"currentPoint\".\n        final double[] currentObjective = computeObjectiveValue(currentPoint);\n        final double[] currentResiduals = computeResiduals(currentObjective);\n        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n        current = new PointVectorValuePair(currentPoint, currentObjective);\n\n        // build the linear problem\n        final double[]   b = new double[nC];\n        final double[][] a = new double[nC][nC];\n        for (int i = 0; i < nR; ++i) {\n\n            final double[] grad   = weightedJacobian.getRow(i);\n            final double weight   = residualsWeights[i];\n            final double residual = currentResiduals[i];\n\n            // compute the normal equation\n            final double wr = weight * residual;\n            for (int j = 0; j < nC; ++j) {\n                b[j] += wr * grad[j];\n            }\n        }\n        return weightedJacobian;\n    }\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\nfinal RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStart();\n        final int nC = currentPoint.length;\n\n        final RealMatrix weightedJacobian = computeJacobian(currentPoint);\n        final double[][] jacobiW = weightedJacobian.getData();\n        for (int i = 0; i < nR; i++) {\n            final double weight = residualsWeights[i];\n            for (int j = 0; j < nC; j++) {\n                jacobiW[i][j] *= weight;\n            }\n        }\n        return weightedJacobian.createMatrix(nR, nC);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        final RealMatrix weightMatrixSqrt = squareRoot(weightMatrix);\n        final double[] residualsWeights = new double[rows];\n        for (int i = 0; i < rows; i++) {\n            residualsWeights[i] = weightMatrixSqrt.getEntry(i, i);\n        }\n        double[][] weightedJacobian = new double[cols][rows];\n        for (int i = 0; i < rows; i++) {\n            double[] grad = new double[cols];\n            for (int j = 0; j < cols; j++) {\n                grad[j] = weightedResidualJacobian[i][j];\n            }\n            for (int j = 0; j < cols; j++) {\n                weightedJacobian[j][i] = residualsWeights[i] * grad[j];\n            }\n        }\n        return weightMatrixSqrt.createMatrix(cols, rows).add(new Array2DRowRealMatrix(weightedJacobian));\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    final RealMatrix weightMatrix = getWeight();\n    if (weightMatrix.getRowDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n    }\n    if (weightMatrix.getColumnDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n    }\n\n    // Diagonal of the weight matrix.\n    final double[] residualsWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n\n    final double[] currentPoint = getStart();\n    final int nC = currentPoint.length;\n\n    final RealMatrix weightedJacobian = weightMatrixSqrt.operate(computeJacobian(params));\n    for (int i = 0; i < nR; ++i) {\n        final double weight = residualsWeights[i];\n        final double residual = weightedResiduals[i];\n        final double wr = weight * residual;\n        for (int j = 0; j < nC; ++j) {\n            weightedJacobian.addToEntry(j, j, wr * weightedResidualJacobian[i][j]);\n        }\n    }\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Get the weight matrix from the optimization data.\n    RealMatrix weightMatrix = getWeight();\n    if (weightMatrix.getRowDimension() != rows) {\n        throw new DimensionMismatchException(weightMatrix.getRowDimension(), rows);\n    }\n    if (weightMatrix.getColumnDimension() != cols) {\n        throw new DimensionMismatchException(weightMatrix.getColumnDimension(), cols);\n    }\n    \n    // Diagonal of the weight matrix.\n    final double[] residualsWeights = new double[rows];\n    for (int i = 0; i < rows; i++) {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n\n    // Calculate the weighted Jacobian using the provided formula.\n    final double[] currentPoint = params;\n    final RealMatrix weightedJacobian = jF.value(currentPoint);\n    double[][] result = new double[cols][params.length];\n    for (int i = 0; i < rows; ++i) {\n        double residual = weightedResiduals[i];\n        double weight = residualsWeights[i];\n        for (int j = 0; j < cols; ++j) {\n            result[j][i] = weightedJacobian.getEntry(i, j) * weight * residual;\n        }\n    }\n    return weightMatrixSqrt.operate(new Array2DRowRealMatrix(result));\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        final RealMatrix jacobian = jF.value(params);\n        if (jacobian.getRowDimension() != rows) {\n            throw new DimensionMismatchException(jacobian.getRowDimension(), rows);\n        }\n        if (jacobian.getColumnDimension() != cols) {\n            throw new DimensionMismatchException(jacobian.getColumnDimension(), cols);\n        }\n        final RealMatrix weightMatrixSqrt = squareRoot(weightMatrix);\n        final double[][] weightedJacobian = jacobian.operate(weightMatrixSqrt);\n        return new Array2DRowRealMatrix(weightedJacobian);\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        final RealMatrix jacobian = jF.value(params);\n        if (jacobian.getRowDimension() != rows) {\n            throw new DimensionMismatchException(jacobian.getRowDimension(), rows);\n        }\n        if (jacobian.getColumnDimension() != cols) {\n            throw new DimensionMismatchException(jacobian.getColumnDimension(), cols);\n        }\n        return jacobian.scalarMultiply(weightMatrixSqrt);\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    final RealMatrix weightMatrixSqrt = squareRoot(weightMatrix);\n    return weightMatrixSqrt.multiply(computeJacobian(params));\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        final RealMatrix weightedJacobian = jacobian.value(params);\n        final RealMatrix weightMatrixSqrt = squareRoot(weightMatrix);\n        return weightedJacobian.scalarMultiply(weightMatrixSqrt);\n    }"
    ],
    [
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"no comparator\");\n    }\n    int result = -1;\n    for (int i = 0; i < values.size(); i++) \n    {\n        if (valueSet.get(i)) {\n            if (result == -1 || comparator.compare(values.get(i), values.get(result)) < 0) {\n                result = i;\n            }\n        } else if (set(i)) {\n            if (result == -1 || comparator.compare(values.get(i), values.get(result)) < 0) {\n                result = i;\n            }\n        }\n    }\n    return result;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set for CollatingIterator\");\n    }\n    if (!anyValueSet(valueSet)) {\n        start();\n    }\n    int least = -1;\n    Object leastVal = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            Object val = values.get(i);\n            if (least == -1 || comparator.compare(leastVal, val) > 0) {\n                least = i;\n                leastVal = val;\n            }\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"no comparator\");\n    }\n    int least = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (least < 0) {\n                least = i;\n            } else {\n                if (comparator.compare(values.get(i), values.get(least)) < 0) {\n                    least = i;\n                }\n            }\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set for CollatingIterator\");\n    }\n    int first = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (first == -1) {\n                first = i;\n            } else {\n                final int comp = comparator.compare(values.get(i), values.get(first));\n                if (comp < 0) {\n                    first = i;\n                } else if (comp == 0) {\n                    if (iterator.getComparator().compare(iterators.get(i), iterators.get(first)) < 0) {\n                        first = i;\n                    }\n                }\n            }\n        }\n    }\n    return first;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (leastIndex < 0) {\n                leastIndex = i;\n            } else if (comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                leastIndex = i;\n            }\n        }\n    }\n    if (leastIndex >= 0) {\n        while (leastIndex > 0) {\n            leastIndex--;\n            if (valueSet.get(leastIndex)) {\n                break;\n            }\n        }\n        set(leastIndex);\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set for CollatingIterator\");\n    }\n    if (values == null) {\n        start();\n    }\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            continue;\n        }\n        if (set(i)) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set for CollatingIterator\");\n    }\n    if (!anyValueSet(valueSet)) {\n        return start();\n    }\n    int least = lastReturned;\n    while (!valueSet.get(least)) {\n        least = (least + 1) % values.size();\n    }\n    for (int i = 0; i < values.size(); i++) {\n        int idx = (least + i + 1) % values.size();\n        if (valueSet.get(idx) && comparator.compare(values.get(idx), values.get(least)) < 0) {\n            least = idx;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set for CollatingIterator\");\n    }\n    int result = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (result == -1 || comparator.compare(values.get(i), values.get(result)) < 0) {\n                result = i;\n            }\n        }\n    }\n    return result;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"no comparator\");\n    }\n    int result = -1;\n    for (int i = 0; i < values.size(); i++) \n    {\n        if (valueSet.get(i))\n        {\n            if (result == -1)\n            {\n                result = i;\n            }\n            else\n            {\n                E val = values.get(i);\n                E resultVal = values.get(result);\n                if (comparator.compare(val, resultVal) < 0)\n                {\n                    result = i;\n                }\n            }\n        }\n    }\n    return result;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"no comparator set\");\n    }\n    if (anyValueSet(valueSet) == false) {\n        return start();\n    }\n    int least = lastReturned;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i) && (least == -1 || comparator.compare(values.get(i), values.get(least)) < 0))\n        {\n            least = i;\n        }\n    }\n    return least;\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    Step step = steps[currentStep];\n    Expression[] predicates = step.getPredicates();\n    return doPredicateName(context, parentPointer, steps, currentStep, predicates, 0);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    Expression expression = step.getNodeTest().getNodeTestExpression();\n    Object value = expression.evaluate(parentPointer.getImmediateNode(), null);\n    return new ChildNodePointer(parentPointer, step, value);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = null;\n    if (step.getNodeTest() instanceof NodeNameTest) {\n        name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    } else {\n        name = new QName(step.getNodeTest().toString());\n    }\n    return parentPointer.createNodeIterator(name.toString(), false, null).getNodePointer();\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodeTest test = step.getNodeTest();\n    if (test instanceof NodeNameTest) {\n        QName name = ((NodeNameTest) test).getNodeName();\n        return parentPointer.createChild(null, name.getLocalPart(), -1, null);\n    } else {\n        throw new RuntimeException(\n            \"Unsupported test for createChildPointerForStep: \" + test);\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        Step step = steps[currentStep];\n        NodeTest nodeTest = step.getNodeTest();\n        if (nodeTest instanceof NodeNameTest) {\n            return parentPointer.createNodeIterator(\n                    ((NodeNameTest) nodeTest).getNodeName(), false, null);\n        } else if (nodeTest instanceof NodeSetTest) {\n            return parentPointer.createNodeIterator(\n                    ((NodeSetTest) nodeTest).getQName(), false, null);\n        } else if (nodeTest instanceof NodeTypeTest) {\n            return parentPointer.createNodeIterator(\n                    null, false, new NodeTypeTest[] { (NodeTypeTest) nodeTest });\n        } else if (nodeTest instanceof NodeTypeSetTest) {\n            return parentPointer.createNodeIterator(\n                    null, false, (NodeTypeTest[]) nodeTest.getNodeTypeTests());\n        } else if (nodeTest instanceof EmptyTest) {\n            return parentPointer.createNodeIterator(\n                    null, false, new Test[] { (EmptyTest) nodeTest });\n        } else if (nodeTest instanceof PositionTest) {\n            return parentPointer.createNodeIterator(\n                    null, false, new Test[] { (PositionTest) nodeTest });\n        } else if (nodeTest instanceof CurrentNodeTest) {\n            return parentPointer.createNodeIterator(null, false, null);\n        } else if (nodeTest instanceof LangTest) {\n            return parentPointer.createNodeIterator(null, false, null);\n        } else if (nodeTest instanceof PositionCallTest) {\n            return parentPointer.createNodeIterator(null, false, null);\n        } else {\n            throw new RuntimeException(\n                    \"Unsupported node test: \" + nodeTest.getClass().getName());\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        Step step = steps[currentStep];\n\n        Expression predicate = predicates[0];\n        String path = predicate.getText();\n        if (path.startsWith(\"fn:local-name(\") && path.endsWith(\")\")) {\n            path = path.substring(\"fn:local-name(\".length(), path.length() - 1);\n        }\n        if (path.startsWith(\"fn:namespace-uri(\") && path.endsWith(\")\")) {\n            path = path.substring(\"fn:namespace-uri(\".length(), path.length() - 1);\n        }\n        if (path.startsWith(\"fn:local-name(\") && path.endsWith(\")\")) {\n            path = path.substring(\"fn:local-name(\".length(), path.length() - 1);\n        }\n        if (path.startsWith(\"fn:local-name(\") && path.endsWith(\")\")) {\n            path = path.substring(\"fn:local-name(\".length(), path.length() - 1);\n        }\n        if (path.startsWith(\"fn:local-name(\") && path.endsWith(\")\")) {\n            path = path.substring(\"fn:local-name(\".length(), path.length() - 1);\n        }\n\n        return parentPointer.createNodeIterator(path, false, null).getNodePointer();\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    Expression[] predicates = step.getPredicates();\n    NodeTest nodeTest = step.getNodeTest();\n    if (predicates.length == 0) {\n        if (nodeTest instanceof NodeNameTest) {\n            String name = ((NodeNameTest) nodeTest).getNodeName();\n            return parentPointer.childIterator(nodeTest, false, null).getNodePointer();\n        } else if (nodeTest instanceof NodeTypeTest) {\n            return parentPointer.childIterator(nodeTest, false, null).getNodePointer();\n        } else if (nodeTest instanceof NodeSetTest) {\n            return parentPointer.childIterator(nodeTest, false, null).getNodePointer();\n        } else {\n            return parentPointer.childIterator(null, false, null).getNodePointer();\n        }\n    } else {\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) {\n            return parentPointer.createNodeIterator(step.getNodeName(), false, null).getNodePointer();\n        } else {\n            return parentPointer.childIterator(nodeTest, false, null).getNodePointer();\n        }\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    Expression expression = step.getNodeTest().getNodeTestExpression();\n    NodePointer pointer;\n    if (expression instanceof PropertyExpression) {\n        pointer = parentPointer.createNodeIterator(\n                ((PropertyExpression) expression).getProperty(),\n                false, null);\n    } else if (expression instanceof NodeNameTest) {\n        QName name = ((NodeNameTest) expression).getNodeName();\n        pointer = parentPointer.createNodeIterator(name.toString(), false, null);\n    } else if (expression instanceof LiteralExpression) {\n        String literal = ((LiteralExpression) expression).getLiteral();\n        pointer = parentPointer.createNodeIterator(\"string\", false, literal);\n    } else if (expression instanceof AttributeValueExpression) {\n        pointer = parentPointer.attributeIterator(\n                ((AttributeNameTest) expression).getAttributeName());\n    } else if (expression instanceof PositionalExpression) {\n        int position = ((PositionalExpression) expression).getPosition();\n        pointer = parentPointer.createNodeIterator(\n                null, false, parentPointer.getIndex() + position - 1);\n    } else if (expression instanceof StepExpression) {\n        pointer = interpretSimpleLocationPath(\n                null, parentPointer.getImmediateParentPointer(),\n                ((StepExpression) expression).getSteps());\n    } else {\n        pointer = parentPointer.createNodeIterator(\n                null, false, parentPointer.getIndex());\n    }\n    pointer.setAttribute(step.getAxis() == Compiler.AXIS_ATTRIBUTE);\n    return pointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        return parentPointer.createNodeIterator(\n                ((NodeNameTest) step.getNodeTest()).getNodeName(),\n                false,\n                null).getNodePointer();\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodePointer childPointer = null;\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_CHILD) {\n            childPointer = parentPointer.createNodeIterator(\n                step.getNodeTest().getNodeName(), false, null).getNodePointer();\n        } else if (axis == Compiler.AXIS_SELF) {\n            childPointer = parentPointer.getValuePointer();\n        } else if (axis == Compiler.AXIS_ATTRIBUTE) {\n            childPointer = parentPointer.attributeIterator(\n                ((NodeNameTest) step.getNodeTest()).getNodeName()).getNodePointer();\n        } else if (axis == Compiler.AXIS_NAMESPACE) {\n            childPointer = parentPointer.namespacePointer(\n                ((WildcardTest) step.getNodeTest()).getNamespace());\n        } else if (axis == Compiler.AXIS_DESCENDANT) {\n            childPointer = parentPointer.childIterator(\n                (NodeTest) step.getNodeTest(), false, null).getNodePointer();\n        } else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF) {\n            childPointer = parentPointer.childIterator(\n                (NodeTest) step.getNodeTest(), true, null).getNodePointer();\n        } else if (axis == Compiler.AXIS_PARENT) {\n            if (parentPointer.getParent().isLeaf()) {\n                childPointer = parentPointer.getParent().createChild(\n                    null, -1, parentPointer.getValue());\n            } else {\n                childPointer = parentPointer.getParent();\n            }\n        } else if (axis == Compiler.AXIS_ANCESTOR) {\n            if (parentPointer.getParent().isLeaf()) {\n                childPointer = parentPointer.getParent().createChild(\n                    null, -1, parentPointer.getValue());\n            } else {\n                childPointer = parentPointer.getParent();\n            }\n        } else if (axis == Compiler.AXIS_PRECEDING) {\n            childPointer = parentPointer.getParent().childIterator(\n                null, false, parentPointer).getNodePointer();\n        } else if (axis == Compiler.AXIS_PRECEDING_SIBLING) {\n            childPointer = parentPointer.getParent().childIterator(\n                null, false, parentPointer).getNodePointer();\n}\n}"
    ],
    [
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.isDirect() ? Math.min(op.getLocation().getX(), inf) : Math.max(op.getLocation().getX(), inf);\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf   = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf   = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf   = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final Locale locale = getLocale();\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy result = cache.get(locale);\n    if(result!=null) {\n        return result;\n    }\n    result= new TextStrategy(field, definingCalendar, locale);\n    cache.putIfAbsent(locale, result);\n    return result;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final StringBuilder sb= new StringBuilder();\n    escapeRegex(sb, definingCalendar.getDisplayName(field, Calendar.SHORT, locale), false).append('|');\n    escapeRegex(sb, definingCalendar.getDisplayName(field, Calendar.LONG, locale), false);\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final StringBuilder formatField= new StringBuilder(definingCalendar.getDisplayName(field, Calendar.SHORT, locale));\n    formatField.append('/').append(definingCalendar.getDisplayName(field, Calendar.LONG, locale));\n\n    final Map<String, Integer> keyValues= getDisplayNames(field, definingCalendar, locale);\n    return new TextStrategy(field, keyValues);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final StringBuilder pattern= new StringBuilder();\n    final StringBuilder formatField= new StringBuilder();\n    int state = 0;\n    for(int i=0; i<parsePattern.pattern().length(); i++) {\n        final char c= parsePattern.pattern().charAt(i);\n        switch(state) {\n        case 0: // start\n            if(c=='\\\\') {\n                state= 1;\n            } else if(Character.isLetter(c)) {\n                formatField.append(c);\n            } else {\n                pattern.append(c);\n            }\n            break;\n        case 1: // escaped character\n            pattern.append(c);\n            state= 0;\n            break;\n        }\n    }\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final Map<String, Integer> keyValues= getDisplayNames(field, definingCalendar, locale);\n    return new TextStrategy(field, keyValues);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final StringBuilder sb= new StringBuilder(definingCalendar.getDisplayName(field, Calendar.SHORT, locale));\n    final String shortValue= sb.toString();\n    sb.append(definingCalendar.getDisplayName(field, Calendar.LONG, locale));\n    final String longValue= sb.toString();\n    final Map<String, Integer> keyValues= new HashMap<>(4);\n    keyValues.put(shortValue, Calendar.SHORT);\n    keyValues.put(longValue, Calendar.LONG);\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Locale locale= getLocale();\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        cache.putIfAbsent(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    final Locale locale = this.locale;\n    synchronized(cache) {\n        Strategy strategy = cache.get(locale);\n        if (strategy != null) {\n            return strategy;\n        }\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        cache.putIfAbsent(locale, strategy);\n        return strategy;\n    }\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Locale locale = parser.locale;\n    if (locale == null) {\n        locale = Locale.getDefault();\n    }\n    Strategy s = cache.get(locale);\n    if (s == null) {\n        synchronized (cache) {\n            s = cache.get(locale);\n            if (s == null) {\n                s = new TextStrategy(field, definingCalendar, locale);\n                cache.put(locale, s);\n            }\n        }\n    }\n    return s;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final Map<String, Integer> keyValues= getDisplayNames(field, definingCalendar, locale);\n    return new TextStrategy(field, keyValues);\n}"
    ],
    [
      "private boolean setNextObject()  {\n    nextObjectSet = false;\n    if (iterator.hasNext()) \n    {\n        E next = iterator.next();\n        if (predicate.evaluate(next)) \n        {\n            nextObject = next;\n            nextObjectSet = true;\n        }\n    }\n    return nextObjectSet;\n}",
      "private boolean setNextObject()  {\n    nextObject = null;\n    nextObjectSet = false;\n    if (iterator == null || !iterator.hasNext()) \n    {\n        return false;\n    }\n    E next = iterator.next();\n    if (predicate != null && !predicate.evaluate(next))\n    {\n        return setNextObject();\n    }\n    nextObject = next;\n    nextObjectSet = true;\n    return true;\n}",
      "private boolean setNextObject()  {\n    if (nextObjectSet) \n    {\n        nextObjectSet = false;\n        return true;\n    }\n    if (iterator.hasNext()) \n    {\n        E next = iterator.next();\n        if (predicate.evaluate(next)) \n        {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObject = null;\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        E next = iterator.next();\n        if (predicate.evaluate(next)) {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        E next = iterator.next();\n        if (predicate.evaluate(next)) \n        {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObject = null;\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        E next = iterator.next();\n        if (predicate.evaluate(next)) \n        {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObjectSet = false;\n    nextObject = null;\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (nextObjectSet) \n    {\n        nextObjectSet = false;\n        return true;\n    }\n    if (iterator.hasNext()) \n    {\n        E next = iterator.next();\n        if (predicate.evaluate(next)) \n        {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObject = null;\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        E next = iterator.next();\n        if (predicate.evaluate(next)) {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        E next = iterator.next();\n        if (predicate.evaluate(next)) \n        {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n\n    nextObject = null;\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        E next = iterator.next();\n        if (predicate.evaluate(next)) \n        {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n\n    nextObject = null;\n    nextObjectSet = false;\n    return false;\n}"
    ],
    [
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            x[i] = lB[i];\n        } \n        else if (x[i] > uB[i]) \n        {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            x[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    for (int i = 0; i < x.length; i++)\n    {\n        if (x[i] < lB[i])\n        {\n            x[i] = lB[i];\n        }\n        else if (x[i] > uB[i])\n        {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) \n        {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) x[i] = lB[i];\n        if (x[i] > uB[i]) x[i] = uB[i];\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    for (int i = 0; i < x.length; i++)\n    {\n        if (x[i] < lB[i])\n        {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i])\n        {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        if(x[i] < lB[i]) \n        {\n            repaired[i] = lB[i];\n        }\n        else if(x[i] > uB[i]) \n        {\n            repaired[i] = uB[i];\n        }\n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws NonSquareMatrixException {\n    if (!matrix.isSquare()) {\n        throw new NonSquareMatrixException(matrix.getRowDimension(),\n            matrix.getColumnDimension());\n    }\n\n    HessenbergTransformer transformer = new HessenbergTransformer(matrix);\n    double[][] matrixT = transformer.getH().getData();\n    double[][] matrixP = transformer.getP().getData();\n\n    int n = matrixT.length;\n\n    // compute matrix norm\n    double norm = 0.0;\n    for (int i = 0; i < n; i++) {\n        for (int j = FastMath.max(i - 1, 0); j < n; j++) {\n            norm += FastMath.abs(matrixT[i][j]);\n        }\n    }\n\n    // we can not handle a matrix with zero norm\n    if (Precision.equals(norm, 0.0, EPSILON)) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    // Backsubstitute to find vectors of upper triangular form\n\n    double r = 0.0;\n    double s = 0.0;\n    double z = 0.0;\n\n    for (int idx = n - 1; idx >= 0; idx--) {\n        double p = realEigenvalues[idx];\n        double q = imagEigenvalues[idx];\n\n        for (int j = 0; j < idx; j++) {\n            matrixT[j][idx] = matrixT[j][idx] - matrixT[j][j] * p - matrixT[j][j + 1] * q;\n        }\n    }\n\n    for (int idx = n - 2; idx >= 0; idx--) {\n        double p = realEigenvalues[idx];\n        double q = imagEigenvalues[idx];\n        double r = realEigenvalues[idx + 1];\n        double s = imagEigenvalues[idx + 1];\n\n        double t = FastMath.hypot(p, q);\n        if (t == 0) {\n            t = p;\n        } else {\n            t = 1 / t;\n        }\n\n        p = p * t;\n        q = q * t;\n\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    if (!matrix.isSquare()) {\n        throw new NonSquareMatrixException(matrix.getRowDimension(),\n                matrix.getColumnDimension());\n    }\n\n    HessenbergTransformer transformer = new HessenbergTransformer(matrix);\n    matrixT = transformer.getH().getData();\n    matrixP = transformer.getP().getData();\n    cachedT = null;\n    cachedP = null;\n    cachedPt = null;\n\n    // transform matrix\n    transform();\n\n    // compute eigenvalues of T\n    int n = matrixT.length;\n    realEigenvalues = new double[n];\n    imagEigenvalues = new double[n];\n\n    double r = 0.0;\n    double s = 0.0;\n    double z = 0.0;\n\n    for (int idx = n - 1; idx >= 0; idx--) {\n        double p = matrixT[idx][idx];\n        double q = matrixT[idx][idx + 1];\n\n        if (FastMath.abs(q) < Precision.EPSILON) {\n            realEigenvalues[idx] = p;\n            imagEigenvalues[idx] = 0.0;\n        } else {\n            double t = FastMath.sqrt(FastMath.pow(p, 2) + FastMath.pow(q, 2));\n            double c = p / t;\n            double s = q / t;\n            z = c / s;\n\n            for (int j = idx - 1; j >= 0; j--) {\n                p = matrixT[j][idx];\n                q = matrixT[j][idx + 1];\n                matrixT[j][idx] = c * p - s * q;\n                matrixT[j][idx + 1] = c * q + s * p;\n            }\n\n            p = matrixP[idx][idx];\n            q = matrixP[idx][idx + 1];\n            matrixP[idx][idx] = c * p - s * q;\n            matrixP[idx][idx + 1] = c * q + s * p;\n        }\n    }\n\n    return new Solver(realEigenvalues.clone(), imagEigenvalues.clone(), eigenvectors.clone());\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws NonSquareMatrixException {\n    if (!matrix.isSquare()) {\n        throw new NonSquareMatrixException(matrix.getRowDimension(),\n            matrix.getColumnDimension());\n    }\n\n    HessenbergTransformer transformer = new HessenbergTransformer(matrix);\n    matrixT = transformer.getH().getData();\n    matrixP = transformer.getP().getData();\n    cachedT = null;\n    cachedP = null;\n    cachedPt = null;\n\n    // transform matrix\n    transform();\n\n    // compute eigenvalues of the tridiagonal form\n    int n = matrixT.length;\n\n    for (int i = 0; i < n - 2; i++) {\n        int il = FastMath.max(i - 1, 0);\n        int iu = FastMath.min(i + 2, n - 1);\n        int idx = findSmallSubDiagonalElement(il, iu);\n\n        double p = 0.0;\n        double q = 0.0;\n        double r = 0.0;\n        double s = 0.0;\n        double t = 0.0;\n        double z = 0.0;\n\n        if (idx == i) {\n           p = matrixT[i][i];\n           q = matrixT[i][i + 1];\n\n           if (FastMath.abs(q) > Precision.EPSILON) {\n              t = FastMath.sqrt(FastMath.pow(q, 2) + FastMath.pow(p, 2));\n              if (FastMath.abs(t) < Precision.EPSILON) {\n                 throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n              }\n              t = 1 / t;\n              s = t * q;\n              z = t * p;\n              matrixT[i][i] = -s;\n              matrixT[i][i + 1] = z;\n              matrixT[i + 1][i] = z;\n              matrixT[i + 1][i + 1] = -s;\n\n              for (int j = i + 2; j < n; j++) {\n                 p = matrixT[j][i];\n                 q = matrixT[j][i + 1];\n}\n}\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to tridiagonal\n    transformToTridiagonal(matrix);\n    \n    // compute the eigenvalues from the tridiagonal form\n    // ...\n    \n    // return the schur transform\n    return new SchurTransformer(matrixT);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    if (!matrix.isSquare()) {\n        throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                             matrix.getColumnDimension());\n    }\n    HessenbergTransformer transformer = new HessenbergTransformer(matrix);\n    double[][] matrixT = transformer.getH().getData();\n    double[][] matrixP = transformer.getP().getData();\n\n    int n = matrixT.length;\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double tmp = matrixT[i][j];\n            matrixT[i][j] = matrixT[j][i];\n            matrixT[j][i] = tmp;\n            tmp = matrixP[i][j];\n            matrixP[i][j] = matrixP[j][i];\n            matrixP[j][i] = tmp;\n        }\n    }\n\n    return new SchurTransformer(MatrixUtils.createRealMatrix(matrixT), MatrixUtils.createRealMatrix(matrixP));\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException{\n    // transform the matrix to tridiagonal\n    transformToTridiagonal(matrix);\n\n    // compute the eigenvalues\n    final int n = matrix.getColumnDimension();\n\n    // determine the initial shift\n    double shift = 0.0;\n    for (int i = 0; i < n; i++) {\n        shift = shift + main[i];\n    }\n\n    // shift the eigenvalues and vectors\n    for (int i = 0; i < n; i++) {\n        realEigenvalues[i] = realEigenvalues[i] - shift;\n        for (int j = 0; j < n; j++) {\n            secondary[j][i] = secondary[j][i] - shift;\n        }\n    }\n\n    // compute the initial QR factorization\n    double[][] matrixT = transformer.getT().getData();\n    QRDecomposition qr = new QRDecomposition(MatrixUtils.createRealMatrix(matrixT));\n\n    // iterate until the eigenvalues are sufficiently close to the diagonal\n    int iteration = 0;\n    while (iteration < MAX_ITERATIONS) {\n        // compute the shift\n        ShiftInfo shiftInfo = new ShiftInfo();\n        computeShift(0, n - 1, iteration, shiftInfo);\n\n        // update the shift and the eigenvalues and vectors\n        shift = shift + shiftInfo.exShift;\n        for (int i = 0; i < n; i++) {\n            realEigenvalues[i] = realEigenvalues[i] - shiftInfo.x;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                matrixT[i][j] = matrixT[i][j] - shiftInfo.y * secondary[j][i];\n            }\n        }\n\n        // update the QR factorization\n        qr = new QRDecomposition(MatrixUtils.createRealMatrix(matrixT));\n\n        // check for convergence\n        if (FastMath.abs(shiftInfo.exShift) < epsilon &&\n            qr.getR().getColumnDimension() == 1) {\n            break;\n        }\n\n        iteration++;\n    }\n\n    // check for convergence\n    if (iteration == MAX_ITERATIONS) {\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    if (!matrix.isSquare()) {\n        throw new NonSquareMatrixException(matrix.getRowDimension(),\n            matrix.getColumnDimension());\n    }\n\n    HessenbergTransformer transformer = new HessenbergTransformer(matrix);\n    double[][] matrixT = transformer.getH().getData();\n    double[][] matrixP = transformer.getP().getData();\n\n    // Transform matrix and find the eigenvalues\n    int maxIterations = MAX_ITERATIONS;\n    for (int iteration = 0; iteration < maxIterations; ++iteration) {\n        int l = findSmallSubDiagonalElement(0, matrixT.length, 1e-12);\n        if (l == matrixT.length) {\n            break;\n        }\n\n        int iu = matrixT.length - 1;\n        int il = l + 1;\n        while (iu >= il) {\n            int idx = il;\n            double p = matrixT[idx][idx - 1];\n            double q = matrixT[idx][idx];\n            ShiftInfo shift = new ShiftInfo();\n            shift.x = p;\n            shift.y = q;\n            shift.w = p / q;\n            shift.exShift = 0.5 * (p * p + q * q) / (p + q);\n\n            int steps = initQRStep(il, iu, shift, matrixT[idx]);\n            for (int j = 0; j < steps; j++) {\n                performDoubleQRStep(il, idx, iu, shift, matrixT[idx]);\n            }\n\n            il = idx + 1;\n        }\n    }\n\n    if (iteration >= maxIterations) {\n        throw new MaxCountExceededException(\"Maximum iterations reached\");\n    }\n\n    return new SchurTransformer(MatrixUtils.createRealMatrix(matrixT),\n        MatrixUtils.createRealMatrix(matrixP));\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                matrix.getColumnDimension());\n        }\n        HessenbergTransformer transformer = new HessenbergTransformer(matrix);\n        double[][] matrixT = transformer.getH().getData();\n        double[][] matrixP = transformer.getP().getData();\n        cachedT = null;\n        cachedP = null;\n        cachedPt = null;\n\n        // transform matrix\n        transform();\n\n        // compute eigenvalues from upper triangular form\n        int n = matrixT.length;\n        realEigenvalues = new double[n];\n        imagEigenvalues = new double[n];\n        for (int i = 0; i < n; i++) {\n            realEigenvalues[i] = matrixT[i][i];\n            imagEigenvalues[i] = 0;\n        }\n\n        // Sort the eigen values (and vectors) in increase order\n        for (int i = 0; i < n; i++) {\n            int k = i;\n            double p = realEigenvalues[i];\n            for (int j = i + 1; j < n; j++) {\n                if (realEigenvalues[j] > p) {\n                    k = j;\n                    p = realEigenvalues[j];\n                }\n            }\n            if (k != i) {\n                realEigenvalues[k] = realEigenvalues[i];\n                realEigenvalues[i] = p;\n                for (int j = 0; j < n; j++) {\n                    p = matrixT[j][i];\n                    matrixT[j][i] = matrixT[j][k];\n                    matrixT[j][k] = p;\n                }\n                p = matrixP[i][0];\n                matrixP[i][0] = matrixP[k][0];\n                matrixP[k][0] = p;\n            }\n        }\n\n        // Determine the largest eigen value in absolute term.\n        maxAbsoluteValue = 0;\n        for (int i = 0; i < n; i++) {\n            if (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    // transform the matrix to tridiagonal\n    SchurTransformer t = new SchurTransformer(matrix);\n    RealMatrix T = t.getT();\n    RealMatrix P = t.getP();\n    double[][] Tdata = T.getData();\n    int n = Tdata.length;\n    // compute matrix norm\n    double norm = 0.0;\n    for (int i = 0; i < n; i++) {\n        for (int j = FastMath.max(i - 1, 0); j < n; j++) {\n            norm = norm + FastMath.abs(Tdata[i][j]);\n        }\n    }\n\n    // we can not handle a matrix with zero norm\n    if (Precision.equals(norm, 0.0, EPSILON)) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    realEigenvalues = new double[n];\n    imagEigenvalues = new double[n];\n    for (int i = 0; i < n; i++) {\n        realEigenvalues[i] = Tdata[i][i];\n        imagEigenvalues[i] = 0.0;\n    }\n    return t;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to tridiagonal\n    transformToTridiagonal(matrix);\n\n    // initialize the eigenvalues with the diagonal elements of the tridiagonal matrix\n    realEigenvalues = new double[main.length];\n    imagEigenvalues = new double[main.length];\n    for (int i = 0; i < main.length; i++) {\n        realEigenvalues[i] = main[i];\n    }\n\n    // init qr step\n    int il = 0;\n    int iu = main.length - 1;\n\n    // init shift\n    final ShiftInfo shift = new ShiftInfo();\n    shift.x = 0;\n    shift.y = 0;\n    shift.w = 0;\n    shift.exShift = 0;\n\n    while (il < iu) {\n        int im;\n        if (iu - il > 4) {\n            im = iu - 4;\n        } else {\n            im = iu;\n        }\n\n        int iteration = initQRStep(il, im, shift, null);\n        do {\n            iteration++;\n            double p = realEigenvalues[im];\n            double q = imagEigenvalues[im];\n\n            computeShift(im, im, iteration, shift);\n\n            double r = shift.w;\n            double s = shift.x;\n            double t = shift.y;\n            double z = shift.exShift;\n\n            final double[] work = new double[3 * matrix.getColumnDimension()];\n\n            for (int j = im; j <= iu; j++) {\n                double[] vJ = transformer.getT().getDataRef()[j];\n                work[j - im] = vJ[il];\n                work[j - im + matrix.getColumnDimension()] = vJ[im];\n                work[j - im + 2 * matrix.getColumnDimension()] = vJ[im + 1];\n            }\n\n            final RealVector v = new ArrayRealVector(work);\n\n            v.operate(new ScaleVector(r));\n            v.operate(new AddVector(s, im - il));\n            v.operate(new AddVector(t, im + 1 - il));\n\n            for (int j = im; j <= iu; j++) {\n}\n}\n}\n}"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final long value : values)\n    {\n        Validate.isTrue(value >= 0, CANNOT_STORE_S_S_VALUES_IN_S_BITS, value);\n        for (E constant : enumClass.getEnumConstants())\n        {\n            if ((value & (1 << constant.ordinal())) != 0)\n            {\n                condensed.add(constant);\n            }\n        }\n    }\n    return condensed;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final long value : values) {\n        result.addAll(EnumUtils.<E>processBitVector(enumClass, value));\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        EnumSet<E> bits = processBitVector(enumClass, value);\n        result.addAll(bits);\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final long value : values) {\n        EnumSet<E> bitVector = processBitVector(enumClass, value);\n        for (E constant : bitVector) {\n            condensed.add(constant);\n        }\n    }\n    return condensed;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final long value : values) {\n        for (int i = 0; i < Long.SIZE; i++) {\n            if ((value & (1L << i)) != 0L) {\n                condensed.add(enumClass.getEnumConstants()[i]);\n            }\n        }\n    }\n    return condensed;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final long value : values) {\n        result.addAll(processBitVector(enumClass, value));\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final long value : values) {\n        result.addAll(EnumUtils.processBitVector(enumClass, value));\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final long value : values) \n    {\n        result.addAll(processBitVector(enumClass, value));\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long bitVector : values) {\n        for (int i = 0; i < Long.SIZE; ++i) {\n            if ((bitVector & (1L << i)) != 0) {\n                result.add(enumClass.getEnumConstants()[i]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final long value : values) {\n        for (int i = 0; i < Long.SIZE; i++) {\n            if ((value & (1L << i)) != 0L) {\n                condensed.add(enumClass.getEnumConstants()[i]);\n            }\n        }\n    }\n    return condensed;\n}"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    int offsetFromUTC = getOffset(oldInstant);\n    long localInstant = oldInstant - offsetFromUTC;\n    DateTimeZone newZone2 = (newZone == null) ? getDefault() : newZone;\n    int offsetToUTC = newZone2.getOffset(localInstant);\n    if (offsetFromUTC == offsetToUTC)\n    {\n        return oldInstant;\n    }\n    return newZone2.convertUTCToLocal(localInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n  if (newZone == null) {\n      newZone = DateTimeZone.getDefault();\n  }\n  long localMillis = convertUTCToLocal(oldInstant);\n  return newZone.convertLocalToUTC(localMillis);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n  if (newZone == null) {\n    newZone = DateTimeZone.getDefault();\n  }\n  long localMillis = convertUTCToLocal(oldInstant);\n  return newZone.convertLocalToUTC(localMillis);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    int millisOffset = getOffset(oldInstant);\n    long localInstant = oldInstant - millisOffset;\n    DateTimeZone tz = newZone == null ? getDefault() : newZone;\n    int millisOffsetNew = tz.getOffset(localInstant);\n    return localInstant + millisOffsetNew;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localMillis = convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(localMillis);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n  if (newZone == null) \n  {\n    newZone = getDefault();\n  }\n\n  long localMillis = convertUTCToLocal(oldInstant);\n  long newZoneMillis = newZone.convertLocalToUTC(localMillis);\n  return newZoneMillis;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    DateTimeZone oldZone = this;\n    long localInstant = oldZone.convertUTCToLocal(oldInstant);\n    if (newZone == null) {\n        newZone = getDefault();\n    }\n    return newZone.convertLocalToUTC(localInstant, false);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n  if (newZone == null) {\n    newZone = DateTimeZone.getDefault();\n  }\n  if (newZone == this) {\n    return oldInstant;\n  }\n  long instantLocal = convertUTCToLocal(oldInstant, false);\n  return newZone.convertLocalToUTC(instantLocal, false);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n  if (newZone == null) {\n      newZone = DateTimeZone.getDefault();\n  }\n  long oldMillis = oldInstant;\n  long oldOffset = getOffset(oldMillis);\n  long localMillis = oldMillis - oldOffset;\n  int newOffset = newZone.getOffset(localMillis);\n  return oldMillis + newOffset - oldOffset;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n  if (newZone == null) {\n      newZone = getDefault();\n  }\n  if (newZone == this) {\n      return oldInstant;\n  }\n  long localMillis = convertUTCToLocal(oldInstant);\n  return newZone.convertLocalToUTC(localMillis, true);\n}"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current / count) + 1);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current / count) + 1);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count - 1) / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count - 1) / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current / count) + 1);\n    if (unit.getRollUnitType() != null) {\n        calendar.set(unit.getRollUnitType().getCalendarField(),\n                unit.getRollMultiple());\n    }\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    if (unit.getRollUnitType() != DateTickUnitType.NONE) \n    {\n        return unit.rollDate(date);\n    }\n    else \n    {\n        return previousStandardDate(date, unit);\n    }\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n        int milliseconds;\n        int seconds;\n        int minutes;\n        int hours;\n        int days;\n        int months;\n        int years;\n\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int count = unit.getMultiple();\n        int current = calendar.get(unit.getCalendarField());\n        int value = count * ((current + count - 1) / count);\n        calendar.set(unit.getCalendarField(), value);\n        return calendar.getTime();\n    }",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current / count) + 1);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    if (unit.equals(DateTickUnitType.YEAR)) {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int current = calendar.get(Calendar.YEAR);\n        calendar.set(Calendar.YEAR, current + unit.getMultiple());\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MONTH)) {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int current = calendar.get(Calendar.MONTH);\n        calendar.set(Calendar.MONTH, current + unit.getMultiple());\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.DAY)) {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int current = calendar.get(Calendar.DAY_OF_MONTH);\n        calendar.set(Calendar.DAY_OF_MONTH, current + unit.getMultiple());\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.HOUR)) {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int current = calendar.get(Calendar.HOUR_OF_DAY);\n        calendar.set(Calendar.HOUR_OF_DAY, current + unit.getMultiple());\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int current = calendar.get(Calendar.MINUTE);\n        calendar.set(Calendar.MINUTE, current + unit.getMultiple());\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.SECOND)) {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        int current = calendar.get(Calendar.SECOND);\n        calendar.set(Calendar.SECOND, current + unit.getMultiple());\n        return calendar.getTime();\n    }\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current / count) + 1);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableName.length() == 0) {\n        throw new IllegalArgumentException(\"Variable name cannot be empty\");\n    }\n    if (variableResolver == null) {\n        return null;\n    }\n    Object value = variableResolver.resolve(variableName);\n    if (value == null) {\n        return null;\n    }\n    if (value instanceof String) {\n        return (String) value;\n    }\n    return value.toString();\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableName.startsWith(variablePrefix.toString())) {\n        variableName = variableName.substring(variablePrefix.toString().length());\n    }\n    if (variableName.endsWith(variableSuffix.toString())) {\n        variableName = variableName.substring(0, variableName.length() - variableSuffix.toString().length());\n    }\n    StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    Object value = resolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    if (value instanceof String) {\n        return (String) value;\n    }\n    if (value instanceof Boolean) {\n        return (value) ? \"true\" : \"false\";\n    }\n    if (value instanceof Character) {\n        return String.valueOf((Character) value);\n    }\n    if (value instanceof Number) {\n        return String.valueOf(value);\n    }\n    if (value instanceof Object[]) {\n        return StrSubstitutor.arrayToString((Object[]) value);\n    }\n    if (value instanceof Iterable<?>) {\n        return StrSubstitutor.listToString((Iterable<?>) value);\n    }\n    if (value instanceof Map<?, ?>) {\n        return StrSubstitutor.mapToString((Map<?, ?>) value);\n    }\n    if (value instanceof Object) {\n        return value.toString();\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver == null) {\n        return null;\n    }\n    final Object value = variableResolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    final String stringValue = value.toString();\n    return stringValue.substring(0, Math.min(stringValue.length(), endPos - startPos));\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableName.length() == 0) {\n        return \"\";\n    }\n\n    // first check if the variable is already in the buffer\n    final int pos = buf.indexOf(variableName, endPos - variableName.length(), endPos);\n    if (pos >= 0 && pos + variableName.length() == endPos) {\n        return \"\";\n    }\n\n    // check if the variable resolver can be used\n    if (getVariableResolver() != null) {\n        Object value = getVariableResolver().lookup(variableName);\n        if (value != null) {\n            if (value instanceof String) {\n                return (String) value;\n            } else {\n                return String.valueOf(value);\n            }\n        }\n    }\n\n    // handle variable names starting with '$'\n    if (variableName.charAt(0) == '$' && (getEscapeChar() == 0 || variableName.charAt(0) != getEscapeChar())) {\n        return variableName;\n    }\n\n    // variable not found, return empty string\n    return \"\";\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableName == null) {\n        return null;\n    }\n    final StrLookup<?> lookup = getVariableResolver();\n    if (lookup == null) {\n        return null;\n    }\n    final Object value = lookup.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    if (value instanceof String) {\n        final String strValue = (String) value;\n        final int len = strValue.length();\n        if (len == 0) {\n            return null;\n        }\n        final char[] charValue = new char[len];\n        strValue.getChars(0, len, charValue, 0);\n        return new String(charValue);\n    }\n    if (value instanceof char[]) {\n        final char[] charValue = (char[]) value;\n        final int len = charValue.length;\n        if (len == 0) {\n            return null;\n        }\n        final char[] result = new char[len];\n        System.arraycopy(charValue, 0, result, 0, len);\n        return new String(result);\n    }\n    return value.toString();\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver == null) {\n        return null;\n    }\n    final Object value = variableResolver.resolve(variableName);\n    return value != null ? value.toString() : null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver == null) {\n        return null;\n    }\n    final String value = variableResolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    final int length = value.length();\n    if (length > 0) {\n        buf.insert(startPos, value, 0, length);\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableName == null || buf == null) {\n        return null;\n    }\n\n    // if this point is reached, it means we're sure the variable has a value\n    // (i.e., it wasn't found as a prefix or suffix)\n    return getVariableResolver().lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver == null) {\n        return null;\n    }\n    final Object value = variableResolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    final String strValue = value.toString();\n    if (strValue == null || strValue.length() == 0) {\n        return null;\n    }\n    final int len = endPos - startPos + 1;\n    if (buf.size() > len) {\n        buf.delete(len, buf.size());\n    }\n    buf.replace(startPos, len, strValue);\n    return strValue;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableName.startsWith(DEFAULT_PREFIX.toString()) == false) {\n        return null;\n    }\n    final String var = variableName.substring(DEFAULT_PREFIX.toString().length(), endPos);\n    final List<String> priorVariables = new ArrayList<String>();\n    return resolveVariable(var, buf, startPos, endPos, priorVariables);\n}"
    ],
    [
      "public String soundex(String str)  {\n    final StringBuilder result = new StringBuilder();\n\n    // Convert to uppercase\n    str = str.toUpperCase();\n\n    // Encode the first character\n    char firstChar = str.charAt(0);\n    result.append(firstChar);\n\n    // Encode the remaining characters\n    for (int i = 1; i < str.length(); i++) {\n        char currentChar = str.charAt(i);\n        char previousChar = str.charAt(i - 1);\n\n        // Ignore vowels and 'H'\n        if (\"AEIOUHW\".indexOf(currentChar) >= 0) {\n            continue;\n        }\n\n        // Map the character to its Soundex code\n        char code = map(currentChar);\n\n        // Handle duplicates\n        if (code == previousChar) {\n            continue;\n        }\n\n        // Append the code to the result\n        result.append(code);\n\n        // Limit the result to the maximum length\n        if (result.length() >= 4) {\n            break;\n        }\n    }\n\n    // Pad with zeros if necessary\n    while (result.length() < 4) {\n        result.append('0');\n    }\n\n    return result.toString();\n}",
      "public String soundex(String str)  {\n    String result = \"\";\n    if (str == null) {\n        return result;\n    }\n    str = str.toUpperCase();\n    char previousCode = '0';\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (i == 0) {\n            result += ch;\n        } else {\n            char code = map(ch);\n            if (code != previousCode) {\n                result += code;\n            }\n            previousCode = code;\n        }\n    }\n    return result;\n}",
      "public String soundex(String str)  {\n    String uppercased = str.toUpperCase();\n    StringBuilder result = new StringBuilder();\n\n    result.append(uppercased.charAt(0));\n\n    for (int i = 1; i < uppercased.length(); i++)\n    {\n        char currentLetter = uppercased.charAt(i);\n        char previousLetter = uppercased.charAt(i - 1);\n\n        switch (currentLetter)\n        {\n            case 'A':\n            case 'E':\n            case 'I':\n            case 'O':\n            case 'U':\n            case 'Y':\n                break;\n            case 'B':\n            case 'F':\n            case 'P':\n            case 'V':\n                result.append(currentLetter);\n                break;\n            case 'C':\n            case 'G':\n            case 'J':\n            case 'K':\n            case 'Q':\n            case 'S':\n            case 'X':\n            case 'Z':\n                if (previousLetter != 'C' && previousLetter != 'S')\n                {\n                    result.append(currentLetter);\n                }\n                break;\n            case 'D':\n            case 'T':\n                if (previousLetter != 'D' && previousLetter != 'T')\n                {\n                    result.append(currentLetter);\n                }\n                break;\n            case 'H':\n                if (previousLetter != 'H')\n                {\n                    result.append(currentLetter);\n                }\n                break;\n            case 'L':\n                if (previousLetter != 'L')\n                {\n                    result.append(currentLetter);\n                }\n                break;\n            case 'M':\n            case 'N':\n                if (previousLetter != 'M' && previousLetter != 'N')\n                {\n                    result.append(currentLetter);\n                }\n                break;\n            case 'R':\n                if (previousLetter != 'R')\n                {\n                    result.append(currentLetter);\n                }\n                break;\n            case 'W':\n            case 'Y':\n                if (previousLetter != 'W' && previousLetter != 'Y')\n                {\n                    result.append(currentLetter);\n                }\n                break;\n            default:\n}\n}\n}",
      "public String soundex(String str)  {\n    str = str.toUpperCase();\n    final StringBuilder result = new StringBuilder(4);\n    result.append(str.charAt(0));\n\n    for (int i = 1; i < str.length(); i++) \n    {\n        char current = str.charAt(i);\n        char previous = str.charAt(i - 1);\n\n        if (!Character.isAlphabetic(current)) \n        {\n            continue;\n        }\n\n        current = Character.toUpperCase(current);\n        final int mapping = current - 'A';\n\n        if (mapping < 0 || mapping >= US_ENGLISH_MAPPING.length) \n        {\n            continue;\n        }\n\n        final char mapped = US_ENGLISH_MAPPING[mapping];\n\n        if (mapped == '0') \n        {\n            continue;\n        }\n\n        if (previous == mapped) \n        {\n            continue;\n        }\n\n        result.append(mapped);\n    }\n\n    if (result.length() > 4) \n    {\n        result.deleteCharAt(4);\n    }\n\n    return result.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase();\n    StringBuilder sb = new StringBuilder();\n    sb.append(str.charAt(0));\n    for (int index = 1; index < str.length(); index++) {\n        char ch = str.charAt(index);\n        if (US_ENGLISH_MAPPING[ch - 'A'] != US_ENGLISH_MAPPING[str.charAt(index - 1) - 'A']) {\n            sb.append(US_ENGLISH_MAPPING[ch - 'A']);\n        }\n    }\n    if (sb.length() > 4) {\n        sb.deleteCharAt(4);\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null || str.isEmpty()) {\n        return \"\";\n    }\n\n    // Convert to upper case and initialize soundex code.\n    str = str.toUpperCase();\n    char[] soundex = new char[4];\n\n    // Get the first character and map it.\n    soundex[0] = map(str.charAt(0));\n\n    // Iterate through remaining characters.\n    int index = 1;\n    for (int i = 1; i < str.length(); i++) {\n        char ch = str.charAt(i);\n\n        // Map the character and handle special cases.\n        char code = map(ch);\n        switch (code) {\n            case 'A':\n            case 'E':\n            case 'I':\n            case 'O':\n            case 'U':\n                break;\n            case 'B':\n            case 'F':\n            case 'P':\n            case 'V':\n                soundex[index++] = '1';\n                break;\n            case 'C':\n            case 'G':\n            case 'J':\n            case 'K':\n            case 'Q':\n            case 'S':\n            case 'X':\n            case 'Z':\n                soundex[index++] = '2';\n                break;\n            case 'D':\n            case 'T':\n                soundex[index++] = '3';\n                break;\n            case 'H':\n                break;\n            case 'L':\n                soundex[index++] = '4';\n                break;\n            case 'M':\n            case 'N':\n                soundex[index++] = '5';\n                break;\n            case 'R':\n                soundex[index++] = '6';\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unsupported character: \" + ch);\n        }\n    }\n\n    // Pad with '9' if necessary.\n    while (index < 4) {\n        soundex[index++] = '9';\n    }\n\n    return new String(soundex);\n}",
      "public String soundex(String str)  {\n    if (str == null || str.isEmpty()) {\n        return null;\n    }\n    StringBuilder builder = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        builder.append(map(ch));\n    }\n    return builder.toString();\n}",
      "public String soundex(String str)  {\n    str = str.toUpperCase();\n    final StringBuilder soundex = new StringBuilder();\n    soundex.append(str.charAt(0));\n    char lastCode = str.charAt(0);\n\n    for (int i = 1; i < str.length(); i++) \n    {\n        char ch = str.charAt(i);\n        char code = map(ch);\n\n        if (code != lastCode) \n        {\n            soundex.append(code);\n            lastCode = code;\n        }\n    }\n\n    soundex.delete(4, soundex.length());\n    soundex.append('0');\n\n    for (int i = soundex.length(); i < 4; i++) \n    {\n        soundex.append('0');\n    }\n\n    return soundex.toString();\n}",
      "public String soundex(String str)  {\n    str = str.toUpperCase();\n    final StringBuilder result = new StringBuilder(str.length());\n    result.append(str.charAt(0));\n    for (int i = 1; i < str.length(); i++) \n    {\n        char ch = str.charAt(i);\n        switch (ch) \n        {\n            case 'A', 'E', 'I', 'O', 'U', 'Y', 'H', 'W', 'N', 'M', 'R':\n                break;\n            case 'B', 'F', 'P', 'V':\n                ch = '1';\n                break;\n            case 'C', 'G', 'J', 'K', 'Q', 'S', 'X', 'Z':\n                ch = '2';\n                break;\n            case 'D', 'T':\n                ch = '3';\n                break;\n            case 'L':\n                ch = '4';\n                break;\n            case 'A', 'E', 'I', 'O', 'U', 'Y', 'H', 'W', 'N', 'M', 'R':\n                break;\n            default:\n                ch = '0';\n        }\n        if (ch != result.charAt(result.length() - 1)) \n        {\n            result.append(ch);\n        }\n    }\n    if (result.length() > 4) \n    {\n        result.deleteCharAt(4);\n    }\n    return result.toString();\n}",
      "public String soundex(String str)  {\n    String result = \"\";\n    if (str != null) {\n        str = str.toUpperCase();\n        result = \"\" + map(str.charAt(0));\n        for (int index = 1; index < str.length(); index++) {\n            char ch = str.charAt(index);\n            char lastCode = result.charAt(result.length() - 1);\n            char code = map(ch);\n            if (code != lastCode) {\n                result += code;\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    } else if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    } else if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    } else if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    } else if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    } else if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    } else if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    } else if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    } else if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    } else if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    } else if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    } else if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    } else if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    } else if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    } else if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    Node first = n.getFirstChild();\n    if (first == null) {\n        return null;\n    }\n    Node left = first.getFirstChild();\n    if (left == null || !left.isName()) {\n        return null;\n    }\n    return new PrototypeMemberDeclaration(left, n);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isAssign()) {\n    Node left = n.getFirstChild();\n    Node right = left.getNext();\n    if (left.isQualifiedName() && right.isVariableInitializer()) {\n      Node lhs = left;\n      Node rhs = right.getFirstChild();\n      if (rhs.isName()) {\n        return new PrototypeMemberDeclaration(lhs, n);\n      }\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isVariableDeclaration()) \n  {\n    Node lhs = n.getFirstChild();\n    Node right = lhs.getNext();\n    if (right != null && !right.isAssign()) \n    {\n      return new PrototypeMemberDeclaration(lhs, n);\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.getType() == Node.ASSIGN) {\n    Node left = n.getFirstChild();\n    if (left.getType() == Node.NAME &&\n        left.getProp(Node.ORIGINALNAME_PROP) == null) {\n      left = left.getFirstChild();\n    }\n    if (left.getType() == Node.MEMBER &&\n        left.getFirstChild().getType() == Node.NAME) {\n      return new PrototypeMemberDeclaration(left, n);\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (!n.isExpressionStatement()) {\n    return null;\n  }\n  Node expr = n.getFirstChild();\n  if (!expr.isAssignment()) {\n    return null;\n  }\n  if (!expr.getLastChild().isVariableInitializer()) {\n    return null;\n  }\n  Node lhs = expr.getFirstChild().getFirstChild();\n  if (!lhs.isMemberExpression()) {\n    return null;\n  }\n  if (!NodeUtil.isPrototypeMember(lhs)) {\n    return null;\n  }\n  return new PrototypeMemberDeclaration(lhs, expr);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign()) {\n        Node left = n.getFirstChild().getFirstChild();\n        Node right = n.getFirstChild().getNext();\n        if (right.isQualifiedName()) {\n            return new PrototypeMemberDeclaration(left, n);\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (!n.isVariableInitializer()) {\n      return null;\n    }\n\n    Node lhs = n.getFirstChild();\n    if (lhs.getProp(Node.IS_DISPATCHER)) {\n      return null;\n    }\n\n    Node rhs = lhs.getNext();\n    if (rhs.isAssignment()) {\n      rhs = rhs.getLastChild();\n    } else if (rhs.isComma()) {\n      rhs = rhs.getFirstChild();\n    }\n\n    if (rhs.isQualifiedName()) {\n      return new PrototypeMemberDeclaration(lhs, n);\n    }\n\n    return null;\n  }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (!n.isAssign()) {\n      return null;\n    }\n\n    Node lhs = n.getFirstChild();\n    if (!lhs.isName()) {\n      return null;\n    }\n\n    Node rhs = n.getLastChild();\n    if (rhs.isCall()) {\n      Node callee = rhs.getFirstChild();\n      if (callee.isQualifiedName()) {\n        String qualifiedName = callee.getString();\n        if (qualifiedName.startsWith(\"Object.defineProperty\") ||\n            qualifiedName.startsWith(\"Object.defineProperties\")) {\n          return null;\n        }\n      }\n    }\n\n    return new PrototypeMemberDeclaration(lhs, n);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (!n.isAssign()) {\n    return null;\n  }\n  Node left = n.getFirstChild();\n  if (!left.isQualifiedName()) {\n    return null;\n  }\n  Node right = n.getLastChild();\n  Node lhs = left.getFirstChild().getFirstChild();\n  return new PrototypeMemberDeclaration(lhs, n);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (!n.isVariable()) {\n    return null;\n  }\n\n  Node lhs = n.getFirstChild();\n  if (lhs == null || !lhs.isQualifiedName()) {\n    return null;\n  }\n\n  String memberName = NodeUtil.getPrototypePropertyName(lhs);\n  if (memberName == null) {\n    return null;\n  }\n  return new PrototypeMemberDeclaration(lhs, n);\n}"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rows = mat.getRowDimension();\n    final int cols = mat.getColumnDimension();\n    final double[][] data = new double[n*rows][m*cols];\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            for (int r = 0; r < rows; r++) \n            {\n                for (int c = 0; c < cols; c++) \n                {\n                    data[i*rows+r][j*cols+c] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix result = zeros(mat.getRowDimension() * n, mat.getColumnDimension() * m);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            copyColumn(mat, 0, result, i * mat.getRowDimension() + j * mat.getColumnDimension());\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rowDimension = mat.getRowDimension();\n    final int columnDimension = mat.getColumnDimension();\n    final double[][] data = new double[rowDimension * n][columnDimension * m];\n\n    for (int r = 0; r < rowDimension; r++) {\n        for (int c = 0; c < columnDimension; c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    data[r + i * rowDimension][c + j * columnDimension] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n\n    return new Array2DRowRealMatrix(data, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix result = zeros(n * mat.getRowDimension(), m * mat.getColumnDimension());\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            copyColumn(mat, 0, result, j * mat.getColumnDimension() + i * mat.getRowDimension());\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix result = zeros(n * mat.getRowDimension(), m * mat.getColumnDimension());\n    for(int r = 0; r < n; r++)\n        for(int c = 0; c < m; c++)\n            copyColumn(mat, 0, result, r * mat.getRowDimension() + c * mat.getColumnDimension());\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int rr = 0; rr < n; rr++) {\n                for (int cc = 0; cc < m; cc++) {\n                    d[r + rr * mat.getRowDimension()][c + cc * mat.getColumnDimension()] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    if (mat.getColumnDimension() == mat.getRowDimension()) {\n        final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n        for (int r = 0; r < n; r++) {\n            for (int c = 0; c < m; c++) {\n                for (int i = 0; i < mat.getRowDimension(); i++) {\n                    System.arraycopy(mat.getRow(i), 0, d[i + r * mat.getRowDimension()], c * mat.getColumnDimension(), mat.getColumnDimension());\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        throw new RuntimeException(\"repmat can only be used for square matrices\");\n    }\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    RealMatrix result = zeros(n * mat.getRowDimension(), m * mat.getColumnDimension());\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            copyColumn(mat, 0, result, j * mat.getColumnDimension() + i * mat.getRowDimension());\n        }\n    }\n    return result;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    if (n <= 0 || m <= 0) \n    {\n        throw new IllegalArgumentException(\"n and m must be greater than or equal to 0.\");\n    }\n\n    final double[][] result = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            System.arraycopy(mat.getData()[i], 0, result[i * mat.getRowDimension() + j], 0, mat.getColumnDimension());\n        }\n    }\n\n    return new Array2DRowRealMatrix(result, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < n; r++) {\n        for (int c = 0; c < m; c++) {\n            for (int rr = 0; rr < mat.getRowDimension(); rr++) {\n                for (int cc = 0; cc < mat.getColumnDimension(); cc++) {\n                    d[r * mat.getRowDimension() + rr][c * mat.getColumnDimension() + cc] = mat.getEntry(rr, cc);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) > 0) \n        {\n            return candidate;\n        }\n        else\n        {\n            candidate = node;\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; node = node.left) {\n        if (node.element.compareTo(reference) <= 0) {\n            candidate = node;\n        } else {\n            return candidate;\n        }\n    }\n    return candidate;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n        else\n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; node = node.left) {\n        if (node.element.compareTo(reference) > 0) {\n            if (candidate == null) {\n                candidate = node;\n            } else {\n                candidate = candidate.getNotLarger(reference);\n            }\n        }\n    }\n    return candidate;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; node = node.right) {\n        if (node.element.compareTo(reference) <= 0) {\n            candidate = node;\n        } else {\n            return candidate;\n        }\n    }\n    return candidate;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;)\n    {\n        if (node.element.compareTo(reference) <= 0)\n        {\n            candidate = node;\n            if (node.right == null)\n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n        else\n        {\n            if (node.left == null)\n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) <= 0) {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) > 0) \n        {\n            return candidate;\n        }\n        else\n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;)\n    {\n        if (node.element.compareTo(reference) <= 0)\n        {\n            candidate = node;\n            if (node.right == null)\n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n        else\n        {\n            if (node.left == null)\n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    return current.bytesReadFromStream + getBytesInflatedHelper();\n}",
      "private long getBytesInflated()  {\n    if (closed) \n    {\n        throw new IOException(\"The stream is closed\");\n    }\n    final int length = in.read(buf.array());\n    if (length > 0) \n    {\n        buf.limit(length);\n        count(buf.limit());\n        inf.setInput(buf.array(), 0, buf.limit());\n    }\n    return bytesRead - current.bytesReadFromStream;\n}",
      "private long getBytesInflated()  {\n    if (current.bytesReadFromStream >= current.bytesRead) \n    {\n        current.bytesRead = current.bytesReadFromStream = 0;\n    } \n    else \n    {\n        current.bytesRead = current.bytesReadFromStream;\n    }\n    return current.bytesRead;\n}",
      "private long getBytesInflated()  throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        final long length = in.read(buf.array());\n        if (length > 0) {\n            buf.limit(length);\n            count(buf.limit());\n            inf.setInput(buf.array(), 0, buf.limit());\n        }\n        return entrySize - entryOffset;\n    }",
      "private long getBytesInflated()  throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (current.bytesReadFromStream >= current.bytesRead) {\n        final int length = in.read(buf.array());\n        if (length > 0) {\n            buf.limit(length);\n            count(buf.limit());\n            inf.setInput(buf.array(), 0, buf.limit());\n        }\n        current.bytesReadFromStream = current.bytesRead;\n    }\n    return current.bytesReadFromStream;\n}",
      "private long getBytesInflated()  throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    long bytesReadFromStream = current.bytesReadFromStream;\n    long bytesReadForEntry = current.entry.getCompressedSize();\n    long bytesInflated = bytesReadForEntry - bytesReadFromStream;\n    if (bytesInflated > Integer.MAX_VALUE) {\n        bytesInflated = Integer.MAX_VALUE;\n    }\n    if (bytesInflated < 0) {\n        bytesInflated = 0L;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    if (bytesInflated > TWO_EXP_32 - current.bytesReadFromStream) \n    {\n        bytesInflated = TWO_EXP_32 - current.bytesReadFromStream;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    if (current.bytesReadFromStream >= current.bytesRead)\n    {\n        current.bytesRead = current.bytesReadFromStream;\n    }\n    return current.bytesReadFromStream - current.bytesRead;\n}",
      "private long getBytesInflated()  {\n    if (current.bytesRead >= current.bytesReadFromStream)\n    {\n        return current.bytesRead - current.bytesReadFromStream;\n    }\n    else\n    {\n        // Java 7 and later.\n        final long bytesConsumed = current.bytesRead - current.bytesReadFromStream;\n        if (bytesConsumed >= TWO_EXP_32)\n        {\n            return bytesConsumed;\n        }\n        else\n        {\n            return TWO_EXP_32 - current.bytesReadFromStream;\n        }\n    }\n}",
      "private long getBytesInflated()  {\n    if (bytesInflated != 0L) {\n        return bytesInflated;\n    }\n\n    long remaining = current.entry.getCompressedSize() - current.bytesReadFromStream;\n    while (remaining > 0) {\n        final long n = in.read(buf.array(), 0, (int) Math.min(buf.capacity(), remaining));\n        if (n < 0) {\n            throw new EOFException(\"Truncated ZIP entry: \"\n                                   + ArchiveUtils.sanitize(current.entry.getName()));\n        }\n        remaining -= n;\n    }\n\n    bytesInflated = current.bytesReadFromStream;\n    return bytesInflated;\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else if (object instanceof NodeList) {\n        return ((NodeList) object).getLength() == 0;\n    } else if (object instanceof Node) {\n        return ((Node) object).getChildNodes().getLength() == 0;\n    } else if (object instanceof Dictionary) {\n        return ((Dictionary<?, ?>) object).size() == 0;\n    } else if (object.getClass().isArray()) {\n        return Array.getLength(object) == 0;\n    } else {\n        return false;\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    if (object.getClass().isArray()) \n    {\n        return Array.getLength(object) == 0;\n    }\n    return false;\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Map)\n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Collection)\n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Object[])\n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator)\n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration)\n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null)\n    {\n        return true;\n    }\n    if (object instanceof Collection)\n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map)\n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object.getClass().isArray())\n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator)\n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration)\n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection)\n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    if (object instanceof NodeList) \n    {\n        return ((NodeList) object).getLength() == 0;\n    }\n    if (object instanceof Node) \n    {\n        return ((Node) object).getChildNodes().getLength() == 0;\n    }\n    if (object instanceof Dictionary) \n    {\n        return ((Dictionary<?, ?>) object).size() == 0;\n    }\n    if (object.getClass().isArray()) \n    {\n        return Array.getLength(object) == 0;\n    }\n    return false;\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    return CollectionUtils.isEmpty(object);\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    return isEmpty(object);\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    return object == null || size(object) == 0;\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null)\n    {\n        return true;\n    }\n    if (object instanceof Collection)\n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map)\n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[])\n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator)\n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration)\n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    if (object.getClass().isArray())\n    {\n        return Array.getLength(object) == 0;\n    }\n    if (object instanceof NodeList)\n    {\n        return ((NodeList) object).getLength() == 0;\n    }\n    if (object instanceof Node)\n    {\n        return ((Node) object).getChildNodes().getLength() == 0;\n    }\n    if (object instanceof Dictionary)\n    {\n        return ((Dictionary<?, ?>) object).size() == 0;\n    }\n    if (object instanceof CompositeMap)\n    {\n        return ((CompositeMap<?, ?>) object).size() == 0;\n    }\n\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n  return TokenStream.isQualifiedName(name) &&\n      !TokenStream.isKeyword(name) &&\n      isLatin(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return TokenStream.isQualifiedName(name) &&\n      !TokenStream.isKeyword(name) &&\n      isLatin(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return TokenStream.isQualifiedName(name) &&\n      // no Unicode escaped characters - some browsers are less tolerant\n      // of Unicode characters that might be valid according to the\n      // language spec.\n      // Note that by this point, Unicode escapes have been converted\n      // to UTF-16 characters, so we're only searching for character\n      // values, not escapes.\n      isLatin(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return TokenStream.isQualifiedName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n\treturn TokenStream.isJSIdentifier(name) &&\n\t\t!TokenStream.isKeyword(name) &&\n\t\t// no Unicode escaped characters - some browsers are less tolerant\n\t\t// of Unicode characters that might be valid according to the\n\t\t// language spec.\n\t\t// Note that by this point, Unicode escapes have been converted\n\t\t// to UTF-16 characters, so we're only searching for character\n\t\t// values, not escapes.\n\t\tisLatin(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return TokenStream.isQualifiedName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return TokenStream.isQualifiedName(name) &&\n      // no Unicode escaped characters - some browsers are less tolerant\n      // of Unicode characters that might be valid according to the\n      // language spec.\n      // Note that by this point, Unicode escapes have been converted\n      // to UTF-16 characters, so we're only searching for character\n      // values, not escapes.\n      isLatin(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n\treturn TokenStream.isJSIdentifier(name) &&\n\t       !TokenStream.isKeyword(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return TokenStream.isJSIdentifier(name) &&\n        !TokenStream.isKeyword(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, Unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        isLatin(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return TokenStream.isQualifiedName(name);\n}"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\nint im = il;\nif (il > iu - 1) {\n    return iu;\n}\n\ndouble p = matrixT[iu - 1][iu - 1] - matrixT[iu][iu];\ndouble q = p * p + matrixT[iu][iu - 1] * matrixT[iu - 1][iu];\nif (FastMath.abs(p) <= epsilon * FastMath.abs(q) && il < iu - 1) {\n    p = matrixT[iu - 2][iu - 2] - matrixT[iu - 1][iu - 1];\n    q = p * p + matrixT[iu - 1][iu - 2] * matrixT[iu - 2][iu - 1];\n    if (FastMath.abs(p) <= epsilon * FastMath.abs(q)) {\n        im = iu - 2;\n    }\n}\n\n// Initialize shift\ncomputeShift(il, iu, 1, shift);\n\n// Compute the first houseHolder vector\nhVec[0] = 1.0;\nhVec[1] = -matrixT[iu][iu - 1];\nhVec[2] = matrixT[iu - 1][iu - 1] - matrixT[iu][iu];\nhVec[1] = hVec[1] / hVec[2];\nhVec[2] = 1.0 / hVec[2];\n\n// Scale the vector if p <= 0\nif (p < 0.0) {\n    hVec[0] = -hVec[0];\n    hVec[1] = -hVec[1];\n    hVec[2] = -hVec[2];\n}\nreturn im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    hVec[2] = 0.0;\n    final int n = matrixT.length;\n    if (il == iu) {\n        hVec[0] = -matrixT[iu][iu];\n        hVec[1] = 1.0;\n        return iu;\n    } else {\n        hVec[0] = matrixT[iu][iu];\n        hVec[1] = -1.0;\n        hVec[2] = matrixT[iu - 1][iu];\n    }\n\n    // Compute the norm of the submatrix starting at row il\n    double s = 0.0;\n    for (int k = il; k <= iu; k++) {\n        s += matrixT[k][k] * matrixT[k][k];\n        for (int j = il; j < k; j++) {\n            s += 2.0 * matrixT[k][j] * matrixT[k][j];\n        }\n    }\n    if (s == 0.0) {\n        s = norm;\n    } else {\n        s = FastMath.sqrt(s);\n    }\n\n    // Normalize hVec[0] so that |hVec[0]|<1\n    if (FastMath.abs(hVec[0]) < 1.0) {\n        hVec[0] = hVec[0] / s;\n    } else {\n        hVec[0] = hVec[0] / FastMath.abs(hVec[0]);\n        hVec[1] = -hVec[1];\n        hVec[2] = -hVec[2];\n        s = -s;\n    }\n\n    // Adjust other components of hVec to satisfy (hVec.H)*T = I\n    final double p = hVec[0];\n    final double q = hVec[1];\n    final double r = hVec[2];\n    for (int k = il; k <= iu; k++) {\n        hVec[k] = matrixT[k][iu - 1] - p * matrixT[k][iu] - q * matrixT[k][iu - 1];\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\nint im;\n\nif (il == iu) {\n\n    // Initialize for single root case\n    hVec[0] = 1.0;\n    hVec[1] = hVec[2] = 0.0;\n    return iu;\n}\n\n// Initialize for two roots case\nhVec[0] = matrixT[iu][iu - 1] / (matrixT[iu][iu - 1] * matrixT[iu][iu - 1] + matrixT[iu - 1][iu - 1] * matrixT[iu - 1][iu - 1]);\nhVec[1] = -FastMath.sqrt(1.0 - hVec[0] * hVec[0]);\nif (matrixT[iu][iu - 1] < 0.0) {\n    hVec[1] = hVec[1] * -1.0;\n}\nhVec[2] = 0.0;\nim = iu - 1;\n\n} else {\n\n    // Initialize for multiple roots case\n    hVec[0] = matrixT[iu][iu - 1] / (matrixT[iu][iu - 1] * matrixT[iu][iu - 1] + matrixT[iu - 1][iu - 1] * matrixT[iu - 1][iu - 1]);\n    hVec[1] = -FastMath.sqrt(1.0 - hVec[0] * hVec[0]);\n    if (matrixT[iu][iu - 1] < 0.0) {\n        hVec[1] = hVec[1] * -1.0;\n    }\n    hVec[2] = matrixT[iu - 1][iu];\n    hVec[2] = hVec[2] / (hVec[0] * hVec[2] + hVec[1] * hVec[1]);\n    im = iu - 2;\n}\n\nreturn im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n        final int n = matrixT.length;\n\n        // Compute shift\n        computeShift(il, iu, 0, shift);\n\n        // Initialize hVec\n        hVec[0] = 1.0;\n        hVec[1] = hVec[2] = 0.0;\n        if (il != iu) {\n            hVec[1] = matrixT[iu][il - 1];\n            hVec[2] = matrixT[iu][il];\n        }\n\n        // Scale hVec\n        final double s = FastMath.sqrt(hVec[1] * hVec[1] + hVec[2] * hVec[2]);\n        if (hVec[1] < 0.0) {\n            s = -s;\n        }\n        hVec[0] = hVec[0] - shift.x - s;\n        hVec[1] = hVec[1] / s;\n        hVec[2] = hVec[2] / s;\n\n        return il;\n    }",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n        final double p = matrixT[iu][iu];\n        final double q = iu > il ? matrixT[iu - 1][iu] : 0.0;\n        final double r = iu > il + 1 ? matrixT[iu - 2][iu] : 0.0;\n\n        hVec[0] = p;\n        hVec[1] = q;\n        hVec[2] = r;\n\n        final double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n\n        shift.x = p / s;\n        shift.y = q / s;\n        shift.w = r / s;\n\n        return iu - il;\n    }",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\nint im;\nif (il == iu) {\n    hVec[0] = matrixT[iu][iu];\n    hVec[1] = 0.0;\n    hVec[2] = matrixT[iu - 1][iu];\n    im = iu;\n} else {\n    hVec[0] = matrixT[iu][iu];\n    hVec[1] = matrixT[iu][iu - 1];\n    hVec[2] = matrixT[iu - 1][iu - 1];\n    im = iu - 1;\n}\nreturn im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n        final double p = matrixT[iu][iu - 1];\n        final double q = matrixT[iu + 1][iu - 1];\n        final double r = matrixT[iu + 2][iu - 1];\n\n        hVec[0] = 1.0;\n        if (iu > il) {\n            hVec[0] = p / FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n        } else if (iu == il) {\n            hVec[0] = 2.0 * p / (FastMath.abs(p) + FastMath.abs(q));\n        }\n\n        hVec[1] = shift.y / hVec[0];\n        hVec[2] = shift.w / hVec[0];\n\n        return iu - 1;\n    }",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n        final int n = matrixT.length;\n        double p = matrixT[il][il - 1];\n        double q = matrixT[il + 1][il - 1];\n        double r = (il < iu - 1) ? matrixT[il + 2][il - 1] : 0.0;\n\n        if (p == 0 && q == 0 && r == 0) {\n            p = 1.0;\n            q = 0.0;\n            r = 0.0;\n        } else {\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n\n        final double s = FastMath.sqrt(p * p + q * q + r * r);\n        final double t = (p < 0) ? -s : s;\n\n        hVec[0] = t;\n        hVec[1] = -q / t;\n        hVec[2] = -r / t;\n\n        return il;\n    }",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n        final int n = matrixT.length;\n\n        // compute matrix norm\n        final double norm = getNorm();\n\n        hVec[0] = 1.0;\n        hVec[1] = 0.0;\n        hVec[2] = 0.0;\n        double p = matrixT[il][il];\n        if (il < iu) {\n            p = p + matrixT[il + 1][il + 1];\n        }\n        if (FastMath.abs(p) <= epsilon * norm) {\n            return iu + 1;\n        }\n        double r = il != iu ? matrixT[il + 2][il] : 0.0;\n        double s = FastMath.sqrt(p * p + matrixT[il + 1][il] * matrixT[il + 1][il] + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n\n        hVec[0] = p / s;\n        hVec[1] = matrixT[il + 1][il] / s;\n        hVec[2] = r / s;\n\n        return il;\n    }",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n        final RealMatrix T = getT();\n        final int n = T.getColumnDimension();\n\n        hVec[0] = T.getEntry(iu, iu) + T.getEntry(iu - 1, iu - 1);\n        hVec[1] = -T.getEntry(iu, iu - 1);\n        hVec[2] = (il == iu - 1) ? T.getEntry(iu - 2, iu - 1) : 0.0;\n\n        for (int k = iu - 2; k >= il; k--) {\n            hVec[0] += T.getEntry(k, k);\n            hVec[1] += T.getEntry(k + 1, k);\n            hVec[2] += (k == il) ? T.getEntry(k - 1, k) : 0.0;\n        }\n\n        for (int j = iu - 1; j >= il; j--) {\n            double h0 = hVec[0];\n            double h1 = hVec[1];\n            double h2 = hVec[2];\n            double t = T.getEntry(j, j - 1);\n            double s = h0 * h0 + h1 * h1 + h2 * h2;\n            if (s != 0.0) {\n                s = FastMath.sqrt(s);\n                if (h0 < 0.0) {\n                    s = -s;\n                }\n                h0 = h0 / s;\n                h1 = h1 / s;\n                h2 = h2 / s;\n            }\n            for (int i = j - 1; i >= il; i--) {\n                double v0 = T.getEntry(i, j);\n                double v1 = T.getEntry(i + 1, j);\n                double v2 = (i == il) ? T.getEntry(i - 1, j) : 0.0;\n                double[] h = new double[] {h0, h1, h2};\n                double[] v = new double[] {v0, v1, v2};\n                double[] p = new double[3];\n}\n}\n}"
    ],
    [
      "public List<TextNode> textNodes()  {\nList<TextNode> textNodes = new ArrayList<>();\nfor (Node node : childNodes) \n{\nif (node instanceof TextNode)\ntextNodes.add((TextNode) node);\n}\nreturn Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\nList<TextNode> textNodes = new ArrayList<>();\nfor (Node node : childNodes) \n{\nif (node instanceof TextNode)\ntextNodes.add((TextNode) node);\n}\nreturn Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\nList<TextNode> textNodes = new ArrayList<>();\nfor (Node node : childNodes) \n{\nif (node instanceof TextNode)\ntextNodes.add((TextNode) node);\n}\nreturn Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\nList<TextNode> textNodes = new ArrayList<>();\nfor (Node node : childNodes) {\nif (node instanceof TextNode)\ntextNodes.add((TextNode) node);\n}\nreturn Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (true);\n        }\n    }\n    return false;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inIncludeSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) \n    {\n        if (!segment.inExceptionSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) \n    {\n        if (!segment.inExceptionSegments()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (true);\n        }\n    }\n    return false;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = chrono.getDifference(end, start, zeroInstance);\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start instanceof LocalDate && end instanceof LocalDate)   {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int amount = chrono.days().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return amount / zeroInstance.size();\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, ZERO);\n    return amount / zeroInstance.size();\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start instanceof LocalDate && end instanceof LocalDate)   {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int amount = chrono.days().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return amount / 7;\n    }\n    if (start instanceof LocalDateTime && end instanceof LocalDateTime)   {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int amount = chrono.hours().getDifference(\n                ((LocalDateTime) end).toInstant().getEpochSecond(), ((LocalDateTime) start).toInstant().getEpochSecond());\n        return amount / 24;\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance.getPeriodType().getDurationFieldType());\n    return amount / zeroInstance.size();\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance.getPeriodType().getFieldType(0));\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = chrono.getDifference(end, start);\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start instanceof LocalDate && end instanceof LocalDate) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int amount = chrono.months().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return amount;\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance.getPeriodType().getFieldType(zeroInstance.size() - 1));\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start instanceof LocalDate && end instanceof LocalDate) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int amount = chrono.years().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return amount;\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance.getPeriodType().getFieldType(0));\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if(start instanceof LocalDate && end instanceof LocalDate) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int amount = chrono.months().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return amount;\n    }\n    if(start instanceof LocalDateTime && end instanceof LocalDateTime) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int amount = chrono.months().getDifference(\n                ((LocalDateTime) end).toInstant().toEpochMilli(), ((LocalDateTime) start).toInstant().toEpochMilli());\n        return amount;\n    }\n    if(start instanceof OffsetDateTime && end instanceof OffsetDateTime) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int amount = chrono.months().getDifference(\n                ((OffsetDateTime) end).toInstant().toEpochMilli(), ((OffsetDateTime) start).toInstant().toEpochMilli());\n        return amount;\n    }\n    if(start instanceof OffsetTime && end instanceof OffsetTime) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int amount = chrono.months().getDifference(\n                ((OffsetTime) end).toInstant().toEpochMilli(), ((OffsetTime) start).toInstant().toEpochMilli());\n        return amount;\n    }\n    if(start instanceof ZonedDateTime && end instanceof ZonedDateTime) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int amount = chrono.months().getDifference(\n                ((ZonedDateTime) end).toInstant().toEpochMilli(), ((ZonedDateTime) start).toInstant().toEpochMilli());\n        return amount;\n    }\n    if(start instanceof Year && end instanceof Year) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int amount = chrono.years().getDifference(\n                ((Year) end).getLong(), ((Year) start).getLong());\n        return amount;\n    }\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start instanceof LocalDate && end instanceof LocalDate) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int amount = chrono.months().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return amount;\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance.getPeriodType().getFieldType(0));\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePeriod object must not be null\");\n    }\n\n    if (!(zeroInstance instanceof Days) && !(zeroInstance instanceof Weeks) && !(zeroInstance instanceof Months) && !(zeroInstance instanceof Quarters) && !(zeroInstance instanceof Years)) {\n        throw new IllegalArgumentException(\"Zero instance must be of class Days, Weeks, Months, Quarters or Years\");\n    }\n\n    if (start instanceof LocalDate && end instanceof LocalDate)   {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int amount = chrono.months().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return amount / zeroInstance.size();\n    }\n\n    int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance.getPeriodType().getUnit());\n    return amount / zeroInstance.size();\n}"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    List<Title> subtitles = getSubtitles();\n    if (subtitles == null) {\n        return null;\n    }\n\n    for (int i = 0; i < subtitles.size(); i++) {\n        if (subtitles.get(i) instanceof LegendTitle) {\n            if (index-- == 0) {\n                return (LegendTitle) subtitles.get(i);\n            }\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    List<Title> subtitles = getSubtitles();\n    if (subtitles != null) {\n        for (Title subtitle : subtitles) {\n            if (subtitle instanceof LegendTitle) {\n                if (index == 0) {\n                    return (LegendTitle) subtitle;\n                }\n                index--;\n            }\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    List subtitles = getSubtitles();\n    if (subtitles == null) {\n        return null;\n    }\n    if (index >= subtitles.size() || index < 0) {\n        return null;\n    }\n    Object subtitleObject = subtitles.get(index);\n    if (subtitleObject instanceof LegendTitle) {\n        return (LegendTitle) subtitleObject;\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    List subtitles = getSubtitles();\n    if (subtitles != null && subtitles.size() > index) {\n        Object subtitle = subtitles.get(index);\n        if (subtitle instanceof LegendTitle) {\n            return (LegendTitle) subtitle;\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    List<Title> subtitles = getSubtitles();\n    for (int i = 0; i < subtitles.size(); i++) {\n        Title subtitle = subtitles.get(i);\n        if (subtitle instanceof LegendTitle) {\n            if (i == index) {\n                return (LegendTitle) subtitle;\n            }\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    List<Title> titles = getSubtitles();\n    for (int i = 0; i < titles.size(); i++) {\n        Title title = titles.get(i);\n        if (title instanceof LegendTitle) {\n            if (index == 0) {\n                return (LegendTitle) title;\n            }\n            index--;\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    List<Title> titles = getSubtitles();\n    if (titles != null) {\n        for (int i = 0; i < titles.size(); i++) {\n            if (titles.get(i) instanceof LegendTitle) {\n                if (index == 0) {\n                    return (LegendTitle) titles.get(i);\n                }\n                else {\n                    index--;\n                }\n            }\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    List<Title> subs = getSubtitles();\n    for (int i = 0; i < subs.size(); i++) {\n        if (subs.get(i) instanceof LegendTitle) {\n            if (index == 0) {\n                return (LegendTitle) subs.get(i);\n            }\n            index--;\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    List subtitles = getSubtitles();\n    if (subtitles != null && subtitles.size() > index) {\n        Object subtitle = subtitles.get(index);\n        if (subtitle instanceof LegendTitle) {\n            return (LegendTitle) subtitle;\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    List<Title> subs = getSubtitles();\n    for (int i = 0; i < subs.size(); i++) {\n        if (subs.get(i) instanceof LegendTitle) {\n            if (i == index) {\n                return (LegendTitle) subs.get(i);\n            }\n        }\n    }\n    return null;\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(nameMap.values().stream()\n        .flatMap(List::stream)\n        .sorted(offsetComparator)\n        .collect(Collectors.toList()));\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(nameMap.values().stream()\n        .flatMap(Collection::stream)\n        .sorted(offsetComparator)\n        .collect(Collectors.toList()));\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(nameMap.values().stream()\n        .flatMap(Collection::stream)\n        .sorted(offsetComparator)\n        .collect(Collectors.toList()));\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(nameMap.values().stream()\n        .flatMap(Collection::stream)\n        .sorted(offsetComparator)\n        .collect(Collectors.toList()));\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(nameMap.values().stream()\n        .flatMap(Collection::stream)\n        .sorted(offsetComparator)\n        .collect(Collectors.toList()));\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(nameMap.values().stream()\n        .flatMap(List::stream)\n        .sorted(offsetComparator)\n        .toList());\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entriesInPhysicalOrder);\n}"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC)\n  {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null)\n    {\n      skipEOLs();\n      if (!match(JsDocToken.RC))\n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      }\n      else \n      {\n        next();\n      }\n    }\n    return typeNode;\n  }\n  else\n  {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC)\n  {\n    skipEOLs();\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null)\n    {\n      skipEOLs();\n      if (!match(JsDocToken.RC))\n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) \n    {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) \n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } \n      else \n      {\n        next();\n      }\n    }\n    return typeNode;\n  } \n  else \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.paramtype.annotation\");\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC)\n    {\n        skipEOLs();\n        Node typeNode = parseOptionalParameterType(next());\n        if (typeNode != null)\n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC))\n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } else\n            {\n                next();\n            }\n        }\n        return typeNode;\n    }\n    else if (token == JsDocToken.ELLIPSIS)\n    {\n        token = next();\n        if (token == JsDocToken.RC)\n        {\n            next();\n            return newNode(Token.ELLIPSIS);\n        } else\n        {\n            Node typeNode = parseTopLevelTypeExpression(token);\n            if (typeNode != null)\n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC))\n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } else\n                {\n                    next();\n                }\n                return typeNode;\n            }\n        }\n    }\n    return null;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) \n    {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) \n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } \n      else \n      {\n        next();\n      }\n    }\n    return typeNode;\n  } \n  else if (token == JsDocToken.ELLIPSIS) \n  {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) \n    {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) \n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } \n      else \n      {\n        next();\n      }\n    }\n    return wrapNode(Token.ELLIPSIS, typeNode);\n  } \n  else \n  {\n    return parseTopLevelTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC)\n    {\n        skipEOLs();\n        Node typeNode = parseTypeExpression(next());\n        if (typeNode != null)\n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC))\n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            }\n            else\n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    }\n    else\n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) \n    {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) \n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } \n      else \n      {\n        next();\n      }\n    }\n    return typeNode;\n  } \n  else \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lc\");\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC)\n  {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null)\n    {\n      skipEOLs();\n      if (!match(JsDocToken.RC))\n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      }\n      else\n      {\n        next();\n      }\n    }\n    return typeNode;\n  }\n  else\n  {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n      skipEOLs();\n      Node paramTypeNode = parseTypeExpression(next());\n      if (paramTypeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n      return paramTypeNode;\n    } else {\n      return parseTopLevelTypeExpression(token);\n    }\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> result = new ArrayList<>();\n    String trace = t.toString();\n    for (int i = 0; i < trace.length(); i++) {\n        if (trace.charAt(i) == '\\n') {\n            result.add(trace.substring(i + 1));\n        }\n    }\n    return result;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> ret = new ArrayList<String>();\n    List<String> frameList = getStackFrameList(t, ret, getCauseMethodNames());\n    if (frameList != null && !frameList.isEmpty()) {\n        removeCommonFrames(frameList, getStackFrameList(t, new ArrayList<String>(), getCauseMethodNames()));\n        ret.addAll(frameList);\n    }\n    return ret;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> frameList = new ArrayList<>();\n    if (t.getCause() != null)\n    {\n        frameList.addAll(getStackFrameList(t.getCause()));\n    }\n    String[] stackFrames = getStackFrames(t.getStackTrace());\n    for (String stackFrame : stackFrames)\n    {\n        if (!stackFrame.contains(\"at java.lang.Thread.dumpStack\"))\n        {\n            frameList.add(stackFrame);\n        }\n    }\n    return frameList;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> ret = new ArrayList<String>();\n    Throwable currentThrowable = t;\n    while (currentThrowable != null)\n    {\n        String[] stackFrames = getStackFrames(currentThrowable.getStackTrace());\n        for (int i = 0; i < stackFrames.length; i++)\n        {\n            ret.add(stackFrames[i]);\n        }\n        currentThrowable = currentThrowable.getCause();\n    }\n    return ret;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> list = new ArrayList<>();\n\n    // Get the stack trace as a String\n    String stackTrace = t.getStackTrace().toString();\n\n    // Split the stack trace into lines\n    String[] lines = stackTrace.split(SystemUtils.LINE_SEPARATOR);\n\n    // Add each line to the list, skipping the first (message) and last (null)\n    for (int i = 1; i < lines.length - 1; i++) \n    {\n        list.add(lines[i]);\n    }\n\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> frames = getStackFrameList(t.getStackTrace());\n    return frames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> result = new ArrayList<String>();\n    for (StackTraceElement element : t.getStackTrace()) {\n        result.add(element.toString());\n    }\n    return result;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> ret = new ArrayList<String>();\n    List<Throwable> throwables = ExceptionUtils.getThrowableList(t);\n    for (Throwable throwable : throwables) {\n        List<String> frames = getStackFrameList(throwable);\n        for (String frame : frames) {\n            ret.add(frame);\n        }\n    }\n    return ret;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> list = new ArrayList<String>();\n    String trace = t.getStackTrace()[0].toString();\n    list.add(trace);\n    while (t.getCause() != null) {\n        t = t.getCause();\n        trace = t.getStackTrace()[0].toString();\n        list.add(trace);\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> frames = new ArrayList<>();\n    final String[] trace = t.getStackTrace();\n\n    for (int i = 0; i < trace.length; i++)\n    {\n        frames.add(trace[i]);\n    }\n\n    return frames;\n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    }\n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    }\n    if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    }\n    if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    }\n    if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    }\n    if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } else {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    }\n    if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n   Node paramList = call.getLastChild();\n   if (paramList.isParamList()) {\n      return false;\n   }\n   for (Node child = paramList.getFirstChild(); child != null;\n       child = child.getNext()) {\n      if (!child.isLiteral() && !child.isThis()) {\n         return true;\n      }\n   }\n   return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n   Node[] children = call.children();\n   for (int i = 2; i < children.length; ++i) {\n       if (NodeUtil.mayHaveSideEffects(children[i])) {\n           return true;\n       }\n   }\n   return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n   // Get the function definition of the method being called.\n   Node fn = call.getFirstChild().getNext().getNext();\n   if (!fn.isFunction()) {\n     return false;\n   }\n\n   // Get the list of arguments to the method call.\n   List<Node> args = call.getSecondChild().getKids();\n\n   // Check if any argument has side effects.\n   for (Node arg : args) {\n     if (NodeUtil.mayHaveSideEffects(arg)) {\n       return true;\n     }\n   }\n\n   return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    // Check if the call has any side effects.\n    SideEffectFlags flags = SideEffectFlags.getSideEffectFlags(call);\n    if (!flags.areAllFlagsSet()) {\n      return true;\n    }\n\n    // Check if any arguments have side effects.\n    for (Node arg : call.getLastChild().getChildren()) {\n      SideEffectFlags argFlags = SideEffectFlags.getSideEffectFlags(arg);\n      if (!argFlags.areAllFlagsSet()) {\n        return true;\n      }\n    }\n\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    // Get the list of arguments from the method call.\n    List<Node> args = call.getLastChild().getPreviousSiblings().asList();\n\n    // Check if any of the arguments are mutable.\n    for (Node arg : args)\n    {\n        JSType argType = compiler.getTypeRegistry().getType(arg);\n        if (argType == null)\n        {\n            return true;\n        }\n\n        if (!compiler.isImmutable(argType))\n        {\n            return true;\n        }\n    }\n\n    // All arguments are immutable, so there are no side effects.\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n\t// TODO: This method should be implemented.\n\treturn false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n   // If there is no source position information, we don't know where to report\n   // the warning, so we just assume there are side effects.\n   if (call.getSourcePosition() == -1) {\n     return true;\n   }\n  \n   Node getprop = call.getFirstChild();\n   Node propName = getprop.getFirstChild().getNext();\n  \n   if (propName.isQuotedString()) {\n     // If the method is called as a string, it may have side effects.\n     return true;\n   }\n  \n   // Check if the method is defined in the current scope.\n   if (call.getDefiningScope() == call.getScope()) {\n     return false;\n   }\n  \n   // If the method is defined in a different scope, we don't have enough information to\n   // determine if it has side effects. So we assume it does.\n   return true;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n\t// TODO: This method is not implemented in the original code.\n\t// Add your logic here to determine if the arguments of the call node have side effects.\n\t// Return true if the arguments have side effects, false otherwise.\n\treturn false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    // If the call node is not a valid type, then we don't have\n    // enough information to determine if it has side effects,\n    // so we assume it does.\n    if (call.getType() != Token.CALL) {\n        return true;\n    }\n\n    Node callee = call.getFirstChild();\n    if (callee.isGetProp()) {\n        callee = callee.getFirstChild();\n    }\n\n    if (callee.isName()) {\n        // If we are calling a built-in object method, we need to\n        // check the specific method to see if it has side effects.\n        // For example, the `push()` method of an Array has side effects.\n        String methodName = callee.getString();\n        if (Builtins.isBuiltinObjectMethod(callee.getParent(), methodName) &&\n            Builtins.getBuiltInObjectMethod(callee.getParent(), methodName).\n                mayHaveSideEffects()) {\n            return true;\n        }\n    }\n\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    // Get the arguments of the method call.\n    Node[] args = call.getLastChild().getPrevious().getPrevious().getPrevious().getPrevious().getChildren();\n    \n    // Check if any of the arguments have side effects.\n    for (Node arg : args) \n    {\n        if (NodeUtil.mayHaveSideEffects(arg, compiler.getLifetimes(), compiler)) \n        {\n            return true;\n        }\n    }\n    \n    return false;\n}"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                     0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                     0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        int sum = 0;\n        for (final ZipExtraField element : data) \n        {\n            sum += element.getLocalFileDataLength().getValue();\n        }\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (final ZipExtraField element : data) \n        {\n            final byte[] local = element.getLocalFileDataData();\n            if (local != null) \n            {\n                System.arraycopy(local, 0, result, start, local.length);\n                start += local.length;\n            }\n        }\n        return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                     0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                     0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        final boolean lastIsUnparseableHolder = data.length > 0\n                && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n                lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getLocalFileDataLength().getValue();\n        }\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                    0, result, start, 2);\n            System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                    0, result, start + 2, 2);\n            start += WORD;\n            final byte[] local = data[i].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n                start += local.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] local = data[data.length - 1].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                     0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                     0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        int sum = WORD * data.length;\n        for (final ZipExtraField element : data) {\n            sum += element.getLocalFileDataLength().getValue();\n        }\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (final ZipExtraField element : data) {\n            System.arraycopy(element.getHeaderId().getBytes(), 0, result, start, 2);\n            System.arraycopy(element.getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);\n            start += WORD;\n            final byte[] local = element.getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n                start += local.length;\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                     0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                     0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                     0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                     0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        int sum = 0;\n        for (final ZipExtraField element : data) {\n            sum += element.getLocalFileDataLength().getValue();\n        }\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (final ZipExtraField element : data) {\n            System.arraycopy(element.getHeaderId().getBytes(), 0, result, start, 2);\n            System.arraycopy(element.getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);\n            final byte[] local = element.getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start + WORD, local.length);\n            }\n            start += WORD + element.getLocalFileDataLength().getValue();\n        }\n        return result;\n    }"
    ],
    [
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n\n    while (node.getCut() != null) {\n        OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n\n    while (node.getCut() != null) {\n        OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n\n    while (node.getCut() != null) \n    {\n        OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    final StringBuilder content = token.content;\n    boolean eol = false;\n    final long startLineNumber = lexer.getCurrentLineNumber();\n\n    while (true) \n    {\n        if (isDelimiter(ch) || eol || isEndOfFile(ch))\n        {\n            if (isDelimiter(ch) && isQuoteChar(peekAhead()))\n            {\n                // quoted delimiter, token is not finished yet...\n                continue;\n            }\n            else if (eol) \n            {\n                if (ignoreEmptyLines && content.length() == 0)\n                {\n                    content.append(\"\");\n                }\n                token.type = EORECORD;\n                break;\n            }\n            else if (isEndOfFile(ch)) \n            {\n                if (ignoreEmptyLines && content.length() == 0) \n                {\n                    content.append(\"\");\n                }\n                token.type = EOF;\n                break;\n            }\n            else if (isDelimiter(ch)) \n            {\n                if (ignoreSurroundingSpaces)\n                {\n                    while (isWhitespace(peekAhead())) { ch = readAhead(); }\n                }\n                token.type = TOKEN;\n                break;\n            }\n        }\n        else if (isEscape(ch))\n        {\n            ch = readEscape();\n        }\n        else\n        {\n            content.append((char)ch);\n        }\n\n        ch = readAhead();\n        eol = readEndOfLine(ch);\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.type = TOKEN;\n    if (token.content.length() == 0 && ch == commentStart) {\n        // comment found\n        token.type = COMMENT;\n        return token;\n    }\n\n    boolean inEscapeSequence = false;\n    boolean eol = false;\n\n    while (true) {\n        if (ch == -1) {\n            // end of file\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            break;\n        }\n\n        if (isDelimiter(ch) && !inEscapeSequence) {\n            if (token.content.length() == 0) {\n                // ignore empty tokens\n                break;\n            } else {\n                // delimiter found\n                token.isReady = true;\n                break;\n            }\n        }\n\n        if (isEndOfLine(ch)) {\n            eol = true;\n            if (token.content.length() == 0) {\n                // empty token return EORECORD(\"\")\n                token.type = EORECORD;\n                break;\n            } else {\n                // end of line found\n                token.isReady = true;\n                break;\n            }\n        }\n\n        if (isEscape(ch) && !inEscapeSequence) {\n            inEscapeSequence = true;\n        } else {\n            inEscapeSequence = false;\n        }\n\n        if (!isMetaChar(ch)) {\n            token.content.append((char) ch);\n        }\n\n        ch = reader.read();\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    final StringBuilder content = token.content;\n\n    while (true) {\n        // end of line reached or token finished\n        if (eol || isDelimiter(ch)) {\n            if (ignoreEmptyLines && content.length() == 0) {\n                if (eol) {\n                    continue; // skip empty line\n                } else {\n                    token.type = EOF;\n                }\n            }\n            break;\n        }\n\n        // check for comment start\n        if (isCommentStart(ch)) {\n            token.type = COMMENT;\n            return token;\n        }\n\n        // check for escape character\n        if (isEscape(ch)) {\n            int nextChar = reader.read();\n            if (nextChar == -1) {\n                throw new IOException(\"(line \" + getCurrentLineNumber() + \") unterminated escape sequence\");\n            }\n            content.append((char) nextChar);\n            ch = reader.read(); // advance past escaped character\n            continue;\n        }\n\n        // add current character\n        content.append((char) ch);\n\n        // read next char\n        ch = reader.read();\n    }\n\n    if (eol) {\n        token.type = EORECORD;\n    } else {\n        token.type = TOKEN;\n    }\n\n    token.isReady = true;\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    final boolean ignoreSurroundingSpaces = this.ignoreSurroundingSpaces;\n    final ExtendedBufferedReader reader = this.reader;\n    boolean eol = false;\n    final StringBuilder content = token.content;\n    content.append((char) ch);\n\n    do {\n        ch = reader.read();\n        eol = readEndOfLine(ch);\n\n        if (ignoreSurroundingSpaces) {\n            while (isWhitespace(ch) && !eol) {\n                ch = reader.read();\n                eol = readEndOfLine(ch);\n            }\n        }\n\n        if (eol) {\n            // empty token return EORECORD(\"\")\n            // noop: token.content.append(\"\");\n            token.type = EORECORD;\n        } else if (isDelimiter(ch)) {\n            // valid token detected, add delimiters to string\n            if (!isEscape(token.content.charAt(token.content.length() - 1))) {\n                content.append((char) ch);\n                // ok, end of token reached\n                token.type = TOKEN;\n            }\n        } else if (isQuoteChar(ch)) {\n            // start of encapsulated token\n            parseEncapsulatedToken(token);\n        } else if (isEndOfFile(ch)) {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        } else {\n            // add current character to token\n            content.append((char) ch);\n        }\n    } while (token.type == INVALID);\n\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.type = TOKEN;\n    if (ch == quoteChar) {\n        return parseEncapsulatedToken(token);\n    } else if (ch == escape) {\n        return parseEscapedToken(token);\n    } else {\n        token.content.append((char) ch);\n        int nextChar;\n        eol = false;\n        while (!eol && (nextChar = reader.read()) != -1) {\n            if (isDelimiter(nextChar) && nextChar != escape) {\n                break;\n            } else if (isEndOfLine(nextChar)) {\n                eol = true;\n            } else {\n                token.content.append((char) nextChar);\n            }\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.type = TOKEN;\n    if (ch == commentStart) {\n        token.type = COMMENT;\n        if (!ignoreSurroundingSpaces) {\n            token.content.append((char) ch);\n        }\n        // read till end of comment\n        do {\n            ch = reader.read();\n            if (reader.isClosed()) {\n                token.type = EOF;\n                break;\n            }\n            token.content.append((char) ch);\n        } while (ch != commentStart);\n        return token;\n    }\n    if (ch == DISABLED) {\n        return token;\n    }\n    if (ignoreSurroundingSpaces && isWhitespace(ch)) {\n        return token;\n    }\n    if (isDelimiter(ch)) {\n        token.type = TOKEN;\n        return token;\n    }\n    if (isEndOfFile(ch)) {\n        token.type = EOF;\n        return token;\n    }\n    if (isQuoteChar(ch)) {\n        return parseEncapsulatedToken(token);\n    }\n    token.content.append((char) ch);\n    if (ignoreSurroundingSpaces && isWhitespace(reader.lookAhead())) {\n        return token;\n    }\n    if (reader.readEndOfLine(reader.lookAhead())) {\n        token.type = EORECORD;\n        return token;\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char)ch);\n    if (eol) {\n        token.type = EORECORD;\n        // token.content.append(\"\");\n    } else if (ch == quoteChar) {\n        token.type = INVALID;\n        // token.content.append(ch);\n    } else if (ch == delimiter || ch == DISABLED) {\n        token.type = TOKEN;\n    } else {\n        if (isCommentStart(ch)) {\n            token.type = COMMENT;\n        }\n    }\n\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    while (true) \n    {\n        // ignore whitespaces at beginning of a token\n        if (ignoreSurroundingSpaces) \n        {\n            while (isWhitespace(ch) && !eol) \n            {\n                ch = reader.read();\n                eol = readEndOfLine(ch);\n            }\n        }\n\n        // ok, start of token reached: simple token\n        token.content.append((char) ch);\n        if (isDelimiter(ch)) \n        {\n            // next token must be a simple token\n            if (token.content.length() > 0) \n            {\n                // add removed blanks when not ignoring whitespace chars...\n                if (ignoreSurroundingSpaces && token.content.charAt(0) == ' ') \n                {\n                    token.content.deleteCharAt(0);\n                }\n                token.type = TOKEN;\n                token.isReady = true;\n            } else \n            {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n                token.isReady = true;\n            }\n        } else if (eol) \n        {\n            // end of line return EORECORD(\"\")\n            token.type = EORECORD;\n            token.isReady = true;\n        } else if (isQuoteChar(ch)) \n        {\n            // consume encapsulated token\n            parseEncapsulatedToken(token);\n        } else if (isEndOfFile(ch)) \n        {\n            // end of file return EOF\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        }\n        if (INVALID == token.type) \n        {\n            throw new IOException(\"Unexpected token character '\" + (char) ch + \"' at line \" + startLineNumber);\n        }\n        if (INVALID != token.type) \n        {\n            return token;\n        }\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    token.content.append((char)ch);\n    while (true) {\n        ch = reader.read();\n        if (eol) {\n            token.type = EORECORD;\n            break;\n        } else if (isDelimiter(ch)) {\n            token.type = TOKEN;\n            break;\n        } else if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            break;\n        } else if (isQuoteChar(ch)) {\n            token.type = TOKEN;\n            break;\n        } else if (isEscape(ch)) {\n            if (ignoreSurroundingSpaces) {\n                while (isWhitespace(reader.peek()) && !eol) {\n                    reader.read();\n                }\n            }\n            ch = readEscape();\n        }\n        token.content.append((char)ch);\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n    boolean eol = false;\n    while (true) {\n        if (eol) {\n            token.type = EORECORD;\n            break;\n        }\n        if (isDelimiter(ch)) {\n            token.type = TOKEN;\n            break;\n        }\n        if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            break;\n        }\n        if (isEscape(ch)) {\n            ch = readEscape();\n        } else {\n            ch = reader.read();\n        }\n        eol = readEndOfLine(ch);\n    }\n    return token;\n}"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] result = new int[dimension];\n    int tmp = index;\n    for (int i = 0; i < dimension - 1; i++) {\n        int count = uniCounterOffset[i];\n        result[i] = tmp / count;\n        tmp %= count;\n    }\n    result[dimension - 1] = tmp;\n    return result;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] c = new int[dimension];\n    for (int i = last; i >= 0; i--) {\n        int mod = uniCounterOffset[i];\n        c[i] = index / mod;\n        index %= mod;\n    }\n    return c;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    int[] result = new int[dimension];\n    for (int i = dimension - 1; i >= 0; i--) {\n        result[i] = index % size[i];\n        index /= size[i];\n    }\n    return result;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    int[] counts = new int[dimension];\n    int factor = totalSize;\n    for (int i = 0; i < dimension; i++) {\n        factor /= size[i];\n        counts[i] = (index / factor) % size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    int[] c = new int[dimension];\n    int offset = index;\n    for (int i = 0; i < dimension; i++) {\n        c[i] = offset / uniCounterOffset[i];\n        offset -= c[i] * uniCounterOffset[i];\n    }\n    return c;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int offset = index;\n    for (int i = dimension - 1; i >= 0; i--) {\n        int counterOffset = uniCounterOffset[i];\n        counts[i] = offset / counterOffset;\n        offset -= counts[i] * counterOffset;\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    int[] result = new int[dimension];\n    for (int i = last; i >= 0; i--) {\n        int count = index / uniCounterOffset[i];\n        result[i] = count;\n        index -= count * uniCounterOffset[i];\n    }\n    return result;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] c = new int[dimension];\n    int i = 0;\n    for (int offset : uniCounterOffset) {\n        c[i++] = index / offset;\n        index %= offset;\n    }\n    return c;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] result = new int[dimension];\n    int counterValue = index;\n    for (int i = last; i >= 0; i--) {\n        result[i] = counterValue % size[i];\n        counterValue /= size[i];\n    }\n    return result;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] c = new int[dimension];\n    for (int i = 0; i < dimension - 1; i++) {\n        int count = 1;\n        for (int j = i + 1; j < dimension; j++) {\n            count *= size[j];\n        }\n        c[i] = (index / count) % size[i];\n    }\n    c[last] = index % size[last];\n    return c;\n}"
    ],
    [
      "public JsonPointer last()  {\n    JsonPointer l = this;\n    while (l._nextSegment != null) {\n        l = l._nextSegment;\n    }\n    return l;\n}",
      "public JsonPointer last()  {\n    JsonPointer n = this;\n    while (n._nextSegment != null) {\n        n = n._nextSegment;\n    }\n    return n;\n}",
      "public JsonPointer last()  {\n    JsonPointer current = this;\n    while (current._nextSegment != null) {\n        current = current._nextSegment;\n    }\n    return current;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer n = this;\n    while (n._nextSegment != null) {\n        n = n._nextSegment;\n    }\n    return n;\n}",
      "public JsonPointer last()  {\n    JsonPointer l = this;\n    while (l._nextSegment != null) {\n        l = l._nextSegment;\n    }\n    return l;\n}",
      "public JsonPointer last()  {\n    JsonPointer l = _nextSegment;\n    if (l == null) {\n        return this;\n    }\n    while (true) {\n        JsonPointer next = l._nextSegment;\n        if (next == null) {\n            return l;\n        }\n        l = next;\n    }\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer l = this;\n    while (l._nextSegment != null) {\n        l = l._nextSegment;\n    }\n    return l;\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) > -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    try(InputStream in = data;\n        InputStream buffered = new BufferedInputStream(in);\n        DigestInputStream digestStream = new DigestInputStream(buffered, digest))\n    {\n        while (digestStream.read() != -1) ;\n        return digest;\n    }\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) > -1) \n    {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) > -1) \n    {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] bytes = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n\n    while ((bytesRead = data.read(bytes)) != -1) {\n        digest.update(bytes, 0, bytesRead);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    return updateDigest(digest, new BufferedInputStream(data));\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) > -1)\n    {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    int bytesRead;\n    byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    while ((bytesRead = data.read(buffer)) > -1)\n    {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) ((Cloneable) obj).clone();\n        } catch (final Throwable ex) {\n            throw new CloneFailedException(ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n        if (obj == null) {\n            return null;\n        }\n        try {\n            return ((T) ((Serializable) obj).clone());\n        } catch (final CloneNotSupportedException e) {\n            throw new CloneFailedException(obj, e);\n        } catch (final SecurityException e) {\n            throw new CloneFailedException(obj, e);\n        }\n    }",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    }\n    final Class<?> clazz = obj.getClass();\n    if (Cloneable.class.isAssignableFrom(clazz)) {\n        try {\n            @SuppressWarnings(\"unchecked\")\n            final T clone = (T) clazz.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final ReflectiveOperationException ex) {\n            throw new CloneFailedException(\"Cloning failed\", ex);\n        }\n    } else if (Serializable.class.isAssignableFrom(clazz)) {\n        final byte[] objectData = SerializationUtils.serialize(obj);\n        final ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n        try {\n            final ObjectInputStream ois = new ObjectInputStream(bais);\n            @SuppressWarnings(\"unchecked\")\n            final T clone = (T) ois.readObject();\n            return clone;\n        } catch (final IOException | ClassNotFoundException ex) {\n            throw new CloneFailedException(\"Cloning failed\", ex);\n        }\n    } else {\n        return null;\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    final Class<?> clazz = obj.getClass();\n    if (clazz.isPrimitive()) {\n        return obj;\n    } else if (obj instanceof Serializable) {\n        try {\n            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            ObjectOutputStream oos = new ObjectOutputStream(baos);\n            oos.writeObject(obj);\n            oos.close();\n            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()));\n            T clonedObj = (T) ois.readObject();\n            ois.close();\n            return clonedObj;\n        } catch (Exception e) {\n            throw new CloneFailedException(\"Cloning failed for class: \" + clazz, e);\n        }\n    } else if (obj instanceof Clone) {\n        try {\n            return (T) ((Clone<?>) obj).clone();\n        } catch (CloneNotSupportedException e) {\n            throw new CloneFailedException(\"Cloning failed for class: \" + clazz, e);\n        }\n    } else {\n        return null;\n    }\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            try {\n                return ((Cloneable<T>) obj).clone();\n            } catch (CloneNotSupportedException ex) {\n                throw new CloneFailedException(\"Cloning not supported: \" + obj, ex);\n            }\n        }\n        final byte[] objectData = SerializationUtils.serialize(obj);\n        final ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n        final ObjectInputStream ois = new ObjectInputStream(bais);\n        final T result = (T) ois.readObject();\n        ois.close();\n        return result;\n    }",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    }\n    final Class<?> clazz = obj.getClass();\n    if (!clazz.isPrimitive() && !clazz.isEnum() && !clazz.isAnnotation() && !clazz.isArray() && !Modifier.isFinal(clazz.getModifiers())) {\n        try {\n            final Constructor<?> constructor = clazz.getConstructor(null);\n            final Object clone = constructor.newInstance(null);\n            if (clone instanceof Cloneable) {\n                ((Cloneable) clone).clone();\n            }\n            return (T) clone;\n        } catch (final Exception e) {\n            throw new CloneFailedException(\"Cloning failed for class: \" + clazz.getName(), e);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    final Class<?> clazz = obj.getClass();\n    try {\n        final Constructor<?> constructor = clazz.getConstructor(null);\n        final T result = (T) constructor.newInstance(null);\n        for (final Field field : clazz.getDeclaredFields()) {\n            field.setAccessible(true);\n            field.set(result, field.get(obj));\n        }\n        return result;\n    } catch (final NoSuchMethodException e) {\n        throw new CloneFailedException(\"No nullary constructor\", e);\n    } catch (final SecurityException e) {\n        throw new CloneFailedException(\"No access to constructor\", e);\n    } catch (final InstantiationException e) {\n        throw new CloneFailedException(\"Failed to instantiate\", e);\n    } catch (final IllegalAccessException e) {\n        throw new CloneFailedException(\"Failed to access field\", e);\n    } catch (final InvocationTargetException e) {\n        throw new CloneFailedException(\"Failed to set field\", e);\n    }\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            try {\n                return ((Cloneable) obj).clone();\n            } catch (CloneNotSupportedException e) {\n                throw new CloneFailedException(e.getMessage());\n            }\n        } else {\n            return SerializationUtils.clone(obj);\n        }\n    }",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return ((Cloneable<T>) obj).clone();\n        } catch (CloneNotSupportedException e) {\n            throw new CloneFailedException(e);\n        }\n    }\n    if (obj instanceof ObjectUtils.Null) {\n        return new ObjectUtils.Null();\n    }\n    // Try serialization, if the object is serializable\n    if (obj instanceof Serializable) {\n        try {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            ObjectOutputStream oos = new ObjectOutputStream(baos);\n            oos.writeObject(obj);\n            oos.close();\n            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n            ObjectInputStream ois = new ObjectInputStream(bais);\n            Object result = ois.readObject();\n            ois.close();\n            if (result instanceof T) {\n                return (T) result;\n            }\n        } catch (Exception e) {\n            // Ignore exception and return null if serialization fails\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n        if (obj == null) {\n            return null;\n        }\n        try {\n            return obj.clone();\n        } catch (final CloneNotSupportedException e) {\n            throw new CloneFailedException(obj, e);\n        }\n    }"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (!sym.isLexicalVariable()) {\n        return null;\n    }\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n        return null;\n    }\n    return scope.getSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n\n  String name = NodeUtil.getBestLValueName(\n      NodeUtil.getBestLValue(type.getSource()));\n  if (name == null) {\n    return null;\n  }\n\n  SymbolScope scope = getScopeInFunction(sym);\n  if (scope == null) {\n    return null;\n  }\n\n  Symbol symbol = scope.getSlot(name);\n  if (symbol == null) {\n    return null;\n  }\n\n  if (!symbol.isLexicalVariable() &&\n      !symbol.isParameter()) {\n    // Some functions capture this symbol from a scope higher up.\n    // Find the actual parameter for this symbol.\n    Symbol paramSymbol = getParameterWithSymbol(type, paramName, symbol);\n    if (paramSymbol == null) {\n      return null;\n    }\n    if (paramSymbol.isLexicalVariable()) {\n      // We found the parameter symbol, but it's not a proper parameter.\n      // It's a lexical variable that shadows a parameter.\n      return null;\n    }\n    return paramSymbol;\n  }\n\n  return symbol;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  Node functionNode = type.getSource();\n  if (functionNode == null) {\n    return null;\n  }\n  SymbolScope scope = getScope(functionNode);\n  if (scope == null) {\n    return null;\n  }\n  return scope.getSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  Node functionNode = type.getSource();\n  if (functionNode == null) {\n    return null;\n  }\n  SymbolScope scope = scopes.get(functionNode);\n  if (scope == null) {\n    return null;\n  }\n  return scope.getSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n\n  return type.getScope().getSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n    return getSymbolForName(type.getSource(), paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n    return getScopeInFunction(sym).getSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (!sym.getFunctionType().isConstructor() &&\n        !sym.getFunctionType().isInterface() &&\n        sym.getScope().getSymbolForScope() == null) {\n        return null;\n    }\n\n    FunctionType type = sym.getFunctionType();\n    if (type.isConstructor()) {\n        SymbolScope scope = getScopeInFunction(sym);\n        if (scope == null) {\n            return null;\n        }\n        return scope.getSlot(paramName);\n    } else {\n        SymbolScope scope = getScopeInFunction(sym);\n        if (scope == null) {\n            return null;\n        }\n        Symbol param = scope.getSlot(paramName);\n        if (param == null || param.getDeclaration() == null ||\n            param.getDeclaration().getType() == null) {\n            return null;\n        }\n        return param;\n    }\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  return getScopeInFunction(sym).getSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (!sym.isLexicalVariable()) \n    {\n        return null;\n    }\n\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) \n    {\n        return null;\n    }\n\n    Symbol param = scope.getSlot(paramName);\n    if (param != null && param.isLexicalVariable()) \n    {\n        return param;\n    }\n\n    return null;\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    n = matrix.getRowDimension();\n    covarianceMatrix = matrix.createMatrix(n, n);\n    double denominator = n - (biasCorrected ? 1.0 : 0.0);\n    for (int j = 0; j < n; j++) {\n        double x_j = 0.0;\n        for (int i = 0; i < n; i++) {\n            x_j += matrix.getEntry(i, j);\n        }\n        x_j /= denominator;\n        for (int i = 0; i < n; i++) {\n            covarianceMatrix.addToEntry(i, j, (matrix.getEntry(i, j) - x_j) * (matrix.getEntry(i, j) - x_j));\n        }\n    }\n    covarianceMatrix.scalarMultiply(1.0 / denominator);\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    RealMatrix result = matrix.createMatrix(matrix.getColumnDimension(), matrix.getColumnDimension());\n    double tempSum = 0.0;\n    for (int j = 0; j < matrix.getColumnDimension(); j++) {\n        for (int i = 0; i < matrix.getColumnDimension(); i++) {\n            for (int k = 0; k < matrix.getRowDimension(); k++) {\n                tempSum += (matrix.getEntry(k, i) - matrix.getColumnVector(i).getMean())\n                        * (matrix.getEntry(k, j) - matrix.getColumnVector(j).getMean());\n            }\n            result.setEntry(i, j, tempSum / (matrix.getRowDimension() - (biasCorrected ? 1 : 0)));\n            tempSum = 0.0;\n        }\n    }\n    return result;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    return computeCovarianceMatrix(matrix, biasCorrected, false);\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    if (matrix == null) {\n        throw new MathIllegalArgumentException(\"Input matrix must not be null\");\n    } else if (matrix.getColumnDimension() < 2) {\n        throw new MathIllegalArgumentException(\"Input matrix must contain at least two columns\");\n    } else if (matrix.getRowDimension() < 2) {\n        throw new MathIllegalArgumentException(\"Input matrix must contain at least two rows\");\n    }\n    n = matrix.getRowDimension();\n    covarianceMatrix = matrix.copy();\n    if (biasCorrected) {\n        for (int i = 0; i < matrix.getColumnDimension(); i++) {\n            covarianceMatrix.setEntry(i, i, covarianceMatrix.getEntry(i, i) / (n - 1));\n        }\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    final int n = matrix.getRowDimension();\n    if (n < 2) {\n        throw new MathIllegalArgumentException(\"At least two rows are required to compute a covariance matrix.\");\n    }\n    if (matrix.getColumnDimension() < 1) {\n        throw new MathIllegalArgumentException(\"At least one column is required to compute a covariance matrix.\");\n    }\n\n    RealMatrix cov = matrix.createMatrix(matrix.getColumnDimension(), matrix.getColumnDimension());\n\n    for (int j = 0; j < matrix.getColumnDimension(); j++) {\n        double x_j_mean = 0.0;\n        for (int i = 0; i < n; i++) {\n            x_j_mean += matrix.getEntry(i, j);\n        }\n        x_j_mean /= n;\n\n        for (int j2 = 0; j2 <= j; j2++) {\n            double covariance_element = 0.0;\n            for (int i = 0; i < n; i++) {\n                covariance_element += (matrix.getEntry(i, j) - x_j_mean) * (matrix.getEntry(i, j2) - matrix.getEntry(i, j2));\n            }\n            if (biasCorrected) {\n                covariance_element /= (n - 1);\n            } else {\n                covariance_element /= n;\n            }\n            cov.setEntry(j, j2, covariance_element);\n            if (j != j2) {\n                cov.setEntry(j2, j, covariance_element);\n            }\n        }\n    }\n    return cov;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    n = matrix.getRowDimension();\n    covarianceMatrix = matrix.createMatrix(matrix.getColumnDimension(), matrix.getColumnDimension());\n    for (int i = 0; i < matrix.getColumnDimension(); i++) {\n        for (int j = i + 1; j < matrix.getColumnDimension(); j++) {\n            covarianceMatrix.setEntry(i, j, covariance(matrix.getColumnVector(i).getData(), matrix.getColumnVector(j).getData(), biasCorrected));\n            covarianceMatrix.setEntry(j, i, covarianceMatrix.getEntry(i, j));\n        }\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    n = matrix.getRowDimension();\n    covarianceMatrix = new Array2DRowRealMatrix(matrix.getColumnDimension(), matrix.getColumnDimension());\n    for (int i = 0; i < matrix.getColumnDimension(); i++) {\n        for (int j = i; j < matrix.getColumnDimension(); j++) {\n            covarianceMatrix.setEntry(i, j, covariance(matrix.getColumnVector(i), matrix.getColumnVector(j), biasCorrected));\n            covarianceMatrix.setEntry(j, i, covarianceMatrix.getEntry(i, j));\n        }\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    double temp = 0.0;\n    if (biasCorrected) {\n        temp = 1.0 / (n - 1);\n    } else {\n        temp = 1.0 / n;\n    }\n    RealMatrix tempMatrix = matrix.scalarMultiply(temp);\n    RealMatrix covarianceMatrix = tempMatrix.transpose().multiply(tempMatrix);\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    RealMatrix result = matrix.createMatrix(matrix.getColumnDimension(), matrix.getColumnDimension());\n    checkSufficientData(matrix);\n    n = matrix.getRowDimension();\n    for (int i = 0; i < matrix.getColumnDimension(); i++) {\n        for (int j = 0; j <= i; j++) {\n            result.setEntry(i, j, covariance(matrix.getColumnVector(i), matrix.getColumnVector(j), biasCorrected));\n            if (i != j) {\n                result.setEntry(j, i, result.getEntry(i, j));\n            }\n        }\n    }\n    return result;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    RealMatrix result = matrix.copy();\n    int n = result.getRowDimension();\n    if (n < 2) {\n        throw new MathIllegalArgumentException(\"Covariance requires at least two rows\");\n    }\n\n    for (int j = 0; j < result.getColumnDimension(); j++) {\n        for (int i = 0; i < j; i++) {\n            double sum = 0;\n            for (int k = 0; k < n; k++) {\n                sum += (result.getEntry(k, i) - result.getEntry(k, j))\n                        * (result.getEntry(k, i) - result.getEntry(k, j));\n            }\n            if (biasCorrected) {\n                result.setEntry(i, j, sum / (n - 1));\n            } else {\n                result.setEntry(i, j, sum / n);\n            }\n        }\n    }\n\n    // Make the matrix symmetric\n    for (int i = 0; i < result.getColumnDimension(); i++) {\n        for (int j = i + 1; j < result.getRowDimension(); j++) {\n            result.setEntry(j, i, result.getEntry(i, j));\n        }\n    }\n\n    return result;\n}"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) \n    {\n        return processBitsGreater57(count);\n    }\n\n    if (bitsCachedSize >= count) \n    {\n        final long result = bitsCached & MASKS[count];\n        bitsCachedSize -= count;\n        bitsCached >>>= count;\n        return result;\n    }\n\n    ensureCache(count);\n\n    final long result = bitsCached & MASKS[count];\n    bitsCachedSize -= count;\n    bitsCached >>>= count;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count == 0) \n        return 0L;\n\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) \n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE + \": \" + count);\n\n    if (count <= bitsCachedSize) \n    {\n        final long bitsOut = bitsCached >> (MAXIMUM_CACHE_SIZE - count);\n        bitsCachedSize -= count;\n        final long bitsLeft = bitsCached & MASKS[bitsCachedSize];\n        bitsCached = bitsLeft;\n        return bitsOut;\n    }\n\n    final int remainingBitsInCache = MAXIMUM_CACHE_SIZE - bitsCachedSize;\n    final int bytesNeeded = (count - remainingBitsInCache) / 8;\n    final int bitsNeeded = (count - remainingBitsInCache) % 8;\n\n    final byte[] buffer = new byte[bytesNeeded + 1];\n    int bytesRead = in.read(buffer, 0, bytesNeeded + 1);\n    if (bytesRead == -1) \n        return -1L;\n\n    final long bytesAsLong = fromLittleEndian(new ByteArrayInputStream(buffer), bytesNeeded + 1);\n    final long bitsOut = (bytesAsLong << remainingBitsInCache) | (bitsCached & MASKS[bitsNeeded]);\n    bitsCachedSize = bitsNeeded;\n    final long bitsLeft = bytesAsLong >> (8 - bitsNeeded);\n\n    if (bytesRead == buffer.length) \n        return bitsOut;\n\n    if (bytesNeeded == 0 && bitsNeeded == 0) \n        return bitsOut;\n\n    final long bitsRead = bytesNeeded * 8 + bitsNeeded;\n    final long bitsToSkip = count - bitsRead;\n\n    skip(in, bitsToSkip / 8L);\n\n    final int bitsToSkipMod8 = (int) (bitsToSkip % 8L);\n    final long skippedBits = fromLittleEndian(new ByteArrayInputStream(buffer, bytesNeeded, 1), 1);\n    final long skippedBitsShifted = skippedBits >> (8 - bitsToSkipMod8);\n    final long skippedBitsMask = MASKS[8 - bitsToSkipMod8];\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count == 0) \n    {\n        return 0;\n    }\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) \n    {\n        throw new IllegalArgumentException(\"count must be >= 0 and <= \" + MAXIMUM_CACHE_SIZE + \": \" + count);\n    }\n\n    if (bitsCachedSize >= count) \n    {\n        final long tmp = (bitsCached >> (bitsCachedSize - count));\n        bitsCachedSize -= count;\n        return tmp;\n    }\n\n    if (ensureCache(count)) \n    {\n        final long tmp = (bitsCached >> (bitsCachedSize - count));\n        bitsCachedSize -= count;\n        return tmp;\n    }\n\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        return processBitsGreater57(count);\n    }\n\n    if (bitsCachedSize >= count) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCachedSize -= count;\n        bitsCached >>>= count;\n        return bitsOut;\n    }\n\n    if (ensureCache(count)) {\n        final int bitsLeftInCache = MAXIMUM_CACHE_SIZE - bitsCachedSize;\n        final int bytesNeeded = (count - bitsLeftInCache) / 8 + 1;\n\n        final long newBits = fromLittleEndian(in, bytesNeeded) & MASKS[count - bitsLeftInCache];\n        final long bitsOut = (bitsCached << bitsLeftInCache) | (newBits >>> (8 - (count - bitsLeftInCache)));\n        bitsCachedSize = count - bitsLeftInCache;\n        bitsCached = newBits << bitsLeftInCache;\n        return bitsOut;\n    }\n\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count == 0) {\n        return 0;\n    }\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (bitsCachedSize >= count) {\n        final long bitsOut = bitsCached & MASKS[bitsCachedSize - count];\n        bitsCachedSize -= count;\n        if (bitsCachedSize == 0) {\n            bitsCached = 0;\n        } else {\n            bitsCached >>>= count;\n        }\n        return bitsOut;\n    }\n    int overflowBits = 0;\n    long overflow = 0l;\n    if (bitsCachedSize > 0) {\n        final int remainingBits = MAXIMUM_CACHE_SIZE - bitsCachedSize;\n        final long bitsOut = bitsCached & MASKS[remainingBits];\n        overflow = bitsCached >>> remainingBits;\n        overflowBits += remainingBits;\n        final long bitsToSkip = count - remainingBits;\n        if (bitsToSkip > 0) {\n            final int read = (int) Math.min(bitsToSkip / 8, Integer.BYTES);\n            final long readBits = fromLittleEndian(in, read);\n            final long skippedBits = readBits << (bitsToSkip - (8 * read));\n            overflow |= skippedBits;\n            overflowBits += (int) bitsToSkip - read * 8;\n        }\n        bitsCachedSize = 0;\n        final long result = (bitsOut << overflowBits) | overflow;\n        return result;\n    }\n    final int read = (int) Math.min(count / 8, Integer.BYTES);\n    final long bits = fromLittleEndian(in, read);\n    final int bitsToShift = count % 8;\n    final long masked = bits << (32 - bitsToShift);\n    final long result = (masked >>> 24) | overflow;\n    bitsCached = (bits & MASKS[bitsToShift]) << (MAXIMUM_CACHE_SIZE - bitsToShift);\n    bitsCachedSize = MAXIMUM_CACHE_SIZE - bitsToShift;\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        return processBitsGreater57(count);\n    }\n\n    if (bitsCachedSize >= count) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCachedSize -= count;\n        bitsCached >>>= count;\n        return bitsOut;\n    }\n\n    final int missing = count - bitsCachedSize;\n    final long bitsOut = bitsCached;\n    final byte[] buffer = new byte[1];\n\n    int read = in.read(buffer);\n    if (read == -1) {\n        if (bitsCachedSize == 0) {\n            return -1;\n        }\n\n        final long remainingBits = bitsCached & MASKS[bitsCachedSize];\n        bitsCachedSize = 0;\n        return remainingBits;\n    }\n\n    if (read == 0) {\n        throw new IOException(\"Unexpected end of stream\");\n    }\n\n    final long bytesAsBits = ((long) buffer[0] & 0xFFL) << bitsCachedSize;\n    bitsCached = bitsOut | bytesAsBits;\n    bitsCachedSize += 8;\n\n    if (bitsCachedSize >= count) {\n        final long result = bitsCached & MASKS[count];\n        bitsCachedSize -= count;\n        bitsCached >>>= count;\n        return result;\n    }\n\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count == 0)\n    {\n        return 0l;\n    }\n\n    if (count >= MAXIMUM_CACHE_SIZE)\n    {\n        return processBitsGreater57(count);\n    }\n\n    if (bitsCachedSize >= count)\n    {\n        final long bitsOut = bitsCached >> (MAXIMUM_CACHE_SIZE - count);\n        bitsCachedSize -= count;\n        bitsCached &= MASKS[bitsCachedSize];\n        return bitsOut;\n    }\n\n    if (count > MAXIMUM_CACHE_SIZE - bitsCachedSize)\n    {\n        final long bitsOut = bitsCached << (MAXIMUM_CACHE_SIZE - bitsCachedSize);\n        final long remainingBits = count - (MAXIMUM_CACHE_SIZE - bitsCachedSize);\n        final long bitsFromStream = fromLittleEndian(in, (int) (remainingBits / 8l));\n        bitsCachedSize = 0;\n        final long bitsToMask = MASKS[(int) remainingBits % 8];\n        final long bitsToShift = bitsFromStream & bitsToMask;\n        bitsCached = bitsOut | bitsToShift;\n        return bitsOut >> (MAXIMUM_CACHE_SIZE - count);\n    }\n\n    final int bytesNeeded = (count + 7) >> 3;\n    final int bytesRead = Math.min(bytesNeeded, in.available());\n    if (bytesRead == 0)\n    {\n        return -1;\n    }\n\n    final long bytesToShift = (bytesNeeded - bytesRead) << 3;\n    final long bitsFromStream = fromLittleEndian(in, bytesRead) << bytesToShift;\n    final long bitsOut = bitsCached | bitsFromStream;\n    bitsCachedSize = count % 8;\n    bitsCached &= MASKS[bitsCachedSize];\n    return bitsOut >> (MAXIMUM_CACHE_SIZE - count);\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE + \", but was \" + count);\n    }\n\n    if (count <= bitsCachedSize) {\n        final long bitsOut = bitsCached & MASKS[bitsCachedSize - count];\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n\n    final long bitsInCache = MAXIMUM_CACHE_SIZE - bitsCachedSize;\n    final long bitsOut = bitsCached << bitsInCache;\n    final long bitsToFetch = count - bitsInCache;\n\n    long l = fromLittleEndian(in, (int) Math.ceil(bitsToFetch / 8f));\n    if (byteOrder == ByteOrder.BIG_ENDIAN) {\n        l = Long.reverseBytes(l);\n    }\n\n    final long fetchedBits = Math.min(bitsToFetch, 64l - bitsInCache);\n    final long bitsToAdd = (l >>> (64 - fetchedBits)) & MASKS[(int) fetchedBits];\n    final long result = bitsOut | bitsToAdd;\n\n    bitsCachedSize += fetchedBits;\n    bitsCached |= (l << (bitsCachedSize - bitsToFetch));\n\n    if (fetchedBits < bitsToFetch) {\n        final long remainingBits = bitsToFetch - fetchedBits;\n        final int remainingByteCount = (int) Math.ceil(remainingBits / 8f);\n        final byte[] remainingBytes = new byte[remainingByteCount];\n        final int read = in.read(remainingBytes);\n        if (read < remainingByteCount) {\n            throw new EOFException(\"Unable to read remaining bits\");\n        }\n\n        for (int i = 0; i < remainingByteCount; i++) {\n            final long b = remainingBytes[i] & 0xFFL;\n            final long shifted = b << ((remainingByteCount - i - 1) * 8);\n            bitsCached |= shifted;\n            bitsCachedSize += 8;\n        }\n    }\n\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count == 0) \n        return 0L;\n\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) \n        throw new IllegalArgumentException(\"requested bits (\" + count + \") must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n\n    if (count <= bitsCachedSize) \n    {\n        final long result = bitsCached & MASKS[bitsCachedSize - count];\n        bitsCachedSize -= count;\n        return result;\n    }\n\n    long result = bitsCached & MASKS[bitsCachedSize];\n    final int missingCount = count - bitsCachedSize;\n\n    final int byteCount = missingCount / 8;\n    final int leftOverBits = missingCount % 8;\n\n    final byte[] buf = new byte[1 + byteCount];\n\n    final int readCount = in.read(buf);\n    if (readCount == -1) \n        throw new EOFException(\"Unexpected end of stream\");\n\n    if (leftOverBits == 0) \n    {\n        for (int i = 0; i < byteCount; i++) \n            result = (result << 8) | (buf[i] & 0xFF);\n    }\n    else \n    {\n        for (int i = 0; i < byteCount; i++) \n            result = (result << 8) | (buf[i] & 0xFF);\n\n        final int shift = 8 - leftOverBits;\n        final int maskedValue = (buf[byteCount] & 0xFF) >> shift;\n        result = (result << leftOverBits) | maskedValue;\n    }\n\n    bitsCachedSize = leftOverBits;\n    bitsCached = result;\n\n    return result;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        return processBitsGreater57(count);\n    }\n    while (bitsCachedSize < count) {\n        final int byteCount = in.read();\n        if (byteCount == -1) {\n            return (bitsCachedSize == 0) ? -1 : bitsCached & MASKS[bitsCachedSize];\n        }\n        final long byteValue = (long) byteCount & 0xFFL;\n        bitsCached = (bitsCached << 8) + byteValue;\n        bitsCachedSize += 8;\n    }\n    final long bitsOut = bitsCached & MASKS[count];\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return bitsOut;\n}"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n    if (data.length != v.data.length) throw new DimensionMismatchException(\"Cannot compute outer product: incompatible dimensions\");\n    FieldMatrix<T> result = new Array2DRowFieldMatrix<>(field, data.length, data.length);\n    for (int i = 0; i < data.length; i++) {\n        for (int j = 0; j < data.length; j++) {\n            result.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return result;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n    if (v.getDimension() != data.length) {\n        throw new DimensionMismatchException(\"Dimension of v must be same as this\");\n    }\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n    if (data.length != v.data.length) throw new DimensionMismatchException(\"Outer product can only be computed between vectors of the same dimension\");\n    final int m = data.length;\n    final FieldMatrix<T> product;\n    if (v instanceof SparseRealVector || this instanceof SparseRealVector) {\n        product = new OpenMapRealMatrix(m, m);\n    } else {\n        product = new Array2DRowRealMatrix(m, m);\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            product.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return product;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n    if (data.length != v.data.length) \n    throw new DimensionMismatchException(\"Two vectors must have the same dimension\");\n    FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, data.length, data.length);\n    for (int i = 0; i < data.length; i++) {\n        for (int j = 0; j < v.data.length; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> product;\n    if (v instanceof SparseArrayFieldVector || this instanceof SparseArrayFieldVector) {\n        product = new OpenMapFieldMatrix<T>(field, m, n);\n    } else {\n        product = new Array2DRowFieldMatrix<T>(field, m, n);\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            product.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return product;\n}"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n   if (label == null) {\n     return true;\n   }\n   Node name;\n   if (target.getType() == Token.LABEL) {\n     name = target.getFirstChild();\n   } else {\n     name = getNextSiblingOfType(target, Token.LABEL);\n   }\n   if (name == null) {\n     return false;\n   }\n   return label.equals(name.getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    return label == null || target.getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n\tif (label == null) {\n\t\treturn true;\n\t}\n\treturn target.isLabelName() && target.getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    return label == null || label.equals(target.getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    Node node = target.getParent();\n    if (node.isLabel()) {\n      return label.equals(node.getFirstChild().getString());\n    } else {\n      return false;\n    }\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    return label == null || label.equals(target.getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    Node cur = target;\n    while (cur.getType() != Token.LABEL) {\n      cur = cur.getParent();\n    }\n    return label.equals(cur.getFirstChild().getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n   if (label == null) {\n      return true;\n   }\n   if (target.isLabel()) {\n      return target.getFirstChild().getString().equals(label);\n   } else {\n      Node parent = target.getParent();\n      if (parent.isLabel()) {\n         return parent.getFirstChild().getString().equals(label);\n      } else {\n         return false;\n      }\n   }\n}",
      "private static boolean matchLabel(Node target, String label)  {\n   if (label == null) {\n      return true;\n   }\n   if (target.getType() == Token.LABEL) {\n      return label.equals(target.getFirstChild().getString());\n   }\n   return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    return label == null || label.equals(target.getString());\n}"
    ],
    [
      "public String getURL(int series, int item)  {\n    String result = this.urlSeries.get(series).get(item);\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = \"\";\n\n    Comparable seriesKey = dataset.getSeriesKey(series);\n    if (seriesKey != null) {\n        result += this.seriesParameterName + \"=\" + URLEncoder.encode(seriesKey.toString(), \"UTF-8\");\n    }\n\n    long x = (long) dataset.getXValue(series, item);\n    String xValue = this.dateFormat.format(new Date(x));\n    result += this.itemParameterName + \"=\" + URLEncoder.encode(xValue, \"UTF-8\");\n\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = this.prefix;\n    boolean firstParameter = result.indexOf(\"?\") == -1;\n    Comparable seriesKey = dataset.getSeriesKey(series);\n    if (seriesKey != null) \n    {\n        result += firstParameter ? \"?\" : \"&amp;\";\n        String s = null;\n        try \n        {\n            s = URLEncoder.encode(seriesKey.toString(), \"UTF-8\");\n        } \n        catch (UnsupportedEncodingException e)\n        {\n            s = seriesKey.toString();\n        }\n        result += this.seriesParameterName + \"=\" + s;\n        firstParameter = false;\n    }\n\n    long x = (long) dataset.getXValue(series, item);\n    String xValue = this.dateFormat.format(new Date(x));\n    result += firstParameter ? \"?\" : \"&amp;\";\n    String s = null;\n    try \n    {\n        s = URLEncoder.encode(xValue, \"UTF-8\");\n    } \n    catch (UnsupportedEncodingException e)\n    {\n        s = xValue;\n    }\n    result += this.itemParameterName + \"=\" + s;\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = \"\";\n\n    List seriesList = (List)urlSeries.get(series);\n    if (seriesList != null && seriesList.size() > item)\n    {\n        result = (String)seriesList.get(item);\n    }\n\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = this.urlSeries.get(series).get(item);\n    if (result == null)\n    {\n        return generateURL(null, series, item);\n    }\n    else \n    {\n        return result;\n    }\n}",
      "public String getURL(int series, int item)  {\n    String result = \"\";\n    if (urlSeries.size() > series)\n    {\n        List<String> urls = (ArrayList<String>)urlSeries.get(series);\n        if (urls.size() > item)\n        {\n            result = urls.get(item);\n        }\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urlList = (List) this.urlSeries.get(series);\n    if (urlList != null) {\n        result = (String) urlList.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = this.prefix;\n    boolean firstParameter = result.indexOf(\"?\") == -1;\n    Comparable seriesKey = dataset.getSeriesKey(series);\n    if (seriesKey != null) \n    {\n        result += firstParameter ? \"?\" : \"&amp;\";\n        String s = null;\n        try \n        {\n            s = URLEncoder.encode(seriesKey.toString(), \"UTF-8\");\n        } \n        catch (UnsupportedEncodingException e) \n        {\n            s = seriesKey.toString();\n        }\n        result += this.seriesParameterName + \"=\" + s;\n        firstParameter = false;\n    }\n\n    long x = (long) dataset.getXValue(series, item);\n    String xValue = this.dateFormat.format(new Date(x));\n    result += firstParameter ? \"?\" : \"&amp;\";\n    String s = null;\n    try \n    {\n        s = URLEncoder.encode(xValue, \"UTF-8\");\n    } \n    catch (UnsupportedEncodingException e) \n    {\n        s = xValue;\n    }\n    result += this.itemParameterName + \"=\" + s;\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = \"\";\n    if (urlSeries.size() > series && urlSeries.get(series) != null) {\n        List urls = (List) urlSeries.get(series);\n        if (urls.size() > item) {\n            result = (String) urls.get(item);\n        }\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    if (item >= 0 && item < getListCount()) \n    {\n        List urls = (List) this.urlSeries.get(item);\n        if (urls != null && item >= 0 && item < urls.size()) \n        {\n            result = (String) urls.get(item);\n        }\n    }\n    return result;\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    if (str.charAt(0) != '0') {\n        return Integer.parseInt(str);\n    }\n    if (str.length() > 1) {\n        return Integer.parseInt(str.substring(1));\n    } else {\n        return -1; // 0 is a valid index\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    int result = 0;\n    for (int i = 0; i < str.length(); ++i) \n    {\n        char c = str.charAt(i);\n        if (c >= '0' && c <= '9') \n        {\n            result = (result << 3) | (c - '0');\n        } \n        else \n        {\n            throw new NumberFormatException(\"Expected digits in JSON Pointer index\");\n        }\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  throws NumberFormatException\n{\n    int len = str.length();\n    if (len > 11) {\n        throw new NumberFormatException(\"Number too large, max Integer size is 10 digits\");\n    }\n    boolean negative = false;\n    if (len > 0 && str.charAt(0) == '-') {\n        negative = true;\n        len--;\n    }\n    int num = 0;\n    for (int i = 0; i < len; i++) {\n        int ch = (int) str.charAt(i);\n        if (ch >= '0' && ch <= '9') {\n            if (num > Integer.MAX_VALUE / 10) {\n                throw new NumberFormatException(\"Number too large, max Integer size is 10 digits\");\n            }\n            num *= 10;\n            if (num > Integer.MAX_VALUE - (ch - '0')) {\n                throw new NumberFormatException(\"Number too large, max Integer size is 10 digits\");\n            }\n            num += (ch - '0');\n        } else {\n            throw new NumberFormatException(\"Expected digits at this position\");\n        }\n    }\n    return (negative ? -num : num);\n}\n\nprotected static JsonPointer _parseTail(String input) {\n    int len = input.length();\n    if (len == 0) {\n        return JsonPointer.EMPTY;\n    }\n    int i = 0;\n    int start = 0;\n    for (; i < len; i++) {\n        int ch = (int) input.charAt(i);\n        if (ch == SEPARATOR) {\n            break;\n        }\n        if (ch == '\\\"') {\n            i++;\n            while (i < len) {\n                ch = (int) input.charAt(i);\n                if (ch == '\\\"') {\n                    i++;\n                    break;\n                }\n                if (ch == '\\\\') {\n                    i++;\n                }\n                i++;\n            }\n        } else if (ch < ' ' || (ch >= 0x7F && ch != '\\t')) {\n}\n}\n}",
      "private final static int _parseIndex(String str)  throws JsonParseException {\n    int len = str.length();\n    if (len == 0) {\n        throw new JsonParseException(\"Unexpected token: empty number\");\n    }\n    char c0 = str.charAt(0);\n    if (c0 == '-') {\n        if (len == 1) {\n            throw new JsonParseException(\"Unexpected token: '-'\");\n        }\n        boolean negative = true;\n        int i = 1;\n        if (str.charAt(i) == '0') {\n            if (len != 2) {\n                throw new JsonParseException(\"Unexpected token: '-0'\");\n            }\n            return negative ? 0 : 0;\n        }\n        int result = _parseInt(str, 1, negative);\n        if (result < MIN_INT_AS_LONG) {\n            throw new JsonParseException(\"Numeric overflow, number too small: \" + str);\n        }\n        return (int) result;\n    } else {\n        boolean negative = false;\n        int result = _parseInt(str, 0, negative);\n        if (result > MAX_INT_AS_LONG) {\n            throw new JsonParseException(\"Numeric overflow, number too large: \" + str);\n        }\n        return (int) result;\n    }\n}",
      "private final static int _parseIndex(String str)  throws IllegalArgumentException\n{\n    if (str.length() > 10) {\n        throw new IllegalArgumentException(\"Numeric value too large: \"+str);\n    } else if (str.length() == 10 && str.charAt(9) > '5') {\n        throw new IllegalArgumentException(\"Numeric value too large: \"+str);\n    } else if (str.length() == 10) {\n        return Integer.parseInt(str);\n    } else {\n        return Integer.parseInt(str, 8);\n    }\n}",
      "private final static int _parseIndex(String str)  throws JsonParseException\n{\n    if (str.length() >= 10) {\n        throw new JsonParseException(\"Numeric overflow in index\");\n    }\n    int result = 0;\n    for (int i = 0; i < str.length(); ++i) {\n        char c = str.charAt(i);\n        if (c >= '0' && c <= '9') {\n            result = result * 10 + (c - '0');\n        } else {\n            throw new JsonParseException(\"Invalid character in index: expected digit, got '\"+c+\"'\");\n        }\n    }\n    return result;\n}\n\nprotected static JsonPointer _parseTail(String input) \nthrows JsonParseException\n{\n    String segment = null;\n    int matchIndex = -1;\n    while (true) {\n        int i = input.indexOf(JsonPointer.SEPARATOR, 0);\n        if (i < 0) {\n            segment = input;\n            break;\n        }\n        String token = input.substring(0, i);\n        if (segment == null) {\n            segment = token;\n        } else {\n            segment = _fullPath(JsonPointer.valueOf(segment), token);\n        }\n        input = input.substring(i + 1);\n        if (input.startsWith(\"#/\")) {\n            input = input.substring(2);\n            matchIndex = Integer.parseInt(input);\n            break;\n        }\n    }\n    return (matchIndex >= 0) ? new JsonPointer(null, segment, matchIndex, null) : new JsonPointer(null, segment, null);\n}\n\nprotected static JsonPointer _parseQuotedTail(String input, int i) \nthrows JsonParseException\n{\n    boolean escaped = false;\n    StringBuilder builder = new StringBuilder();\n    while (++i < input.length()) {\n        char c = input.charAt(i);\n        if (c == '\\\\' && !escaped) {\n            escaped = true;\n        } else if (c == '\"') {\n            if (!escaped) {\n                return new JsonPointer(null, builder.toString(), null);\n            } else {\n                escaped = false;\n            }\n        } else {\n            builder.append(c);\n        }\n}\n}",
      "private final static int _parseIndex(String str)  throws NumberFormatException\n{\n    int result = 0;\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if (c >= '0' && c <= '9') {\n            result = (result << 3) + (result << 1) + (c - '0');\n        } else if (c >= 'a' && c <= 'f') {\n            result = (result << 3) + (result << 1) + (c - 'a' + 10);\n        } else if (c >= 'A' && c <= 'F') {\n            result = (result << 3) + (result << 1) + (c - 'A' + 10);\n        } else {\n            throw new NumberFormatException(\"Expected digit character in number, but found '\"+c+\"'\");\n        }\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  throws NumberFormatException\n{\n    int len = str.length();\n    if (len == 1) {\n        switch (str.charAt(0)) {\n            case '0': return 0;\n            case '1': return 1;\n            case '2': return 2;\n            case '3': return 3;\n            case '4': return 4;\n            case '5': return 5;\n            case '6': return 6;\n            case '7': return 7;\n            case '8': return 8;\n            case '9': return 9;\n            default: throw new NumberFormatException(\"Unexpected character in number: \" + str);\n        }\n    }\n    if (len == 2) {\n        if (str.charAt(0) == '0') {\n            throw new NumberFormatException(\"Unexpected character in number: \" + str);\n        }\n        switch (str.charAt(1)) {\n            case '0': return 10;\n            case '1': return 11;\n            case '2': return 12;\n            case '3': return 13;\n            case '4': return 14;\n            case '5': return 15;\n            case '6': return 16;\n            case '7': return 17;\n            case '8': return 18;\n            case '9': return 19;\n            default: throw new NumberFormatException(\"Unexpected character in number: \" + str);\n        }\n    }\n    if (len == 3) {\n        if (str.charAt(0) == '0') {\n            throw new NumberFormatException(\"Unexpected character in number: \" + str);\n        }\n        if (str.charAt(1) == '0') {\n            throw new NumberFormatException(\"Unexpected character in number: \" + str);\n        }\n        switch (str.charAt(2)) {\n            case '0': return 20;\n            case '1': return 21;\n            case '2': return 22;\n            case '3': return 23;\n            case '4': return 24;\n            case '5': return 25;\n}\n}\n}",
      "private final static int _parseIndex(String str)  throws JsonParseException\n{\n    if (str.length() > 10) {\n        throw new JsonParseException(\"Integer overflow: \"+str);\n    }\n    if (str.length() > 9) {\n        if (str.charAt(0) != '2') {\n            throw new JsonParseException(\"Integer overflow: \"+str);\n        }\n        char ch = str.charAt(1);\n        if (ch < '0' || ch > '3') {\n            throw new JsonParseException(\"Integer overflow: \"+str);\n        }\n        long result = Long.parseLong(str, 8);\n        if (result > Integer.MAX_VALUE) {\n            throw new JsonParseException(\"Integer overflow: \"+str);\n        }\n        return (int) result;\n    }\n    if (str.length() == 9) {\n        char ch = str.charAt(0);\n        if (ch < '0' || ch > '1') {\n            throw new JsonParseException(\"Integer overflow: \"+str);\n        }\n        long result = Long.parseLong(str, 8);\n        if (result > Integer.MAX_VALUE) {\n            throw new JsonParseException(\"Integer overflow: \"+str);\n        }\n        return (int) result;\n    }\n    long result = Long.parseLong(str, 10);\n    if (result > Integer.MAX_VALUE) {\n        throw new JsonParseException(\"Integer overflow: \"+str);\n    }\n    return (int) result;\n}\nprotected static JsonPointer _parseTail(String input)\nthrows JsonParseException\n{\n    int len = input.length();\n    if (len == 0) {\n        throw new JsonParseException(\"Unexpected end of JSON pointer\");\n    }\n    if (input.charAt(0) == '#') {\n        if (len == 1) {\n            throw new JsonParseException(\"Unexpected end of JSON pointer\");\n        }\n        return new JsonPointer(input.substring(1));\n    }\n    if (len == 1 && input.charAt(0) == '/') {\n        return EMPTY;\n    }\n    if (input.charAt(0) == '[') {\n        return _parseArrayIndex(input.substring(1));\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    if (str.charAt(0) != '0') {\n        return Integer.parseInt(str);\n    }\n    if (str.length() > 1) {\n        return Integer.parseInt(str.substring(1));\n    }\n    return 0;\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node callNode = new Node(Token.CALL, srcref);\n  callNode.addChildToFront(NodeUtil.getFunction(methodName));\n  callNode.addChildToFront(argumentNode);\n  return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  // ...\n  if (methodName.equals(\"define\")) {\n    if (!verifyDefine(t, expr, methodName, args)) {\n      return null;\n    }\n    return buildCallNode(methodName, arg, srcref);\n  } else if (methodName.equals(\"require\")) {\n    if (!verifyProvide(t, methodName, arg)) {\n      return null;\n    }\n    return buildCallNode(methodName, arg, srcref);\n  } else {\n    return buildCallNode(methodName, argumentNode, srcref);\n  }\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node callNode = new Node(Token.CALL);\n  callNode.addChildToFront(new Node(Token.NAME, methodName));\n  callNode.addChildToFront(argumentNode);\n  callNode.setSrcRef(srcref);\n\n  return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node expr = new Node(Token.NAME, methodName, -1, -1);\n    if (srcref != null) {\n      expr = srcref.copyInformationFrom(expr);\n    }\n    return new Node(Token.CALL, expr, argumentNode);\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  // ...\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  if (methodName.equals(\"define\")) {\n    Node expr = new StringNode(Token.STRING, \"var a = \" + argumentNode.toString() + \";\");\n    expr.setStaticSourceFile(srcref.getStaticSourceFile());\n    expr.setSourcePosition(srcref.getSourcePosition());\n    return expr;\n  }\n  if (methodName.equals(\"provide\")) {\n    Node expr = new StringNode(Token.STRING, \"var a = \" + argumentNode.toString() + \";\");\n    expr.setStaticSourceFile(srcref.getStaticSourceFile());\n    expr.setSourcePosition(srcref.getSourcePosition());\n    return expr;\n  }\n  return new CallNode(Token.NAME, methodName, argumentNode, srcref);\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    NodeCall nodeCall = new NodeCall(Token.NAME, methodName, null);\n    nodeCall.addChild(argumentNode);\n    nodeCall.setSourcePosition(srcref.getSourcePosition());\n    return nodeCall;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node left = NodeUtil.createName(methodName);\n    left.setChangeTime(left.getChangeTime() | argumentNode.getChangeTime());\n\n    if (argumentNode != null) {\n      left = NodeUtil.createCall(left, argumentNode);\n    }\n    left.setChangeTime(left.getChangeTime() | srcref.getChangeTime());\n    left = NodeUtil.srcrefTree(left, srcref);\n    return left;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  if (argumentNode.getType() == Token.NUMBER) {\n    return new NumberNode(methodName, argumentNode.getDouble(), srcref);\n  }\n  return new StringNode(methodName, argumentNode.getString(), srcref);\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node[] children = new Node[2];\n  children[0] = newName(methodName);\n  children[1] = argumentNode;\n  return new CallNode(null, children, srcref);\n}"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n    final int size = doubles.length;\n    final DoubleIndex[] sortedIndexes = new DoubleIndex[size];\n\n    // Create an array of indices and fill it with values from 0 to size - 1\n    final int[] indices = new int[size];\n    for (int i = 0; i < size; i++) {\n        indices[i] = i;\n    }\n\n    // Fill sortedIndexes with DoubleIndex objects, containing the fitness values\n    for (int i = 0; i < size; i++) {\n        sortedIndexes[i] = new DoubleIndex(doubles[i], i);\n    }\n\n    // Sort the array using the compareTo method of DoubleIndex\n    Arrays.sort(sortedIndexes);\n\n    // Extract the sorted indices from the sortedIndexes array\n    final int[] result = new int[size];\n    for (int i = 0; i < size; i++) {\n        result[i] = sortedIndexes[i].index;\n    }\n\n    return result;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] doubleIndices = new DoubleIndex[doubles.length];\n    for (int r = 0; r < doubles.length; r++) {\n        doubleIndices[r] = new DoubleIndex(doubles[r], r);\n    }\n\n    // Sort indexes by value\n    Arrays.sort(doubleIndices);\n\n    // Extract original indices\n    final int[] sortedIndices = new int[doubles.length];\n    for (int r = 0; r < doubles.length; r++) {\n        sortedIndices[r] = doubleIndices[r].index;\n    }\n\n    return sortedIndices;\n}\n\n// Normalizes fitness values to the range [0,1]. Adds a penalty to the\n// fitness value if out of range. The penalty is adjusted by calling",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n\n    // Create an array of indices for the fitness values\n    final int[] indices = new int[len];\n    for (int i = 0; i < len; i++) {\n        indices[i] = i;\n    }\n\n    // Sort the indices based on the fitness values\n    Arrays.sort(indices, new DoubleIndex(doubles));\n\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = IntStream.range(0, doubles.length).toArray();\n    Arrays.sort(indices, new DoubleIndexComparator(doubles));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    final int[] result = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        result[i] = indices[i].index;\n    }\n    return result;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    final int[] result = new int[doubles.length];\n    for (int i = 0; i < result.length; i++) {\n        result[i] = indices[i].index;\n    }\n    return result;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int N = doubles.length;\n    final DoubleIndex[] indices = new DoubleIndex[N];\n    for (int i = 0; i < N; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n\n    Arrays.sort(indices);\n\n    final int[] sortedIndices = new int[N];\n    for (int i = 0; i < N; i++) {\n        sortedIndices[i] = indices[i].index;\n    }\n\n    return sortedIndices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    final int[] sortedIndices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        sortedIndices[i] = indices[i].index;\n    }\n    return sortedIndices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = IntStream.range(0, doubles.length).toArray();\n    Arrays.sort(indices, new DoubleIndexComparator(doubles));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    final int[] result = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        result[i] = indices[i].index;\n    }\n    return result;\n}"
    ],
    [
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        int m = householderVectors.length;\n        double[][] pa = new double[m][m];\n        for (int j = 0; j < m; ++j) \n        {\n            for (int i = 0; i <= j; ++i) \n            {\n                if (i == j) \n                {\n                    pa[i][j] = 1.0;\n                } \n                else if (i == j - 1) \n                {\n                    pa[i][j] = householderVectors[j][j - 1];\n                } \n                else if (i > j - 1) \n                {\n                    pa[i][j] = 0.0;\n                } \n                else \n                {\n                    pa[i][j] = householderVectors[j][i];\n                }\n            }\n        }\n\n        cachedQt = MatrixUtils.createRealMatrix(pa);\n    }\n\n    // return the cached matrix\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        int m = householderVectors.length;\n        double[][] pa = new double[m][m];\n        for (int j = 0; j < m; ++j) \n        {\n            for (int i = 0; i <= j; ++i) \n            {\n                if (i == j) \n                {\n                    pa[i][j] = 1.0;\n                } \n                else \n                {\n                    pa[i][j] = 0.0;\n                }\n            }\n        }\n        for (int j = 0; j < m - 1; ++j) \n        {\n            double g = 0.0;\n            for (int i = j; i < m; ++i) \n            {\n                g += householderVectors[i][j] * pa[i][j - 1];\n            }\n            g = (g / householderVectors[j][j - 1]) / householderVectors[j][j - 1];\n            for (int i = j; i < m; ++i) \n            {\n                pa[i][j] += g * householderVectors[i][j - 1];\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(pa);\n    }\n    // return the cached matrix\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = householderVectors.length;\n        final double[][] qt = new double[m][m];\n        for (int j = 0; j < m; ++j) {\n            // copy the entry of the lower sub-diagonal\n            qt[j][j - 1] = householderVectors[j][j - 1];\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qt);\n    }\n\n    // return the cached matrix\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = householderVectors.length;\n        final double[][] q = new double[m][m];\n\n        // orthogonal similarity transformation\n        // (note: this implementation avoids unnecessary computation)\n        for (int j = 0; j < m - 1; ++j) {\n            double p = householderVectors[j][j + 1];\n            for (int i = j; i < m; ++i) {\n                q[i][j] = p * householderVectors[i][j + 1];\n            }\n        }\n\n        // orthogonal similarity transformation\n        // (note: this implementation avoids unnecessary computation)\n        for (int j = m - 2; j >= 0; --j) {\n            double p = householderVectors[j][j + 1];\n            for (int i = j; i >= 0; --i) {\n                q[i][j] -= p * q[i + 1][j + 1];\n            }\n        }\n\n        cachedQt = MatrixUtils.createRealMatrix(q);\n    }\n\n    // return the cached matrix\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = householderVectors.length;\n        final int n = householderVectors[0].length;\n        final double[][] qt = new double[n][m];\n\n        // compute the inverse of the Q matrix\n        for (int j = 0; j < n; ++j) {\n            for (int i = 0; i <= j; ++i) {\n                double sum = householderVectors[i][j];\n                if (i > 0) {\n                    for (int k = 0; k < i; ++k) {\n                        sum -= qt[k][j] * householderVectors[i][k];\n                    }\n                }\n                qt[i][j] = sum / householderVectors[i][i];\n            }\n        }\n\n        cachedQt = MatrixUtils.createRealMatrix(qt);\n    }\n\n    // return the cached matrix\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = householderVectors.length;\n        final int n = householderVectors[0].length;\n        final double[][] qt = new double[n][m];\n\n        for (int j = 0; j < n; ++j) {\n            for (int i = 0; i <= j; ++i) {\n                qt[j][i] = householderVectors[i][j];\n            }\n        }\n\n        cachedQt = MatrixUtils.createRealMatrix(qt);\n    }\n\n    // return the cached matrix\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        final double[][] q = new double[m][m];\n\n        // orthogonal similarity transformation\n        for (int i = 0; i < m - 1; ++i) \n        {\n            final double p = Math.sqrt(householderVectors[i][i] * householderVectors[i][i] +\n                                      householderVectors[i + 1][i] * householderVectors[i + 1][i]);\n\n            if (p == 0) \n            {\n                throw new RuntimeException(\"Zero p-value in Householder transformation\");\n            }\n\n            final double c = householderVectors[i][i] / p;\n            final double s = householderVectors[i + 1][i] / p;\n\n            for (int j = 0; j <= i; ++j) \n            {\n                final double q_ji = q[j][i];\n                final double q_jj = q[j][i + 1];\n                q[j][i] = c * q_ji - s * q_jj;\n                q[j][i + 1] = s * q_ji + c * q_jj;\n            }\n        }\n\n        // copy the diagonal elements\n        for (int i = 0; i < m; ++i) {\n            q[i][i] = 1;\n        }\n\n        // cache the matrix for subsequent calls\n        cachedQt = MatrixUtils.createRealMatrix(q);\n    }\n\n    // return the cached matrix\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        final double[][] qt = new double[m][m];\n\n        // Copy upper triangular part of Q\n        for (int i = 0; i < m; ++i) \n        {\n            for (int j = 0; j <= i; ++j) \n            {\n                qt[i][j] = householderVectors[i][j];\n            }\n        }\n\n        // Set lower triangular part to zeros\n        for (int i = 1; i < m; ++i) \n        {\n            for (int j = 0; j < i; ++j) \n            {\n                qt[i][j] = 0.0;\n            }\n        }\n\n        cachedQt = MatrixUtils.createRealMatrix(qt);\n    }\n\n    // return the cached matrix\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = householderVectors.length;\n        final int n = householderVectors[0].length;\n        final double[][] qt = new double[n][m];\n\n        // compute the elements of the matrix\n        for (int j = 0; j < n; ++j) {\n            for (int i = 0; i <= j; ++i) {\n                qt[j][i] = householderVectors[i][j];\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qt);\n    }\n\n    // return the cached matrix\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = householderVectors.length;\n        final int n = householderVectors[0].length;\n        final double[][] qt = new double[n][m];\n\n        for (int j = 0; j < n; ++j) {\n            for (int i = 0; i <= j; ++i) {\n                qt[j][i] = householderVectors[i][j];\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qt);\n    }\n    return cachedQt;\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) {\n        return this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> transformedSet = new HashSet<>();\n    for (E element : set) \n    {\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> transformedSet = new HashSet<>();\n    for (E element : set) {\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> transformedSet = new HashSet<>();\n    for (E element : set)\n    {\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> transformedSet = new HashSet<>();\n    for (E element : set) {\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> transformedSet = new HashSet<>();\n    for (E element : set)\n    {\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> transformedSet = new HashSet<>();\n    for (E element : set) \n    {\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> transformedSet = new HashSet<>();\n    for (E element : set) {\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> transformedSet = new HashSet<>();\n    for (E element : set)\n    {\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> transformedSet = new HashSet<>();\n    for (E element : set) \n    {\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    Set<E> transformedSet = new HashSet<>();\n    for (E element : set)\n    {\n        transformedSet.add(transformer.transform(element));\n    }\n    return transformedSet;\n}"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity <= buffer.length) {\n        return this;\n    }\n    final char[] old = buffer;\n    buffer = new char[Math.max(capacity, old.length * 2)];\n    System.arraycopy(old, 0, buffer, 0, size);\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        char[] newBuffer = new char[Math.max(capacity, buffer.length * 2)];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length)\n    {\n        final char[] old = buffer;\n        buffer = new char[Math.max(capacity, old.length * 2)];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length)\n    {\n        final char[] old = buffer;\n        buffer = new char[Math.max(capacity, old.length * 2)];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length)\n    {\n        final char[] old = buffer;\n        buffer = new char[Math.max(old.length * 2, capacity)];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity <= buffer.length) {\n        return this;\n    }\n    char[] oldBuffer = buffer;\n    int newSize = Math.max(oldBuffer.length << 1, capacity);\n    buffer = new char[newSize];\n    System.arraycopy(oldBuffer, 0, buffer, 0, size);\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        final int newCapacity = Math.max(old.length << 1, capacity);\n        buffer = new char[newCapacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        char[] old = buffer;\n        buffer = new char[Math.max(old.length * 2, capacity)];\n        System.arraycopy(old, 0, buffer, 0, old.length);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[Math.max(capacity, old.length * 2)];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity <= buffer.length) \n    {\n        return this;\n    }\n    // TODO: Consider using a larger prime number for the new capacity to avoid frequent re-allocations.\n    final int newCapacity = Math.max(Math.max(buffer.length * 2, capacity), CAPACITY);\n    final char[] old = buffer;\n    buffer = new char[newCapacity];\n    System.arraycopy(old, 0, buffer, 0, size);\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    return findCumulativeRangeBounds(dataset, true);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    Range result = findStackedRangeBounds(dataset);\n    if (result != null) {\n        double lower = result.getLowerBound();\n        if (lower < dataset.getRangeLowerBound()) {\n            lower = dataset.getRangeLowerBound();\n        }\n        double upper = result.getUpperBound();\n        if (upper > dataset.getRangeUpperBound()) {\n            upper = dataset.getRangeUpperBound();\n        }\n        result = new Range(lower, upper);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    Range result = findRangeBounds(dataset, true);\n    if (result != null) \n    {\n        result = Range.shift(result, -result.getLowerBound(), false);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    return findCumulativeRangeBounds(dataset, false);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    Range result = findRangeBounds(dataset, true);\n    if (result != null) \n    {\n        double min = result.getLowerBound();\n        double max = result.getUpperBound();\n        double total = 0;\n        for (Comparable<?> rowKey : dataset.getRowKeys()) \n        {\n            total += calculateStackTotal(dataset, (int) rowKey);\n            min = Math.min(min, total);\n            max = Math.max(max, total);\n        }\n        result = new Range(min, max);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null)\n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    double cumulativeValue = 0.0;\n    Comparable[] rowKeys = dataset.getRowKeys();\n    for (Comparable rowKey : rowKeys)\n    {\n        PieDataset rowDataset = DatasetUtilities.createPieDatasetForRow(dataset, rowKey);\n        for (Comparable columnKey : dataset.getColumnKeys())\n        {\n            if (rowDataset != null)\n            {\n                Number value = rowDataset.getValue(columnKey);\n                if (value != null)\n                {\n                    cumulativeValue += value.doubleValue();\n                    if (result == null)\n                    {\n                        result = new Range(cumulativeValue, cumulativeValue);\n                    }\n                    else\n                    {\n                        result = Range.expandToInclude(result, cumulativeValue);\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    Range range = findStackedRangeBounds(dataset);\n    return new Range(range.getLowerBound(), range.getUpperBound() - range.getLowerBound());\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null)\n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getCumulativeRangeBounds();\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        return null;\n    }\n    Range result = super.findRangeBounds(dataset, false);\n    if (result != null) {\n        double base = calculateStackTotal(dataset, 0);\n        if (this.includeBaseInRange) {\n            result = Range.expandToInclude(result, base);\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    return findCumulativeRangeBounds(dataset, false);\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if ((hoursOffset < -23) || (hoursOffset > 23)) {\n        throw new IllegalArgumentException(\"hoursOffset must be in the range -23 to +23 (inclusive): \" + hoursOffset);\n    }\n    if ((minutesOffset < -59) || (minutesOffset > 59)) {\n        throw new IllegalArgumentException(\"minutesOffset must be in the range -59 to +59 (inclusive): \" + minutesOffset);\n    }\n    if ((hoursOffset >= 0 && minutesOffset < 0) || (hoursOffset < 0 && minutesOffset >= 0)) {\n        throw new IllegalArgumentException(\"Invalid minutesOffset for positive hoursOffset\");\n    }\n    int offsetMillis = hoursOffset * DateTimeConstants.MILLIS_PER_HOUR + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n    if (Math.abs(offsetMillis) > 24 * 60 * 60 * 1000) {\n        throw new IllegalArgumentException(\"Offset too large: \" + offsetMillis);\n    }\n    return new DateTimeZone(getOffsetZoneId(hoursOffset, minutesOffset), offsetMillis);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Hours must be in range -23 to +23\");\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Minutes must be in range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be positive when hours are positive\");\n    }\n    if (hoursOffset == 24 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Offset must not exceed +/- 23:59:59.000\");\n    }\n    if (hoursOffset == -24 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Offset must not exceed +/- 23:59:59.000\");\n    }\n    int offsetSeconds = seconds(hoursOffset, minutesOffset);\n    return forOffsetSeconds(offsetSeconds);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if ((minutesOffset < -59) || ((minutesOffset > 59) && (hoursOffset >= 0))) {\n        throw new IllegalArgumentException(\"Minutes must be in range -59 to 59\");\n    }\n    if ((hoursOffset < -23) || ((hoursOffset > 23) && (minutesOffset != 0))) {\n        throw new IllegalArgumentException(\"Hours must be in range -23 to 23\");\n    }\n    int offsetMillis = (hoursOffset * 60 + minutesOffset) * DateTimeConstants.MILLIS_PER_MINUTE;\n    if (offsetMillis < -DateTimeConstants.MILLIS_PER_DAY) {\n        throw new IllegalArgumentException(\"Offset too small, must be >= -24:00\");\n    }\n    if (offsetMillis > DateTimeConstants.MILLIS_PER_DAY) {\n        throw new IllegalArgumentException(\"Offset too large, must be <= +24:00\");\n    }\n    return fixedOffsetZone(\"Z+\" + hoursOffset + \":\" + minutesOffset, offsetMillis);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if ((minutesOffset < -59) || ((minutesOffset > 59) && (hoursOffset >= 0))) {\n        throw new IllegalArgumentException(\"Minutes must be in range -59 to +59 inclusive\");\n    }\n    if ((hoursOffset < -23) || (hoursOffset > 23)) {\n        throw new IllegalArgumentException(\"Hours must be in range -23 to +23 inclusive\");\n    }\n    int offset = (hoursOffset * 60) + minutesOffset;\n    if (offset > 540 || offset < -540) {\n        throw new IllegalArgumentException(\"Total offset must be in range -540 to +540\");\n    }\n    return fixedOffsetZone(\"Etc/GMT\" + (hoursOffset < 0 ? \"-\" : \"+\") + Math.abs(hoursOffset) + minutesOffset, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if ((minutesOffset < -59) || (minutesOffset > 59)) {\n        throw new IllegalArgumentException(\"Minutes must be between -59 and +59\");\n    }\n\n    if ((hoursOffset > 23) || (hoursOffset < -23)) {\n        throw new IllegalArgumentException(\"Hours must be between -23 and +23\");\n    }\n\n    if ((hoursOffset == 23) && (minutesOffset > 59)) {\n        throw new IllegalArgumentException(\"Offset cannot exceed +23:59:59.000\");\n    }\n\n    if ((hoursOffset == -23) && (minutesOffset < -59)) {\n        throw new IllegalArgumentException(\"Offset cannot exceed -23:59:59.000\");\n    }\n\n    return fixedOffsetZone(hoursOffset, minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) \n    {\n        throw new IllegalArgumentException(\"hoursOffset must be >= -23 and <= +23\");\n    }\n\n    if (minutesOffset > 59 || minutesOffset < -59) \n    {\n        throw new IllegalArgumentException(\"minutesOffset must be >= -59 and <= +59\");\n    }\n\n    // If we have a negative hour, we need to make sure that the minutes are\n    // positive.\n    if (hoursOffset < 0) \n    {\n        if (minutesOffset < 0) \n        {\n            throw new IllegalArgumentException(\"minutes must be positive when hours is negative\");\n        }\n    }\n\n    if (minutesOffset != 0) \n    {\n        throw new IllegalArgumentException(\"Cannot use minute offset if not standard\");\n    }\n\n    int millis = (hoursOffset * DateTimeConstants.MILLIS_PER_HOUR) + (minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE);\n    if (millis > DateTimeConstants.MILLIS_PER_DAY) \n    {\n        throw new IllegalArgumentException(\"Offset too large, must be <= +/-23:59:59.000\");\n    }\n\n    // If we're zero then we just return UTC.\n    if (hoursOffset == 0 && minutesOffset == 0) \n    {\n        return UTC;\n    }\n\n    // Otherwise, we create a new zone object.\n    return new FixedOffsetZone(hoursOffset, minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if ((minutesOffset < -59) || (minutesOffset > 59)) {\n        throw new IllegalArgumentException(\"Minutes offset must be in the range -59 to 59 (offset: \" + minutesOffset + \").\");\n    }\n\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n\n    if (totalMinutes > 540) {\n        throw new IllegalArgumentException(\"Offset must be <= +8:00 (offset: \" + totalMinutes + \").\");\n    } else if (totalMinutes < -540) {\n        throw new IllegalArgumentException(\"Offset must be >= -12:00 (offset: \" + totalMinutes + \").\");\n    }\n\n    return fixedOffsetZone(\"+\", totalMinutes / 60, totalMinutes % 60);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if ((hoursOffset > 23) || (hoursOffset < -23)) \n    {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if ((minutesOffset > 59) || (minutesOffset < -59)) \n    {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if ((hoursOffset == 0) && (minutesOffset < 0)) \n    {\n        throw new IllegalArgumentException(\"Negative minutes not supported for positive hours: \" + minutesOffset);\n    }\n    if ((hoursOffset > 0) && (minutesOffset < 0)) \n    {\n        throw new IllegalArgumentException(\"Negative minutes not supported for positive hours: \" + minutesOffset);\n    }\n    if (((hoursOffset == -23) && (minutesOffset > -3600)) || ((hoursOffset == 23) && (minutesOffset < 3600))) \n    {\n        throw new IllegalArgumentException(\"Offset too far out of range: \" + hoursOffset + \" hours \" + minutesOffset + \" minutes\");\n    }\n    return new DateTimeZone(hoursOffset, minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"hoursOffset must be in the range -23 to +23 (inclusive): \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"minutesOffset must be in the range -59 to +59 (inclusive): \" + minutesOffset);\n    }\n\n    if (hoursOffset != 0 || minutesOffset != 0) {\n        int millisOffset = (hoursOffset * DateTimeConstants.MILLIS_PER_HOUR) + (minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE);\n        return fixedOffsetZone(hoursOffset < 0 ? \"-\" : \"+\", millisOffset);\n    } else {\n        return UTC;\n    }\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours (\" + hoursOffset + \") must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes (\" + minutesOffset + \") must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be positive when hours are positive\");\n    }\n    int offsetMillis = (hoursOffset * DateTimeConstants.MILLIS_PER_HOUR)\n            + (minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE);\n    if (Math.abs(offsetMillis) > (24 * DateTimeConstants.MILLIS_PER_HOUR)) {\n        throw new IllegalArgumentException(\"Offset must be within +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(\"Z\" + hoursOffset + minutesOffset, offsetMillis);\n}"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n    int level = 0;\n    int start = pos;\n    for (int i = pos; i < queue.length(); i++)\n    {\n        char c = queue.charAt(i);\n        if (c == open)\n            level++;\n        else if (c == close)\n            level--;\n        if (level == 0)\n        {\n            pos = i + 1;\n            return queue.substring(start, pos);\n        }\n    }\n    throw new IllegalStateException(\"Unbalanced string: missing closing '\" + close + \"' for '\" + open + \"'\");\n}",
      "public String chompBalanced(char open, char close)  {\n    int openCount = 1;\n    int closeCount = 0;\n    int start = pos;\n    while (true) {\n        if (isEmpty())\n            throw new IllegalStateException(\"Unbalanced string: missing close\");\n        if (peek() == close) {\n            closeCount++;\n            if (openCount == closeCount) {\n                pos++;\n                return queue.substring(start, pos);\n            }\n        }\n        if (peek() == open)\n            openCount++;\n        pos++;\n    }\n}",
      "public String chompBalanced(char open, char close)  {\n    Validate.notNull(queue);\n    int start = pos;\n    boolean escaped = false;\n    int balanced = 0;\n    for (; !isEmpty(); pos++) \n    {\n        char c = queue.charAt(pos);\n        if (c == ESC) \n        {\n            escaped = !escaped;\n        }\n        else if (!escaped && c == open) \n        {\n            balanced++;\n        }\n        else if (!escaped && c == close) \n        {\n            balanced--;\n        }\n        else if (balanced == 0) \n        {\n            break;\n        }\n    }\n    if (balanced != 0) \n    {\n        throw new IllegalStateException(\"Unbalanced match\");\n    }\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = StringUtil.borrowBuilder();\n    int nesting = 0;\n    while (!isEmpty()) {\n        char c = consume();\n        if (c == open) {\n            nesting++;\n            out.append(c);\n        }\n        else if (c == close) {\n            nesting--;\n            out.append(c);\n        }\n        else if (nesting == 0) {\n            return StringUtil.releaseBuilder(out);\n        }\n        else {\n            out.append(c);\n        }\n    }\n    return StringUtil.releaseBuilder(out);\n}",
      "public String chompBalanced(char open, char close)  {\n    Validate.isTrue(open != close);\n    int level = 0;\n    StringBuilder out = StringUtil.borrowBuilder();\n    for (int i = pos; i < queue.length(); i++) {\n        char c = queue.charAt(i);\n        switch (c) {\n        case open:\n            level++;\n            break;\n        case close:\n            level--;\n            if (level == 0) {\n                pos = i + 1;\n                return StringUtil.releaseBuilder(out);\n            }\n            break;\n        case ESC:\n            i++;\n            break;\n        default:\n            out.append(c);\n        }\n    }\n    throw new IllegalStateException(\"Unbalanced open/close characters\");\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = StringUtil.borrowBuilder();\n    int depth = 0;\n    for (int i = pos; i < queue.length(); i++) {\n        char c = queue.charAt(i);\n        if (c == open)\n            depth++;\n        else if (c == close)\n            depth--;\n        else if (depth >= 0 && c == ESC) // ignore escapes in balanced strings\n            continue;\n        else if (depth >= 0)\n            out.append(c);\n        \n        if (depth == 0) {\n            pos = i+1;\n            return StringUtil.releaseBuilder(out);\n        }\n    }\n    return null; // unbalanced\n}",
      "public String chompBalanced(char open, char close)  {\n    Validate.isTrue(open != close, \"Opening and closing delimiters must be different\");\n    \n    int start = pos;\n    boolean balanced = false;\n    for (int i = pos; i < queue.length(); i++) {\n        char c = queue.charAt(i);\n        balanced = c == close ? !balanced : c == open ? balanced : balanced;\n        if (balanced) {\n            pos = i + 1;\n            return queue.substring(start, pos);\n        }\n    }\n    \n    if (!balanced)\n        throw new IllegalStateException(\"Unbalanced delimiters, expected \" + open + \" before \" + close);\n    return null;\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = StringUtil.borrowBuilder();\n    int nest = 0;\n    while (!isEmpty()) {\n        char c = consume();\n        if (c == open)\n            nest++;\n        else if (c == close)\n            nest--;\n        if (nest >= 0)\n            out.append(c);\n        if (nest == 0)\n            break;\n    }\n    return StringUtil.releaseBuilder(out);\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = StringUtil.borrowBuilder();\n    int nested = 0;\n    for (int i = pos; i < queue.length(); i++) {\n        char c = queue.charAt(i);\n        if (c == close && nested == 0) {\n            i++;\n            break;\n        } else if (c == open) {\n            nested++;\n        } else if (c == close) {\n            nested--;\n        } else if (c == ESC) {\n            i++;\n            if (i >= queue.length())\n                throw new IllegalStateException(\"Unexpected end of string when unescaping\");\n            char next = queue.charAt(i);\n            if (next == open || next == close)\n                out.append(next);\n            else\n                out.append(c);\n        } else {\n            out.append(c);\n        }\n    }\n\n    String result = StringUtil.releaseBuilder(out);\n    if (nested != 0)\n        throw new IllegalStateException(\"Unbalanced parentheses\");\n    return result;\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = StringUtil.borrowBuilder();\n    int nested = 0;\n    while (!isEmpty()) {\n        char c = consume();\n        if (c == open) {\n            nested++;\n            out.append(c);\n        } else if (c == close) {\n            nested--;\n            out.append(c);\n            if (nested == 0)\n                break;\n        } else if (c == ESCAPE) {\n            if (!isEmpty())\n                out.append(consume());\n        } else {\n            out.append(c);\n        }\n    }\n    return StringUtil.releaseBuilder(out);\n}"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Get the rank of the matrix\n        int rank = qr.getRank(0.0000001);\n        // Get the beta vector\n        RealVector beta = calculateBeta();\n        // Get the R matrix\n        RealMatrix rMatrix = qr.getR();\n        // Get the top p rows of R\n        RealMatrix rTopP = rMatrix.getSubMatrix(0, rank - 1, 0, rMatrix.getColumnDimension() - 1);\n        // Calculate the variance-covariance matrix of the beta vector\n        return rTopP.transpose().multiply(rTopP).scalarMultiply(1 / beta.dotProduct(rTopP)).scalarAdd(new Array2DRowRealMatrix(rank, rank).fill(Double.NaN));\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n    final int p = qr.getR().getColumnDimension();\n    RealMatrix R = qr.getR();\n    RealMatrix invRRT = R.transpose().multiply(R).inverse();\n    RealMatrix topRRT = invRRT.getSubMatrix(0, p - 1, 0, p - 1);\n    RealMatrix betaVariance = topRRT.scalarMultiply(sigmaSquared);\n    \n    return betaVariance;\n}",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix rTranspose = qr.getQR().transpose();\n        RealMatrix rInverse = new LUDecomposition(rTranspose.multiply(qr.getQR())).getSolver().getInverse();\n        return rInverse.scalarMultiply(rTranspose.getRowDimension());\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // No DME advertised - args valid if we get here\n        RealMatrix rrt = qr.getR().transpose().multiply(qr.getR()).scalarMultiply(1d/(xMatrix.getRowDimension() - xMatrix.getColumnDimension()));\n        return rrt.getSubMatrix(0, qr.getR().getColumnDimension()-1, 0, qr.getR().getColumnDimension()-1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Create the matrix (X'X)^-1\n        RealMatrix invXX = qr.getR().transpose().multiply(qr.getR()).inverse();\n        \n        // Use the QR decomposition solver to compute the variance-covariance matrix\n        return invXX.scalarMultiply(xMatrix.transpose().multiply(xMatrix));\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Calculate the QR decomposition\n        QRDecomposition qrDecomposition = new QRDecomposition(xMatrix.transpose().multiply(xMatrix));\n\n        // Extract the R matrix from the QR decomposition\n        RealMatrix rMatrix = qrDecomposition.getR();\n\n        // Create the identity matrix of size p (number of rows in R)\n        int p = rMatrix.getColumnDimension();\n        RealMatrix identityMatrix = new Array2DRowRealMatrix(p, p).scalarAdd(1);\n\n        // Compute and return the variance-covariance matrix\n        return rMatrix.transpose().multiply(rMatrix).scalarMultiply(1 / (xMatrix.getRowDimension() - p)).multiply(identityMatrix);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final RealMatrix R = qr.getR();\n        final int r = R.getColumnDimension();\n        final int n = R.getRowDimension();\n        RealMatrix invRTR = R.transpose().multiply(R).inverse();\n\n        // No try-catch or advertised NotStrictlyPositiveException - NPE above if n < 3\n        Array2DRowRealMatrix invRTRExt = new Array2DRowRealMatrix(n, r);\n        double[][] invRTRExtData = invRTRExt.getDataRef();\n        for (int i = 0; i < r; i++) {\n            for (int j =0; j < r; j++) {\n                invRTRExtData[i][j] = (i == j) ? invRTR.getEntry(i, j) : 0d;\n            }\n        }\n\n        // No DME advertised - args valid if we get here\n        return invRTRExt.multiply(xMatrix.transpose()).multiply(xMatrix).multiply(invRTRExt).scalarMultiply(n);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Calculate the rank of the matrix\n        int rank = qr.getRank(0.000000001);\n\n        // Get the top p rows of R from QR decomposition\n        RealMatrix R = qr.getR().getSubMatrix(0, rank - 1, 0, rank - 1);\n\n        // Calculate the inverse of R^T * R\n        RealMatrix invRTR = new LUDecomposition(R.transpose().multiply(R)).getSolver().getInverse();\n\n        // Calculate and return the variance-covariance matrix\n        return invRTR.multiply(R.transpose()).multiply(R);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n    RealMatrix R = qr.getR();\n    final int p = R.getColumnDimension();\n\n    // Create the matrix (R'R)^(-1)\n    RealMatrix invRRT = new Array2DRowRealMatrix(p, p);\n    double[][] invRRTData = invRRT.getDataRef();\n    for (int i = 0; i < p; i++) {\n        for (int j = 0; j < p; j++) {\n            if (i == j) {\n                invRRTData[i][j] = 1d / R.getEntry(i, j);\n            } else {\n                invRRTData[i][j] = 0d;\n            }\n        }\n    }\n\n    // Calculate the variance-covariance matrix\n    // No DME advertised - args valid if we get here\n    return invRRT.multiply(xMatrix.transpose().multiply(xMatrix));\n}",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Create augmented identity matrix\n        RealMatrix R = qr.getR();\n        final int p = R.getColumnDimension();\n        final int n = R.getRowDimension();\n\n        // No try-catch or advertised NotStrictlyPositiveException - NPE above if n < 3\n        Array2DRowRealMatrix RRT = new Array2DRowRealMatrix(n, n);\n        double[][] RRTData = RRT.getDataRef();\n        for (int i = 0; i < n; i++) {\n            for (int j =0; j < n; j++) {\n                if (i == j && i < p) {\n                    RRTData[i][j] = R.getEntry(i, j) * R.getEntry(i, j);\n                } else {\n                    RRTData[i][j] = 0d;\n                }\n            }\n        }\n\n        // Compute and return beta variance-covariance matrix\n        // No DME advertised - args valid if we get here\n        return RRT.scalarMultiply(Math.pow(qr.getSolver().getResidualNorms()[0],2));\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n    return \"+\" + printOffset(offset);\n}",
      "private static String printOffset(int offset)  {\n    int hours = (int) (offset / (1000 * 60 * 60));\n    int minutes = (int) ((offset % (1000 * 60 * 60)) / (1000 * 60));\n    return ((hours > 0) ? \"+\" : \"-\") + String.format(\"%02d\", Math.abs(hours)) + \":\" + String.format(\"%02d\", Math.abs(minutes));\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n    int absOffset = Math.abs(offset);\n    int hoursOffset = absOffset / 3600000;\n    int minutesOffset = (absOffset / 60000) % 60;\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return \"Z\";\n    }\n    StringBuffer buf = new StringBuffer();\n    if (offset < 0) {\n        buf.append('-');\n    } else {\n        buf.append('+');\n    }\n    if (hoursOffset < 10) {\n        buf.append('0');\n    }\n    buf.append(hoursOffset);\n    buf.append(':');\n    if (minutesOffset < 10) {\n        buf.append('0');\n    }\n    buf.append(minutesOffset);\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n    int hours = Math.abs(offset / 3600000);\n    int minutes = Math.abs((offset / 60000) % 60);\n    int millis = Math.abs(offset % 60000);\n\n    if (hours == 0 && minutes == 0) {\n        return \"Z\";\n    } else if (hours > 99) {\n        return \"+\" + hours / 100 + hours % 100 + \":\" + minutes / 10 + minutes % 10 + \":\" + millis / 1000 + millis / 100 % 10 + millis / 10 % 10 + millis % 10;\n    } else if (minutes == 0) {\n        return \"+\" + hours / 10 + hours % 10 + \":00\";\n    } else {\n        return \"+\" + hours / 10 + hours % 10 + \":\" + minutes / 10 + minutes % 10;\n    }\n}",
      "private static String printOffset(int offset)  {\n    int absOffset = Math.abs(offset);\n    int hoursOffset = absOffset / 3600000;\n    int minutesOffset = (absOffset / 60000) % 60;\n    StringBuilder buf = new StringBuilder(50);\n    if (offset < 0) {\n        buf.append('-');\n    } else {\n        buf.append('+');\n    }\n    if (hoursOffset < 10) {\n        buf.append('0');\n    }\n    buf.append(hoursOffset);\n    buf.append(':');\n    if (minutesOffset < 10) {\n        buf.append('0');\n    }\n    buf.append(minutesOffset);\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    return \"+\" + printOffset(offset);\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    if (offset >= -60 && offset <= 60) {\n        return (offset >= 0 ? \"+\" : \"-\") + \"0\" + Math.abs(offset);\n    }\n    int hours = offset / 3600000;\n    int minutes = (offset / 60000) % 60;\n    return (offset >= 0 ? \"+\" : \"-\") + hours + \":\" + (minutes < 10 ? \"0\" : \"\") + minutes;\n}"
    ],
    [
      "public int getIndex(Comparable key)  {\n    int index = this.keys.indexOf(key);\n    if (index >= 0) return index;\n    index = this.indexMap.get(key);\n    if (index >= 0) return index;\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"key cannot be null\");\n    }\n    int index = this.indexMap.get(key);\n    return (index >= 0 && index < keys.size()) ? index : -1;\n}",
      "public int getIndex(Comparable key)  {\n    int index = this.indexMap.indexOfKey(key);\n    if (index >= 0) {\n        return index;\n    }\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"key cannot be null\");\n    }\n    Comparable columnKey = getColumnKey(0);\n    if (columnKey != null) {\n        int column = getColumnIndex(columnKey);\n        if (column >= firstCategoryIndex && column <= lastCategoryIndex()) {\n            return getRowIndex(key);\n        }\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"key cannot be null\");\n    }\n    if (this.indexMap.containsKey(key)) {\n        return (Integer) this.indexMap.get(key);\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    int index = this.underlying.getColumnIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"key cannot be null\");\n    }\n    int index = this.indexMap.get(key);\n    if (index == null) {\n        return -1;\n    }\n    return index;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"key cannot be null\");\n    }\n    Comparable[] keys = getKeys().toArray(new Comparable[0]);\n    for (int i = 0; i < keys.length; i++) {\n        if (key.equals(keys[i])) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"key cannot be null\");\n    }\n    Integer i = (Integer)indexMap.get(key);\n    if (i != null) {\n        return i.intValue();\n    }\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    int index = this.keys.indexOf(key);\n    if (index >= 0 && index <= getItemCount()) {\n        return index;\n    }\n    return -1;\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n\tMap<String, StaticSlot<JSType>> slots = new HashMap<>();\n\tfor (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet())\n\t{\n\t\tif (!slots.containsKey(symbolEntry.getKey()))\n\t\t{\n\t\t\tslots.put(symbolEntry.getKey(), symbolEntry.getValue());\n\t\t}\n\t}\n\treturn slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n  for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n    if (!slots.containsKey(symbolEntry.getKey())) {\n      slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n    }\n  }\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n\tMap<String, StaticSlot<JSType>> slots = new HashMap<>();\n\tfor (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet())\n\t{\n\t\tif (!slots.containsKey(symbolEntry.getKey()))\n\t\t{\n\t\t\tslots.put(symbolEntry.getKey(), symbolEntry.getValue());\n\t\t}\n\t}\n\treturn slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n            slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n    }\n\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.dirtySymbols.entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n            slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n    }\n    \n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.linkedEquivalent.cache.symbols.entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n            slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n    }\n\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n            slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n    }\n\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n\n  for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n    if (!slots.containsKey(symbolEntry.getKey())) {\n      slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n    }\n  }\n\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    // Add any slots from the parent scope.\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : parent.allFlowSlots().entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n\tMap<String, StaticSlot<JSType>> slots = new HashMap<>();\n\n\t// Get the cache for the current linked flow scope.\n\tFlatFlowScopeCache cache = getFlatFlowScopeCache();\n\n\t// Copy the symbols from the cache into the result map.\n\tfor (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n\t\tif (!slots.containsKey(symbolEntry.getKey())) {\n\t\t\tslots.put(symbolEntry.getKey(), symbolEntry.getValue());\n\t\t}\n\t}\n\n\treturn slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n  for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) \n  {\n    if (!slots.containsKey(symbolEntry.getKey())) {\n      slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n    }\n  }\n  return slots;\n}"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
    ],
    [
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    double absAsinh;\n    if (a > 0.167) {\n        absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.036) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a >= CBRT2) {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    }\n    else if (a >= EIGHTHS) {\n        // Use a rational approximation\n        double temp = a * a;\n        double z = temp / (2.0 + temp);\n        z = z * (temp / (2.0 + temp));\n        z = z * (temp / (2.0 + temp));\n        z = z * a;\n\n        result = z;\n    }\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        a = -a;\n        negate = true;\n    }\n\n    double result;\n    if (a > 0.5) {\n        /* |a| > 0.5, use alternative formula */\n        double ratioa;\n        double ratiob;\n        double temp;\n\n        double da = 2 - (a * a);\n        double daa = da + da + da;\n        double dab = da - daa;\n\n        // ratio = a/da\n        temp = a * HEX_40000000;\n        ratioa = a + temp - temp;\n        ratiob = a - ratioa;\n\n        // Account for rounding in division\n        ratiob += (a - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for da\n        ratiob += -da / da;\n        // Account for db\n        ratiob += -a * da / da / da;\n\n        result = ratioa + ratiob;\n    }\n    else {\n        /* |a| <= 0.5, use standard formula */\n        if (a > 0.167) {\n            result = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n        } else {\n            final double a2 = a * a;\n            if (a > 0.097) {\n                result = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n            } else if (a > 0.036) {\n}\n}\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    if (a > 20) {\n        if (a >= LOG_MAX_VALUE) {\n            // Avoid overflow (MATH-905).\n            final double t = exp(0.5 * a);\n            return (0.5 * t) * t;\n        } else {\n            return 0.5 * exp(a);\n        }\n    } else if (a < -20) {\n        if (a <= -LOG_MAX_VALUE) {\n            // Avoid overflow (MATH-905).\n            final double t = exp(-0.5 * a);\n            return (0.5 * t) * t;\n        } else {\n            return 0.5 * exp(-a);\n        }\n    }\n\n    final double hiPrec[] = new double[2];\n    if (a < 0.0) {\n        a = -a;\n    }\n    expm1(a, 0.0, hiPrec);\n\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n    /* Numerator */\n    double na = ya;\n    double nb = yb;\n\n    /* Denominator */\n    double da = 2.0 + ya;\n    double db = -(da - 2.0 - ya);\n    double temp = da + yb;\n    db += -(temp - da - yb);\n    da = temp;\n\n    temp = da * HEX_40000000;\n    double daa = da + temp - temp;\n    double dab = da - daa;\n\n    // ratio = na/da\n    double ratio = na/da;\n    temp = ratio * HEX_40000000;\n    double ratioa = ratio + temp - temp;\n    double ratiob = ratio - ratioa;\n\n    // Correct for rounding in division\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n    double result;\n    if (a > 0.167) {\n        result = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            result = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.036) {\n            result = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n            result = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    double absAsinh;\n    if (a > 0.167) {\n        absAsinh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.036) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n            absAsinh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        a = -a;\n        negate = true;\n    }\n    if (a > 1) {\n        if (a >= 1000) {\n            double t = exp(0.5 * a);\n            return (0.5 * t) * t;\n        } else {\n            double t = exp(a);\n            return log((t + 1) / (t - 1));\n        }\n    } else {\n        if (a <= 0.0001) {\n            return a;\n        } else {\n            double a2 = a * a;\n            double term = 0.0;\n            double result = a;\n            for (int i = 1; i <= 20; i++) {\n                term *= a2;\n                result += term / (2 * i + 1);\n            }\n            return negate ? -result : result;\n        }\n    }\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        a = -a;\n        negate = true;\n    }\n    if (a > 0.167) {\n        a = (FastMath.log(FastMath.sqrt(a * a + 1) + a) + FastMath.log(2));\n    } else if (a > 0.036) {\n        a = (FastMath.log(FastMath.sqrt(a * a + 1) + a) + FastMath.log(1 + (1 - a) / (1 + a)));\n    } else if (a > 0.0036) {\n        a = (FastMath.log(FastMath.sqrt(a * a + 1) + a) + FastMath.log(1 + 0.5 * (1 - a) / (1 + a)));\n    } else {\n        a = FastMath.log(1 + a / (1 - a));\n    }\n    if (negate) {\n        a = -a;\n    }\n    return a;\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n    if (a >= 1.0) \n    {\n        return (a > 1.0) ? Double.POSITIVE_INFINITY : Double.NaN;\n    }\n    if (a <= -1.0) \n    {\n        return (a < -1.0) ? Double.NEGATIVE_INFINITY : Double.NaN;\n    }\n    if (a <= FastMath.E - 1.0) \n    {\n        return a;\n    }\n    if (a >= 1.0 - FastMath.E) \n    {\n        return FastMath.log(a + FastMath.sqrt(a * a + 1));\n    }\n    double x = a * 2.0;\n    double y = 1.0 + x * a;\n    double z = y * y;\n    double w = y / (z + 1.0);\n    double r = w * w;\n    double s = r * r;\n    double t = s * s;\n    return x * (t / 5.0 + r - s + w);\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n// util/FastMath.java\nif (a > 0.167) {\n    return FastMath.log(FastMath.sqrt(a * a + 1) + a);\n} else {\n    final double a2 = a * a;\n    if (a > 0.097) {\n        return a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n    } else if (a > 0.036) {\n        return a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n    } else if (a > 0.0036) {\n        return a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n    } else {\n}\n}\n}"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check for invalid inputs\n    if (values == null) {\n        throw new NullArgumentException(\"values\");\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Invalid normalized sum: \" + normalizedSum);\n    }\n    double sum = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (Double.isNaN(sum)) {\n        throw new MathArithmeticException(\"Input array contains NaN values.\");\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Input array sums to zero.\");\n    }\n\n    // Create a new array to store the normalized values\n    double[] normalizedValues = new double[values.length];\n\n    // Normalize the values\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    // Return the normalized array\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\n                \"Normalized sum cannot be NaN\");\n    }\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\n                \"Normalized sum cannot be infinite\");\n    }\n    double sum = sum(values, 0, values.length);\n    if (Double.isNaN(sum)) {\n        throw new MathArithmeticException(\"Input array contains NaN elements\");\n    }\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(\"Input array contains infinite elements\");\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Input array sum is zero\");\n    }\n    double[] result = copyOf(values);\n    for (int i = 0; i < result.length; ++i) {\n        result[i] *= normalizedSum / sum;\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Normalized sum may not be NaN\");\n    }\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Normalized sum may not be infinite\");\n    }\n    if (values == null) {\n        throw new NullArgumentException(\"Input array must not be null\");\n    }\n    double sum = StatUtils.sum(values, 0, values.length);\n    if (Double.isNaN(sum)) {\n        return values.clone();\n    }\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(\"Infinite input sum\");\n    }\n    if (sum == 0.0) {\n        throw new MathArithmeticException(\"Zero input sum\");\n    }\n    double[] result = values.clone();\n    for (int i = 0; i < result.length; ++i) {\n        result[i] = result[i] * normalizedSum / sum;\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check for invalid input\n    if (values == null) {\n        throw new IllegalArgumentException(\"Input array is null\");\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new IllegalArgumentException(\"Target sum is not valid\");\n    }\n\n    // Calculate the sum of non-NaN elements\n    double sum = 0.0;\n    int count = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n            count++;\n        }\n    }\n\n    // Check if the input array sums to zero\n    if (count == 0) {\n        throw new ArithmeticException(\"Input array sums to zero\");\n    }\n\n    // Normalize the array elements\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    MathUtils.checkNotNull(values);\n    if (!Double.isFinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Invalid normalizedSum (\" + normalizedSum + \"). Only finite values are accepted\");\n    }\n    if (SUM.evaluate(values) == 0.0) {\n        throw new MathArithmeticException(\"Cannot normalize array: sum is zero\");\n    }\n    double[] result = values.clone();\n    for (int i = 0; i < result.length; ++i) {\n        if (!Double.isNaN(result[i])) {\n            result[i] *= normalizedSum / SUM.evaluate(values);\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check for invalid input\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Invalid normalizedSum: \" + normalizedSum);\n    }\n    for (double value : values) {\n        if (Double.isInfinite(value)) {\n            throw new MathArithmeticException(\"Input array contains infinite values.\");\n        }\n    }\n    double sum = MathArrays.sum(values, 0, values.length);\n    if (Double.isNaN(sum)) {\n        throw new MathIllegalArgumentException(\"Input array contains NaN values.\");\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Input array sums to zero.\");\n    }\n\n    // Normalize the values\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        normalizedValues[i] = values[i] * normalizedSum / sum;\n    }\n\n    // Return the normalized array\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check for invalid arguments\n    if (normalizedSum == Double.POSITIVE_INFINITY || normalizedSum == Double.NEGATIVE_INFINITY || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Invalid normalizedSum value: \" + normalizedSum);\n    }\n    if (values == null) {\n        throw new MathIllegalArgumentException(\"Input array is null\");\n    }\n\n    // Calculate the sum of non-NaN elements\n    double sum = 0;\n    int numNonNaN = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n            numNonNaN++;\n        }\n    }\n\n    // Check if the input array sums to zero\n    if (numNonNaN == 0) {\n        throw new MathArithmeticException(\"Input array sums to zero\");\n    }\n\n    // Normalize the array\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = Double.NaN;\n        }\n    }\n\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\n                \"Target sum must not be NaN\");\n    }\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\n                \"Target sum must not be infinite\");\n    }\n\n    int nonNaNCount = 0;\n    double sum = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n            nonNaNCount++;\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\n                \"Input array elements must not all be NaN\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Invalid normalizedSum: \" + normalizedSum);\n    }\n    if (values.length == 0) {\n        throw new MathArithmeticException(\"Unable to compute sum of empty array\");\n    }\n    double sum = StatUtils.sum(values);\n    if (Double.isNaN(sum)) {\n        throw new MathArithmeticException(\"Unable to compute sum of array with NaN values\");\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Unable to compute sum of array with zero sum\");\n    }\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    // Check for invalid inputs\n    if (normalizedSum == Double.POSITIVE_INFINITY || normalizedSum == Double.NEGATIVE_INFINITY || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Invalid normalizedSum: \" + normalizedSum);\n    }\n    if (values == null) {\n        throw new IllegalArgumentException(\"Input array is null\");\n    }\n\n    // Calculate the sum of non-NaN elements\n    double sum = 0;\n    int nonNaNCount = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n            nonNaNCount++;\n        }\n    }\n\n    // Throw exception if input array sums to zero or if there are no non-NaN elements\n    if (sum == 0 || nonNaNCount == 0) {\n        throw new MathArithmeticException(\"Input array sums to zero or has no non-NaN elements\");\n    }\n\n    // Normalize the elements\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = Double.NaN;\n        }\n    }\n\n    return normalizedValues;\n}"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return MutableDateTime.ofEpochMillis(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return MutableDateTime.ofEpochMillis(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime mutableDateTime = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                mutableDateTime = mutableDateTime.withZone(iZone);\n            }\n            return mutableDateTime;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix inverse = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealVector XtOY = getX().transpose().operate(yVector);\n        RealVector beta=inverse.operate(XtOY);\n        return beta;\n}",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix inverse = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealVector xTXinverse = inverse.operate(getX().transpose());\n        return xTXinverse.multiply(OI.operate(getYVector()));\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix invXTOIX = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealMatrix XTOIY = getX().transpose().multiply(OI).operate(getY());\n        return invXTOIX.operate(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix invXO = getOmegaInverse().multiply(getX().transpose());\n        RealMatrix invXTX = invXO.multiply(getX());\n        RealMatrix invXTXInv = new LUDecomposition(invXTX).getSolver().getInverse();\n        return invXTXInv.multiply(invXO).multiply(yVector);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n    RealMatrix OI = getOmegaInverse();\n    RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n    RealVector XTY = getX().transpose().operate(yVector);\n    return XTOIX.solve(XTY);\n}",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OmegaInv = getOmegaInverse();\n        RealMatrix XTX = getX().transpose().multiply(getX());\n        RealMatrix XTIOmegaInvX = getX().transpose().multiply(OmegaInv).multiply(getX());\n        RealMatrix XTIOmegaInvy = getX().transpose().multiply(OmegaInv).multiply(getY());\n        return XTIOmegaInvX.getSolver().solve(XTIOmegaInvy);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n    RealMatrix OI = getOmegaInverse();\n    RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n    RealVector XTY = getX().transpose().operate(yVector);\n    RealMatrix pinvXTY = OI.multiply(XTY);\n    return XTOIX.solve(pinvXTY);\n}",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix invXTOIX = new LUDecomposition(XTOIX).getSolver().getInverse();\n        return invXTOIX.multiply(getX().transpose()).multiply(OI).operate(yVector);\n}",
      "@Override\n    protected RealVector calculateBeta()  {\n    RealMatrix OI = getOmegaInverse();\n    RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n    RealVector XTY = getX().transpose().multiply(OI).operate(getYVector());\n    RealMatrix inverse = new LUDecomposition(XTOIX).getSolver().getInverse();\n    return inverse.operate(XTY);\n}",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix invSigmaXT = getOmegaInverse().multiply(getX().transpose());\n        return invSigmaXT.multiply(yVector);\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    return this.selectFirst(\"#\"+id);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    \n    return Collector.collect(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    \n    return Collector.collect(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    return this.selectFirst(\"#\"+id);\n}",
      "public Element getElementById(String id)  {\n    return this.selectFirst(\"#\" + id);\n}",
      "public Element getElementById(String id)  {\n    return selectFirst(\"#\" + id);\n}",
      "public Element getElementById(String id)  {\n    return this.selectFirst(\"#\" + id);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = normalize(id);\n\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}",
      "public Element getElementById(String id)  {\n    return selectFirst(\"#\" + id);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns.isEmpty()) \n    {\n        return pattern;\n    }\n    return customPatterns.get(0) + insertFormats(pattern, customPatterns.subList(1, customPatterns.size()));\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder(pattern.length());\n    int pos = 0;\n    while (pos < pattern.length()) {\n        char ch = pattern.charAt(pos);\n        if (ch == START_FMT) {\n            int depth = 1;\n            for (int start = pos + 1; start < pattern.length(); start++) {\n                if (pattern.charAt(start) == START_FE) {\n                    depth++;\n                } else if (pattern.charAt(start) == END_FE) {\n                    depth--;\n                    if (depth == 0) {\n                        String desc = pattern.substring(pos + 1, start);\n                        Format format = getFormat(desc);\n                        if (format != null) {\n                            result.append(pattern.substring(pos, start + 1));\n                            result.append(format);\n                            pos = start;\n                        } else {\n                            pos = start;\n                        }\n                        break;\n                    }\n                }\n            }\n            if (depth != 0) {\n                throw new IllegalArgumentException(\n                        \"Unterminated format element at position \" + pos);\n            }\n        } else {\n            result.append(ch);\n        }\n        pos++;\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length());\n    int pos = 0;\n    final int patternLength = pattern.length();\n    final int customPatternsSize = customPatterns.size();\n    final String[] customPatternsArray = customPatterns.toArray(new String[customPatternsSize]);\n    while (pos < patternLength) {\n        final int start = pos;\n        seekNonWs(pattern, new ParsePosition(pos));\n        final int text = pos;\n        int depth = 0;\n        for (; pos < patternLength; next(pos)) {\n            switch (pattern.charAt(pos.getIndex())) {\n            case START_FE:\n                depth++;\n                break;\n            case END_FE:\n                depth--;\n                if (depth == 0) {\n                    final String desc = parseFormatDescription(pattern, new ParsePosition(text));\n                    if (containsElements(customPatternsArray)) {\n                        for (String customPattern : customPatternsArray) {\n                            if (customPattern.equals(desc)) {\n                                result.append(customPattern);\n                                break;\n                            }\n                        }\n                    } else {\n                        result.append(desc);\n                    }\n                    pos++;\n                    break;\n                }\n                break;\n            case QUOTE:\n                appendQuotedString(pattern, pos, result, false);\n                break;\n            }\n            if (pos >= patternLength) {\n                break;\n            }\n        }\n        if (pos == start) {\n            result.append(pattern.charAt(pos));\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns == null || customPatterns.isEmpty()) {\n        return pattern;\n    }\n    StringBuilder buf = new StringBuilder(pattern.length() + customPatterns.size() * 5);\n    int pos = 0, last = 0;\n    while (pos < pattern.length()) {\n        if (pattern.charAt(pos) == START_FMT) {\n            if (last < pos) {\n                buf.append(pattern, last, pos);\n            }\n            String desc = parseFormatDescription(pattern, new ParsePosition(pos + 1));\n            if (desc.startsWith(QUOTE) && customPatterns.contains(desc.substring(1, desc.length() - 1))) {\n                buf.append(pattern, last, pos + 1);\n                buf.append(desc);\n                last = pos + 1;\n            }\n        }\n        pos++;\n    }\n    if (last < pos) {\n        buf.append(pattern, last, pos);\n    }\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns.isEmpty()) {\n        return pattern;\n    }\n    final StringBuilder builder = new StringBuilder(pattern.length() + customPatterns.size() * 5);\n    int lastIndex = 0;\n    for (int i = 0; i < customPatterns.size(); i++) {\n        final String desc = customPatterns.get(i);\n        final int start = pattern.indexOf('%', lastIndex);\n        if (start < 0) {\n            throw new IllegalArgumentException(\n                    \"Invalid custom format pattern: \" + customPatterns.get(i));\n        }\n        builder.append(pattern.substring(lastIndex, start));\n        builder.append(desc);\n        lastIndex = start + 1;\n    }\n    builder.append(pattern.substring(lastIndex));\n    return builder.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    int pos = 0;\n    while (pos < pattern.length()) {\n        final char ch = pattern.charAt(pos++);\n        if (ch == START_FMT) {\n            final ParsePosition parsePos = new ParsePosition(pos, pattern);\n            final String formatDescription = parseFormatDescription(pattern, parsePos);\n            final String customPattern = customPatterns.get(0);\n            customPatterns.remove(0);\n            result.append(pattern.substring(pos - 1, parsePos.getIndex())).append(customPattern);\n            pos = parsePos.getIndex();\n        } else {\n            result.append(ch);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder(pattern.length());\n    int pos = 0;\n    int customPos = 0;\n    while (pos < pattern.length() && customPos < customPatterns.size()) {\n        int nextArg = readArgumentIndex(pattern, pos);\n        if (nextArg >= 0) {\n            result.append(pattern, pos, nextArg);\n            result.append(customPatterns.get(customPos++));\n            pos = nextArg + 1;\n        } else {\n            result.append(pattern, pos, pattern.length());\n            break;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder(pattern.length());\n    int pos = 0;\n    for (int start = 0, end = StrMatcher.indexOf(pattern, \"%\", 0, -1); end >= 0; start = end + 1, end = StrMatcher.indexOf(pattern, \"%\", start, -1)) \n    {\n        result.append(pattern.substring(pos, start));\n        if (customPatterns != null) \n        {\n            result.append(customPatterns.get(start / 3));\n        } \n        else \n        {\n            result.append(\"%\");\n        }\n        pos = end + 1;\n    }\n    result.append(pattern.substring(pos));\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns.size() == 0) {\n        return pattern;\n    }\n    StringBuilder buf = new StringBuilder(pattern);\n    for (String custom : customPatterns) {\n        int start = pattern.indexOf(\"{\" + custom + \"}\");\n        if (start == -1) {\n            throw new IllegalArgumentException(\"Invalid format: \" + pattern);\n        }\n        int end = pattern.indexOf(\"}\", start);\n        if (end == -1) {\n            throw new IllegalArgumentException(\"Invalid format: \" + pattern);\n        }\n        buf.replace(start, end + 1, custom);\n    }\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder fullPattern = new StringBuilder(pattern.length());\n    final ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) {\n        final int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        final int text = pos.getIndex();\n        int depth = 0;\n        for (; pos.getIndex() < pattern.length(); next(pos)) {\n            switch (pattern.charAt(pos.getIndex())) {\n            case START_FMT:\n                depth++;\n                break;\n            case END_FE:\n                depth--;\n                if (depth == 0) {\n                    final String formatDescription = pattern.substring(text, pos.getIndex());\n                    final String customPattern = customPatterns.get(customPatterns.size() - 1);\n                    fullPattern.append(pattern.substring(start, text));\n                    fullPattern.append(customPattern);\n                    customPatterns.remove(customPatterns.size() - 1);\n                    break;\n                }\n                break;\n            case QUOTE:\n                appendQuotedString(pattern, pos, fullPattern, false);\n                break;\n            }\n        }\n        if (start == pos.getIndex()) {\n            fullPattern.append(pattern.charAt(pos.getIndex()));\n        }\n    }\n    return fullPattern.toString();\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (!from.getRawType().equals(to.getRawType())) {\n    return false;\n  }\n\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n\n  for (int i = 0; i < fromArgs.length; i++) {\n    if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n      return false;\n    }\n  }\n\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  // Check if raw types are different\n  if (!from.getRawType().equals(to.getRawType())) {\n    return false;\n  }\n\n  // Check if type arguments are equal\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n  for (int i = 0; i < fromArgs.length; i++) {\n    if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n\n  // Check if type variables are equal under the mapping.\n  Type fromVar = from.getRawType();\n  Type toVar = to.getRawType();\n  if (!matches(fromVar, toVar, typeVarMap)) {\n    return false;\n  }\n\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n\n  for (int i = 0; i < fromArgs.length; i++) {\n    if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n      return false;\n    }\n  }\n\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n\n  // Check if they have the same raw type.\n  if (!from.getRawType().equals(to.getRawType())) {\n    return false;\n  }\n\n  // If they are not equal, see if the typeVarMap can fix it.\n  if (!matches(from.getRawType(), to.getRawType(), typeVarMap)) {\n    return false;\n  }\n\n  // Otherwise, compare the type arguments.\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n  for (int i = 0; i < fromArgs.length; i++) {\n    if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n      return false;\n    }\n  }\n\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!to.getRawType().equals(from.getRawType())) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  // Compare the raw types.\n  if (!from.getRawType().equals(to.getRawType())) {\n    return false;\n  }\n\n  // Compare the actual type arguments.\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n\n  for (int i = 0; i < fromArgs.length; i++) {\n    if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n      return false;\n    }\n  }\n\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (!from.getRawType().equals(to.getRawType())) {\n    return false;\n  }\n\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n\n  for (int i = 0; i < fromArgs.length; i++) {\n    if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n\n    // Check if the raw types are equal\n    if (!from.getRawType().equals(to.getRawType())) {\n        return false;\n    }\n\n    // Get the actual type arguments from both parameterized types\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    // Compare the actual type arguments for equality\n    for (int i = 0; i < fromArgs.length; i++) {\n        if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n\n  if (from.getRawType().equals(to.getRawType())) {\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    \n    checkAlterPeriodConverters();\n    \n    ConverterSet set = iPeriodConverters;\n    Converter existing = set.select(converter.getPeriodType(null));\n    if (existing == converter) {\n        return null;\n    }\n    if (existing == null) {\n        Converter[] added = set.add(converter, null);\n        return added[0];\n    } else {\n        Converter[] removed = set.remove(existing, null);\n        Converter[] added = set.add(converter, removed);\n        return removed[0];\n    }\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        throw new IllegalArgumentException(\"Converter must not be null\");\n    }\n    ConverterSet set = iPeriodConverters;\n    ConverterSet.Entry[] entries = set.iSelectEntries;\n    if (entries != null) {\n        for (ConverterSet.Entry entry : entries) {\n            if (entry.iConverter == converter) {\n                return (PeriodConverter)entry.iConverter;\n            }\n        }\n    }\n    for (int i = set.size(); --i >= 0;) {\n        Converter converter1 = set.iConverters[i];\n        if (converter1 == converter) {\n            return (PeriodConverter)converter1;\n        }\n    }\n    return set.add(converter, set.iConverters).select(converter.getPeriodType(null));\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    \n    checkAlterPeriodConverters();\n    ConverterSet set = iPeriodConverters;\n    for (int i = 0; i < set.size(); ++i) {\n        Converter current = set.iSelectEntries[i].iConverter;\n        if (current == converter) {\n            return (PeriodConverter)current;\n        }\n        if (current.equals(converter)) {\n            set.iSelectEntries[i] = new ConverterSet.Entry(converter.getPeriodType(null), converter);\n            return (PeriodConverter)current;\n        }\n    }\n    if (converter == null) {\n        return null;\n    }\n    ConverterSet.Entry[] newEntries = new ConverterSet.Entry[set.size() + 1];\n    System.arraycopy(set.iSelectEntries, 0, newEntries, 0, set.size());\n    newEntries[set.size()] = new ConverterSet.Entry(converter.getPeriodType(null), converter);\n    set.iSelectEntries = newEntries;\n    return null;\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    ConverterSet set = iPeriodConverters;\n    for (int i = set.size() - 1; i >= 0; i--) \n    {\n        Converter other = set.get(i);\n        if (converter.getClass() == other.getClass()) \n        {\n            if (converter.equals(other)) \n            {\n                return null;\n            }\n            set.remove(i);\n            break;\n        }\n    }\n    set.add(converter, null);\n    return null;\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        throw new IllegalArgumentException(\"converter cannot be null\");\n    }\n    ConverterSet set = iPeriodConverters;\n    PeriodConverter replaced = null;\n    for (int i = 0; i < set.size(); i++) \n    {\n        PeriodConverter candidate = set.get(i);\n        if (candidate.equals(converter)) \n        {\n            replaced = candidate;\n            break;\n        }\n    }\n    if (replaced != null) \n    {\n        if (replaced.equals(converter)) \n        {\n            return null;\n        }\n        set = set.remove(replaced, new PeriodConverter[] {replaced});\n    }\n    set = set.add(converter, new PeriodConverter[] {converter});\n    iPeriodConverters = set;\n    return replaced;\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    ConverterSet set = iPeriodConverters;\n    Converter converter2 = set.add(converter, new Converter[0]);\n    if (converter2 == converter) {\n        return null;\n    }\n    return (PeriodConverter)converter2;\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        Class<?> type = converter.getClass();\n        ConverterSet set = iPeriodConverters;\n        Converter current = set.select(type);\n        if (current != null) {\n            if (current.equals(converter)) {\n                return null;\n            } else {\n                set = set.remove(current);\n            }\n        }\n        Converter replaced = set.add(converter);\n        if (replaced != null) {\n            if (current != null) {\n                set = set.add(current);\n            }\n            return (PeriodConverter)replaced;\n        }\n        return null;\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            throw new IllegalArgumentException(\"Converter cannot be null.\");\n        }\n        Class<?> type = converter.getPeriodType(null);\n        ConverterSet set = iPeriodConverters;\n        Converter current = set.select(type);\n        if (current != null) {\n            if (current.equals(converter)) {\n                return null;\n            }\n            set.remove(current);\n        }\n        set.add(converter);\n        return current;\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    \n        checkAlterPeriodConverters();\n        if (converter != null) {\n            List<Converter> list = Arrays.asList(iPeriodConverters.iConverters);\n            for (int i = 0; i < list.size(); i++) {\n                Converter converter1 = list.get(i);\n                if (converter.getClass().equals(converter1.getClass())) {\n                    iPeriodConverters.iSelectEntries[i] = null;\n                    return converter1;\n                }\n            }\n            iPeriodConverters.iConverters = (Converter[])ArrayUtils.add(iPeriodConverters.iConverters, converter);\n            iPeriodConverters.iSelectEntries = null;\n            return null;\n        }\n        return null;\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    checkAlterPeriodConverters();\n    ConverterSet newSet = iPeriodConverters.add(converter, new PeriodConverter[0]);\n    if (newSet == iPeriodConverters) {\n        return null;\n    } else {\n        iPeriodConverters = newSet;\n        return converter;\n    }\n}"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n    if (colorToNodeMap == null) {\n      throw new IllegalStateException(\"Graph must be colored before getting partition super nodes\");\n    }\n    return colorToNodeMap[graph.getNode(node).getAnnotation(GraphColoring.Color).value];\n}",
      "public N getPartitionSuperNode(N node)  {\n  int color = getGraph().getNode(node).getAnnotation(GraphColoring.Color.class).value;\n  List<GraphNode> nodes = Lists.newArrayList();\n  for (GraphNode node1 : getGraph().getNodes())\n  {\n    if (getGraph().getNode(node1).getAnnotation(GraphColoring.Color.class).value == color)\n    {\n      nodes.add(node1);\n    }\n  }\n  return nodes.get(0);\n}",
      "public N getPartitionSuperNode(N node)  {\n    if (colorToNodeMap == null) {\n      return node;\n    }\n\n    List<N> nodes = Lists.newArrayList();\n    nodes.add(node);\n    int color = getGraph().getNode(node).getAnnotation(Color.class).value;\n    for (N n : colorToNodeMap) {\n        if (n != null && getGraph().getNode(n).getAnnotation(Color.class).value == color) {\n            nodes.add(n);\n        }\n    }\n\n    N superNode = NodeUtil.newName(null, \"SuperNode\" + color, null);\n    for (N n : nodes) {\n        getGraph().getNode(n).setAnnotation(superNode);\n    }\n    return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n    int color = graph.getNode(node).getAnnotation(GraphColoring.Color.class).value;\n    List<N> superNode = new ArrayList<>();\n    for (N n : graph.getNodes())\n    {\n        if (graph.getNode(n).getAnnotation(GraphColoring.Color.class).value == color)\n        {\n            superNode.add(n);\n        }\n    }\n    return superNode.get(0);\n}",
      "public N getPartitionSuperNode(N node)  {\n    int color = graph.getNode(node).getAnnotation(GraphColoring.Color.class).value;\n    N superNode = colorToNodeMap[color];\n    if (superNode == null) \n    {\n        superNode = graph.newSubGraph().getNode(node);\n        colorToNodeMap[color] = superNode;\n    }\n    return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  if (colorToNodeMap == null) {\n    color();\n  }\n  return colorToNodeMap[graph.getNode(node).getAnnotation(GraphColoring.Color).value];\n}",
      "public N getPartitionSuperNode(N node)  {\n    return colorToNodeMap[graph.getNode(node).getAnnotation(GraphColoring.Color).value];\n}",
      "public N getPartitionSuperNode(N node)  {\n    int color = graph.getNode(node).getAnnotation(GraphColoring.Color.class).value;\n    for (N n : graph.getNodes()) {\n      if (graph.getNode(n).getAnnotation(GraphColoring.Color.class).value == color) {\n        return n;\n      }\n    }\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n  if (colorToNodeMap == null) \n  {\n    return node;\n  }\n  else \n  {\n    for (N n : colorToNodeMap) \n    {\n      if (n == node) \n      {\n        return node;\n      }\n    }\n    return colorToNodeMap[0];\n  }\n}",
      "public N getPartitionSuperNode(N node)  {\n    if (colorToNodeMap == null) {\n        return node;\n    }\n    N superNode = colorToNodeMap[GraphColoring.Color(node).value];\n    if (superNode == null) {\n        return node;\n    }\n    return superNode;\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n    double integralSum = 0;\n    for (int i = 0; i < points.length; i++)\n    {\n        integralSum += weights[i] * f.value(points[i]);\n    }\n    return integralSum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0;\n    for (int i = 0; i < getNumberOfPoints(); i++) {\n        integral += getWeight(i) * f.value(getPoint(i));\n    }\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0.0;\n    for (int i = 0; i < getNumberOfPoints(); i++) \n    {\n        sum += getWeight(i) * f.value(getPoint(i));\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integralValue = 0.0;\n    for (int i = 0; i < getNumberOfPoints(); i++)\n    {\n        integralValue += getWeight(i) * f.value(getPoint(i));\n    }\n    return integralValue;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integralValue = 0.0;\n\n    // Iterate through the integration points and weights\n    for (int i = 0; i < points.length; i++) \n    {\n        // Evaluate the function at the integration point\n        double functionValue = f.value(points[i]);\n\n        // Multiply the function value by the weight and add it to the integral\n        integralValue += weights[i] * functionValue;\n    }\n\n    // Return the estimated integral value\n    return integralValue;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integralSum = 0;\n    for (int i = 0; i < points.length; i++) {\n        integralSum += weights[i] * f.value(points[i]);\n    }\n    return integralSum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integralSum = 0;\n    for (int i = 0; i < points.length; i++) {\n        integralSum += weights[i] * f.value(points[i]);\n    }\n    return integralSum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0.0;\n    for (int i = 0; i < getNumberOfPoints(); i++) \n    {\n        sum += getWeight(i) * f.value(getPoint(i));\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null && map2 == null) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (keys1.size() != keys2.size()) {\n        return false;\n    }\n    Iterator iterator = keys1.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        if (!SerialUtilities.equalPaint((Paint) map1.get(key), (Paint) map2.get(key))) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) \n    {\n        return true;\n    }\n    if (map1 == null || map2 == null) \n    {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) \n    {\n        return false;\n    }\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) \n    {\n        Comparable key = (Comparable) iterator1.next();\n        if (!map1.get(key).equals(map2.get(key))) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) return true;\n    if (map1 == null || map2 == null) return false;\n    if (map1.size() != map2.size()) return false;\n    Set set1 = map1.keySet();\n    for (Iterator it = set1.iterator(); it.hasNext();) \n    {\n        Comparable key = (Comparable) it.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (paint1 == paint2) continue;\n        if (paint1 == null || paint2 == null || !paint1.equals(paint2)) return false;\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null && map2 == null) {\n        return true;\n    }\n\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n\n    if (keys1.size() != keys2.size()) {\n        return false;\n    }\n\n    Iterator iterator1 = keys1.iterator();\n    Iterator iterator2 = keys2.iterator();\n\n    while (iterator1.hasNext()) {\n        Comparable key1 = (Comparable) iterator1.next();\n        Comparable key2 = (Comparable) iterator2.next();\n\n        if (!key1.equals(key2)) {\n            return false;\n        }\n\n        Paint paint1 = (Paint) map1.get(key1);\n        Paint paint2 = (Paint) map2.get(key2);\n\n        if (!SerialUtilities.equalPaints(paint1, paint2)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n\n    Iterator iterator1 = map1.keySet().iterator();\n    while (iterator1.hasNext()) {\n        Comparable key = (Comparable) iterator1.next();\n        if (!map2.containsKey(key)) {\n            return false;\n        }\n\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null && map2 == null) {\n        return true;\n    }\n\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n\n    for (Map.Entry entry : map1.entrySet()) {\n        Comparable key = (Comparable) entry.getKey();\n        Paint paint = (Paint) entry.getValue();\n        if (!map2.containsKey(key) || !map2.get(key).equals(paint)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator keyIterator = map1.keySet().iterator();\n    while (keyIterator.hasNext()) {\n        Comparable key = (Comparable) keyIterator.next();\n        if (!map1.get(key).equals(map2.get(key))) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null && map2 == null) {\n        return true;\n    } else if (map1 == null || map2 == null) {\n        return false;\n    } else if (map1.size() != map2.size()) {\n        return false;\n    } else {\n        for (Object key : map1.keySet()) {\n            if (!map2.containsKey(key) || !map1.get(key).equals(map2.get(key))) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) \n    {\n        return true;\n    }\n\n    if (map1 == null || map2 == null) \n    {\n        return false;\n    }\n\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n\n    if (keys1.size() != keys2.size()) \n    {\n        return false;\n    }\n\n    Iterator iterator = keys1.iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n\n        if (paint1 == paint2) \n        {\n            continue;\n        }\n\n        if (paint1 == null || paint2 == null || !paint1.equals(paint2)) \n        {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null && map2 == null) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        if (!SerialUtilities.equalPaint((Paint) map1.get(key), (Paint) map2.get(key))) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (parent.isExprResult()) {\n      // Don't replace the entire expression if we're in an exprResult.\n      // Otherwise, the replacement might be used in the wrong context.\n      Node left = expr.getFirstChild();\n      Node right = left.getNext();\n      left = replaceExpression(t, left, parent);\n      return right == null ? left : IR.add(left, right);\n    }\n\n    if (expr.isString()) {\n      String replacement = getReplacement(expr.getString());\n      if (replacement != null) {\n        Node result = IR.string(replacement);\n        result.copyInformationFromForTree(expr);\n        return result;\n      }\n    }\n\n    String replacement = getReplacement(expr.getQualifiedName());\n    if (replacement != null) {\n      Node result = IR.name(replacement);\n      result.copyInformationFromForTree(expr);\n      return result;\n    }\n\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  int type = expr.getType();\n  if (type == Token.ADD)\n  {\n    Node left = expr.getFirstChild();\n    Node right = left.getNext();\n    return replaceExpression(t, left, parent)\n        .add(replaceExpression(t, right, parent));\n  }\n  else if (type == Token.STRING)\n  {\n    t.report(expr, REPLACE_STRING_ERROR);\n    return expr;\n  }\n  else\n  {\n    String key = getReplacement(expr.toString());\n    if (key != null)\n    {\n      return buildReplacement(expr, parent, new StringBuilder(key));\n    }\n    else\n    {\n      t.report(expr, REPLACE_STRING_ERROR);\n      return expr;\n    }\n  }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  switch (expr.getType()) {\n    case Token.ADD:\n      Node left = expr.getFirstChild();\n      Node right = left.getNext();\n      Node prefix = replaceExpression(t, left, parent);\n      return replaceExpression(t, right, prefix);\n    case Token.STRING:\n      String str = expr.getString();\n      if (str.length() > REPLACE_ONE_MARKER.length()) {\n        String key = placeholderToken + nameGenerator.generateNextName();\n        recordReplacement(expr, key);\n        return buildReplacement(expr, null, key);\n      } else {\n        return expr;\n      }\n    case Token.NAME:\n      if (parent.isQualifiedName() || parent.isUnscopedQualifiedName()) {\n        String name = expr.getString();\n        if (registry.hasType(name)) {\n          String replacement = findMatching(name);\n          if (replacement != null) {\n            return IR.name(replacement);\n          }\n        } else {\n          String replacement = findMatchingClass(registry.getType(name),\n              expr.getQualifiedName().split(\"\\\\.\"));\n          if (replacement != null) {\n            return IR.name(replacement);\n          }\n        }\n      }\n      break;\n    case Token.CALL:\n      Node callee = expr.getFirstChild();\n      if (callee.isName()) {\n        String name = callee.getString();\n        Config config = findMatching(name);\n        if (config != null) {\n          doSubstitutions(t, config, expr);\n          return null;\n        }\n      }\n      break;\n    default:\n      return expr.cloneTree();\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  switch (expr.getType()) {\n    case Token.ADD:\n      Node left = expr.getFirstChild();\n      Node right = left.getNext();\n      left = replaceExpression(t, left, expr);\n      right = replaceExpression(t, right, expr);\n      return IR.add(left, right);\n    case Token.STRING:\n      String replacement = getReplacement(expr.getString());\n      if (replacement.equals(placeholderToken)) {\n        return expr;\n      }\n      return IR.string(replacement);\n    default:\n      String replacement = getReplacement(placeholderToken);\n      return IR.add(IR.string(replacement), expr);\n  }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (parent.isCall()) {\n      return replaceCallExpression(t, expr, (CallNode) parent);\n    } else if (parent.isNew()) {\n      return replaceNewExpression(t, expr, (NewExpression) parent);\n    } else if (parent.isExprResult()) {\n      return replaceExprResultExpression(t, expr, (ExpressionResultNode) parent);\n    } else {\n      return replaceOtherExpression(t, expr, parent);\n    }\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String replacement = getReplacement(expr.getString());\n        Node replacementNode = IR.string(replacement);\n        replacementNode.copyInformationFromForTree(expr);\n        parent.replaceChild(expr, replacementNode);\n        return replacementNode;\n    }\n\n    if (expr.isQualifiedName()) {\n        String replacement = getReplacement(expr.getString());\n        Node replacementNode = IR.name(replacement);\n        replacementNode.copyInformationFromForTree(expr);\n        parent.replaceChild(expr, replacementNode);\n        return replacementNode;\n    }\n\n    if (expr.isCall()) {\n        Config config = findMatching(expr.toString());\n        if (config != null) {\n            doSubstitutions(t, config, expr);\n            return expr;\n        }\n    }\n\n    if (expr.isAssign()) {\n        Node exprToReplace = expr.getFirstChild();\n        Node replacement = replaceExpression(t, exprToReplace, expr);\n        if (replacement != exprToReplace) {\n            expr.replaceChild(exprToReplace, replacement);\n        }\n        return expr;\n    }\n\n    if (expr.isUnaryExpression()) {\n        Node exprToReplace = expr.getFirstChild();\n        Node replacement = replaceExpression(t, exprToReplace, expr);\n        if (replacement != exprToReplace) {\n            expr.replaceChild(exprToReplace, replacement);\n        }\n        return expr;\n    }\n\n    if (expr.isBinaryExpression()) {\n        Node leftToReplace = expr.getFirstChild();\n        Node rightToReplace = leftToReplace.getNext();\n        Node leftReplacement = replaceExpression(t, leftToReplace, expr);\n        Node rightReplacement = replaceExpression(t, rightToReplace, expr);\n        if (leftReplacement != leftToReplace || rightReplacement != rightToReplace) {\n            expr.replaceChild(leftToReplace, leftReplacement);\n            expr.replaceChild(rightToReplace, rightReplacement);\n        }\n        return expr;\n    }\n\n    if (expr.isConditional()) {\n        Node condition = expr.getFirstChild();\n        Node thenBlock = condition.getNext();\n        Node elseBlock = thenBlock.getNext();\n}\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isCall()) {\n      // Replace function calls with string literals.\n      String replacement = nameGenerator.generateNextName();\n      RecordFunctionCall(replacement, expr);\n      return IR.string(replacement);\n    }\n    if (expr.isString()) {\n      // Replace string literals with string literals.\n      return expr;\n    }\n    if (expr.isName()) {\n      // Replace variable references with string literals.\n      return IR.string(expr.getString());\n    }\n    if (expr.isQualifiedName()) {\n      // Replace qualified names with string literals.\n      return IR.string(expr.getQualifiedName());\n    }\n    if (expr.isVarArgs()) {\n      // Replace varargs with string literals.\n      return IR.string(expr.getVarArgs());\n    }\n    if (expr.isOptionalArg()) {\n      // Replace optional arguments with string literals.\n      return IR.string(expr.getOptionalArg());\n    }\n    if (expr.isSyntheticBlock()) {\n      // Replace synthetic blocks with string literals.\n      return IR.string(expr.getSyntheticBlock());\n    }\n    if (expr.isQuotedString()) {\n      // Replace quoted strings with string literals.\n      return IR.string(expr.getString());\n    }\n\n    // Replace other expressions with placeholders.\n    String replacement = nameGenerator.generateNextName();\n    RecordExpression(replacement, expr);\n    return IR.string(replacement);\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  Node result = null;\n  if (expr.isString() || expr.isQuotedString()) {\n    return expr;\n  } else if (expr.isCall()) {\n    // Replace any function calls with a placeholder token.\n    result = nameGenerator.generateNextName();\n    recordReplacement(expr, result);\n    return IR.string(placeholderToken);\n  } else {\n    // Replace any other expression with a placeholder token.\n    result = nameGenerator.generateNextName();\n    recordReplacement(expr, result);\n    return IR.string(placeholderToken);\n  }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (parent.isCall()) {\n        return replaceCallExpression(t, expr, parent);\n    } else if (parent.isNew()) {\n        return replaceNewExpression(t, expr, parent);\n    } else {\n        return replaceExpressionWithTemporaryName(t, expr, parent);\n    }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  Node result = null;\n  if (expr.isQuotedString()) {\n    if (!expr.isString()) {\n      t.report(expr, REPLACE_ONE_MARKER, \"quotedString\");\n      result = IR.string(getReplacement(expr.getString()));\n    } else {\n      t.report(expr, REPLACE_ONE_MARKER, \"string\");\n      result = IR.name(getReplacement(expr.getString()));\n    }\n  } else if (expr.isString()) {\n    t.report(expr, REPLACE_ONE_MARKER, \"string\");\n    result = IR.name(getReplacement(expr.getString()));\n  } else if (expr.isCall()) {\n    String key = getReplacement(expr.getQualifiedName());\n    if (key != null) {\n      t.report(expr, REPLACE_ONE_MARKER, \"functionCall\");\n      result = IR.name(key);\n      if (replaceCalls) {\n        doSubstitutions(t, findMatching(key), expr);\n      }\n    }\n  } else if (expr.isQualifiedName()) {\n    String key = getReplacement(expr.getQualifiedName());\n    if (key != null) {\n      t.report(expr, REPLACE_ONE_MARKER, \"qualifiedName\");\n      result = IR.name(key);\n      if (replaceCalls) {\n        doSubstitutions(t, findMatching(key), expr);\n      }\n    }\n  } else if (expr.isCase()) {\n    // Replace the switch case label with the replacement name.\n    t.report(expr, REPLACE_ONE_MARKER, \"case\");\n    result = IR.name(getReplacement(expr.getQualifiedName()));\n    if (replaceCases) {\n      doSubstitutions(t, findMatching(expr.getQualifiedName()), expr);\n    }\n  } else if (expr.isGetterDef()) {\n    // Replace the property name with the replacement name.\n    t.report(expr, REPLACE_ONE_MARKER, \"getter\");\n    result = IR.name(getReplacement(expr.getQualifiedName()));\n    if (replaceGetters) {\n      doSubstitutions(t, findMatching(expr.getQualifiedName()), expr);\n    }\n}\n}"
    ],
    [
      "public double[] getCoefficients()  {\n    double[] out = new double[c.length + a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    System.arraycopy(c, 0, out, a.length, c.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[c.length + a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    System.arraycopy(c, 0, out, a.length, c.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length + c.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    System.arraycopy(c, 0, out, a.length, c.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[c.length + a.length];\n    System.arraycopy(c, 0, out, 0, c.length);\n    System.arraycopy(a, 0, out, c.length, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length + c.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    System.arraycopy(c, 0, out, a.length, c.length);\n    return out;\n}"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo jsDocInfo = node.getJSDocInfo();\n  if (jsDocInfo != null) {\n    String desc = jsDocInfo.getDescription();\n    if (desc != null && !desc.isEmpty()) {\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo jsDocInfo = node.getJSDocInfo();\n    if (jsDocInfo != null) {\n        String desc = jsDocInfo.getDescription();\n        if (desc != null && !desc.isEmpty()) {\n            builder.setDesc(desc);\n            return true;\n        } else {\n            throw new MalformedException(\"Invalid JsDoc description: \" + desc, node);\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo docInfo = node.getJSDocInfo();\n  if (docInfo == null || !docInfo.hasTag(JSDocInfo.TAG_DESC)) {\n    return false;\n  }\n\n  // Check for the description in the @desc tag.\n  String description = docInfo.getDescription();\n  if (description == null) {\n    throw new MalformedException(\n        \"Missing description in @desc annotation for message \" +\n            builder.getKey(), node);\n  }\n\n  builder.setDesc(description);\n  return true;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info == null) {\n    return false;\n  }\n  String desc = info.getDescription();\n  if (desc == null || desc.isEmpty()) {\n    return false;\n  }\n  builder.setDesc(desc.trim());\n  if (info.isMeaning()) {\n    builder.setMeaning(info.getMeaning().trim());\n  }\n  return true;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo info = node.getJSDocInfo();\n    if (info != null) {\n      if (info.hasDesc()) {\n        builder.setDesc(info.getDescription());\n      } else if (info.isMeaning()) {\n        builder.setMeaning(info.getMeaning());\n      } else if (info.isKey()) {\n        builder.setKey(info.getKey());\n      }\n      if (info.isOptional()) {\n        builder.setIsOptionalArg(true);\n      }\n      if (info.isStatic()) {\n        builder.setIsStatic(true);\n      }\n      if (info.isNoSideEffects()) {\n        builder.setSideEffectFlags(SideEffectFlags.NO_SIDE_EFFECTS);\n      } else {\n        if (info.getModifies().contains(\"this\")) {\n          builder.setSideEffectFlags(SideEffectFlags.ONLY_MODIFIES_THIS);\n        } else if (info.getModifies().size() > 1 ||\n            (info.getModifies().size() == 1 && !info.getModifies().contains(\"this\"))) {\n          builder.setSideEffectFlags(SideEffectFlags.ONLY_MODIFIES_ARGUMENTS);\n        }\n      }\n      return true;\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo jsDocInfo = node.getJSDocInfo();\n    if (jsDocInfo != null) {\n        String desc = jsDocInfo.getDescription();\n        if (desc != null) {\n            builder.setDesc(desc);\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo jsDocInfo = node.getJSDocInfo();\n    if (jsDocInfo == null) {\n      return false;\n    }\n    String desc = jsDocInfo.getDescription();\n    if (desc == null || desc.isEmpty()) {\n      return false;\n    }\n    desc = desc.trim();\n    if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n      builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n      builder.setIsHidden(true);\n    } else {\n      builder.setDesc(desc);\n    }\n    return true;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo == null) {\n      return false;\n    }\n\n    // Extract description\n    String description = docInfo.getDescription();\n    if (description != null) {\n      builder.setDesc(description);\n      return true;\n    }\n\n    // Extract key\n    String key = docInfo.getKey();\n    if (key != null) {\n      builder.setKey(key);\n      return true;\n    }\n\n    // Extract meaning\n    String meaning = docInfo.getMeaning();\n    if (meaning != null) {\n      builder.setMeaning(meaning);\n      return true;\n    }\n\n    // Extract parts\n    for (String part : docInfo.getParts()) {\n      builder.appendStringPart(part);\n    }\n\n    // Extract placeholders\n    for (String placeholder : docInfo.getPlaceholders()) {\n      builder.appendPlaceholderReference(placeholder);\n    }\n\n    // Extract hidden\n    if (docInfo.isPrivate()) {\n      builder.setIsHidden(true);\n    }\n\n    return true;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    String desc = info.getDescription();\n    if (desc != null) {\n      desc = desc.trim();\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo jsDocInfo = node.getJSDocInfo();\n    if (jsDocInfo != null) {\n      String desc = jsDocInfo.getDescription();\n      if (desc != null && !desc.isEmpty()) {\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n\n    // Iterate over all points\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n\n        // If the point is assigned to a different cluster than previously, increment the assignedDifferently counter\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        // Add the point to the corresponding cluster\n        clusters.get(clusterIndex).addPoint(p);\n\n        // Update the point's assignment\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\nint assignedDifferently = 0;\nint pointIndex = 0;\nfor (final T p : points) \n{\nint clusterIndex = getNearestCluster(clusters, p);\nif (clusterIndex != assignments[pointIndex]) \n{\nassignedDifferently++;\n}\n\nCentroidCluster<T> cluster = clusters.get(clusterIndex);\ncluster.addPoint(p);\nassignments[pointIndex++] = clusterIndex;\n}\n\nreturn assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double sum_xy = 0.0;\n        double sum_x = 0.0;\n        double sum_y = 0.0;\n        double sum_x2 = 0.0;\n        double sum_y2 = 0.0;\n        double n = (double) xArray.length;\n        for (int i = 0; i < xArray.length; i++) {\n            sum_x += xArray[i];\n            sum_y += yArray[i];\n            sum_x2 += xArray[i] * xArray[i];\n            sum_y2 += yArray[i] * yArray[i];\n            sum_xy += xArray[i] * yArray[i];\n        }\n        double covariance = (sum_xy - sum_x * sum_y / n) / (n - 1);\n        return biasCorrected ? covariance : covariance * n / (n - 1);\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double sumX = 0.0;\n        double sumY = 0.0;\n        double sumXY = 0.0;\n        double sumXSqr = 0.0;\n        double sumYSqr = 0.0;\n        int length = xArray.length;\n\n        for (int i = 0; i < length; i++) {\n            double x = xArray[i];\n            double y = yArray[i];\n\n            sumX += x;\n            sumY += y;\n            sumXY += x * y;\n            sumXSqr += x * x;\n            sumYSqr += y * y;\n        }\n\n        double meanX = sumX / length;\n        double meanY = sumY / length;\n\n        double cov = (sumXY - length * meanX * meanY) / (length - 1);\n        if (biasCorrected) {\n            cov = cov * length / (length - 1);\n        }\n\n        return cov;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double sum_xy = 0.0;\n        double sum_x = 0.0;\n        double sum_y = 0.0;\n        double sum_x2 = 0.0;\n        double sum_y2 = 0.0;\n        for (int i = 0; i < xArray.length; i++) {\n            sum_x += xArray[i];\n            sum_y += yArray[i];\n            sum_xy += xArray[i] * yArray[i];\n            sum_x2 += xArray[i] * xArray[i];\n            sum_y2 += yArray[i] * yArray[i];\n        }\n        int n = xArray.length;\n        double mean_x = sum_x / n;\n        double mean_y = sum_y / n;\n        double cov = (n * sum_xy - sum_x * sum_y) / (n * (n - 1));\n        if (biasCorrected) {\n            cov = (n * sum_xy - sum_x * sum_y) / (n * (n - 1));\n        } else {\n            cov = (n * sum_xy - sum_x * sum_y) / (n - 1);\n        }\n        return cov;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double sumX = 0.0;\n        double sumY = 0.0;\n        double sumXY = 0.0;\n        double sumXSq = 0.0;\n        double sumYSq = 0.0;\n\n        int n = xArray.length;\n\n        for (int i = 0; i < n; i++) {\n            double x = xArray[i];\n            double y = yArray[i];\n\n            sumX += x;\n            sumY += y;\n            sumXY += x * y;\n            sumXSq += x * x;\n            sumYSq += y * y;\n        }\n\n        double meanX = sumX / n;\n        double meanY = sumY / n;\n\n        double numerator = sumXY - n * meanX * meanY;\n        double denominator = Math.sqrt((sumXSq - n * meanX * meanX) * (sumYSq - n * meanY * meanY));\n\n        if (denominator == 0) {\n            return Double.NaN;\n        }\n\n        double covariance = numerator / denominator;\n\n        if (biasCorrected) {\n            covariance = covariance * (n / (n - 1));\n        }\n\n        return covariance;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double sum_xx = 0.0;\n        double sum_yy = 0.0;\n        double sum_xy = 0.0;\n        for (int i = 0; i < xArray.length; i++) {\n            sum_xx += Math.pow(xArray[i], 2);\n            sum_yy += Math.pow(yArray[i], 2);\n            sum_xy += xArray[i] * yArray[i];\n        }\n        int n = xArray.length;\n        double mean_x = sum_xx / n;\n        double mean_y = sum_yy / n;\n        double cov = (sum_xy - n * mean_x * mean_y) / (n - 1);\n        if (biasCorrected) {\n            cov = cov * (n / (n - 1));\n        }\n        return cov;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double sumXY = 0.0d;\n        double sumX = 0.0d;\n        double sumY = 0.0d;\n        double sumXSq = 0.0d;\n        double sumYSq = 0.0d;\n        for (int i = 0; i < xArray.length; i++) {\n            double x = xArray[i];\n            double y = yArray[i];\n            sumXY += x * y;\n            sumX += x;\n            sumY += y;\n            sumXSq += x * x;\n            sumYSq += y * y;\n        }\n        int n = xArray.length;\n        double numerator = n * sumXY - sumX * sumY;\n        double denominator = Math.sqrt((n * sumXSq - sumX * sumX) * (n * sumYSq - sumY * sumY));\n        double r = numerator / denominator;\n        if (biasCorrected) {\n            r = (n * r) / (n - 1);\n        }\n        return r;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double sumXY = 0.0;\n        double sumX2 = 0.0;\n        double sumY2 = 0.0;\n        double xAvg = 0.0;\n        double yAvg = 0.0;\n        int n = xArray.length;\n        for (int i = 0; i < n; i++) {\n            xAvg += xArray[i];\n            yAvg += yArray[i];\n        }\n        xAvg /= n;\n        yAvg /= n;\n        for (int i = 0; i < n; i++) {\n            double x = xArray[i] - xAvg;\n            double y = yArray[i] - yAvg;\n            sumXY += x * y;\n            sumX2 += x * x;\n            sumY2 += y * y;\n        }\n        double temp = sumX2 * sumY2;\n        if (temp == 0.0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.CORRELATION_SINGULARITY);\n        }\n        double cov = sumXY / (n - (biasCorrected ? 1 : 0));\n        return cov;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double sumX = 0.0;\n        double sumY = 0.0;\n        double sumXY = 0.0;\n        double sumXSq = 0.0;\n        double sumYSq = 0.0;\n\n        // Calculate the sums\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n            sumXSq += xArray[i] * xArray[i];\n            sumYSq += yArray[i] * yArray[i];\n        }\n\n        // Calculate the covariance\n        double covariance = (sumXY - (sumX * sumY) / xArray.length) / (xArray.length - 1);\n\n        // Bias correction\n        if (biasCorrected) {\n            covariance *= (xArray.length - 2) / (xArray.length - 1);\n        }\n\n        return covariance;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double sumX = 0.0;\n        double sumY = 0.0;\n        double sumXY = 0.0;\n        double sumXSq = 0.0;\n        double sumYSq = 0.0;\n\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n            sumXSq += xArray[i] * xArray[i];\n            sumYSq += yArray[i] * yArray[i];\n        }\n\n        int n = xArray.length;\n        double meanX = sumX / n;\n        double meanY = sumY / n;\n\n        double covXY = (n * sumXY - sumX * sumY) / (n * (n - 1));\n        if (biasCorrected) {\n            covXY = covXY * (n - 2) / (n - 1);\n        }\n\n        return covXY;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double sumXY = 0.0d;\n        double sumX = 0.0d;\n        double sumY = 0.0d;\n        double sumX2 = 0.0d;\n        double sumY2 = 0.0d;\n        for (int i = 0; i < xArray.length; i++) {\n            sumXY += xArray[i] * yArray[i];\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumX2 += xArray[i] * xArray[i];\n            sumY2 += yArray[i] * yArray[i];\n        }\n        double n = xArray.length;\n        if (biasCorrected) {\n            n -= 1.0d;\n        }\n        return (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n    }\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    if (value > Integer.MAX_VALUE) \n    {\n        skip(Integer.MAX_VALUE);\n        realSkip(value - Integer.MAX_VALUE);\n    }\n    else if (value > 0) \n    {\n        final long skipped = is.skip(value);\n        count(skipped);\n        entryOffset += skipped;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value > Integer.MAX_VALUE) \n    {\n        throw new EOFException(\"Truncated ZIP entry: \"\n                + ArchiveUtils.sanitize(current.entry.getName()));\n    }\n\n    final long remaining = value - current.bytesReadFromStream;\n    final long n = in.skip(remaining);\n    if (n != remaining) \n    {\n        throw new EOFException(\"Truncated ZIP entry: \"\n                + ArchiveUtils.sanitize(current.entry.getName()));\n    }\n    count(n);\n    current.bytesReadFromStream += n;\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value > 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = readOneByte();\n            if (x == -1) {\n                throw new EOFException(\"Truncated ZIP entry: \"\n                                       + ArchiveUtils.sanitize(current.entry.getName()));\n            }\n            skipped += x;\n        }\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value <= 0) \n    {\n        return;\n    }\n    final long available = in.available();\n    final long skipped = Math.min(value, available);\n    final int x = in.read(skipBuf, 0, (int) skipped);\n    if (x == -1) \n    {\n        throw new EOFException();\n    }\n    count(x);\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value <= 0)\n    {\n        return;\n    }\n    long skipped = 0;\n    while (skipped < value)\n    {\n        final long rem = value - skipped;\n        final int x = readOneByte();\n        if (x == -1)\n        {\n            return;\n        }\n        skipped += x;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) {\n                throw new EOFException(\"Truncated ZIP entry: \"\n                                                      + ArchiveUtils.sanitize(current.entry.getName()));\n            }\n            skipped += x;\n        }\n        count(skipped);\n    } else {\n        throw new IllegalArgumentException();\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value > Integer.MAX_VALUE) {\n        throw new IOException(\"Cannot skip more than \" + Integer.MAX_VALUE + \" bytes at once\");\n    }\n    if (value > 0) {\n        final int readLen = Math.min(value > 0x7FFFFFFF ? 0x7FFFFFFF : (int) value, Integer.MAX_VALUE);\n        final byte[] buf = new byte[readLen];\n        int remaining = readLen;\n        while (remaining > 0) {\n            final int read = in.read(buf, readLen - remaining, remaining);\n            if (read == -1) {\n                throw new EOFException(\"Truncated ZIP entry: \"\n                                                               + ArchiveUtils.sanitize(current.entry.getName()));\n            }\n            remaining -= read;\n            count(read);\n        }\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = readOneByte();\n            if (x == -1) {\n                return;\n            }\n            skipped += x;\n        }\n        return;\n    }\n    throw new IllegalArgumentException();\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = readOneByte();\n            if (x == -1) {\n                return;\n            }\n            skipped += x;\n        }\n        count(skipped);\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value <= 0)\n    {\n        return;\n    }\n    long skipped = 0;\n    while (skipped < value)\n    {\n        final long rem = value - skipped;\n        final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1)\n        {\n            throw new EOFException(\"Unexpected end of ZIP stream\");\n        }\n        skipped += x;\n    }\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null)\n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null)\n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null)\n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null)\n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null)\n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null)\n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null)\n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  StringBuilder sb = new StringBuilder();\n  for (CharSequence part : messageParts) {\n    if (part instanceof PlaceholderReference) {\n      sb.append(CaseFormat.LOWER_CAMEL.to(\n          CaseFormat.UPPER_UNDERSCORE,\n          ((PlaceholderReference) part).getName()));\n    } else {\n      sb.append(part);\n    }\n  }\n  String tcValue = sb.toString();\n\n  return String.valueOf(FP.fingerprint(tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  StringBuilder sb = new StringBuilder();\n  for (CharSequence part : messageParts) {\n    if (part instanceof PlaceholderReference) {\n      sb.append(CaseFormat.LOWER_CAMEL.to(\n          CaseFormat.UPPER_UNDERSCORE,\n          ((PlaceholderReference) part).getName()));\n    } else {\n      sb.append(part);\n    }\n  }\n  String tcValue = sb.toString();\n  return Long.toString(\n      GoogleJsMessageIdGenerator.FP.fingerprint(tcValue), 36);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  StringBuilder sb = new StringBuilder();\n  for (CharSequence part : messageParts) {\n    if (part instanceof PlaceholderReference) {\n      sb.append(CaseFormat.LOWER_CAMEL.to(\n          CaseFormat.UPPER_UNDERSCORE,\n          ((PlaceholderReference) part).getName()));\n    } else {\n      sb.append(part);\n    }\n  }\n  String tcValue = sb.toString();\n\n  long fingerprint = GoogleJsMessageIdGenerator.FP.fingerprint(tcValue);\n  return Long.toString(fingerprint, Character.MAX_RADIX);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  StringBuilder sb = new StringBuilder();\n  for (CharSequence part : messageParts) {\n    if (part instanceof PlaceholderReference) {\n      sb.append(CaseFormat.LOWER_CAMEL.to(\n          CaseFormat.UPPER_UNDERSCORE,\n          ((PlaceholderReference) part).getName()));\n    } else {\n      sb.append(part);\n    }\n  }\n  String tcValue = sb.toString();\n  return String.valueOf(FP.fingerprint(tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } else \n        {\n            sb.append(part);\n        }\n    }\n    return String.valueOf(FP.fingerprint(sb.toString()));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  StringBuilder sb = new StringBuilder();\n  for (CharSequence part : messageParts) {\n    if (part instanceof PlaceholderReference) {\n      sb.append(CaseFormat.LOWER_CAMEL.to(\n          CaseFormat.UPPER_UNDERSCORE,\n          ((PlaceholderReference) part).getName()));\n    } else {\n      sb.append(part);\n    }\n  }\n  return String.valueOf(FP.fingerprint(sb.toString()));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  StringBuilder sb = new StringBuilder();\n  for (CharSequence part : messageParts) {\n    if (part instanceof PlaceholderReference) {\n      sb.append(CaseFormat.LOWER_CAMEL.to(\n          CaseFormat.UPPER_UNDERSCORE,\n          ((PlaceholderReference) part).getName()));\n    } else {\n      sb.append(part);\n    }\n  }\n  return String.valueOf(\n      MessageId.generateId(sb.toString(), null));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  StringBuilder sb = new StringBuilder();\n  for (CharSequence part : messageParts) {\n    if (part instanceof PlaceholderReference) {\n      sb.append(CaseFormat.LOWER_CAMEL.to(\n          CaseFormat.UPPER_UNDERSCORE,\n          ((PlaceholderReference) part).getName()));\n    } else {\n      sb.append(part);\n    }\n  }\n  String tcValue = sb.toString();\n\n  long fp = GoogleJsMessageIdGenerator.FP.fingerprint(tcValue);\n  return String.valueOf(fp);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  StringBuilder sb = new StringBuilder();\n  for (CharSequence part : messageParts) {\n    if (part instanceof PlaceholderReference) {\n      sb.append(CaseFormat.LOWER_CAMEL.to(\n          CaseFormat.UPPER_UNDERSCORE,\n          ((PlaceholderReference) part).getName()));\n    } else {\n      sb.append(part);\n    }\n  }\n  return String.valueOf(\n      MessageId.generateId(sb.toString(), null));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n  StringBuilder sb = new StringBuilder();\n  for (CharSequence part : messageParts) {\n    if (part instanceof PlaceholderReference) {\n      sb.append(CaseFormat.LOWER_CAMEL.to(\n          CaseFormat.UPPER_UNDERSCORE,\n          ((PlaceholderReference) part).getName()));\n    } else {\n      sb.append(part);\n    }\n  }\n  return String.valueOf(\n      FP.fingerprint(sb.toString()));\n}"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long currentPosition = archive.position();\n    final long startPosition = currentPosition - maxDistanceFromEnd;\n    long position = currentPosition - minDistanceFromEnd;\n    if (position < startPosition) {\n        position = startPosition;\n    }\n    archive.position(position);\n    final ByteBuffer bbuf = ByteBuffer.allocate(sig.length);\n    while (position < currentPosition) {\n        bbuf.rewind();\n        IOUtils.readFully(archive, bbuf);\n        if (Arrays.equals(sig, bbuf.array())) {\n            return true;\n        }\n        position++;\n        archive.position(position);\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long start = archive.size() - maxDistanceFromEnd;\n    long currentPosition = archive.position();\n    while (currentPosition >= start) {\n        archive.position(currentPosition);\n        if (IOUtils.readFully(archive, sig) == sig.length) {\n            return true;\n        }\n        currentPosition -= 2;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long newPosition = currentPosition - maxDistanceFromEnd;\n    if (newPosition < minDistanceFromEnd) {\n        newPosition = minDistanceFromEnd;\n    }\n    archive.position(newPosition);\n    if (!Arrays.equals(sig, readBytes(maxDistanceFromEnd - minDistanceFromEnd))) {\n        archive.position(currentPosition);\n        return false;\n    }\n    return true;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long newPosition = currentPosition - maxDistanceFromEnd;\n    if (newPosition < 0) {\n        newPosition = 0;\n    }\n    archive.position(newPosition);\n    long startPosition = archive.position();\n    boolean found = IOUtils.indexOf(archive, sig) >= 0;\n    if (!found) {\n        archive.position(currentPosition);\n    }\n    return found;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long newPosition = currentPosition - maxDistanceFromEnd;\n\n    if (newPosition < 0) {\n        return false;\n    }\n\n    if (newPosition < currentPosition - minDistanceFromEnd) {\n        newPosition = currentPosition - minDistanceFromEnd;\n    }\n\n    archive.position(newPosition);\n    int len = Math.toIntExact(Math.min(maxDistanceFromEnd, currentPosition - newPosition));\n\n    byte[] tmpBuf = new byte[len];\n    long bytesRead = 0L;\n    do {\n        int r = archive.read(tmpBuf, (int) bytesRead, len - (int) bytesRead);\n        if (r == -1) {\n            return false;\n        }\n        bytesRead += r;\n    } while (bytesRead < len);\n\n    for (int i = len - sig.length; i >= 0; i--) {\n        if (Arrays.equals(sig, tmpBuf, i, sig.length)) {\n            archive.position(newPosition + i);\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long newPosition = currentPosition - maxDistanceFromEnd;\n\n    while (currentPosition - newPosition > minDistanceFromEnd) {\n        archive.position(newPosition);\n        byte[] signature = new byte[sig.length];\n        IOUtils.readFully(archive, signature);\n        if (Arrays.equals(signature, sig)) {\n            return true;\n        }\n        newPosition -= sig.length;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long newPosition = currentPosition - minDistanceFromEnd;\n    if (newPosition < 0) {\n        newPosition = 0;\n    }\n    archive.position(newPosition);\n    long end = archive.size();\n    while (newPosition < end) {\n        if (IOUtils.readFully(archive, wordBbuf) != WORD) {\n            throw new IOException(\"Unexpected end of ZIP archive\");\n        }\n        if (Arrays.equals(sig, wordBuf)) {\n            return true;\n        }\n        newPosition += WORD;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long currentPosition = archive.size();\n    final long startPosition = Math.max(currentPosition - maxDistanceFromEnd, 0);\n    long endPosition = Math.max(currentPosition - minDistanceFromEnd, startPosition);\n\n    while (startPosition <= endPosition) {\n        archive.position(endPosition);\n        final int read = archive.read(sig);\n        if (read != -1 && Arrays.equals(sig, sig)) {\n            return true;\n        }\n        endPosition--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long endPosition = archive.size();\n    final long minPosition = endPosition - minDistanceFromEnd;\n    final long maxPosition = endPosition - maxDistanceFromEnd;\n    final long startPosition = Math.max(minPosition, maxPosition - 0xFFFFL);\n\n    archive.position(startPosition);\n    long currentPosition;\n    while ((currentPosition = archive.position()) < endPosition) {\n        int len = (int) Math.min(maxPosition - currentPosition, 0xFFFFL);\n        len = IOUtils.indexOf(archive, sig, len);\n        if (len >= 0) {\n            archive.position(currentPosition + len);\n            return true;\n        }\n        archive.position((int) currentPosition - 0xFFFFL);\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long newPosition = currentPosition - maxDistanceFromEnd;\n    if (newPosition < archive.size() - minDistanceFromEnd) {\n        newPosition = archive.size() - minDistanceFromEnd;\n    }\n    archive.position(newPosition);\n    if (archive.read(sig) == sig.length) {\n        return true;\n    } else {\n        return false;\n    }\n}"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n        AxisLocation location = getDomainAxisLocation(index);\n        RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getDomainAxisEdge());\n        }\n        return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n        AxisLocation location = getDomainAxisLocation(index);\n        RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getDomainAxisEdge());\n        }\n        return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n        AxisLocation location = getDomainAxisLocation(index);\n        RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getDomainAxisEdge(0));\n        }\n        return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n        AxisLocation location = getDomainAxisLocation(index);\n        RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getDomainAxisEdge(0));\n        }\n        return result;\n    }",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n        AxisLocation location = getDomainAxisLocation(index);\n        RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getDomainAxisEdge());\n        }\n        return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n        AxisLocation location = getDomainAxisLocation(index);\n        RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getDomainAxisEdge());\n        }\n        return result;\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public InputStream getDataStream()  {\n    if (_originalStream != null) {\n        return _originalStream;\n    }\n    \n    if (_bufferedData != null) {\n        ByteArrayInputStream bais = new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n        return bais;\n    }\n    \n    return null;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) return null;\n    \n    if (_bufferedData == null) \n    {\n        return _originalStream;\n    }\n    \n    final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    return new SequenceInputStream(byteArrayInputStream, _originalStream);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream != null) \n    {\n        return _originalStream;\n    }\n    else \n    {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream != null) {\n        return _originalStream;\n    }\n    \n    if (_bufferedData != null) {\n        final int len = _bufferedStart + _bufferedLength;\n        final byte[] copy = new byte[len];\n        System.arraycopy(_bufferedData, _bufferedStart, copy, 0, len);\n        return new ByteArrayInputStream(copy);\n    }\n    \n    return new ByteArrayInputStream(new byte[0]);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream != null) \n    {\n        return _originalStream;\n    }\n    if (_bufferedData != null) \n    {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return null;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream != null) \n    {\n        return _originalStream;\n    }\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream != null) return _originalStream;\n    if (_bufferedData != null)\n    {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return null;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) return null;\n    if (_bufferedData == null) return _originalStream;\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream != null) \n    {\n        return _originalStream;\n    }\n    else \n    {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    return section;\n}",
      "protected Comparable getSectionKey(int section)  {\n    return section;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    PieDataset dataset = getDataset();\n    if (dataset == null) {\n        key = new Integer(section);\n    }\n    else {\n        key = dataset.getSeriesKey(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    return section;\n}",
      "protected Comparable getSectionKey(int section)  {\n    int series = getSeriesIndex(section);\n    Comparable key = getSeriesKey(series);\n\n    // Generate unique keys if necessary.\n    if (key == null) {\n        key = new Integer(section);\n    }\n\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    PieDataset dataset = getDataset();\n    if (dataset instanceof TimeTableXYDataset) {\n        key = dataset.getColumnKey(section);\n    } else {\n        key = dataset.getSeriesKey(section);\n    }\n\n    if (key == null) {\n        key = new Integer(section);\n    }\n\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    PieDataset dataset = getDataset();\n    if (dataset != null) {\n        int keys = dataset.getColumnCount();\n        if (keys > section) {\n            result = dataset.getColumnKey(section);\n        }\n    }\n    if (result == null) {\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = this.pieDataset.getSeriesKey(section);\n    if (result == null) {\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section >= 0 && section < dataset.getRowCount()) {\n        Comparable key = dataset.getRowKey(section);\n        if (key != null) {\n            return key;\n        }\n    }\n\n    // generate a unique key (just an incrementing number)\n    return new Integer(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.values.getColumnKey(section);\n    if (key == null) {\n        key = new Integer(section);\n        this.values.setColumnKey(section, key);\n    }\n    return key;\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            if (_currToken != JsonToken.VALUE_NUMBER_FLOAT) {\n                return false;\n            }\n            Number n = getNumberValue();\n            if (!(n instanceof Float) && !(n instanceof Double)) {\n                return false;\n            }\n            return Double.isNaN(n.doubleValue());\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return Float.isNaN(_currentObject().floatValue());\n            }\n            if (_currToken == JsonToken.VALUE_NUMBER_DOUBLE) {\n                return Double.isNaN(_currentObject().doubleValue());\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = getNumberValue();\n                if (n instanceof Float) {\n                    return Float.isNaN((Float)n);\n                } else if (n instanceof Double) {\n                    return Double.isNaN((Double)n);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return Float.isNaN(((Number) _currentObject()).floatValue());\n            }\n            if (_currToken == JsonToken.VALUE_NUMBER_DOUBLE) {\n                return Double.isNaN(((Number) _currentObject()).doubleValue());\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = getNumberValue();\n                if (n instanceof Double) {\n                    return Double.isNaN((double) n);\n                } else if (n instanceof Float) {\n                    return Float.isNaN((float) n);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken != JsonToken.VALUE_NUMBER_FLOAT) {\n                return false;\n            }\n            return Float.isNaN(((Number)_currentObject()).floatValue());\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken != JsonToken.VALUE_NUMBER_FLOAT) {\n                return false;\n            }\n            return Float.isNaN(_currentNumberValue);\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken != JsonToken.VALUE_NUMBER_FLOAT) {\n                return false;\n            }\n            Number n = getNumberValue();\n            if (!(n instanceof Double)) {\n                return false;\n            }\n            return Double.isNaN((Double) n);\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken != JsonToken.VALUE_NUMBER_FLOAT) {\n                return false;\n            }\n            Number n = getNumberValue();\n            if (!(n instanceof Double)) {\n                return false;\n            }\n            return Double.isNaN(n.doubleValue());\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken != JsonToken.VALUE_NUMBER_FLOAT) {\n                return false;\n            }\n            return Float.isNaN(((Number)_currentObject()).floatValue());\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    } \n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    final int prefixLength = prefix.length();\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefixLength);\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = str.length() - suffix.length();\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = 0;\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = str.length() - prefix.length();\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, suffix, 0, suffix.length());\n}"
    ],
    [
      "public String nextString() throws IOException  { \n    int p = peeked; \n    if (p == PEEKED_NONE) \n    { \n        p = doPeek(); \n    } \n\n    if (p == PEEKED_UNQUOTED_NAME) \n    { \n        String result = nextUnquotedValue(); \n        peeked = PEEKED_NONE; \n        pathNames[stackSize - 1] = result; \n        return result; \n    } \n    if (p == PEEKED_SINGLE_QUOTED_NAME) \n    { \n        String result = nextQuotedValue('\\''); \n        peeked = PEEKED_NONE; \n        pathNames[stackSize - 1] = result; \n        return result; \n    } \n    if (p == PEEKED_DOUBLE_QUOTED_NAME) \n    { \n        String result = nextQuotedValue('\"'); \n        peeked = PEEKED_NONE; \n        pathNames[stackSize - 1] = result; \n        return result; \n    } \n\n    if (p == PEEKED_LONG) \n    { \n        peeked = PEEKED_NONE; \n        pathIndices[stackSize - 1]++; \n        return Long.toString(peekedLong); \n    } \n    if (p == PEEKED_NUMBER) \n    { \n        peekedString = new String(buffer, pos, peekedNumberLength); \n        pos += peekedNumberLength; \n    } \n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) \n    { \n        if (p == PEEKED_UNQUOTED) \n        { \n            peekedString = nextUnquotedValue(); \n        } \n        else \n        { \n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"'); \n        } \n    } \n    else \n    { \n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString()); \n    } \n\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n    } else if (p != PEEKED_BUFFERED) {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE)\n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME)\n    {\n        result = nextUnquotedValue();\n    }\n    else if (p == PEEKED_SINGLE_QUOTED_NAME)\n    {\n        result = nextQuotedValue('\\'');\n    }\n    else if (p == PEEKED_DOUBLE_QUOTED_NAME)\n    {\n        result = nextQuotedValue('\"');\n    }\n    else if (p == PEEKED_NUMBER)\n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    }\n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED)\n    {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    else if (p == PEEKED_UNQUOTED)\n    {\n        peekedString = nextUnquotedValue();\n    }\n    else\n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextString() throws IOException  { \n    int p = peeked;\n    if (p == PEEKED_NONE)\n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME)\n    {\n        result = nextUnquotedValue();\n    }\n    else if (p == PEEKED_SINGLE_QUOTED_NAME)\n    {\n        result = nextQuotedValue('\\'');\n    }\n    else if (p == PEEKED_DOUBLE_QUOTED_NAME)\n    {\n        result = nextQuotedValue('\"');\n    }\n    else\n    {\n        throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    String result;\n\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED_NAME) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED_NAME) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) \n    {\n      result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED_NAME)\n    {\n      result = nextQuotedValue('\\'');\n    }\n    else if (p == PEEKED_DOUBLE_QUOTED_NAME)\n    {\n      result = nextQuotedValue('\"');\n    }\n    else if (p == PEEKED_LONG)\n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return Long.toString(peekedLong);\n    }\n    else if (p == PEEKED_NUMBER) \n    {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    }\n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) \n    {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    else if (p == PEEKED_UNQUOTED) \n    {\n      peekedString = nextUnquotedValue();\n    }\n    else if (p != PEEKED_BUFFERED) \n    {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) \n    {\n      result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED_NAME)\n    {\n      result = nextQuotedValue('\\'');\n    }\n    else if (p == PEEKED_DOUBLE_QUOTED_NAME)\n    {\n      result = nextQuotedValue('\"');\n    }\n    else if (p == PEEKED_LONG) \n    {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return \"\" + peekedLong;\n    }\n    else if (p == PEEKED_NUMBER) \n    {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } \n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) \n    {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } \n    else if (p == PEEKED_UNQUOTED) \n    {\n      peekedString = nextUnquotedValue();\n    } \n    else \n    {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n      p = doPeek();\n    }\n\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) \n    {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) \n    {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) \n    {\n      result = nextQuotedValue('\"');\n    } \n    else \n    {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Max width must be >= 4\");\n    }\n    final int len = str.length();\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (offset > len) {\n        offset = len;\n    }\n    if (offset + maxWidth > len) {\n        return str.substring(offset, len);\n    }\n    return \"...\" + str.substring(offset, offset + maxWidth - 3);\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Max width must be >= 4\");\n    }\n    final int len = str.length();\n    if (offset < 0) {\n        offset = 0;\n    } else {\n        offset = Math.min(offset, len);\n    }\n    if (offset >= len) {\n        return EMPTY;\n    }\n    if (offset + maxWidth >= len) {\n        return str.substring(offset);\n    }\n    return str.substring(offset, offset + maxWidth - 3) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Width must be at least 4\");\n    }\n\n    if (offset < 0) {\n        offset = 0;\n    }\n\n    if (offset > len) {\n        offset = len;\n    }\n\n    if (offset + maxWidth >= len) {\n        return str;\n    }\n\n    return str.substring(offset, offset + maxWidth - 3) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Width must be >= 4\");\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (offset > len) {\n        offset = len;\n    }\n    if (len - offset <= maxWidth - 3) {\n        return str;\n    }\n    return (str.substring(offset, offset + (maxWidth - 3)) + \"...\");\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Max width must be at least 4\");\n    }\n    final int len = str.length();\n    if (len <= offset) {\n        return EMPTY;\n    }\n    if (len - offset <= maxWidth - 3) {\n        return str;\n    }\n    return appendIfMissing(str, \"...\", offset, len - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (offset > len) {\n        offset = len;\n    }\n\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Abbreviated String must be at least 4 characters long\");\n    }\n\n    if (len - offset <= maxWidth - 3) {\n        return str;\n    }\n\n    return (str.substring(offset, offset + (maxWidth - 3)) + \"...\");\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Max width must be at least 4\");\n    }\n    final int len = str.length();\n    if (len <= maxWidth) {\n        return str;\n    }\n    if (offset < 0) {\n        offset = 0;\n    } else if (offset > len) {\n        offset = len;\n    }\n    if (offset >= maxWidth) {\n        return EMPTY;\n    }\n    final int newLen = len - maxWidth + 3;\n    final char[] buf = new char[newLen];\n    final int end = Math.min(offset + maxWidth - 3, len);\n    str.getChars(offset, end, buf, 0);\n    buf[maxWidth - 4] = '.';\n    buf[maxWidth - 3] = '.';\n    buf[maxWidth - 2] = '.';\n    return new String(buf);\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException();\n    }\n    if (offset < 0) {\n        offset = 0;\n    } else if (offset > len) {\n        offset = len;\n    }\n    if (offset >= maxWidth - 3) {\n        return str.substring(offset);\n    } else if (len <= maxWidth) {\n        return str;\n    } else {\n        return str.substring(offset, offset + (maxWidth - 3)) + \"...\";\n    }\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (offset > len) {\n        offset = len;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"width must be >= 4\");\n    }\n    if (len - offset <= maxWidth - 3) {\n        return str;\n    }\n    return str.substring(offset, offset + (maxWidth - 3)) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (offset > len) {\n        offset = len;\n    }\n\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Width must be at least 4\");\n    }\n\n    if (offset + maxWidth >= len) {\n        return str;\n    } else {\n        return (str.substring(offset, offset + maxWidth - 3) + \"...\");\n    }\n}"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastMapping.originalName) {\n        lastMapping.originalName = symbolName;\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) {\n            lastMapping.id = index;\n        } else {\n            lastMapping.id = originalNameMap.size();\n            originalNameMap.put(symbolName, lastMapping.id);\n        }\n    }\n    return lastMapping.id;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastMapping.originalName) {\n        lastMapping.originalName = symbolName;\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) {\n            lastSourceFileIndex = index;\n        } else {\n            lastSourceFileIndex = originalNameMap.size();\n            originalNameMap.put(symbolName, lastSourceFileIndex);\n        }\n    }\n    return lastSourceFileIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastMapping.originalName) {\n      lastMapping.originalName = symbolName;\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        lastMapping.id = index;\n      } else {\n        lastMapping.id = originalNameMap.size();\n        originalNameMap.put(symbolName, lastMapping.id);\n      }\n    }\n    return lastMapping.id;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastMapping.originalName) {\n        lastMapping.originalName = symbolName;\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) {\n            lastMapping.id = index;\n        } else {\n            lastMapping.id = originalNameMap.size();\n            originalNameMap.put(symbolName, lastMapping.id);\n        }\n    }\n    return lastMapping.id;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastMapping.originalName) {\n      lastMapping.originalName = symbolName;\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        lastMapping.id = index;\n      } else {\n        lastMapping.id = originalNameMap.size();\n        originalNameMap.put(symbolName, lastMapping.id);\n      }\n    }\n    return lastMapping.id;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastMapping.originalName) {\n      lastMapping.originalName = symbolName;\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        lastMapping.id = index;\n      } else {\n        lastMapping.id = originalNameMap.size();\n        originalNameMap.put(symbolName, lastMapping.id);\n      }\n    }\n    return lastMapping.id;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastMapping.originalName) {\n      lastMapping.originalName = symbolName;\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        lastMapping.id = index;\n      } else {\n        lastMapping.id = originalNameMap.size();\n        originalNameMap.put(symbolName, lastMapping.id);\n      }\n    }\n    return lastMapping.id;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastMapping.originalName) {\n        lastMapping.originalName = symbolName;\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) {\n            lastSourceFileIndex = index;\n        } else {\n            lastSourceFileIndex = originalNameMap.size();\n            originalNameMap.put(symbolName, lastSourceFileIndex);\n        }\n    }\n    return lastSourceFileIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastMapping.originalName) {\n        lastMapping.originalName = symbolName;\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) {\n            lastMapping.id = index;\n        } else {\n            lastMapping.id = originalNameMap.size();\n            originalNameMap.put(symbolName, lastMapping.id);\n        }\n    }\n    return lastMapping.id;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastMapping.originalName) {\n        lastMapping.originalName = symbolName;\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) {\n            lastMapping.id = index;\n        } else {\n            lastMapping.id = originalNameMap.size();\n            originalNameMap.put(symbolName, lastMapping.id);\n        }\n    }\n    return lastMapping.id;\n}"
    ],
    [
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedLong;\n    }\n    if (p == PEEKED_NUMBER) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        double value = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n        if (!Double.isFinite(value)) {\n            throw new NumberFormatException(\"Expected a finite double but was \" + value);\n        }\n        return value;\n    }\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE)\n    {\n        p = doPeek();\n    }\n\n    if (p == PEEKED_LONG)\n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER)\n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    }\n\n    if (p == PEEKED_STRING)\n    {\n        String value = nextString();\n        try\n        {\n            return Double.parseDouble(value);\n        }\n        catch (NumberFormatException nfe)\n        {\n            throw new NumberFormatException(\"Failed to parse double: \" + value);\n        }\n    }\n\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedLong;\n    }\n    if (p == PEEKED_NUMBER) {\n        String numberStr = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n        try {\n            double result = Double.parseDouble(numberStr);\n            if (Double.isNaN(result) || Double.isInfinite(result)) {\n                throw new NumberFormatException(\"Expected a valid double but was \" + numberStr);\n            }\n            return result;\n        } catch (NumberFormatException e) {\n            throw new NumberFormatException(\"Expected a valid double but was \" + numberStr);\n        }\n    }\n\n    if (p == PEEKED_STRING) {\n        String string = peekedString;\n        peekedString = null;\n        pathIndices[stackSize - 1]++;\n        try {\n            return Double.parseDouble(string);\n        } catch (NumberFormatException e) {\n            throw new NumberFormatException(\"Expected a valid double but was \" + string);\n        }\n    }\n    if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED) {\n        String string = nextString();\n        try {\n            return Double.parseDouble(string);\n        } catch (NumberFormatException e) {\n            throw new NumberFormatException(\"Expected a valid double but was \" + string);\n        }\n    }\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n\n  if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return peekedLong;\n  } else if (p == PEEKED_NUMBER) {\n    try {\n      double result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n      if (Double.isNaN(result) || Double.isInfinite(result)) {\n        throw new NumberFormatException(\"Expected a valid double but was \" + result);\n      }\n      pos += peekedNumberLength;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } catch (NumberFormatException e) {\n      throw new NumberFormatException(\"Expected a valid double but was \" + peek());\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a number but was \" + peek());\n  }\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedLong;\n    }\n    else if (p == PEEKED_NUMBER) \n    {\n        String number = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n        try\n        {\n            double result = Double.parseDouble(number);\n            if (Double.isNaN(result) || Double.isInfinite(result)) \n            {\n                throw new NumberFormatException(\"JSON forbids non-finite numbers: \" + number);\n            }\n            return result;\n        }\n        catch (NumberFormatException e) \n        {\n            throw new NumberFormatException(\"Error parsing double: \" + e.getMessage());\n        }\n    }\n    else if (p == PEEKED_STRING)\n    {\n        String number = peekedString;\n        peekedString = null;\n        pathIndices[stackSize - 1]++;\n        try\n        {\n            double result = Double.parseDouble(number);\n            if (Double.isNaN(result) || Double.isInfinite(result)) \n            {\n                throw new NumberFormatException(\"JSON forbids non-finite numbers: \" + number);\n            }\n            return result;\n        }\n        catch (NumberFormatException e) \n        {\n            throw new NumberFormatException(\"Error parsing double: \" + e.getMessage());\n        }\n    }\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE)\n    {\n        p = doPeek();\n    }\n\n    if (p == PEEKED_LONG)\n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedLong;\n    }\n    else if (p == PEEKED_NUMBER)\n    {\n        String number = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n\n        try\n        {\n            double value = Double.parseDouble(number);\n\n            if (Double.isNaN(value) || Double.isInfinite(value))\n            {\n                throw new NumberFormatException(\"Expected a valid double but was \" + number);\n            }\n\n            return value;\n        }\n        catch (NumberFormatException e)\n        {\n            throw new NumberFormatException(\"Expected a valid double but was \" + number, e);\n        }\n    }\n    else\n    {\n        throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE)\n    {\n        p = doPeek();\n    }\n\n    if (p == PEEKED_LONG)\n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER)\n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    }\n    \n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return peekedLong;\n  } else if (p == PEEKED_NUMBER) {\n    String numberString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    try {\n      return Double.parseDouble(numberString);\n    } catch (NumberFormatException e) {\n      throw new NumberFormatException(\"Expected a valid double but was \" + numberString);\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n\n  if (p == PEEKED_LONG) \n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return peekedLong;\n  }\n  else if (p == PEEKED_NUMBER) \n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n  }\n  else if (p == PEEKED_STRING) \n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    String str = peekedString;\n    peekedString = null;\n    try \n    {\n      return Double.parseDouble(str);\n    } \n    catch (NumberFormatException e) \n    {\n      throw new NumberFormatException(\"Expected a double but was \" + str + locationString());\n    }\n  }\n  else \n  {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return peekedLong;\n  } else if (p == PEEKED_NUMBER) {\n    String numberString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    try {\n      double result = Double.parseDouble(numberString);\n      if (!Double.isFinite(result)) {\n        throw new NumberFormatException(\"Expected a finite double but was \" + result + \" at \" + locationString());\n      }\n      return result;\n    } catch (NumberFormatException nfe) {\n      throw new NumberFormatException(\"Expected a double but was \" + numberString + \" at \" + locationString(), nfe);\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n}"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n    if(str == null) \n    {\n        return null;\n    }\n    if(repeat < 0) \n    {\n        return EMPTY;\n    }\n    StringBuilder sb = new StringBuilder(repeat * str.length());\n    for(int i = 0; i < repeat; ++i) \n    {\n        sb.append(str);\n    }\n    return sb.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n\tif (str == null) {\n\t\treturn null;\n\t}\n\tif (repeat < 0) {\n\t\treturn EMPTY;\n\t}\n\n\tfinal char[] buf = new char[str.length() * repeat];\n\tfor (int i = 0; i < repeat; i++) {\n\t\tstr.getChars(0, str.length(), buf, i * str.length());\n\t}\n\treturn new String(buf);\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    if (repeat == 1) {\n        return str;\n    }\n    StringBuilder buf = new StringBuilder(repeat * str.length());\n    for (int i = repeat - 1; i >= 0; i--) {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if(str == null || repeat <= 0) {\n        return EMPTY;\n    }\n    final StringBuilder buffer = new StringBuilder(str.length() * repeat);\n    for(int i = 0; i < repeat; i++) {\n        buffer.append(str);\n    }\n    return buffer.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final char[] buf = new char[repeat * str.length()];\n    for (int i = 0; i < repeat; i++) {\n        str.getChars(0, str.length(), buf, i * str.length());\n    }\n    return new String(buf);\n}",
      "public static String repeat(final String str, final int repeat)  {\n\tif (str == null) {\n\t\treturn null;\n\t}\n\tif (repeat == 0) {\n\t\treturn EMPTY;\n\t}\n\tif (repeat > 0) {\n\t\tfinal StringBuilder buf = new StringBuilder(repeat * str.length());\n\t\tfor (int i = 0; i < repeat; i++) {\n\t\t\tbuf.append(str);\n\t\t}\n\t\treturn buf.toString();\n\t}\n\tfinal StringBuilder buf = new StringBuilder((-repeat - 1) * str.length());\n\tfor (int i = repeat; i < 0; i++) {\n\t\tbuf.append(str);\n\t}\n\treturn buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n\tif (str == null) {\n\t\treturn null;\n\t}\n\tif (repeat <= 0) {\n\t\treturn EMPTY;\n\t}\n\tfinal int strLen = str.length();\n\tfinal char[] buf = new char[strLen * repeat];\n\tfor (int i = 0; i < repeat; i++) {\n\t\tstr.getChars(0, strLen, buf, i * strLen);\n\t}\n\treturn new String(buf);\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    if (repeat < 0) {\n        return EMPTY;\n    }\n    if (repeat == 0) {\n        return EMPTY;\n    }\n    final int count = repeat / strLen;\n    final int reminder = repeat % strLen;\n    final StringBuilder result = new StringBuilder(repeat);\n    for (int i = 0; i < count; i++) {\n        result.append(str);\n    }\n    if (reminder > 0) {\n        result.append(str.substring(0, reminder));\n    }\n    return result.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n\tif (str == null || repeat == 0) {\n\t\treturn null;\n\t}\n\treturn new StringBuilder(repeat * str.length()).append(str).toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if(str == null || repeat < 0) \n    {\n        return null;\n    }\n    return new String(new char[repeat]).replace('\\0', str.charAt(0));\n}"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    if (implementations != null) {\n        Class<?> clazz = implementations.get(headerId);\n        if (clazz != null) {\n            try {\n                return (ZipExtraField) clazz.newInstance();\n            } catch (Exception e) {\n                // ignore and fall back to UnrecognizedExtraField\n            }\n        }\n    }\n    ZipExtraField extraField = new UnrecognizedExtraField();\n    extraField.setHeaderId(headerId);\n    return extraField;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    if (implementations.containsKey(headerId)) \n    {\n        Class<?> clazz = implementations.get(headerId);\n        return (ZipExtraField) clazz.newInstance();\n    } else {\n        return new UnrecognizedExtraField();\n    }\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    if (headerId.equals(JarMarker.HEADER_ID)) {\n        // This is a custom field, we know how to handle it\n        return new JarMarker();\n    } else {\n        // This is an unknown header, we need to try and create an\n        // UnrecognizedExtraField from it.\n        ZipExtraField field = new UnrecognizedExtraField();\n        field.setHeaderId(headerId);\n        return field;\n    }\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    for (final Map.Entry<ZipShort, Class<?>> entry : implementations.entrySet()) {\n        if (headerId.equals(entry.getKey())) {\n            return (ZipExtraField) entry.getValue().newInstance();\n        }\n    }\n    final ZipShort header = new ZipShort(headerId.getValue() & 0xFFFF);\n    final UnrecognizedExtraField uef = new UnrecognizedExtraField();\n    uef.setHeaderId(header);\n    return uef;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    for (final Map.Entry<ZipShort, Class<?>> entry : implementations.entrySet()) {\n        if (entry.getKey().equals(headerId)) {\n            return entry.getValue().newInstance();\n        }\n    }\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    if (headerId.equals(JarMarker.HEADER_ID)) {\n        JarMarker extraField = new JarMarker();\n        extraField.setHeaderId(headerId);\n        return extraField;\n    }\n    \n    for (Map.Entry<ZipShort, Class<?>> entry : implementations.entrySet()) {\n        if (entry.getKey().equals(headerId)) {\n            return (ZipExtraField) entry.getValue().newInstance();\n        }\n    }\n    \n    UnrecognizedExtraField extraField = new UnrecognizedExtraField();\n    extraField.setHeaderId(headerId);\n    return extraField;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    if (headerId.equals(UnrecognizedExtraField.getHeaderId())) {\n        return new UnrecognizedExtraField();\n    }\n\n    // Check if we already have a registered implementation of this\n    // field.\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return (ZipExtraField) clazz.newInstance();\n    }\n\n    // If not, look for an implementation in the current classpath.\n    String className = \"org.apache.commons.compress.archivers.zip.impl.extrafields.\"\n        + headerId.toString() + \"ExtraField\";\n    try {\n        clazz = Class.forName(className);\n        implementations.put(headerId, clazz);\n    } catch (ClassNotFoundException ex) {\n        // Ignore, fall back to unrecognized.\n    }\n    if (clazz != null) {\n        return (ZipExtraField) clazz.newInstance();\n    }\n\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    for (final Map.Entry<ZipShort, Class<?>> entry : implementations.entrySet()) {\n        if (entry.getKey().equals(headerId)) {\n            return entry.getValue().newInstance();\n        }\n    }\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    if (headerId.equals(JarMarker.HEADER_ID)) {\n        return JarMarker.getInstance();\n    } else {\n        ZipExtraField field = implementations.get(headerId);\n        if (field == null) {\n            field = new UnrecognizedExtraField();\n            field.setHeaderId(headerId);\n        }\n        return field;\n    }\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField extraField = implementations.get(headerId);\n    if (extraField != null) \n    {\n        return extraField.newInstance();\n    }\n    return new UnrecognizedExtraField();\n}"
    ],
    [
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for (int i = 0; i < sz; i++) {\n            if (chars.contains(chrs[i])) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n    if (str == null) {\n        return 0;\n    }\n    if (str.isEmpty() || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for(int i=0; i<sz; i++) {\n        if(chars.contains(chrs[i])) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for(int i=0; i<sz; i++) {\n        if(chars.contains(chrs[i])) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for (final char c : chrs) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n    if (str == null) {\n        return 0;\n    }\n    if (str.isEmpty() || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) \n        {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) \n        {\n            if (chars.contains(c)) \n            {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n    if (str == null) {\n        return 0;\n    }\n    if (str.isEmpty() || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    if (map == null) {\n        return null;\n    }\n    Map clone = (Map) map.clone();\n    for (Object key : clone.keySet()) {\n        if (key instanceof CategoryMarker) {\n            CategoryMarker marker = (CategoryMarker) key;\n            if (marker instanceof PublicCloneable) {\n                PublicCloneable pc = (PublicCloneable) marker;\n                CategoryMarker newMarker = (CategoryMarker) pc.clone();\n                clone.put(newMarker, clone.get(key));\n            }\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    for (Map.Entry entry : map.entrySet()) {\n        clone.put(entry.getKey(), entry.getValue());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) map.clone();\n    for (Iterator it = clone.keySet().iterator(); it.hasNext();) {\n        Object key = it.next();\n        Object value = clone.get(key);\n        if (value instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) value;\n            Object newValue = pc.clone();\n            clone.put(key, newValue);\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = null;\n    if (map != null) {\n        result = (Map) map.clone();\n        for (Object key : result.keySet()) {\n            Map categoryMarkers = (Map) result.get(key);\n            if (categoryMarkers != null) {\n                result.put(key, (Map) categoryMarkers.clone());\n            }\n        }\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = (Map) map.clone();\n    for (Iterator it = result.keySet().iterator(); it.hasNext();) {\n        Object key = it.next();\n        Object marker = result.get(key);\n        if (marker instanceof PublicCloneable) {\n            PublicCloneable pc = (PublicCloneable) marker;\n            result.put(key, (Object) pc.clone());\n        }\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    if (map == null) {\n        return null;\n    }\n    Map result = new HashMap();\n    for (Map.Entry entry : map.entrySet()) {\n        Comparable key = (Comparable) entry.getKey();\n        List list = (List) entry.getValue();\n        List cloneList = (List) ObjectUtilities.deepClone(list);\n        result.put(key, cloneList);\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    if (map == null) {\n        return null;\n    }\n    Map newMap = new HashMap();\n    for (Object key : map.keySet()) {\n        newMap.put(key, (Marker) ((Marker) map.get(key)).clone());\n    }\n    return newMap;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = null;\n    if (map != null) {\n        result = new HashMap(map);\n        for (Object key : result.keySet()) {\n            if (key instanceof PublicCloneable) {\n                PublicCloneable pc = (PublicCloneable) key;\n                Object cloneKey = pc.clone();\n                result.put(cloneKey, result.get(key));\n            }\n        }\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    if (map == null) {\n        return null;\n    }\n    Map clone = new HashMap();\n    for (Map.Entry entry : map.entrySet()) {\n        Object key = entry.getKey();\n        Object value = entry.getValue();\n        if (value instanceof PublicCloneable) {\n            clone.put(key, ((PublicCloneable) value).clone());\n        } else {\n            clone.put(key, value);\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = (Map) map.clone();\n    for (Object key : result.keySet()) {\n        List list = (List) result.get(key);\n        result.put(key, cloneMarkers(list));\n    }\n    return result;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = 0;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                     0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                     0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = 0;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                     0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                     0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                     0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                     0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                     0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                     0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final int size = data.length;\n    if (size == 0) {\n        return EMPTY_BYTE_ARRAY;\n    }\n\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += data[i].getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (final ZipExtraField element : data) {\n        System.arraycopy(element.getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(element.getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        final byte[] central = element.getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start + WORD, central.length);\n        }\n        start += element.getCentralDirectoryLength().getValue();\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                     0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                     0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final int regularExtraFieldCount = data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final int size = data.length;\n    if (size == 0) {\n        return EMPTY_BYTE_ARRAY;\n    }\n    if (size == 1) {\n        return data[0].getCentralDirectoryData();\n    }\n    final ZipShort headerId = data[0].getHeaderId();\n    if (headerId.equals(UnparseableExtraFieldData.HEADER_ID)) {\n        final UnparseableExtraFieldData uef = new UnparseableExtraFieldData();\n        uef.parseFromCentralDirectoryData(data[0].getCentralDirectoryData(), 0, data[0].getCentralDirectoryLength().getValue());\n        return uef.getCentralDirectoryData();\n    }\n    int sum = 0;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < size; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start + WORD, central.length);\n            start += central.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final int size = data.length;\n    int sum = 0;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < size; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final int size = data.length;\n    if (size == 0) {\n        return EMPTY_BYTE_ARRAY;\n    }\n    int sum = WORD * size;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < size; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    return result;\n}"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        final Set<E> set = createSetBasedOnList(set, coll);\n        final int sizeBefore = size();\n        for(final E e: coll)\n        {\n            add(index, e);\n        }\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        return addAll(index, CollectionUtils.addAll(set, coll));\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n\n        // Iterate through the collection to add unique elements.\n        for (final E element : coll) \n        {\n            if (!set.contains(element)) \n            {\n                add(index++, element);\n                changed = true;\n            }\n        }\n\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n    // Create a new list to hold the unique elements.\n    List<E> uniqueElements = new ArrayList<>();\n\n    // Iterate through the collection of elements to add.\n    for (E element : coll) \n{\n        // If the element is not in the set, add it to both the set and the unique elements list.\n        if (!set.contains(element)) \n{\n            set.add(element);\n            uniqueElements.add(element);\n        }\n    }\n\n    // Add the unique elements to the list at the specified index.\n    for (E element : uniqueElements) \n{\n        super.add(index++, element);\n    }\n\n    // Return true if the list changed.\n    return !uniqueElements.isEmpty();\n}",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n\n        for(final E e:coll) \n        {\n            if(set.contains(e)) \n            {\n                continue;\n            }\n            set.add(e);\n            add(index,e);\n            changed = true;\n        }\n\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        if (coll == null) return false;\n        boolean changed = false;\n        for (final E e : coll) {\n            if (!set.contains(e)) {\n                add(index++, e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        if (coll.contains(null)) {\n            throw new NullPointerException(\"null elements not allowed\");\n        }\n        for (final E e : coll) {\n            if (set.contains(e)) {\n                continue;\n            }\n            changed = true;\n            add(index++, e);\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n\n        for(final E e : coll) {\n            if(set.contains(e)) {\n                continue;\n            } else {\n                add(index, e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n\n        // Iterate over the collection of objects to add\n        for (final E object : coll) {\n            // If the object is not already in the list\n            if (!set.contains(object)) {\n                // Add the object to the list\n                add(index, object);\n                // Mark that the collection changed\n                changed = true;\n            }\n        }\n\n        // Return whether the collection changed\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        return addUniqueElements(index, coll, false);\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        evaluations.incrementCount();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        evaluations.incrementCount();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        evaluations.incrementCount();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        evaluations.incrementCount();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        evaluations.incrementCount();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        evaluations.incrementCount();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        evaluations.incrementCount();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        evaluations.incrementCount();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        evaluations.incrementCount();\n        return f.value(x);\n    }"
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if(this.lowerBound < bin.upperBound && this.upperBound > bin.lowerBound)\n    {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    double thisMin = this.lowerBound;\n    double thisMax = this.upperBound;\n    double binMin = bin.getLowerBound();\n    double binMax = bin.getUpperBound();\n    if (thisMin > binMax) {\n        return false;\n    }\n    if (thisMax < binMin) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound || this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound || this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    boolean result = false;\n    if (bin.getLowerBound() >= this.lowerBound && bin.getLowerBound() <= this.upperBound) {\n        result = true;\n    }\n    if (bin.getUpperBound() >= this.lowerBound && bin.getUpperBound() <= this.upperBound) {\n        result = true;\n    }\n    if (this.lowerBound >= bin.getLowerBound() && this.lowerBound <= bin.getUpperBound()) {\n        result = true;\n    }\n    if (this.upperBound >= bin.getLowerBound() && this.upperBound <= bin.getUpperBound()) {\n        result = true;\n    }\n    return result;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    return (this.lowerBound < bin.upperBound) \n            && (this.upperBound > bin.lowerBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if(this.lowerBound < bin.upperBound && this.upperBound > bin.lowerBound) \n    {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    return (this.lowerBound >= bin.lowerBound && this.lowerBound <= bin.upperBound) ||\n           (this.upperBound >= bin.lowerBound && this.upperBound <= bin.upperBound) ||\n           (bin.lowerBound >= this.lowerBound && bin.lowerBound <= this.upperBound) ||\n           (bin.upperBound >= this.lowerBound && bin.upperBound <= this.upperBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound || bin.lowerBound > this.upperBound) {\n        return false;\n    } else if (this.lowerBound >= bin.lowerBound && this.upperBound <= bin.upperBound) {\n        return true;\n    } else if (this.lowerBound < bin.lowerBound && this.upperBound > bin.upperBound) {\n        return true;\n    } else if (this.lowerBound < bin.lowerBound && this.upperBound == bin.lowerBound) {\n        if (!this.includeUpperBound || !bin.includeLowerBound) {\n            return false;\n        }\n        return true;\n    } else if (this.lowerBound == bin.upperBound && this.upperBound > bin.upperBound) {\n        if (!this.includeLowerBound || !bin.includeUpperBound) {\n            return false;\n        }\n        return true;\n    } else if (this.lowerBound > bin.lowerBound && this.upperBound > bin.lowerBound\n            && this.lowerBound < bin.upperBound) {\n        return true;\n    } else if (this.lowerBound > bin.lowerBound && this.upperBound == bin.lowerBound) {\n        if (!this.includeLowerBound || !bin.includeLowerBound) {\n            return false;\n        }\n        return true;\n    } else if (this.lowerBound < bin.upperBound && this.upperBound == bin.upperBound) {\n        if (!this.includeUpperBound || !bin.includeUpperBound) {\n            return false;\n        }\n        return true;\n    }\n    return false;\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    if (strLen == 0) {\n        return new String[0];\n    }\n    final List<String> tokens = new ArrayList<>();\n    int startPos = 0;\n    int currentPos = 0;\n    int tokenType = Character.getType(str.charAt(0));\n    boolean firstLetter = true;\n    while (currentPos < strLen) {\n        final int newTokenType = Character.getType(str.charAt(currentPos));\n        if (tokenType != newTokenType || (camelCase && (Character.isLowerCase(str.charAt(currentPos)) && tokenType == Character.UPPERCASE_LETTER && firstLetter))) {\n            tokens.add(str.substring(startPos, currentPos));\n            startPos = currentPos;\n            tokenType = newTokenType;\n            firstLetter = false;\n        }\n        currentPos++;\n    }\n    tokens.add(str.substring(startPos, currentPos));\n    return tokens.toArray(new String[tokens.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new String[0];\n    }\n    final int strLen = str.length();\n    List<String> result = new ArrayList<>();\n    int startPos = 0;\n    int currentType = Character.getType(str.charAt(0));\n    for (int i = 1; i <= strLen; i++) {\n        int newType = i != strLen ? Character.getType(str.charAt(i)) : Character.TYPE_CONTROL;\n        if (currentType != newType || i == strLen) {\n            String token = str.substring(startPos, i);\n            if (camelCase && Character.isLowerCase(token.charAt(0)) && Character.isUpperCase(str.charAt(i))) {\n                result.set(result.size() - 1, result.get(result.size() - 1) + token);\n            } else {\n                result.add(token);\n            }\n            startPos = i;\n            currentType = newType;\n        }\n    }\n    return result.toArray(new String[result.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    if (strLen == 0) {\n        return EMPTY_ARRAY;\n    }\n    final List<String> tokensList = new ArrayList<>();\n    char previousCharType = Character.getType(str.charAt(0));\n    StringBuilder currentToken = new StringBuilder();\n    currentToken.append(str.charAt(0));\n    for (int i = 1; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        final int chType = Character.getType(ch);\n        if (previousCharType != chType || (!camelCase && Character.isLowerCase(ch) && Character.isUpperCase(currentToken.charAt(currentToken.length() - 1)))) {\n            tokensList.add(currentToken.toString());\n            currentToken = new StringBuilder();\n        }\n        previousCharType = chType;\n        currentToken.append(ch);\n    }\n    tokensList.add(currentToken.toString());\n    return tokensList.toArray(new String[0]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    int strLen = str.length();\n    if (strLen == 0) {\n        return EMPTY_ARRAY;\n    }\n    final StringBuilder buf = new StringBuilder(strLen + 16);\n    final char[] array = str.toCharArray();\n    final StringBuilder token = new StringBuilder(strLen + 16);\n    int tokenStart = 0;\n    int arrayIndex = 0;\n    boolean lastWasSeparator = true;\n    boolean isPrevTokenSeparator = false;\n    boolean isCurrentTokenSeparator = false;\n    while (arrayIndex < strLen) {\n        char ch = array[arrayIndex];\n        int chType = Character.getType(ch);\n        if (camelCase) {\n            if (chType == Character.UPPERCASE_LETTER) {\n                isCurrentTokenSeparator = true;\n                if (tokenStart != arrayIndex) {\n                    token.append(array, tokenStart, arrayIndex - tokenStart);\n                }\n                if (isPrevTokenSeparator) {\n                    token.append(ch);\n                    tokenStart = arrayIndex + 1;\n                    lastWasSeparator = false;\n                    isPrevTokenSeparator = false;\n                }\n            } else if (chType == Character.LOWERCASE_LETTER) {\n                isCurrentTokenSeparator = false;\n            }\n        } else {\n            if (chType == Character.LOWERCASE_LETTER) {\n                isCurrentTokenSeparator = true;\n                if (tokenStart != arrayIndex) {\n                    token.append(array, tokenStart, arrayIndex - tokenStart);\n                }\n                if (isPrevTokenSeparator) {\n                    token.append(ch);\n                    tokenStart = arrayIndex + 1;\n                    lastWasSeparator = false;\n                    isPrevTokenSeparator = false;\n                }\n            } else if (chType == Character.UPPERCASE_LETTER) {\n                isCurrentTokenSeparator = true;\n            } else {\n                isCurrentTokenSeparator = false;\n            }\n        }\n        if (!isCurrentTokenSeparator) {\n            token.append(ch);\n            if (lastWasSeparator) {\n}\n}\n}\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    int strLen = str.length();\n    if (strLen == 0) {\n        return EMPTY_ARRAY;\n    }\n    final ArrayList<String> tokens = new ArrayList<>();\n    int startPos = 0;\n    char previousCharType = Character.getType(str.charAt(0));\n    for (int i = 1; i <= strLen; ++i) {\n        char ch = (i == strLen) ? 0 : str.charAt(i);\n        int chType = Character.getType(ch);\n        if (chType == previousCharType) {\n            continue;\n        }\n        if (i - startPos > 0) {\n            tokens.add(str.substring(startPos, i));\n        }\n        previousCharType = chType;\n        startPos = i;\n    }\n    if (startPos < strLen) {\n        tokens.add(str.substring(startPos));\n    }\n    String[] result = new String[tokens.size()];\n    return tokens.toArray(result);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    if (strLen == 0) {\n        return new String[0];\n    }\n    final ArrayList<String> tokens = new ArrayList<>();\n    int start = 0;\n    int type = Character.getType(str.charAt(0));\n    for (int i = 1; i <= strLen; i++) {\n        final int newType;\n        final char ch = (i < strLen) ? str.charAt(i) : 0;\n        if (ch <= 0xFFFF) {\n            newType = Character.getType(ch);\n        } else {\n            newType = Character.getType(Character.codePointAt(str, i, 2));\n            i++;\n        }\n        if (newType != type) {\n            if (type != Character.LOWERCASE_LETTER || (newType == Character.LOWERCASE_LETTER && ((camelCase && start == i - 1) || start < i - 2))) {\n                tokens.add(str.substring(start, i));\n                start = i;\n            } else {\n                if (start == i) {\n                    start++;\n                }\n            }\n            type = newType;\n        }\n    }\n    if (start < strLen) {\n        tokens.add(str.substring(start));\n    }\n    return tokens.toArray(new String[tokens.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    if (strLen == 0) {\n        return EMPTY_ARRAY;\n    }\n\n    final List<String> tokens = new ArrayList<>();\n    int startPos = 0;\n    char currentType = Character.getType(str.charAt(0));\n    for (int i = 1; i <= strLen; i++) {\n        final char ch;\n        final char nextType;\n        if (i == strLen) {\n            ch = 0;\n            nextType = Character.TYPE_CONTROL;\n        } else {\n            ch = str.charAt(i);\n            nextType = Character.getType(ch);\n        }\n        if (currentType == nextType) {\n            continue;\n        }\n        final boolean isEndOfToken = (i == strLen) || (currentType != Character.TYPE_WHITESPACE && nextType == Character.TYPE_WHITESPACE);\n        if (camelCase && Character.isLowerCase(ch) && (currentType == Character.TYPE_UPPERCASE_LETTER || currentType == Character.TYPE_TITLECASE_LETTER)\n                && ((i == startPos && currentType == Character.TYPE_UPPERCASE_LETTER) || (startPos > 0 && Character.isLowerCase(str.charAt(startPos - 1))))) {\n            currentType = nextType;\n            continue;\n        }\n        if (isEndOfToken) {\n            tokens.add(str.substring(startPos, i));\n            currentType = nextType;\n            startPos = i;\n        }\n    }\n    return tokens.toArray(EMPTY_ARRAY);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    if (strLen == 0) {\n        return EMPTY_ARRAY;\n    }\n    final ArrayList<String> tokens = new ArrayList<String>();\n    int lastIndex = 0, type = Character.getType(str.charAt(0));\n    for (int i = 1; i <= strLen; i++) {\n        if (i < strLen) {\n            final int newType = Character.getType(str.charAt(i));\n            if (newType != type || ((camelCase) \n                && (newType == Character.UPPERCASE_LETTER)\n                && (type == Character.LOWERCASE_LETTER))) {\n                tokens.add(str.substring(lastIndex, i));\n                lastIndex = i;\n                type = newType;\n            }\n        } else {\n            tokens.add(str.substring(lastIndex, i));\n        }\n    }\n    return tokens.toArray(new String[tokens.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return new String[0];\n    }\n\n    final ArrayList<String> tokens = new ArrayList<>();\n    int start = 0;\n    int codePoint;\n    for (int i = 0; i < len; i += Character.charCount(codePoint)) {\n        codePoint = str.codePointAt(i);\n        final int type = Character.getType(codePoint);\n        if (i == 0) {\n            switch (type) {\n                case Character.LOWERCASE_LETTER:\n                case Character.TITLECASE_LETTER:\n                case Character.OTHER_LETTER:\n                    tokens.add(\"\");\n                    break;\n            }\n        } else {\n            final int prevType = Character.getType(str.codePointAt(i - Character.charCount(str.codePointAt(i - 1))));\n            if (camelCase) {\n                switch (type) {\n                    case Character.LOWERCASE_LETTER:\n                        if (prevType == Character.UPPERCASE_LETTER) {\n                            tokens.add(str.substring(start, i));\n                            start = i;\n                        }\n                        break;\n                    case Character.TITLECASE_LETTER:\n                    case Character.OTHER_LETTER:\n                        if (prevType == Character.LOWERCASE_LETTER) {\n                            tokens.add(str.substring(start, i));\n                            start = i;\n                        } else if (prevType == Character.OTHER_LETTER) {\n                            if (tokens.size() == 0 || !tokens.get(tokens.size() - 1).isEmpty()) {\n                                tokens.add(\"\");\n                            }\n                        }\n                        break;\n                }\n            } else {\n                switch (type) {\n                    case Character.LOWERCASE_LETTER:\n                    case Character.TITLECASE_LETTER:\n                    case Character.OTHER_LETTER:\n                        if (prevType == Character.WHITESPACE || prevType == Character.PUNCTUATION || prevType == Character.SYMBOL) {\n                            tokens.add(str.substring(start, i));\n                            start = i;\n                        }\n                        break;\n}\n}\n}\n}\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    if (strLen == 0) {\n        return EMPTY_ARRAY;\n    }\n\n    final ArrayList<String> tokens = new ArrayList<>();\n    int startPos = 0;\n\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n\n        final int chType = Character.getType(ch);\n        if (i > startPos && chType != Character.DECIMAL_DIGIT && chType != Character.LETTER_NUMBER) {\n            tokens.add(str.substring(startPos, i));\n            startPos = i;\n        }\n\n        if (camelCase) {\n            if ((chType == Character.LOWERCASE_LETTER) && ((i == startPos) || (Character.getType(str.charAt(i - 1)) == Character.UPPERCASE_LETTER))) {\n                tokens.add(str.substring(startPos, i));\n                startPos = i;\n            }\n        }\n    }\n\n    if (startPos < strLen) {\n        tokens.add(str.substring(startPos));\n    }\n\n    return tokens.toArray(new String[tokens.size()]);\n}"
    ],
    [
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, Chronology.ISO, Locale.getDefault(), null, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= text.length()) {\n        return bucket.computeMillis(true, text);\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(\"Unable to parse datetime from text: \" + text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    return -1L;\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            return bucket.computeMillis(true, text);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    return -1;\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(\"Unable to parse text: \" + text + \" at position: \" + newPos);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            return millis;\n        } else {\n            newPos = ~newPos;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(\"Unable to parse datetime: \" + text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(\"Text cannot be parsed: \" + text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, Chronology.ISO, Locale.ROOT, null, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= text.length()) {\n        return bucket.computeMillis(true, text);\n    } else {\n        return -1;\n    }\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            return bucket.computeMillis(true, text);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(\"Unable to parse date-time from text: \" + text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(\"Error parsing datetime from text: \" + text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            return bucket.computeMillis(true, text);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(\"Parsed text does not contain a valid date-time\");\n}"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n  return new MinimizedCondition(\n      new MeasuredNode(n.cloneNode(), estimateCostOneLevel(n), false),\n      new MeasuredNode(new Node(Token.SCRIPT, \"\", -1, -1), Integer.MAX_VALUE,\n          false));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return new MinimizedCondition(\n      new MeasuredNode(n, estimateCostOneLevel(n), false),\n      new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  return new MinimizedCondition(\n      new MeasuredNode(n, estimateCostOneLevel(n), false),\n      new MeasuredNode(\n          new Node(Token.SCRIPT).srcref(n), Integer.MAX_VALUE, true));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Node placeholder = swapWithPlaceholderNode(n);\n  return new MinimizedCondition(\n      MeasuredNode.addNode(n.cloneTree()),\n      new MeasuredNode(new Node(Token.SCRIPT).srcref(n), Integer.MAX_VALUE, false));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  Node scriptNode = new Node(Token.SCRIPT).srcref(n);\n  scriptNode.setLength(Integer.MAX_VALUE);\n  return new MinimizedCondition(\n      new MeasuredNode(n.cloneTree(), 1, false),\n      new MeasuredNode(scriptNode.cloneTree(), 1, false));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return new MinimizedCondition(\n      new MeasuredNode(n.cloneNode(), estimateCostOneLevel(n), false),\n      new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Node scriptNode = new Node(Token.SCRIPT);\n  scriptNode.setSourcePosition(n.getSourcePosition());\n  scriptNode.setLength(Integer.MAX_VALUE);\n  MeasuredNode positive = new MeasuredNode(n.cloneTree(), 0, false);\n  MeasuredNode negative = new MeasuredNode(scriptNode, 0, false);\n  return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  return new MinimizedCondition(\n      new MeasuredNode(n, estimateCostOneLevel(n), false),\n      new MeasuredNode(Token.SCRIPT, Integer.MAX_VALUE, false));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  Node script = new Node(Token.SCRIPT);\n  script.setSourcePosition(n.getSourcePosition());\n  script.setSourcePositionForTree(n.getSourcePositionForTree());\n  script.setLength(Integer.MAX_VALUE);\n  return new MinimizedCondition(new MeasuredNode(n, 1, false),\n      new MeasuredNode(script, 1, false));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Node scriptNode = new Node(Token.SCRIPT);\n  scriptNode.setSourcePosition(n.getSourcePosition());\n  scriptNode.setSourceEncodedPosition(n.getSourceEncodedPosition());\n  scriptNode.setLength(Integer.MAX_VALUE);\n  return new MinimizedCondition(\n      new MeasuredNode(n.cloneTree(), n.getSourcePosition(), false),\n      new MeasuredNode(scriptNode, n.getSourcePosition(), false));\n}"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    Collections.addAll(condensed, values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        ConverterSet set = iPartialConverters;\n        Converter[] converters = set.iConverters;\n        int length = converters.length;\n\n        for (int i=0; i<length; i++) {\n            Converter existing = converters[i];\n            if (converter.equals(existing)) {\n                // Already in the set.\n                return null;\n            }\n            \n            if (converter.getSupportedType() == existing.getSupportedType()) {\n                // Replace the converter.\n                Converter[] copy = new Converter[length];\n                    \n                for (int j=0; j<length; j++) {\n                    if (j != i) {\n                        copy[j] = converters[j];\n                    } else {\n                        copy[j] = converter;\n                    }\n                }\n\n                return (PartialConverter)set.selectSlow(new ConverterSet(copy), converter.getSupportedType());\n            }\n        }\n\n        // Not found, so add it.\n        Converter[] copy = new Converter[length + 1];\n        System.arraycopy(converters, 0, copy, 0, length);\n        copy[length] = converter;\n        \n        return (PartialConverter)set.selectSlow(new ConverterSet(copy), converter.getSupportedType());\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    return iPartialConverters.add(converter, null);\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    Converter[] converters = iPartialConverters.iConverters;\n\n    for (int i=0; i<converters.length; i++) {\n        Converter existing = converters[i];\n        if (converter.equals(existing)) {\n            // Already in the set.\n            return null;\n        }\n        \n        if (converter.getSupportedType() == existing.getSupportedType()) {\n            // Replace the converter.\n            Converter[] copy = new Converter[converters.length];\n\n            for (int j=0; j<converters.length; j++) {\n                if (j != i) {\n                    copy[j] = converters[j];\n                } else {\n                    copy[j] = converter;\n                }\n            }\n\n            iPartialConverters = new ConverterSet(copy);\n            return existing;\n        }\n    }\n\n    // Not found, so add it.\n    iPartialConverters = iPartialConverters.add(converter, null);\n    return null;\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter replaced = iPartialConverters.add(converter, null);\n        return replaced;\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    Converter[] converters = iPartialConverters.iConverters;\n\n    for (int i=0; i<converters.length; i++) {\n        PartialConverter existing = (PartialConverter)converters[i];\n        if (converter.equals(existing)) {\n            // Already in the set.\n            return null;\n        }\n        \n        if (converter.getSupportedType() == existing.getSupportedType()) {\n            // Replace the converter.\n            Converter[] copy = new Converter[converters.length];\n                    \n            for (int j=0; j<converters.length; j++) {\n                if (j != i) {\n                    copy[j] = converters[j];\n                } else {\n                    copy[j] = converter;\n                }\n            }\n            return (PartialConverter)new ConverterSet(copy).select(converter.getSupportedType());\n        }\n    }\n\n    // Not found, so add it.\n    Converter[] copy = new Converter[converters.length + 1];\n    System.arraycopy(converters, 0, copy, 0, converters.length);\n    copy[converters.length] = converter;\n    return (PartialConverter)new ConverterSet(copy).select(converter.getSupportedType());\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        ConverterSet set = iPartialConverters;\n        Converter[] converters = set.iConverters;\n        int length = converters.length;\n\n        for (int i=0; i<length; i++) {\n            Converter existing = converters[i];\n            if (converter.equals(existing)) {\n                // Already in the set.\n                return null;\n            }\n            \n            if (converter.getSupportedType() == existing.getSupportedType()) {\n                // Replace the converter.\n                Converter[] copy = new Converter[length];\n                    \n                for (int j=0; j<length; j++) {\n                    if (j != i) {\n                        copy[j] = converters[j];\n                    } else {\n                        copy[j] = converter;\n                    }\n                }\n                set.iSelectEntries[i] = new ConverterSet.Entry(converter.getSupportedType(), converter);\n                return (PartialConverter)existing;\n            }\n        }\n\n        // Not found, so add it.\n        Converter[] copy = new Converter[length + 1];\n        System.arraycopy(converters, 0, copy, 0, length);\n        copy[length] = converter;\n        set.iSelectEntries = Arrays.copyOf(set.iSelectEntries, set.iSelectEntries.length+1);\n        set.iSelectEntries[length] = new ConverterSet.Entry(converter.getSupportedType(), converter);\n        \n        return null;\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        throw new NullPointerException();\n    }\n    \n    ConverterSet set = iPartialConverters;\n    Converter[] converters = set.iConverters;\n    int length = converters.length;\n\n    for (int i=0; i<length; i++) {\n        Converter existing = converters[i];\n        if (converter.equals(existing)) {\n            // Already in the set.\n            return null;\n        }\n        \n        if (converter.getSupportedType() == existing.getSupportedType()) {\n            // Replace the converter.\n            Converter[] copy = new Converter[length];\n                    \n            for (int j=0; j<length; j++) {\n                if (j != i) {\n                    copy[j] = converters[j];\n                } else {\n                    copy[j] = converter;\n                }\n            }\n            set.iConverters = copy;\n            return (PartialConverter)existing;\n        }\n    }\n\n    // Not found, so add it.\n    Converter[] copy = new Converter[length + 1];\n    System.arraycopy(converters, 0, copy, 0, length);\n    copy[length] = converter;\n    set.iConverters = copy;\n    return null;\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    ConverterSet set = iPartialConverters;\n    PartialConverter existing = (PartialConverter)set.select(converter.getSupportedType());\n    if (existing != null) {\n        if (converter.equals(existing)) {\n            return null;\n        }\n        Converter[] removed = {existing};\n        set = set.remove(converter, removed);\n        return removed[0];\n    }\n    Converter[] added = {converter};\n    set = set.add(converter, added);\n    return added[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        return iPartialConverters.add(converter, new Converter[1])[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    ConverterSet set = iPartialConverters;\n    int length = set.size();\n\n    for (int i=0; i<length; i++) {\n        Converter existing = set.select(i);\n        if (converter.equals(existing)) {\n            // Already in the set.\n            return null;\n        }\n        \n        if (converter.getSupportedType() == existing.getSupportedType()) {\n            // Replace the converter.\n            ConverterSet copy = set.remove(i, null);\n            copy.add(converter, null);\n            return (PartialConverter)copy.select(converter.getSupportedType());\n        }\n    }\n\n    // Not found, so add it.\n    set.add(converter, null);\n    return null;\n}"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope parent = scope.getParentScope();\n    while (!parent.isLexicalScope()) {\n      parent = parent.getParentScope();\n    }\n    return parent.getScopeDepth() + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope nearestLexicalScope = scope;\n    int depth = 0;\n    while (!nearestLexicalScope.isLexicalScope()) {\n      nearestLexicalScope = nearestLexicalScope.getParentScope();\n      depth++;\n    }\n    return depth + nearestLexicalScope.getScopeDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope parent = scope.getParentScope();\n    while (!parent.isLexicalScope()) {\n      parent = parent.getParentScope();\n    }\n    return parent.getScopeDepth() + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n      return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n      SymbolScope lexicalScope = scope.getSlot(scope.getSymbolForScope().getName()).getSymbol().getScope();\n      return lexicalScope.getScopeDepth() + getLexicalScopeDepth(lexicalScope);\n    } else {\n      return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) \n    {\n        return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) \n    {\n        int depth = 0;\n        SymbolScope current = scope;\n        while (!current.isLexicalScope()) \n        {\n            current = current.getParentScope();\n            depth++;\n        }\n        depth++;\n        return depth;\n    } else \n    {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n        SymbolScope currentScope = scope;\n        int depth = 0;\n        while (currentScope != null) {\n            if (currentScope.isLexicalScope()) {\n                depth += currentScope.getScopeDepth();\n                break;\n            }\n            currentScope = currentScope.getParentScope();\n            depth++;\n        }\n        return depth;\n    } else {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n      return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n      SymbolScope lexicalScope = scope;\n      int depth = 0;\n      while (!lexicalScope.isLexicalScope()) {\n        lexicalScope = lexicalScope.getParentScope();\n        depth++;\n      }\n      return depth + lexicalScope.getScopeDepth();\n    } else {\n      return 0;\n    }\n  }",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) \n  {\n    return scope.getScopeDepth();\n  } \n  else if (scope.isPropertyScope()) \n  {\n    SymbolScope parent = scope.getParentScope();\n    int depth = 0;\n    while (!parent.isLexicalScope()) \n    {\n      depth++;\n      parent = parent.getParentScope();\n    }\n    return depth + parent.getScopeDepth();\n  } \n  else \n  {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope nearestLexical = scope;\n    int depth = 0;\n    while (!nearestLexical.isLexicalScope()) {\n      nearestLexical = nearestLexical.getParentScope();\n      depth++;\n    }\n    return depth + nearestLexical.getScopeDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getScopeDepth();\n    }\n    return getLexicalScopeDepth(scope.getOwnSlot(SymbolTable.GLOBAL_THIS).getSymbol().getScope()) + 1;\n}"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // create the blocks layout array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    // copy data into blocks\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n            final int rowStart = blockRow * BLOCK_SIZE;\n            final int rowEnd   = Math.min(rowStart + BLOCK_SIZE, rows);\n            final int columnStart = blockColumn * BLOCK_SIZE;\n            final int columnEnd   = Math.min(columnStart + BLOCK_SIZE, columns);\n            final int blockIndex = blockRow * blockColumns + blockColumn;\n            blocks[blockIndex] = new double[Math.max(rowEnd - rowStart, 0) * Math.max(columnEnd - columnStart, 0)];\n            for (int row = rowStart; row < rowEnd; ++row) {\n                for (int column = columnStart; column < columnEnd; ++column) {\n                    final int elementIndex = (row - rowStart) * (columnEnd - columnStart) + (column - columnStart);\n                    blocks[blockIndex][elementIndex] = rawData[row][column];\n                }\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // create the blocks layout array\n    final double[][] blocksData = new double[blockRows * blockColumns][];\n\n    // copy entries to blocks layout\n    for (int r = 0; r < rows; ++r) {\n        for (int c = 0; c < columns; ++c) {\n            final int blockRow  = r / BLOCK_SIZE;\n            final int blockColumn = c / BLOCK_SIZE;\n            final int blockIndex = blockRow * blockColumns + blockColumn;\n            if (blocksData[blockIndex] == null) {\n                blocksData[blockIndex] = new double[BLOCK_SIZE * BLOCK_SIZE];\n            }\n            final int blockRowOffset  = r % BLOCK_SIZE;\n            final int blockColumnOffset = c % BLOCK_SIZE;\n            blocksData[blockIndex][blockRowOffset * BLOCK_SIZE + blockColumnOffset] =\n                rawData[r][c];\n        }\n    }\n\n    return blocksData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // create blocks layout array\n    final double[][] blocks = new double[blockRows][blockColumns];\n\n    // copy entries from raw layout to blocks layout\n    for (int row = 0; row < rows; ++row) {\n        for (int column = 0; column < columns; ++column) {\n            final int blockRow    = row    / BLOCK_SIZE;\n            final int blockColumn = column / BLOCK_SIZE;\n            final int blockIndex  = blockRow * blockColumns + blockColumn;\n            final int rawIndex    = row * columns + column;\n            blocks[blockRow][blockColumn][blockIndex] = rawData[row][column];\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // create the blocks layout array\n    final double[][] blocksData = new double[blockRows][blockColumns];\n\n    // copy data from raw layout to blocks layout\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n\n            final int blockStartRow   = blockRow    * BLOCK_SIZE;\n            final int blockEndRow     = Math.min(rows, (blockRow + 1) * BLOCK_SIZE);\n            final int blockStartColumn = blockColumn * BLOCK_SIZE;\n            final int blockEndColumn = Math.min(columns, (blockColumn + 1) * BLOCK_SIZE);\n\n            for (int row = blockStartRow; row < blockEndRow; ++row) {\n                for (int column = blockStartColumn; column < blockEndColumn; ++column) {\n                    blocksData[blockRow][blockColumn] += rawData[row][column];\n                }\n            }\n        }\n    }\n\n    return blocksData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // create the blocks layout array\n    final double[][] blocks = new double[blockRows][blockColumns];\n\n    // copy the data from the raw array to the blocks layout array\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < columns; ++j) {\n            blocks[i / BLOCK_SIZE][j / BLOCK_SIZE][i % BLOCK_SIZE][j % BLOCK_SIZE] = rawData[i][j];\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // create result array\n    final double[][] blocksLayout = new double[blockRows][blockColumns];\n\n    // fill result array from raw data\n    for (int r = 0; r < rows; ++r) {\n        for (int c = 0; c < columns; ++c) {\n            final int blockRow = r / BLOCK_SIZE;\n            final int blockColumn = c / BLOCK_SIZE;\n            final int blockIndex = blockRow * blockColumns + blockColumn;\n            final int rowIndex = r % BLOCK_SIZE;\n            final int colIndex = c % BLOCK_SIZE;\n            blocksLayout[blockRow][blockColumn][rowIndex][colIndex] = rawData[r][c];\n        }\n    }\n\n    return blocksLayout;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // create blocks layout array\n    final double[][] blockData = new double[blockRows * blockColumns][];\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n            final int blockStartRow    = blockRow    * BLOCK_SIZE;\n            final int blockEndRow      = Math.min(blockStartRow + BLOCK_SIZE, rows);\n            final int blockStartColumn = blockColumn * BLOCK_SIZE;\n            final int blockEndColumn    = Math.min(blockStartColumn + BLOCK_SIZE, columns);\n            final double[] block = new double[(blockEndRow - blockStartRow) * (blockEndColumn - blockStartColumn)];\n            int blockIndex = 0;\n            for (int rowIndex = blockStartRow; rowIndex < blockEndRow; ++rowIndex) {\n                for (int columnIndex = blockStartColumn; columnIndex < blockEndColumn; ++columnIndex) {\n                    block[blockIndex++] = rawData[rowIndex][columnIndex];\n                }\n            }\n            blockData[blockRow * blockColumns + blockColumn] = block;\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // create the blocks layout array\n    final double[][] blocksData = new double[blockRows][blockColumns];\n\n    // copy elements to blocks layout array\n    for (int row = 0; row < rows; ++row) {\n        for (int column = 0; column < columns; ++column) {\n            final int blockRow    = row    / BLOCK_SIZE;\n            final int blockColumn = column / BLOCK_SIZE;\n            final int blockIndex = blockRow * blockColumns + blockColumn;\n            final int elementIndex = row * columns + column;\n            blocksData[blockRow][blockColumn][elementIndex] = rawData[row][column];\n        }\n    }\n\n    return blocksData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // create result array\n    final double[][] blocksLayout = new double[blockRows * blockColumns][];\n\n    // fill result array\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n            final int startRow   = blockRow   * BLOCK_SIZE;\n            final int endRow     = Math.min(rows, (blockRow + 1) * BLOCK_SIZE);\n            final int startColumn = blockColumn * BLOCK_SIZE;\n            final int endColumn   = Math.min(columns, (blockColumn + 1) * BLOCK_SIZE);\n\n            // create block and fill it\n            final double[] block = new double[(endRow - startRow) * (endColumn - startColumn)];\n            int blockIndex = 0;\n            for (int row = startRow; row < endRow; ++row) {\n                for (int column = startColumn; column < endColumn; ++column) {\n                    block[blockIndex++] = rawData[row][column];\n                }\n            }\n\n            // add block to result array\n            blocksLayout[blockRow * blockColumns + blockColumn] = block;\n        }\n    }\n\n    return blocksLayout;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // create blocks layout array\n    final double[][] blocks = new double[blockRows * blockColumns][];\n\n    // fill in blocks\n    for (int row = 0; row < rows; ++row) {\n        for (int column = 0; column < columns; ++column) {\n            final int blockRow    = row    / BLOCK_SIZE;\n            final int blockColumn = column / BLOCK_SIZE;\n            final int blockIndex = blockRow * blockColumns + blockColumn;\n            if (blocks[blockIndex] == null) {\n                blocks[blockIndex] = new double[BLOCK_SIZE * BLOCK_SIZE];\n            }\n            final int blockRowOffset = row % BLOCK_SIZE;\n            final int blockColumnOffset = column % BLOCK_SIZE;\n            blocks[blockIndex][blockRowOffset * BLOCK_SIZE + blockColumnOffset] = rawData[row][column];\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    long bitVector = 0;\n    for (int i = 0; i < result.length; i++) {\n    \tbitVector = bitVector << 64 | result[i];\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0L;\n    for (final E value : condensed) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    long bitVector = 0;\n    for (long bit : result) {\n        bitVector = (bitVector << Long.SIZE) | bit;\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    if (condensed.size() > 64)\n    {\n        throw new IllegalArgumentException(CANNOT_STORE_S_S_VALUES_IN_S_BITS, new Object[] {condensed.size(), 64});\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result[0];\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0L;\n    for (final E value : condensed) \n    {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    if (condensed.size() > Long.SIZE) {\n        throw new IllegalArgumentException(CANNOT_STORE_S_S_VALUES_IN_S_BITS);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result[0];\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long bitVector = 0;\n    for (final E value : condensed) \n    {\n        bitVector |= 1L << value.ordinal();\n    }\n    return bitVector;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    long bitvector = 0;\n    for (long l : result) {\n        bitvector = (bitvector << Long.BYTES) | l;\n    }\n    return bitvector;\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp zero = new Dfp(a.field,0);\n    final Dfp one = new Dfp(a.field,1);\n    final Dfp two = new Dfp(a.field,2);\n\n    if (a.isInfinite()) {\n        return a.newInstance((byte)1, Dfp.INFINITE);\n    }\n\n    if (a.isNaN()) {\n        return a.newInstance();\n    }\n\n    /* If the exponent is less than zero then we can certainly\n     * return zero */\n    if (a.exp < 0) {\n        a.field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n        Dfp result = a.newInstance(zero);\n        result = result.dotrap(DfpField.FLAG_INEXACT, DfpMath.TRUNC_TRAP, a, result);\n        return result;\n    }\n\n    /* If the exponent is greater than or equal to digits, then it\n     * must already be an integer since there is no precision left\n     * for any fractional part */\n\n    if (a.exp >= a.field.DIGITS) {\n        return a.newInstance(a);\n    }\n\n    /* General case:  create another dfp, result, that contains the\n     * a with the fractional part lopped off.  */\n\n    Dfp result = a.newInstance();\n    for (int i = 0; i < a.field.DIGITS-result.exp; i++) {\n        result.changed |= result.mant[i] != 0;\n        result.mant[i] = 0;\n    }\n\n    if (result.changed) {\n        switch (result.rmode) {\n            case ROUND_FLOOR:\n                if (result.sign == -1) {\n                    // then we must increment the mantissa by one\n                    result = result.add(one.newInstance(-1));\n                }\n                break;\n\n            case ROUND_CEIL:\n                if (result.sign == 1) {\n                    // then we must increment the mantissa by one\n                    result = result.add(one);\n                }\n                break;\n\n            case ROUND_HALFUP:\n            case ROUND_HALFDOWN:\n}\n}\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    if (a.mant[a.mant.length-1] == 0) {\n        // a is zero\n        return DfpMath.newInstance(0);\n    }\n\n    /* If the exponent is less than zero then we can certainly\n     * return zero */\n    if (a.exp < 0) {\n        Dfp result = DfpMath.newInstance(a.getZero());\n        return DfpMath.dotrap(DfpMath.DfpField.FLAG_INEXACT, DfpMath.TRUNC_TRAP, a, result);\n    }\n\n    /* If the exponent is greater than or equal to digits, then it\n     * must already be an integer since there is no precision left\n     * for any fractional part */\n\n    if (a.exp >= a.mant.length) {\n        return DfpMath.newInstance(a);\n    }\n\n    /* General case:  create another dfp, result, that contains the\n     * a with the fractional part lopped off.  */\n\n    Dfp result = DfpMath.newInstance(a);\n    for (int i = 0; i < a.mant.length-result.exp; i++) {\n        changed |= result.mant[i] != 0;\n        result.mant[i] = 0;\n    }\n\n    if (changed) {\n        switch (rmode) {\n            case ROUND_FLOOR:\n                if (result.sign == -1) {\n                    // then we must increment the mantissa by one\n                    result = result.add(DfpMath.newInstance(-1));\n                }\n                break;\n\n            case ROUND_CEIL:\n                if (result.sign == 1) {\n                    // then we must increment the mantissa by one\n                    result = result.add(DfpMath.getOne());\n                }\n                break;\n// dfp/DfpMath.java\n        }\n    }\n\n    result.exp = a.exp;\n    result.nans = a.nans;\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp zero = a.field.getZero();\n\n    if (a.isInfinite()) {\n        if (a.lessThan(zero)) {\n            return a.newInstance((byte)1, Dfp.NEGATIVE_INFINITY);\n        } else {\n            return a.newInstance((byte)1, Dfp.INFINITE);\n        }\n    }\n\n    if (a.isNaN()) {\n        return a.newInstance((byte)1, Dfp.NAN);\n    }\n\n    /* If the exponent is less than zero then we can certainly\n     * return zero */\n    if (a.exp < 0) {\n        a.field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n        Dfp result = a.newInstance(zero);\n        result = result.dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, a, result);\n        return result;\n    }\n\n    /* If the exponent is greater than or equal to digits, then it\n     * must already be an integer since there is no precision left\n     * for any fractional part */\n\n    if (a.exp >= a.field.getDigits()) {\n        return a.newInstance(a);\n    }\n\n    /* General case:  create another dfp, result, that contains the\n     * a with the fractional part lopped off.  */\n\n    Dfp result = a.newInstance();\n    for (int i = 0; i < a.field.getDigits()-result.exp; i++) {\n        result.mant[i] = 0;\n    }\n\n    if (result.exp > 0) {\n        switch (a.field.getRoundingMode()) {\n            case ROUND_FLOOR:\n                if (result.sign == -1) {\n                    // then we must increment the mantissa by one\n                    result = result.add(a.newInstance(-1));\n                }\n                break;\n\n            case ROUND_CEIL:\n                if (result.sign == 1) {\n                    // then we must increment the mantissa by one\n                    result = result.add(a.getOne());\n                }\n                break;\n\n            default:\n                break;\n        }\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp zero = a.getField().getZero();\n    final Dfp one = a.getField().getOne();\n    final Dfp two = a.getField().getTwo();\n    final Dfp three = a.getField().getConstant(3);\n    final Dfp four = a.getField().getConstant(4);\n    final Dfp five = a.getField().getConstant(5);\n\n    if (a.isInfinite()) {\n        return a;\n    }\n\n    if (a.isNaN()) {\n        return a.newInstance(Dfp.NAN_STRING);\n    }\n\n    if (a.equals(zero)) {\n        return a.newInstance(one);\n    }\n\n    if (a.equals(one)) {\n        return a.newInstance(two);\n    }\n\n    if (a.lessThan(zero)) {\n        // we could return -exp(-a), but we return 1/exp(a) instead\n        // as this is more accurate for small a.\n        final Dfp inv = one.divide(a.expInternal(a.negate()));\n\n        if (inv.isInfinite()) {\n            return inv.newInstance((byte)1, Dfp.INFINITE);\n        }\n\n        return inv.newInstance();\n    }\n\n    /* If the exponent is less than zero then we can certainly\n     * return zero */\n    if (a.exp < -1022) {\n        return a.newInstance(zero);\n    }\n\n    /* If the exponent is greater than or equal to digits, then it\n     * must already be an integer since there is no precision left\n     * for any fractional part */\n\n    if (a.exp >= a.getField().getDigits()) {\n        return a.newInstance(a);\n    }\n\n    /* General case:  create another dfp, result, that contains the\n     * a with the fractional part lopped off.  */\n\n    Dfp result = a.newInstance();\n    for (int i = 0; i < a.exp - result.exp; i++) {\n        result.mant[i] = 0;\n    }\n\n    if (result.mant[0] != 0 || result.exp == 0) {\n}\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp zero = new Dfp(a.field, 0L);\n\n    if (a.isInfinite()) {\n        if (a.isNegative()) {\n            return zero.newInstance((byte)1, Dfp.NEGATIVE_INFINITY);\n        } else {\n            return zero.newInstance((byte)1, Dfp.POSITIVE_INFINITY);\n        }\n    }\n\n    if (a.isNaN()) {\n        return zero.newInstance((byte)1, Dfp.NAN);\n    }\n\n    final Dfp[] aSplit = split(a);\n\n    if (aSplit[1].equals(zero)) {\n        // a is an integer\n        return zero.newInstance(aSplit[0]);\n    }\n\n    if (aSplit[0].equals(zero)) {\n        // |a| < 1\n        final Dfp c = a.subtract(aSplit[1]);\n        final Dfp r;\n        final int ui = (int)((aSplit[1].abs()).log10() / 3.32);\n\n        if (ui > 7) {\n            // very small exponent.  |a| < 1e-8\n            r = aSplit[0].divide(aSplit[1]);\n            r = r.exp().multiply(aSplit[1]);\n\n        } else {\n            if (ui > 0) {\n                r = splitPow(split(aSplit[0]), ui);\n                r = r.multiply(pow(two, aSplit[1].intValue()));\n                r = r.multiply(exp(c));\n            } else {\n                r = splitPow(split(aSplit[0]), ui);\n            }\n        }\n\n        if (a.sign < 0 && y.rint().equals(y) && !y.remainder(two).equals(zero)) {\n            // if a is odd integer\n            r = r.negate();\n        }\n\n        return r;\n\n    } else {\n        // |a| >= 1\n        final Dfp r;\n        final int ui = (int)((aSplit[1].abs()).log10() / 3.32);\n\n        if (ui > 7) {\n}\n}\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    if (a.mant[a.mant.length-1] == 0) {\n        // a is zero\n        return a.newInstance(a.getZero());\n    }\n\n    /* If the exponent is less than zero then we can certainly\n     * return zero */\n    if (a.exp < 0) {\n        a.field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n        Dfp result = a.newInstance(a.getZero());\n        result = result.dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, a, result);\n        return result;\n    }\n\n    /* If the exponent is greater than or equal to digits, then it\n     * must already be an integer since there is no precision left\n     * for any fractional part */\n\n    if (a.exp >= a.mant.length) {\n        return a.newInstance(a);\n    }\n\n    /* General case:  create another dfp, result, that contains the\n     * a with the fractional part lopped off.  */\n\n    Dfp result = a.newInstance();\n    for (int i = 0; i < a.mant.length-result.exp; i++) {\n        a.changed |= result.mant[i] != 0;\n        result.mant[i] = 0;\n    }\n\n    if (a.changed) {\n        switch (a.rmode) {\n            case ROUND_FLOOR:\n                if (result.sign == -1) {\n                    // then we must increment the mantissa by one\n                    result = result.add(a.newInstance(-1));\n                }\n                break;\n\n            case ROUND_CEIL:\n                if (result.sign == 1) {\n                    // then we must increment the mantissa by one\n                    result = result.add(a.getOne());\n                }\n                break;\n        }\n    }\n\n    /* We have the exponent, now work on the mantissa */\n\n    a = a.divide(a.power10K(a.exp));\n    if (a.exp > -1023) {\n        a = a.subtract(a.getOne());\n    }\n\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    /* If a is zero then the result is one */\n    if (a.mant[a.mant.length-1] == 0) {\n        return a.newInstance(a.sign, a.exp);\n    }\n\n    /* If the exponent is less than zero then we can certainly\n     * return zero */\n    if (a.exp < 0) {\n        a.field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n        Dfp result = a.newInstance(a.getZero());\n        result = result.dotrap(DfpField.FLAG_INEXACT, DfpMath.TRUNC_TRAP, a, result);\n        return result;\n    }\n\n    /* If the exponent is greater than or equal to digits, then it\n     * must already be an integer since there is no precision left\n     * for any fractional part */\n\n    if (a.exp >= a.mant.length) {\n        return a.newInstance(a.sign, a.exp);\n    }\n\n    /* General case:  create another dfp, result, that contains the\n     * a with the fractional part lopped off.  */\n\n    Dfp result = a.newInstance(a.sign, a.exp);\n    for (int i = 0; i < a.mant.length-result.exp; i++) {\n        a.changed |= result.mant[i] != 0;\n        result.mant[i] = 0;\n    }\n\n    if (a.changed) {\n        switch (a.rmode) {\n            case ROUND_FLOOR:\n                if (result.sign == -1) {\n                    // then we must increment the mantissa by one\n                    result = result.add(a.newInstance(-1));\n                }\n                break;\n\n            case ROUND_CEIL:\n                if (result.sign == 1) {\n                    // then we must increment the mantissa by one\n                    result = result.add(a.getOne());\n                }\n                break;\n            case ROUND_DOWN:\n            case ROUND_UP:\n            case ROUND_HALF_DOWN:\n            case ROUND_HALF_UP:\n            case ROUND_HALF_EVEN:\n                // do nothing\n                break;\n        }\n}\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    /* If the exponent is less than zero then we can certainly\n     * return zero */\n    if (a.exp < 0) {\n        a.field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n        Dfp result = a.newInstance(a.getZero());\n        result = result.dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, a, result);\n        return result;\n    }\n\n    /* If the exponent is greater than or equal to digits, then it\n     * must already be an integer since there is no precision left\n     * for any fractional part */\n\n    if (a.exp >= a.mant.length) {\n        return a.newInstance(a);\n    }\n\n    /* General case:  create another dfp, result, that contains the\n     * a with the fractional part lopped off.  */\n\n    Dfp result = a.newInstance(a);\n    for (int i = 0; i < a.mant.length-result.exp; i++) {\n        a.changed |= result.mant[i] != 0;\n        result.mant[i] = 0;\n    }\n\n    if (a.changed) {\n        switch (a.rmode) {\n            case ROUND_FLOOR:\n                if (result.sign == -1) {\n                    // then we must increment the mantissa by one\n                    result = result.add(a.newInstance(-1));\n                }\n                break;\n\n            case ROUND_CEIL:\n                if (result.sign == 1) {\n                    // then we must increment the mantissa by one\n                    result = result.add(a.getOne());\n                }\n                break;\n        }\n    }\n\n    /* We have the exponent, now work on the mantissa */\n\n    a = a.divide(a.power10(result.exp));\n    if (result.exp > -1023) {\n        a = a.subtract(a.getOne());\n    }\n\n    if (result.exp < -1074) {\n        return a.newInstance();\n    }\n\n    if (result.exp > 1023) {\n}\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    /* If exponent is outside of bounds, return +Infinity or 0 as\n     * appropriate */\n    if (a.exp < -2046) {\n        return a.newInstance((byte) 1, Dfp.INFINITE);\n    }\n\n    if (a.mant[a.mant.length - 1] == 0) {\n        // a is zero\n        return a.newInstance(a);\n    }\n\n    /* If the exponent is less than zero then we can certainly\n     * return zero */\n    if (a.exp < 0) {\n        field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n        Dfp result = newInstance(getZero());\n        result = dotrap(DfpField.FLAG_INEXACT, TRUNC_TRAP, a, result);\n        return result;\n    }\n\n    /* If the exponent is greater than or equal to digits, then it\n     * must already be an integer since there is no precision left\n     * for any fractional part */\n    if (a.exp >= mant.length) {\n        return newInstance(a);\n    }\n\n    /* General case:  create another dfp, result, that contains the\n     * a with the fractional part lopped off.  */\n\n    Dfp result = newInstance(a);\n    for (int i = 0; i < mant.length - result.exp; i++) {\n        changed |= result.mant[i] != 0;\n        result.mant[i] = 0;\n    }\n\n    if (changed) {\n        switch (rmode) {\n            case ROUND_FLOOR:\n                if (result.sign == -1) {\n                    // then we must increment the mantissa by one\n                    result = result.add(newInstance(-1));\n                }\n                break;\n\n            case ROUND_CEIL:\n                if (result.sign == 1) {\n                    // then we must increment the mantissa by one\n                    result = result.add(getOne());\n                }\n                break;\n\n            case ROUND_DOWN:\n                if (result.sign == 1) {\n                    result = result.add(newInstance(-1));\n                }\n                break;\n\n            case ROUND_UP:\n}\n}\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp zero = new Dfp(0);\n    final Dfp one = a.getField().getESplit();\n    final Dfp x2 = a.multiply(a);\n\n    if (a.lessThan(zero)) {\n        return one.divide(expInternal(a.negate()));\n    }\n\n    if (a.equals(zero)) {\n        return one.newInstance();\n    }\n\n    if (a.equals(one)) {\n        return a.newInstance(one.add(new Dfp(1, Dfp.FINITE)));\n    }\n\n    if (a.greaterThan(one)) {\n        final Dfp r = expInternal(one.divide(a));\n        return r.multiply(expInternal(a.multiply(r)));\n    }\n\n    // break a into an integer and a fractional part.  a = n + m\n    final Dfp inta = a.rint();\n    final Dfp fraca = a.subtract(inta);\n\n    final int ia = inta.intValue();\n    if (ia > 2147483646) {\n        // return +Infinity\n        return a.newInstance((byte)1, Dfp.INFINITE);\n    }\n\n    if (ia < -2147483646) {\n        // return 0;\n        return a.newInstance();\n    }\n\n    final Dfp einta = splitPow(a.getField().getESplit(), ia);\n    final Dfp efraca = expInternal(fraca);\n\n    return einta.multiply(efraca);\n}"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    final T norm = getNorm();\n    final T threshold = norm.multiply(0.6);\n    if (threshold.equals(0)) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.multiply(norm).getReal()) <= threshold.getReal()) {\n        final T inverse = FastMath.sqrt(y.multiply(norm).getReal() * y.multiply(norm).getReal() + z.multiply(norm).getReal() * z.multiply(norm).getReal()).reciprocal();\n        return new FieldVector3D<>(0, inverse.multiply(z), inverse.multiply(-y));\n    } else if (FastMath.abs(y.multiply(norm).getReal()) <= threshold.getReal()) {\n        final T inverse = FastMath.sqrt(x.multiply(norm).getReal() * x.multiply(norm).getReal() + z.multiply(norm).getReal() * z.multiply(norm).getReal()).reciprocal();\n        return new FieldVector3D<>(inverse.multiply(-z), 0, inverse.multiply(x));\n    }\n    final T inverse = FastMath.sqrt(x.multiply(norm).getReal() * x.multiply(norm).getReal() + y.multiply(norm).getReal() * y.multiply(norm).getReal()).reciprocal();\n    return new FieldVector3D<>(inverse.multiply(y), inverse.multiply(-x), 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    final T threshold = getNorm().multiply(0.6);\n    if (threshold.equals(T.ZERO)) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.get()) <= threshold) {\n        final T inverse  = T.ONE.divide(FastMath.sqrt(y.getSquared() + z.getSquared()));\n        return new FieldVector3D<>(T.ZERO, inverse.multiply(z), inverse.multiply(y));\n    } else if (FastMath.abs(y.get()) <= threshold) {\n        final T inverse  = T.ONE.divide(FastMath.sqrt(x.getSquared() + z.getSquared()));\n        return new FieldVector3D<>(inverse.multiply(z), T.ZERO, inverse.multiply(x));\n    }\n    final T inverse  = T.ONE.divide(FastMath.sqrt(x.getSquared() + y.getSquared()));\n    return new FieldVector3D<>(inverse.multiply(y), -inverse.multiply(x), T.ZERO);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    if (FastMath.abs(x) <= 0.6 * getNorm()) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= 0.6 * getNorm()) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    final double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        final double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        final double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    final double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    final double x = getX();\n    final double y = getY();\n    final double z = getZ();\n\n    final double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        final double inverse = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        final double inverse = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    final double inverse = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    final T norm = getNorm();\n    if (norm.isZero()) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    final T dot = getDotProduct(u);\n\n    if (dot.compareTo(norm.multiply((2.0e-15 - 1.0))) < 0) {\n      // special case u = -v: we select a PI angle rotation around\n      // an arbitrary vector orthogonal to u\n      final T w = u.orthogonal();\n      return new FieldVector3D<>(0, w.getX(), w.getY(), w.getZ());\n    } else {\n      // general case: (u, v) defines a plane, we select\n      // the shortest possible rotation: axis orthogonal to this plane\n      final T q0 = FastMath.sqrt(0.5 * (1.0 + dot.divide(norm)));\n      final T coeff = FastMath.invsqrt(2.0 * q0.multiply(norm));\n      final T q = getCrossProduct(u, v);\n      return new FieldVector3D<>(q0, q.getX().multiply(coeff), q.getY().multiply(coeff), q.getZ().multiply(coeff));\n    }\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n\n}"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  throws IllegalArgumentException\n{\n    if (other == null) {\n        throw new IllegalArgumentException(\"other cannot be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"this and other do not overlap\");\n    }\n    return new Range<T>(\n        Math.max(this.minimum, other.minimum),\n        Math.min(this.maximum, other.maximum),\n        comparator\n    );\n}",
      "public Range<T> intersectionWith(final Range<T> other)  throws IllegalArgumentException {\n    if (other == null) {\n        throw new IllegalArgumentException(\"other must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"other must overlap this\");\n    }\n    Comparator<T> comparator = getComparator();\n    if (comparator == null) {\n        comparator = ComparableComparator.<T>INSTANCE;\n    }\n    T start = comparator.compare(minimum, other.minimum) <= 0 ? minimum : other.minimum;\n    T end = comparator.compare(maximum, other.maximum) >= 0 ? maximum : other.maximum;\n    return new Range<T>(start, end, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  throws IllegalArgumentException\n{\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Range does not overlap\");\n    }\n    final int start = elementCompareTo(other.minimum) > 0 ? elementCompareTo(other.minimum) : other.elementCompareTo(minimum);\n    final int end = elementCompareTo(other.maximum) < 0 ? elementCompareTo(other.maximum) : other.elementCompareTo(maximum);\n    return Range.between(minimum, end, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\nif (!isOverlappedBy(other)) {\nthrow new IllegalArgumentException(\"Range does not overlap\");\n}\nT resultMin = minimum;\nT resultMax = maximum;\nif (comparator != other.comparator) {\nif (!isNaturalOrdering()) {\nthrow new RuntimeException(\"Cannot compare with different comparators\");\n}\nif (!other.isNaturalOrdering()) {\nthrow new RuntimeException(\"Cannot compare with different comparators\");\n}\nif (minimum.compareTo(other.minimum) > 0) {\nresultMin = other.minimum;\n}\nif (maximum.compareTo(other.maximum) < 0) {\nresultMax = other.maximum;\n}\n}\nif (resultMin.compareTo(resultMax) > 0) {\nthrow new IllegalArgumentException(\"Invalid intersection\");\n}\nreturn new Range<T>(resultMin, resultMax, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  throws IllegalArgumentException\n{\n    if (other == null) {\n        throw new IllegalArgumentException(\"other cannot be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"this and other must be overlapping\");\n    }\n    if (containsRange(other)) {\n        return this;\n    }\n    final T lower = isAfter(other.minimum) ? other.minimum : minimum;\n    final T upper = isBefore(other.maximum) ? other.maximum : maximum;\n    return new Range<T>(lower, upper, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n\tif (other == null) {\n\t\tthrow new IllegalArgumentException(\"other cannot be null\");\n\t}\n\tif (!isOverlappedBy(other)) {\n\t\tthrow new IllegalArgumentException(\"other does not overlap this\");\n\t}\n\tif (isBefore(other.minimum)) {\n\t\treturn Range.is(other.minimum, other.getComparator());\n\t} else if (isAfter(other.maximum)) {\n\t\treturn Range.is(other.maximum, other.getComparator());\n\t} else {\n\t\treturn Range.between(minimum, maximum, getComparator());\n\t}\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n        if (!isOverlappedBy(other)) {\n            throw new IllegalArgumentException(\"Range intersection is not valid: this=\" + this + \", other=\" + other);\n        }\n        return new Range<>(Math.max(minimum, other.minimum), Math.min(maximum, other.maximum), comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  throws IllegalArgumentException\n{\n    if (!isOverlappedBy(other))\n        throw new IllegalArgumentException(\"No intersection\");\n    return between(Math.max(minimum, other.minimum), Math.min(maximum, other.maximum));\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n\tif (!isOverlappedBy(other)) {\n\t\tthrow new IllegalArgumentException(\"Cannot find intersection of non-overlapping ranges\");\n\t}\n\tComparator<T> comparator = getComparator();\n\tif (comparator == null) {\n\t\tcomparator = ComparableComparator.INSTANCE;\n\t}\n\treturn new Range<T>(comparator.max(minimum, other.minimum), comparator.min(maximum, other.maximum), comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\nif (other == null) {\n        throw new IllegalArgumentException(\"other cannot be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"this range (\" + this + \") does not overlap other range (\" + other + \")\");\n    }\n\n    final T min = (other.isAfter(minimum) ? minimum : other.minimum);\n    final T max = (isAfter(other.maximum) ? other.maximum : maximum);\n\n    return new Range<>(min, max, comparator);\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    OutputStreamBasedJsonGenerator gen =\n            new OutputStreamBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new WriterBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out) {\n        @Override\n        protected void _writeUTF8(int codePoint) throws IOException\n        {\n            // Override this method to write code points as UTF-8 encoded bytes\n            // to the underlying output stream.\n        }\n    };\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out, _characterEscapes);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    OutputStreamBasedJsonGenerator gen = new OutputStreamBasedJsonGenerator(ctxt,\n        _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out,\n            _characterEscapes, _maximumNonEscapedChar, _rootValueSeparator);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    OutputStreamBasedJsonGenerator gen =\n        new UTF8OutputStreamBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return (Byte) o1 == (Byte) o2;\n    }\n    if (type.equals(Short.TYPE)) {\n        return (Short) o1 == (Short) o2;\n    }\n    if (type.equals(Integer.TYPE)) {\n        return (Integer) o1 == (Integer) o2;\n    }\n    if (type.equals(Character.TYPE)) {\n        return (Character) o1 == (Character) o2;\n    }\n    if (type.equals(Long.TYPE)) {\n        return (Long) o1 == (Long) o2;\n    }\n    if (type.equals(Float.TYPE)) {\n        return (Float) o1 == (Float) o2;\n    }\n    if (type.equals(Double.TYPE)) {\n        return (Double) o1 == (Double) o2;\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return (Boolean) o1 == (Boolean) o2;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return ((Byte) o1).equals((Byte) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return ((Short) o1).equals((Short) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return ((Integer) o1).equals((Integer) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return ((Character) o1).equals((Character) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return ((Long) o1).equals((Long) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return ((Float) o1).equals((Float) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return ((Double) o1).equals((Double) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return ((Boolean) o1).equals((Boolean) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.isEnum()) {\n        return o1 == o2 || o1.equals(o2);\n    }\n    if (type == Byte.class) {\n        return (Byte) o1 == (Byte) o2;\n    }\n    if (type == Short.class) {\n        return (Short) o1 == (Short) o2;\n    }\n    if (type == Integer.class) {\n        return (Integer) o1 == (Integer) o2;\n    }\n    if (type == Character.class) {\n        return (Character) o1 == (Character) o2;\n    }\n    if (type == Long.class) {\n        return (Long) o1 == (Long) o2;\n    }\n    if (type == Float.class) {\n        return (Float) o1 == (Float) o2;\n    }\n    if (type == Double.class) {\n        return (Double) o1 == (Double) o2;\n    }\n    if (type == Boolean.class) {\n        return (Boolean) o1 == (Boolean) o2;\n    }\n    if (type == String.class) {\n        return o1 == o2 || ((String) o1).equals((String) o2);\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return (Byte) o1 == (Byte) o2;\n    }\n    if (type.equals(Short.TYPE)) {\n        return (Short) o1 == (Short) o2;\n    }\n    if (type.equals(Integer.TYPE)) {\n        return (Integer) o1 == (Integer) o2;\n    }\n    if (type.equals(Character.TYPE)) {\n        return (Character) o1 == (Character) o2;\n    }\n    if (type.equals(Long.TYPE)) {\n        return (Long) o1 == (Long) o2;\n    }\n    if (type.equals(Float.TYPE)) {\n        return (Float) o1 == (Float) o2;\n    }\n    if (type.equals(Double.TYPE)) {\n        return (Double) o1 == (Double) o2;\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return (Boolean) o1 == (Boolean) o2;\n    }\n    if (type.isEnum()) {\n        return o1.equals(o2);\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isPrimitive()) {\n        throw new IllegalArgumentException(\"Unsupported primitive type: \" + type);\n    } else {\n        return o1.equals(o2);\n    }\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return ((Byte) o1).equals((Byte) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return ((Short) o1).equals((Short) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return ((Integer) o1).equals((Integer) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return ((Character) o1).equals((Character) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return ((Long) o1).equals((Long) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return ((Float) o1).equals((Float) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return ((Double) o1).equals((Double) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return ((Boolean) o1).equals((Boolean) o2);\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isEnum()) {\n        return o1.equals(o2);\n    }\n    if (type.isPrimitive()) {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return ((Byte) o1).equals((Byte) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return ((Short) o1).equals((Short) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return ((Integer) o1).equals((Integer) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return ((Character) o1).equals((Character) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return ((Long) o1).equals((Long) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return ((Float) o1).equals((Float) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return ((Double) o1).equals((Double) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return ((Boolean) o1).equals((Boolean) o2);\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isEnum()) {\n        return o1.equals(o2);\n    }\n    if (type.isPrimitive()) {\n        throw new IllegalArgumentException(\"Illegal type: \" + type);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return (Byte) o1 == (Byte) o2;\n    }\n    if (type.equals(Short.TYPE)) {\n        return (Short) o1 == (Short) o2;\n    }\n    if (type.equals(Integer.TYPE)) {\n        return (Integer) o1 == (Integer) o2;\n    }\n    if (type.equals(Character.TYPE)) {\n        return (Character) o1 == (Character) o2;\n    }\n    if (type.equals(Long.TYPE)) {\n        return (Long) o1 == (Long) o2;\n    }\n    if (type.equals(Float.TYPE)) {\n        return (Float) o1 == (Float) o2;\n    }\n    if (type.equals(Double.TYPE)) {\n        return (Double) o1 == (Double) o2;\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return (Boolean) o1 == (Boolean) o2;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return (Byte) o1 == (Byte) o2;\n    }\n    if (type.equals(Short.TYPE)) {\n        return (Short) o1 == (Short) o2;\n    }\n    if (type.equals(Integer.TYPE)) {\n        return (Integer) o1 == (Integer) o2;\n    }\n    if (type.equals(Character.TYPE)) {\n        return (Character) o1 == (Character) o2;\n    }\n    if (type.equals(Long.TYPE)) {\n        return (Long) o1 == (Long) o2;\n    }\n    if (type.equals(Float.TYPE)) {\n        return (Float) o1 == (Float) o2;\n    }\n    if (type.equals(Double.TYPE)) {\n        return (Double) o1 == (Double) o2;\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return (Boolean) o1 == (Boolean) o2;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isEnum()) {\n        return o1.equals(o2);\n    }\n    if (type.isPrimitive() || type.isSynthetic()) {\n        return o1.equals(o2);\n    }\n    return false;\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.isEnum()) {\n        return o1 == o2 || (o1 != null && o1.equals(o2));\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return (Byte) o1 == (Byte) o2;\n    }\n    if (type.equals(Short.TYPE)) {\n        return (Short) o1 == (Short) o2;\n    }\n    if (type.equals(Integer.TYPE)) {\n        return (Integer) o1 == (Integer) o2;\n    }\n    if (type.equals(Character.TYPE)) {\n        return (Character) o1 == (Character) o2;\n    }\n    if (type.equals(Long.TYPE)) {\n        return (Long) o1 == (Long) o2;\n    }\n    if (type.equals(Float.TYPE)) {\n        return (Float) o1 == (Float) o2;\n    }\n    if (type.equals(Double.TYPE)) {\n        return (Double) o1 == (Double) o2;\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return (Boolean) o1 == (Boolean) o2;\n    }\n    if (type.equals(String.class)) {\n        return o1 == o2 || (o1 != null && o1.equals(o2));\n    }\n    return o1 == o2 || (o1 != null && o1.equals(o2));\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return ((Byte) o1).equals((Byte) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return ((Short) o1).equals((Short) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return ((Integer) o1).equals((Integer) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return ((Character) o1).equals((Character) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return ((Long) o1).equals((Long) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return ((Float) o1).equals((Float) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return ((Double) o1).equals((Double) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return ((Boolean) o1).equals((Boolean) o2);\n    }\n    return o1.equals(o2);\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    } else {\n        return type.getNativeType(JSTypeNative.NO_TYPE);\n    }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type.getNativeType(JSTypeNative.NO_TYPE);\n  } else {\n    return type;\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type == null) {\n    return null;\n  }\n  if (type.isUnknownType()) {\n    return type;\n  }\n  if (type.isNoResolvedType()) {\n    return getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }\n  if (type.hasAnyTemplateTypesInternal()) {\n    return null;\n  }\n  if (isExemptFromTemplateTypeInvariance(type)) {\n    return null;\n  }\n  if (!type.isNominalType()) {\n    return null;\n  }\n  if (type.isInterface()) {\n    return null;\n  }\n  return getLeastSupertype(getNativeType(JSTypeNative.OBJECT_TYPE), type);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnknownType()) {\n        return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n    } else if (type.isNoResolvedType()) {\n        return getNativeType(JSTypeNative.NO_TYPE);\n    } else {\n        return type;\n    }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    } else {\n        return type;\n    }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }\n  if (type.isUnknownType()) {\n    return type.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }\n  if (type.hasAnyTemplateTypesInternal()) {\n    return type.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type == null) {\n    return null;\n  } else if (type.isUnknownType()) {\n    return type;\n  } else if (type.isNoResolvedType()) {\n    return getNativeType(JSTypeNative.NO_TYPE);\n  } else {\n    return type;\n  }\n}"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n        return blindScope;\n    }\n    if (originalType.isNullable() && restrictedType.isNullable()) {\n        return blindScope;\n    }\n    if (originalType.isNullable()) {\n        // If the original type is nullable, it means we're refining a\n        // potentially undefined symbol, so we need to refine the whole\n        // flow scope.\n        return maybeRestrictTwoNames(blindScope, node, originalType, restrictedType, node, originalType, restrictedType);\n    }\n    if (restrictedType.isNullable()) {\n        // If the restricted type is nullable, it means we're refining a\n        // potentially undefined symbol, so we need to refine the whole\n        // flow scope.\n        return maybeRestrictTwoNames(blindScope, node, originalType, restrictedType, node, originalType, restrictedType);\n    }\n    if (originalType.isUndefined() && restrictedType.isNullable()) {\n        // We can safely refine this to just be undefined, since it's already\n        // nullable.\n        return maybeRestrictTwoNames(blindScope, node, originalType, restrictedType, node, originalType, restrictedType);\n    }\n    if (restrictedType.isUndefined()) {\n        // If the restricted type is undefined, it means we're refining a\n        // potentially undefined symbol, so we need to refine the whole\n        // flow scope.\n        return maybeRestrictTwoNames(blindScope, node, originalType, restrictedType, node, originalType, restrictedType);\n    }\n    if (originalType.isBoolean() && restrictedType.isNullable()) {\n        // If the original type is boolean and the restricted type is nullable,\n        // we need to refine the flow scope to handle both cases.\n        return maybeRestrictTwoNames(blindScope, node, originalType, restrictedType, node, originalType, restrictedType);\n    }\n    if (restrictedType.isBoolean()) {\n        // If the restricted type is boolean, we need to refine the flow\n        // scope to handle both cases.\n        return maybeRestrictTwoNames(blindScope, node, originalType, restrictedType, node, originalType, restrictedType);\n    }\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    boolean shouldRefine = restrictedType != null && restrictedType != originalType;\n    if (shouldRefine) {\n      // Create a new flow scope and declare the name with the new type.\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    } else {\n      // No need to refine the name, just use the existing blind scope.\n      return blindScope;\n    }\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (originalType == restrictedType) {\n        return blindScope;\n    }\n\n    if (node.isQualifiedName()) {\n        return maybeRestrictTwoNames(\n            blindScope, node, originalType, restrictedType, null, null);\n    }\n\n    if (node.isName()) {\n        return maybeRestrictTwoNames(\n            blindScope, node, originalType, restrictedType, null, null);\n    }\n\n    if (node.isInstanceOf()) {\n        Node left = node.getFirstChild();\n        Node right = node.getLastChild();\n        return maybeRestrictTwoNames(\n            blindScope, left, originalType, restrictedType, right, null);\n    }\n\n    if (node.isLabelName() || node.isLabel()) {\n        // Label names and label statements are not actually names.\n        // They are treated like names, but they are not really.\n        // So, we need to put them in the flow lattice, but we don't\n        // want to promote them to a variable.\n        //\n        // This is a bit of a hack, but it works.\n        if (restrictedType != null) {\n            return blindScope.createChildFlowScope()\n                .inferSlotType(node.getName(), restrictedType);\n        }\n        return blindScope;\n    }\n\n    if (node.isCase()) {\n        return caseNameOrGetProp(node.getFirstChild(), blindScope, true);\n    }\n\n    if (node.isCaseOf()) {\n        return caseNameOrGetProp(node.getFirstChild(), blindScope, true);\n    }\n\n    if (node.isGetProp()) {\n        return caseNameOrGetProp(node.getFirstChild().getLastChild(),\n            blindScope, false);\n    }\n\n    if (node.isGetElem()) {\n        return caseNameOrGetProp(node.getFirstChild().getLastChild(),\n            blindScope, false);\n    }\n\n    if (node.isVar()) {\n        // Do not refine variables.\n        return blindScope;\n    }\n\n    if (node.isParamList()) {\n        // Do not refine function arguments.\n        return blindScope;\n    }\n\n    if (node.isCall()) {\n}\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (originalType == restrictedType) {\n        return blindScope;\n    }\n\n    if (node == null) {\n        return blindScope; // Nothing to restrict\n    }\n\n    if (node.isQualifiedName()) {\n        return maybeRestrictQualifiedName(blindScope, node, originalType, restrictedType);\n    } else {\n        return maybeRestrictNonQualifiedName(blindScope, node, originalType, restrictedType);\n    }\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n        return blindScope;\n    }\n\n    if (node.isQualifiedName()) {\n        return maybeRestrictTwoNames(blindScope, node, originalType, restrictedType, null, null);\n\n    } else if (node.isName()) {\n        return caseNameOrGetProp(node, blindScope, true);\n\n    } else {\n        return caseTypeOf(node, restrictedType, null, blindScope);\n    }\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n        return blindScope;\n    }\n\n    if (node.isQualifiedName()) {\n        return maybeRestrictTwoNames(blindScope, node, originalType, restrictedType, null, null);\n    } else {\n        // If it's not a qualified name, we still need to handle\n        // the case where the property being accessed might be undefined.\n        //\n        // We do this by creating a new flow scope, and then we\n        // restrict the property to the new type.\n        //\n        // If the property is defined, then the new flow scope will\n        // have a slot for it. If the property is not defined, then\n        // we will throw an exception when we try to access it.\n\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n  if (node.isQualifiedName()) {\n    return maybeRestrictTwoNames(\n        blindScope, node, originalType, restrictedType,\n        null, null, null);\n  }\n  if (node.isName()) {\n    return caseNameOrGetProp(node, blindScope, false);\n  }\n  return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType.isUnknown()) {\n      return blindScope;\n    }\n\n    if (node.isQualifiedName()) {\n      return maybeRestrictTwoNames(blindScope, null, null, null, node, originalType, restrictedType);\n    }\n\n    if (node.isName()) {\n      return maybeRestrictTwoNames(blindScope, node, originalType, restrictedType, null, null, null);\n    }\n\n    // If we get here, we have a non-name node. We're going to have to\n    // generate a new flow scope to represent the restriction.\n    return maybeRestrictTwoNames(blindScope, null, originalType, restrictedType, null, null, null);\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    boolean shouldRefine = restrictedType != null && restrictedType != originalType;\n    if (shouldRefine) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n\n    skipEOLs();\n    if (!match(JsDocToken.LPAREN)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lparen\");\n    }\n    next();\n\n    skipEOLs();\n    if (!match(JsDocToken.NAME)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.name\");\n    }\n\n    int lineno = current().getLineno();\n    int charno = current().getCharno();\n    String methodName = current().getString();\n\n    next();\n\n    if (match(JsDocToken.LAMBDA)) {\n      return parseTopDownLambda(methodName, lineno, charno);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RPAREN)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n    }\n\n    next();\n\n    if (!match(JsDocToken.LBRACE)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lbrace\");\n    }\n\n    next();\n\n    Node typeParams = null;\n    if (match(JsDocToken.LANGLE)) {\n      next();\n      skipEOLs();\n      typeParams = parseTypeParameters(current());\n      if (typeParams == null) {\n        return null;\n      }\n\n      skipEOLs();\n      if (!match(JsDocToken.RANGLE)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rangle\");\n      }\n\n      next();\n    }\n\n    Node parameters = parseParametersType(current());\n    if (parameters == null) {\n      return null;\n    }\n\n    Node resultType = parseResultType(current());\n    if (resultType == null) {\n      return null;\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n\n    next();\n\n    functionType.addChildToBack(typeParams);\n    functionType.addChildToBack(parameters);\n    functionType.addChildToBack(resultType);\n\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  skipEOLs();\n  if (!match(JsDocToken.LPAREN)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lparen\");\n  }\n  next();\n\n  skipEOLs();\n  Node typeParams = parseTypeParameters(next());\n  if (typeParams != null) {\n    skipEOLs();\n    if (!match(JsDocToken.RPAREN)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n    }\n    next();\n    return new FunctionType(typeParams);\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.IDENTIFIER)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n  int thisLineno = current().getLineno();\n  int thisCharno = current().getCharno();\n  String thisName = current().getString();\n  next();\n\n  skipEOLs();\n  if (!match(JsDocToken.COLON)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n  next();\n\n  skipEOLs();\n  Node thisType = parseTypeName(next());\n  if (thisType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typename\");\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.RPAREN)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n  }\n  next();\n\n  skipEOLs();\n  Node paramsType = parseParametersType(next());\n  if (paramsType == null) {\n    return null;\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.RPAREN)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n  }\n  next();\n\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.result\");\n  }\n\n  if (paramsType.hasChild(thisType)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.this\");\n  }\n\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.FUNCTION) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.function\");\n    }\n    next();\n    skipEOLs();\n\n    if (match(JsDocToken.LAMBDA)) {\n      next();\n      skipEOLs();\n\n      Node params = parseParametersType(next());\n      if (params == null) {\n        return null;\n      }\n\n      skipEOLs();\n      Node resultType = parseResultType(next());\n      if (resultType == null) {\n        return null;\n      }\n\n      Node functionType = newNode(Token.FUNCTION_TYPE);\n      functionType.addChildToBack(params);\n      functionType.addChildToBack(resultType);\n\n      skipEOLs();\n      if (!match(JsDocToken.RB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n      }\n      next();\n      return functionType;\n    }\n\n    if (!match(JsDocToken.LPAREN)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lparen\");\n    }\n    next();\n\n    Node typeParameters = parseTypeParameters(token);\n    Node params = parseParametersType(next());\n    if (params == null) {\n      return null;\n    }\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    }\n\n    Node functionType = newNode(Token.FUNCTION_TYPE);\n    if (typeParameters != null) {\n      functionType.addChildToBack(typeParameters);\n    }\n    functionType.addChildToBack(params);\n    functionType.addChildToBack(resultType);\n\n    skipEOLs();\n    if (!match(JsDocToken.RPAREN)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n    }\n    next();\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n  if (!match(JsDocToken.LPAREN)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lparen\");\n  }\n  next();\n  skipEOLs();\n\n  // 'this' parameter\n  if (!match(JsDocToken.IDENT)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n  Node thisName = newStringNode(\"this\", lineno, charno);\n  next();\n  skipEOLs();\n\n  // ':'\n  if (!match(JsDocToken.COLON)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n  next();\n  skipEOLs();\n\n  // 'this' type\n  Node thisType = parseTypeName(next());\n  if (thisType == null) {\n    return null;\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.RPAREN)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n  }\n  next();\n  skipEOLs();\n\n  // parameters type\n  Node paramsType = parseParametersType(next());\n  if (paramsType == null) {\n    return null;\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.RPAREN)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n  }\n  next();\n\n  // return type\n  Node returnType = parseResultType(next());\n  if (returnType == null) {\n    return null;\n  }\n\n  Node functionTypeNode = newNode(Token.FUNCTION);\n\n  functionTypeNode.addChildToBack(thisName);\n  functionTypeNode.addChildToBack(newStringNode(\":\", lineno, charno));\n  functionTypeNode.addChildToBack(thisType);\n  functionTypeNode.addChildToBack(newStringNode(\":\", lineno, charno));\n  functionTypeNode.addChildToBack(paramsType);\n  functionTypeNode.addChildToBack(newStringNode(\":\", lineno, charno));\n  functionTypeNode.addChildToBack(returnType);\n\n  return functionTypeNode;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    skipEOLs();\n    if (!match(JsDocToken.LPARENT)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lparen\");\n    }\n\n    next();\n\n    skipEOLs();\n    if (!match(JsDocToken.THIS_KEYWORD)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n\n    next();\n\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n\n    next();\n\n    skipEOLs();\n    if (!match(JsDocToken.IDENTIFIER)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typename\");\n    }\n\n    int lineno = current().getLineno();\n    int charno = current().getCharno();\n\n    String typeName = current().getStringValue();\n    next();\n\n    Node typeParamList = parseTypeParameters();\n    if (typeParamList == null) {\n      return null;\n    }\n\n    Node thisType = newStringNode(typeName, lineno, charno);\n\n    if (match(JsDocToken.LPARENT)) {\n      next();\n      skipEOLs();\n      Node memberType = parseTypeExpressionList(next());\n      if (memberType != null) {\n        thisType.addChildToFront(memberType);\n\n        skipEOLs();\n        if (!match(JsDocToken.RPARENT)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n        }\n\n        next();\n      }\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RPARENT)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n    }\n\n    next();\n\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n      return null;\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RPARENT)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n    }\n\n    next();\n\n    return newNode(Token.FUNCTION_TYPE, typeParamList, thisType, parametersType);\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (!match(JsDocToken.IDENTIFIER, \"function\")) {\n        return null;\n    }\n\n    next();\n    skipEOLs();\n\n    Node typeParams = null;\n    if (match(JsDocToken.LT)) {\n        next();\n        skipEOLs();\n        typeParams = parseTypeParameters(next());\n        if (typeParams == null) {\n            return null;\n        }\n    }\n\n    skipEOLs();\n\n    if (!match(JsDocToken.LPAREN)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lparen\");\n    }\n    next();\n\n    skipEOLs();\n\n    Node paramList = parseParametersType(next());\n    if (paramList == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.parameterlist\");\n    }\n\n    skipEOLs();\n\n    Node resultType = null;\n    if (match(JsDocToken.RARROW)) {\n        next();\n        skipEOLs();\n        resultType = parseTypeExpression(next());\n        if (resultType == null) {\n            return null;\n        }\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RPAREN)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n    }\n    next();\n\n    Node functionTypeNode = newNode(Token.FUNCTION);\n    if (typeParams != null) {\n        functionTypeNode.addChildToBack(typeParams);\n    }\n    functionTypeNode.addChildToBack(paramList);\n    if (resultType != null) {\n        functionTypeNode.addChildToBack(resultType);\n    }\n    return functionTypeNode;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  skipEOLs();\n  if (!match(JsDocToken.LPAREN)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lparen\");\n  }\n  next();\n\n  skipEOLs();\n  Node typeParams = parseTypeParameters(token);\n\n  skipEOLs();\n  if (!match(JsDocToken.THIS)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n  next();\n\n  skipEOLs();\n  Node thisType = parseTypeName(token);\n\n  skipEOLs();\n  if (!match(JsDocToken.RPAREN)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n  }\n  next();\n\n  skipEOLs();\n  Node paramTypes = parseParametersType(next());\n\n  skipEOLs();\n  if (!match(JsDocToken.RARROW)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rarrow\");\n  }\n  next();\n\n  skipEOLs();\n  Node resultType = parseTypeExpression(next());\n\n  if (typeParams != null) {\n    thisType = createTemplateNode().addChildToFront(typeParams).addChildToFront(thisType);\n  }\n  return newNode(Token.FUNCTION, thisType, paramTypes, resultType);\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  if (!match(JsDocToken.LPAREN)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lparen\");\n  }\n\n  next();\n  skipEOLs();\n\n  Node typeParameters = null;\n  if (match(JsDocToken.LAMBDA)) {\n    next();\n    skipEOLs();\n    typeParameters = parseTypeParameters();\n    if (typeParameters == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lparen\");\n    }\n    if (!match(JsDocToken.RARROW)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rarrow\");\n    }\n    next();\n    skipEOLs();\n  } else if (match(JsDocToken.LAMBDA, JsDocToken.IDENTIFIER)) {\n    next();\n    skipEOLs();\n    Node name = parseName(token);\n    if (name == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.identifier\");\n    }\n    if (!match(JsDocToken.RARROW)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rarrow\");\n    }\n    next();\n    skipEOLs();\n    typeParameters = new StringNode(name.getString(), token.getLineno(), token.getCharno());\n    typeParameters.setType(Token.NAME);\n  } else if (!match(JsDocToken.RARROW)) {\n    Node thisType = parseTypeName(JsDocToken.NAME);\n    if (thisType == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.name\");\n    }\n    thisType.setType(Token.NAME);\n    Node thisArg = newNode(Token.NAME);\n    thisArg.setType(Token.NAME);\n    thisArg.setString(\"this\");\n    thisArg.setLineno(token.getLineno());\n    thisArg.setCharno(token.getCharno());\n    thisArg.setStaticSourceFile(sourceFile);\n    thisArg.setInputId(inputId);\n    thisArg.setLength(token.getLexeme().length());\n}\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n\n    if (!match(JsDocToken.LPAR)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lpar\");\n    }\n    next();\n    skipEOLs();\n\n    // 'this' ':' TypeName,\n    if (!match(JsDocToken.NAME, \"this\")) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n\n    Node thisType = parseTypeName(next());\n    if (thisType == null) \n    {\n        return null;\n    }\n    functionType.addChildToBack(thisType);\n\n    // '(' 'this' ':' TypeName, ParametersType ')'\n    if (!match(JsDocToken.LPAR)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lpar\");\n    }\n    next();\n    skipEOLs();\n\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) \n    {\n        return null;\n    }\n    functionType.addChildToBack(parametersType);\n\n    skipEOLs();\n    if (!match(JsDocToken.RPAR)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rpar\");\n    }\n    next();\n\n    // ')' ResultType\n    if (!match(JsDocToken.RPAR)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rpar\");\n    }\n    next();\n\n    // ResultType\n    Node resultType = parseResultType(token);\n    if (resultType == null) \n    {\n        return null;\n    }\n    functionType.addChildToBack(resultType);\n\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  if (!match(JsDocToken.FUNCTION)) {\n    return null;\n  }\n  next();\n  skipEOLs();\n\n  Node typeParams = parseTypeParameters(token);\n  if (typeParams != null) {\n    functionType.addChildToBack(typeParams);\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.LPAREN)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lparen\");\n  }\n\n  next();\n  skipEOLs();\n\n  Node paramList = parseParametersType(next());\n  if (paramList == null) {\n    return null;\n  }\n\n  functionType.addChildToBack(paramList);\n\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return null;\n  }\n\n  functionType.addChildToBack(resultType);\n  return functionType;\n}"
    ],
    [
      "public static String deleteWhitespace(final String str)  {\n    if (str == null)\n    {\n        return null;\n    }\n    final int len = str.length();\n    final StringBuilder buf = new StringBuilder(len);\n    for (int i = 0; i < len; i++)\n    {\n        final char ch = str.charAt(i);\n        if (!Character.isWhitespace(ch))\n        {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final StringBuilder b = new StringBuilder(len);\n    for (int i = 0; i < len; i++) {\n        char ch = str.charAt(i);\n        if (!Character.isWhitespace(ch)) {\n            b.append(ch);\n        }\n    }\n    return b.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final char[] buf = str.toCharArray();\n    int newLength = 0;\n    for (final char ch : buf) {\n        if (!Character.isWhitespace(ch)) {\n            buf[newLength++] = ch;\n        }\n    }\n    if (newLength == buf.length) {\n        return str;\n    }\n    return new String(buf, 0, newLength);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null)\n    {\n        return null;\n    }\n    final int len = str.length();\n    final StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < len; i++) \n    {\n        char ch = str.charAt(i);\n        if (!Character.isWhitespace(ch)) \n        {\n            sb.append(ch);\n        }\n    }\n    return sb.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final StringBuilder buf = new StringBuilder(strLen);\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (!Character.isWhitespace(ch)) {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    return str.replaceAll(\"\\\\s\", \"\");\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null)\n        return null;\n    int start = 0;\n    int end = str.length();\n\n    // Find first non-whitespace character\n    while (start < end && Character.isWhitespace(str.charAt(start)))\n        start++;\n\n    // Find last non-whitespace character\n    while (end > start && Character.isWhitespace(str.charAt(end - 1)))\n        end--;\n\n    // Return empty string if all characters were whitespace\n    if (start >= end)\n        return EMPTY;\n\n    // Return substring without whitespaces\n    return str.substring(start, end);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final char[] arr = new char[len];\n    int count = 0;\n    for (int i = 0; i < len; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            arr[count++] = str.charAt(i);\n        }\n    }\n    return new String(arr, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    return str.replaceAll(\"\\\\s+\", \"\");\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final char[] array = str.toCharArray();\n    final StringBuilder sb = new StringBuilder();\n    for (final char ch : array) {\n        if (!Character.isWhitespace(ch)) {\n            sb.append(ch);\n        }\n    }\n    return sb.toString();\n}"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty())\n    {\n        return null;\n    }\n    SummaryStatisticsValues aggregatedSummary = new StatisticalSummaryValues(0.0,0.0,0,0.0,0.0,0.0);\n    for (SummaryStatistics stat : statistics) {\n        aggregatedSummary.add(stat.getSummary());\n    }\n    return aggregatedSummary;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n    double sum = 0.0;\n    long n = 0L;\n\n    for (SummaryStatistics ss : statistics) {\n        n += ss.getN();\n        sum += ss.getSum();\n        max = Math.max(max, ss.getMax());\n        min = Math.min(min, ss.getMin());\n    }\n\n    double mean = (n == 0L) ? Double.NaN : (sum / n);\n    double variance = 0.0;\n\n    for (SummaryStatistics ss : statistics) {\n        variance += ss.getVariance() * ss.getN();\n    }\n\n    variance /= n;\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty())\n    {\n        return null;\n    }\n    double max = Double.NEGATIVE_INFINITY, min = Double.POSITIVE_INFINITY;\n    long n = 0L;\n    double sum = 0.0, sumsq = 0.0, sumLog = 0.0;\n    for (SummaryStatistics s : statistics)\n    {\n        max = Math.max(max, s.getMax());\n        min = Math.min(min, s.getMin());\n        n += s.getN();\n        sum += s.getSum();\n        sumsq += s.getSumsq();\n        sumLog += s.getSumOfLogs();\n    }\n    double mean = (n == 0L) ? 0.0 : (sum / n);\n    double variance = (n <= 1L) ? 0.0 : (sumsq / (n - 1) - mean * mean);\n    double sd = (n <= 1L) ? 0.0 : Math.sqrt(variance);\n    double gmean = (n == 0L) ? 0.0 : Math.exp(sumLog / n);\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double mean = 0.0;\n    double variance = 0.0;\n    long n = 0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n    double sum = 0.0;\n\n    for (SummaryStatistics stat : statistics) {\n        n += stat.getN();\n        sum += stat.getSum();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n\n        double tempMean = stat.getSum() / stat.getN();\n        variance += stat.getN() * Math.pow(tempMean - mean, 2);\n        mean = (sum / n);\n    }\n\n    variance /= (n - 1);\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double mean = 0.0;\n    double variance = 0.0;\n    long n = 0L;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n    double sum = 0.0;\n\n    for (SummaryStatistics stat : statistics) {\n        mean += stat.getMean() * stat.getN();\n        variance += stat.getVariance() * stat.getN();\n        n += stat.getN();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        sum += stat.getSum();\n    }\n\n    mean /= n;\n    variance /= n - 1;\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty())\n        return null;\n\n    StatisticalSummaryValues.Builder builder = StatisticalSummaryValues.builder();\n    for (SummaryStatistics ss : statistics) {\n        builder.add(ss);\n    }\n    return builder.build();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    SummaryStatistics aggregatedStatistics = new SummaryStatistics();\n    for (SummaryStatistics s : statistics) {\n        aggregatedStatistics.add(s);\n    }\n    return aggregatedStatistics.getSummary();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    StatisticalSummaryValues aggValues = new StatisticalSummaryValues(0, 0, 0, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 0);\n\n    for (SummaryStatistics s : statistics) {\n        aggValues = aggValues.combine(s.getSummary());\n    }\n\n    return aggValues;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty())\n        return null;\n\n    StatisticalSummaryValues aggSummary = new StatisticalSummaryValues(0,0,0,0,0,0);\n    for (SummaryStatistics stat : statistics) {\n        aggSummary.mean += stat.getMean();\n        aggSummary.variance += stat.getVariance();\n        aggSummary.n += stat.getN();\n        aggSummary.max = Math.max(aggSummary.max, stat.getMax());\n        aggSummary.min = Math.min(aggSummary.min, stat.getMin());\n        aggSummary.sum += stat.getSum();\n    }\n\n    aggSummary.mean /= aggSummary.n;\n    aggSummary.variance /= aggSummary.n - 1; //corrected for unbiased estimate\n\n    return aggSummary;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty())\n    {\n        return null;\n    }\n    double sum = 0, sumsq = 0, sumLog = 0, max = Double.NEGATIVE_INFINITY, min = Double.POSITIVE_INFINITY, sumsqLog = 0;\n    long n = 0;\n    for (SummaryStatistics stat : statistics)\n    {\n        n += stat.getN();\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        sumLog += stat.getSumOfLogs();\n        sumsqLog += stat.getSumsqLog();\n        if (stat.getMax() > max)\n        {\n            max = stat.getMax();\n        }\n        if (stat.getMin() < min)\n        {\n            min = stat.getMin();\n        }\n    }\n    double mean = (n == 0) ? 0 : sum / n;\n    double variance = (n == 0) ? 0 : (sumsq / n) - (mean * mean);\n    double stddev = (n == 0) ? 0 : Math.sqrt(variance);\n    double gmean = (n == 0) ? 0 : Math.pow(sum / n, 1.0 / n);\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2);\n    }\n    double sumSquaredDifferences = 0;\n    for (int i = 0; i < n; i++) {\n        double difference = sample1[i] - sample2[i] - meanDifference;\n        sumSquaredDifferences += difference * difference;\n    }\n    return sumSquaredDifferences / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double d = sample1[i] - sample2[i] - meanDifference;\n        result += d * d;\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2);\n    }\n    double sumSquaredDifferences = 0;\n    for (int i = 0; i < n; i++) {\n        double difference = sample1[i] - sample2[i] - meanDifference;\n        sumSquaredDifferences += difference * difference;\n    }\n    return sumSquaredDifferences / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2);\n    }\n    double sumSquaredDifferences = 0;\n    for (int i = 0; i < n; i++) {\n        double difference = sample1[i] - sample2[i] - meanDifference;\n        sumSquaredDifferences += difference * difference;\n    }\n    return sumSquaredDifferences / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2);\n    }\n    double sumSquaredDifferences = 0;\n    for (int i = 0; i < n; i++) {\n        double difference = sample1[i] - sample2[i] - meanDifference;\n        sumSquaredDifferences += difference * difference;\n    }\n    return sumSquaredDifferences / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2);\n    }\n    double sumSquaredDifferences = 0;\n    for (int i = 0; i < n; i++) {\n        double difference = sample1[i] - sample2[i] - meanDifference;\n        sumSquaredDifferences += difference * difference;\n    }\n    return sumSquaredDifferences / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION);\n    }\n    double sumSquaredDifferences = StatUtils.sumSq(sample1, sample2, meanDifference);\n    return sumSquaredDifferences / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2);\n    }\n    double variance = 0;\n    for (int i = 0; i < n; i++) {\n        double difference = sample1[i] - sample2[i] - meanDifference;\n        variance += difference * difference;\n    }\n    return variance / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n    }\n    return result / (n - 1);\n}"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double total = 0.0;\n    for (Comparable key : dataset.getKeys()) {\n        Number value = dataset.getValue(key);\n        if (value != null && value.doubleValue() >= 0.0) {\n            total = total + value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double total = 0.0;\n    for (Comparable key : dataset.getKeys()) {\n        Number value = dataset.getValue(key);\n        if (value != null) {\n            double doubleValue = value.doubleValue();\n            if (doubleValue >= 0.0) {\n                total = total + doubleValue;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double result = 0.0;\n    for (Comparable key : dataset.getKeys()) {\n        Number number = dataset.getValue(key);\n        if (number != null) {\n            double value = number.doubleValue();\n            if (value >= 0.0) {\n                result = result + value;\n            }\n        }\n    }\n    return result;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double result = 0.0;\n    int seriesCount = dataset.getSeriesCount();\n    for (int series = 0; series < seriesCount; series++) {\n        Comparable seriesKey = dataset.getSeriesKey(series);\n        Number number = dataset.getYValue(series, 0);\n        if (number != null) {\n            double value = number.doubleValue();\n            if (value >= 0.0) {\n                result = result + value;\n            }\n        }\n    }\n    return result;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double result = 0.0;\n    int count = dataset.getSeriesCount();\n    for (int series = 0; series < count; series++) {\n        Comparable key = dataset.getSeriesKey(series);\n        Number value = dataset.getValue(key);\n        if (value != null && value.doubleValue() > 0.0) {\n            result += value.doubleValue();\n        }\n    }\n    return result;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double result = 0.0;\n    int seriesCount = dataset.getSeriesCount();\n    for (int series = 0; series < seriesCount; series++) {\n        Comparable seriesKey = dataset.getSeriesKey(series);\n        Number number = dataset.getYValue(series, 0);\n        if (number != null && number.doubleValue() >= 0.0) {\n            result += number.doubleValue();\n        }\n    }\n    return result;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    List<Comparable> keys = dataset.getKeys();\n    for (Comparable key : keys) {\n        Number value = dataset.getValue(key);\n        if (value != null && value.doubleValue() >= 0) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    for (Comparable key : dataset.getKeys()) {\n        Number number = dataset.getValue(key);\n        if (number != null) {\n            double value = number.doubleValue();\n            if (value >= 0.0) {\n                total = total + value;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double result = 0.0;\n    for (Comparable key : dataset.getKeys()) {\n        Number number = dataset.getValue(key);\n        if (number != null && number.doubleValue() >= 0.0) {\n            result += number.doubleValue();\n        }\n    }\n    return result;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double total = 0.0;\n    int itemCount = dataset.getSeriesCount();\n    for (int item = 0; item < itemCount; item++) {\n        Number number = dataset.getYValue(item);\n        if (number != null && number.doubleValue() >= 0.0) {\n            total += number.doubleValue();\n        }\n    }\n\n    return total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n    if (peeked == PEEKED_NONE) {\n        doPeek();\n    }\n    if (peeked == PEEKED_SINGLE_QUOTED_NAME) {\n        peekedString = nextQuotedValue('\\'');\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n    } else if (peeked == PEEKED_DOUBLE_QUOTED_NAME) {\n        peekedString = nextQuotedValue('\"');\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n    } else if (peeked == PEEKED_UNQUOTED_NAME) {\n        peekedString = nextUnquotedValue();\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n    } else {\n        throw new IOException(\"Expected name\");\n    }\n    return peekedString;\n}",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE)\n    p = doPeek();\n\n  if (p == PEEKED_SINGLE_QUOTED_NAME)\n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return peekedString;\n  }\n  else if (p == PEEKED_DOUBLE_QUOTED_NAME)\n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return peekedString;\n  }\n  else if (p == PEEKED_UNQUOTED_NAME)\n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return nextUnquotedValue();\n  }\n  else\n  {\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE)\n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME)\n    {\n        peekedString = nextQuotedValue('\\'');\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    else if (p == PEEKED_DOUBLE_QUOTED_NAME)\n    {\n        peekedString = nextQuotedValue('\"');\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    else if (p == PEEKED_UNQUOTED_NAME)\n    {\n        peekedString = nextUnquotedValue();\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    else\n    {\n        throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n}",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE)\n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_UNQUOTED_NAME)\n  {\n    String result;\n    if (p == PEEKED_SINGLE_QUOTED_NAME)\n    {\n      result = nextQuotedValue('\\'');\n    }\n    else if (p == PEEKED_DOUBLE_QUOTED_NAME)\n    {\n      result = nextQuotedValue('\"');\n    }\n    else\n    {\n      result = nextUnquotedValue();\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n  if (p == PEEKED_LONG)\n  {\n    peekedLong = Long.parseLong(peekedString);\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return peekedString;\n  }\n  throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n}",
      "public String nextName() throws IOException  {\n    if (peeked == PEEKED_NONE) {\n      doPeek();\n    }\n    if (peeked == PEEKED_SINGLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return new String(buffer, pos, peekedNumberLength);\n    } else if (peeked == PEEKED_DOUBLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return new String(buffer, pos, peekedNumberLength);\n    } else if (peeked == PEEKED_UNQUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return nextUnquotedValue();\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n}",
      "public String nextName() throws IOException  {\n    if (peeked == PEEKED_NONE) {\n      doPeek();\n    }\n    if (peeked == PEEKED_SINGLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    } else if (peeked == PEEKED_DOUBLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    } else if (peeked == PEEKED_UNQUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    } else {\n      throw new IOException(\"Expected a name but was \" + peek() + locationString());\n    }\n}",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n\n  if (p == PEEKED_SINGLE_QUOTED_NAME) \n  {\n    peekedString = nextQuotedValue('\\'');\n    peeked = PEEKED_NONE;\n  }\n  else if (p == PEEKED_DOUBLE_QUOTED_NAME) \n  {\n    peekedString = nextQuotedValue('\"');\n    peeked = PEEKED_NONE;\n  }\n  else if (p == PEEKED_UNQUOTED_NAME)\n  {\n    peekedString = nextUnquotedValue();\n    peeked = PEEKED_NONE;\n  }\n  else if (p == PEEKED_BUFFERED) \n  {\n    peekedString = peekedString;\n  }\n  else \n  {\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }\n  pathIndices[stackSize - 1]++;\n  return peekedString;\n}",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE)\n    p = doPeek();\n\n  if (p == PEEKED_SINGLE_QUOTED_NAME)\n    return nextQuotedValue('\\'');\n  else if (p == PEEKED_DOUBLE_QUOTED_NAME)\n    return nextQuotedValue('\"');\n  else if (p == PEEKED_UNQUOTED_NAME)\n    return nextUnquotedValue();\n  else\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n}",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_SINGLE_QUOTED_NAME) \n  {\n    result = nextQuotedValue('\\'');\n  } \n  else if (p == PEEKED_DOUBLE_QUOTED_NAME)\n  {\n    result = nextQuotedValue('\"');\n  } \n  else if (p == PEEKED_UNQUOTED_NAME)\n  {\n    result = nextUnquotedValue();\n  } \n  else if (p == PEEKED_BUFFERED)\n  {\n    result = peekedString;\n    peekedString = null;\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE)\n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_UNQUOTED_NAME)\n    {\n        String result;\n        if (p == PEEKED_SINGLE_QUOTED_NAME)\n        {\n            result = nextQuotedValue('\\'');\n        }\n        else if (p == PEEKED_DOUBLE_QUOTED_NAME)\n        {\n            result = nextQuotedValue('\"');\n        }\n        else\n        {\n            result = nextUnquotedValue();\n        }\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n    else\n    {\n        throw new IllegalStateException(\"Expected a property name but was \" + peek() + locationString());\n    }\n}"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null)\n        return null;\n    if (array.length == 0)\n        return EMPTY_INT_ARRAY;\n    int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++)\n        result[i] = (array[i] == null ? valueForNull : array[i].intValue());\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null)\n        return null;\n    else if (array.length == 0)\n        return EMPTY_INT_ARRAY;\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++)\n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null)\n        return null;\n    else if (array.length == 0)\n        return EMPTY_INT_ARRAY;\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++)\n        result[i] = array[i] == null ? valueForNull : array[i].intValue();\n    return result;\n}"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        if (inUncompressedChunk) {\n            if (uncompressedBytesRemaining <= 0) {\n                return -1;\n            }\n            final int bytesToRead = Math.min((int) Math.min(len, bytesRemaining),\n                    in.available());\n            final int bytesRead = IOUtils.readFully(in, b, off, bytesToRead);\n            count(bytesRead);\n            if (bytesRead > 0) {\n                uncompressedBytesRemaining -= bytesRead;\n            }\n            return bytesRead;\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (currentCompressedChunk != null) \n        {\n            int read = currentCompressedChunk.read(b, off, len);\n            if (read == -1) \n            {\n                currentCompressedChunk.close();\n                currentCompressedChunk = null;\n                readNextBlock();\n                if (endReached) \n                {\n                    read = -1;\n                } else \n                {\n                    read = currentCompressedChunk.read(b, off, len);\n                }\n            }\n            return read;\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            final int bytesLeftInBlock = Math.min(uncompressedBytesRemaining, len);\n            final int bytesRead = in.read(b, off, bytesLeftInBlock);\n            if (bytesRead == -1) {\n                throw new IOException(\"Unexpected EOF in compressed stream.\");\n            }\n            uncompressedBytesRemaining -= bytesRead;\n            return bytesRead;\n        } else if (currentCompressedChunk != null) {\n            final int bytesRead = currentCompressedChunk.read(b, off, len);\n            if (bytesRead == -1) {\n                currentCompressedChunk.close();\n                currentCompressedChunk = null;\n                readNextBlock();\n                if (endReached) {\n                    return -1;\n                }\n                return readOnce(b, off, len);\n            }\n            return bytesRead;\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        final int toRead = Math.min(uncompressedBytesRemaining, len);\n        final int bytesRead = in.read(b, off, toRead);\n        if (bytesRead == -1) {\n            throw new IOException(\"Unexpected end-of-stream reading uncompressed block\");\n        }\n        count(bytesRead);\n        uncompressedBytesRemaining -= bytesRead;\n        readIndex += bytesRead;\n        if (uncompressedBytesRemaining == 0) {\n            inUncompressedChunk = false;\n        }\n        return bytesRead;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) \n    {\n        final int left = Math.min(uncompressedBytesRemaining, len);\n        if (left == 0) \n        {\n            return -1;\n        }\n        System.arraycopy(in.buf, in.index, b, off, left);\n        uncompressedBytesRemaining -= left;\n        in.index += left;\n        return left;\n    }\n    else if (currentCompressedChunk != null) \n    {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        if (inUncompressedChunk) {\n            if (uncompressedBytesRemaining > 0) {\n                final int toRead = Math.min(len, uncompressedBytesRemaining);\n                final int read = in.read(b, off, toRead);\n                count(read);\n                uncompressedBytesRemaining -= read;\n                size += read;\n                return read;\n            }\n            inUncompressedChunk = false;\n        } else {\n            readNextBlock();\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk != null) \n    {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            if (uncompressedBytesRemaining == 0) {\n                return -1;\n            }\n            final int read = Math.min(len, uncompressedBytesRemaining);\n            in.read(b, off, read);\n            uncompressedBytesRemaining -= read;\n            return read;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            int bytesLeft = uncompressedBytesRemaining;\n            if (bytesLeft <= 0) {\n                return -1;\n            }\n            if (len >= bytesLeft) {\n                System.arraycopy(in.readBytes(bytesLeft), 0, b, off, bytesLeft);\n                uncompressedBytesRemaining = 0;\n                inUncompressedChunk = false;\n                return bytesLeft;\n            }\n            System.arraycopy(in.readBytes(len), 0, b, off, len);\n            uncompressedBytesRemaining -= len;\n            return len;\n        } else {\n            if (currentCompressedChunk != null) {\n                return currentCompressedChunk.read(b, off, len);\n            } else {\n                return -1;\n            }\n        }\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            final int read = Math.min(uncompressedBytesRemaining, len);\n            if (read <= 0) {\n                return -1;\n            }\n            inUncompressedChunk = false;\n            return IOUtils.readFully(in, b, off, read);\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node arg = getArgumentForCallOrNew(site, argIndex);\n    if (arg == null) {\n        return arg;\n    }\n    Node parent = site.node.getParent();\n    if (parent.isDotCall() && parent.getFirstChild() == site.node) {\n        arg = parent;\n    }\n    return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node arg = getArgumentForCallOrNew(site, argIndex);\n  if (arg != null) {\n    return arg;\n  }\n  if (site.scope == null) {\n    return null;\n  }\n  Node parent = site.scope.getParent();\n  while (parent != null) {\n    if (parent.isCall() || parent.isNew()) {\n      arg = getArgumentForCallOrNew(parent, argIndex);\n      if (arg != null) {\n        return arg;\n      }\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node arg = null;\n  Node firstChild = site.node.getFirstChild();\n  if (site.node.isCall()\n      && firstChild.getNext() != null\n      && firstChild.getNext().isCall()) {\n    arg = NodeUtil.getArgumentForCallOrNew(firstChild.getNext(), argIndex);\n  } else if (site.node.isCall() && firstChild.getNext() != null) {\n    arg = NodeUtil.getArgumentForCallOrNew(site.node.getFirstChild().getNext(),\n        argIndex);\n  } else if (site.node.isGet()) {\n    arg = NodeUtil.getArgumentForCallOrNew(site.node.getLastChild(),\n        argIndex);\n  }\n  return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node arg = null;\n  Node node = site.node;\n  if (NodeUtil.isCallOrNew(node)) {\n    arg = NodeUtil.getArgumentForCallOrNew(node, argIndex);\n  } else if (node.isDotCall()) {\n    arg = NodeUtil.getArgumentForDotCall(node, argIndex);\n  }\n  if (arg == null) {\n    throw new IllegalStateException(\n        \"Unexpected expression node\" + argIndex +\n        \"\\n parent:\" + site.node.getParent());\n  }\n  return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node arg = null;\n  if (site.node.isCall()) {\n    arg = getNthSibling(site.node.getFirstChild().getNext(), argIndex);\n  } else if (site.node.isGet()) {\n    arg = site.node.getLastChild();\n  } else if (site.node.isDot()) {\n    arg = site.node.getSecondChild();\n  } else {\n    // This should be unreachable.\n    throw new IllegalStateException(\n        \"Unexpected expression node\" + site.node +\n        \"\\n parent:\" + site.node.getParent());\n  }\n  return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  if (site.node.isCall()) {\n    return NodeUtil.getArgumentForCallOrNew(site.node, argIndex);\n  } else if (site.node.isDotCall()) {\n    Node expr = site.node.getFirstChild();\n    Node varName = expr.getLastChild();\n    if (varName.isName()) {\n      Reference ref = new Reference(site.node, site.node);\n      ref.setModule(site.module);\n      return NodeUtil.getArgumentForCallOrNew(site.node, argIndex, ref);\n    }\n  } else if (site.node.isGet()) {\n    Node expr = site.node.getFirstChild();\n    Node varName = expr.getLastChild();\n    if (varName.isName()) {\n      Reference ref = new Reference(site.node, site.node);\n      ref.setModule(site.module);\n      return NodeUtil.getArgumentForCallOrNew(site.node, argIndex, ref);\n    }\n  }\n  return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node arg = getArgumentForCallOrNew(site.node, argIndex);\n  if (arg == null) {\n    if (site.node.isDotCall()) {\n      Node left = site.node.getFirstChild();\n      Node right = site.node.getLastChild();\n      if (left.isName() && right.isString()) {\n        String name = left.getString();\n        for (Node child = site.module.getGlobalScope().getScope(name).getFirstChild();\n             child != null;\n             child = child.getNext()) {\n          if (NodeUtil.isVariable(child)) {\n            return eliminateVariable(site, child);\n          }\n        }\n      }\n    }\n  }\n  return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n  Node arg = getArgumentForCallOrNew(site.node, argIndex);\n  if (arg != null) {\n    return arg;\n  }\n\n  Node callOrDotExpr = site.node;\n  if (callOrDotExpr.isCall()) {\n    return getArgumentForCallOrNew(callOrDotExpr, argIndex);\n  } else if (callOrDotExpr.isDot()) {\n    Node target = callOrDotExpr.getFirstChild();\n    if (isCallOrNewTarget(target)) {\n      Node argIndexNode = getArgumentForCallOrNew(\n          target.getParent(), argIndex - 1);\n      if (argIndexNode != null) {\n        return argIndexNode;\n      }\n    }\n  }\n  return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site.node.isCall()) {\n        return NodeUtil.getArgumentForCallOrNew(site.node, argIndex);\n    } else if (site.node.isGetProp() || site.node.isGetElem()) {\n        Node base = site.node.getFirstChild();\n        if (base.isCall()) {\n            return NodeUtil.getArgumentForCallOrNew(base, argIndex);\n        } else {\n            return site.node;\n        }\n    } else {\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + site.node +\n            \"\\n parent:\" + site.node.getParent());\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site.node.isCall()) {\n      return getArgumentForCallOrNew(site.node, argIndex);\n    }\n    if (site.node.isGet()) {\n      Node target = site.node.getLastChild();\n      if (target.isString() && \"arguments\".equals(target.getString())) {\n        return getArgumentForCallOrNew(site.node.getParent(), argIndex);\n      }\n    }\n    if (site.node.isDot()) {\n      Node receiver = site.node.getFirstChild();\n      if (receiver.isName()) {\n        String name = receiver.getString();\n        if (\"arguments\".equals(name)) {\n          return getArgumentForCallOrNew(site.node.getParent(), argIndex);\n        } else {\n          return null;\n        }\n      }\n    }\n    return null;\n}"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n      return null;\n    }\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    if (type.getImplicitPrototype() != null) {\n      return getTypeDeprecationInfo(type.getImplicitPrototype());\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n\n    return \"\";\n  }\n  if (type.isUnionType() || type.isTemplateType() || type.isTemplate()) {\n    return getTypeDeprecationInfo(type.toMaybeUnionType().getTypesUnderEquality(type).typeA);\n  }\n  if (type.isNamedType()) {\n    JSDocInfo typeDocInfo = ((ObjectType) type).getJSDocInfo();\n    if (typeDocInfo != null && typeDocInfo.isDeprecated()) {\n      if (typeDocInfo.getDeprecationReason() != null) {\n        return typeDocInfo.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n  }\n  if (type.isAnyType() || type.isUnknownType() || type.isNullable()) {\n    return null;\n  }\n  if (type.isVoidType()) {\n    return \"Void type should not be used as a property type\";\n  }\n  if (type.isNumberType()) {\n    return \"Number type should not be used as a property type\";\n  }\n  if (type.isBooleanType()) {\n    return \"Boolean type should not be used as a property type\";\n  }\n  if (type.isStringType()) {\n    return \"String type should not be used as a property type\";\n  }\n  if (type.isArrayType()) {\n    return \"Array type should not be used as a property type\";\n  }\n  if (type.isRegExpType()) {\n    return \"RegExp type should not be used as a property type\";\n  }\n  if (type.isDateType()) {\n    return \"Date type should not be used as a property type\";\n  }\n  if (type.isRecordType()) {\n    return \"Record type should not be used as a property type\";\n  }\n  if (type.isEnumElementType()) {\n    return \"Enum element type should not be used as a property type\";\n  }\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n\n    return \"\";\n  }\n  if (type.isNominalType()) {\n    ObjectType objectType = type.toObjectType();\n    if (objectType.isClass()) {\n      return getTypeDeprecationInfo(objectType.getImplicitPrototype());\n    }\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) {\n    return null;\n  }\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n\n    return \"\";\n  }\n\n  if (type.getNativeType(JSTypeNative.OBJECT) != null) {\n    return \"\";\n  }\n\n  if (type.isUnknownType() || type.isAllType()) {\n    return \"\";\n  }\n\n  if (type.isUnionType() && type.toMaybeUnionType().getTypes().size() > 1) {\n    return \"\";\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    return null;\n}\n\nboolean setDeprecationReason(String reason) \n{\n    lazyInitInfo();\n\n    if (info.deprecated != null) {\n        return false;\n    }\n\n    info.deprecated = reason;\n    return true;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n      return null;\n    }\n\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (!type.isClassOrEnum()) {\n    return null;\n  }\n\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n\n    return \"\";\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) {\n    return null;\n  }\n\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n\n    return \"\";\n  }\n\n  if (type.hasReferenceName() && type.getImplicitPrototype() != null) {\n    return getTypeDeprecationInfo(type.getImplicitPrototype());\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) \n  {\n    if (info.getDeprecationReason() != null) \n    {\n      return info.getDeprecationReason();\n    }\n    return \"\";\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n      return null;\n    }\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    if (type.getImplicitPrototype() != null) {\n      return getTypeDeprecationInfo(type.getImplicitPrototype());\n    }\n    return null;\n}"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result != null) {\n        return result;\n    }\n\n    synchronized (cTimeZoneDisplayCache) {\n        // Double-checked locking to avoid unnecessary locking\n        result = cTimeZoneDisplayCache.get(key);\n        if (result != null) {\n            return result;\n        }\n\n        result = tz.getDisplayName(daylight, style, locale);\n        if (result != null) {\n            cTimeZoneDisplayCache.put(key, result);\n        }\n    }\n\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        synchronized (cTimeZoneDisplayCache) {\n            result = cTimeZoneDisplayCache.get(key);\n            if (result == null) {\n                result = tz.getDisplayName(daylight, style, locale);\n                cTimeZoneDisplayCache.put(key, result);\n            }\n        }\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result != null) {\n        return result;\n    }\n\n    if (locale != null) {\n        // Use the localized display name\n        result = tz.getDisplayName(daylight, style, locale);\n    } else {\n        // Use the default display name\n        result = tz.getDisplayName(daylight, style);\n    }\n\n    cTimeZoneDisplayCache.putIfAbsent(key, result);\n\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result != null) {\n        return result;\n    }\n    if (locale == null) {\n        locale = Locale.getDefault();\n    }\n    StringBuffer buffer = new StringBuffer();\n    tz.getDisplayName(daylight, style, locale, buffer);\n    result = buffer.toString();\n    cTimeZoneDisplayCache.put(key, result);\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result != null) {\n        return result;\n    }\n\n    String display;\n    if (locale == null) {\n        locale = Locale.getDefault();\n    }\n\n    if (tz == TimeZone.getDefault()) {\n        display = SystemUtils.USER_TIMEZONE;\n    } else {\n        display = TzDateConverter.getLocalizedTimeZone(tz, daylight, style, locale);\n    }\n\n    if (display == null) {\n        display = tz.getDisplayName(daylight, style, locale);\n    }\n\n    if (display.isEmpty()) {\n        display = \"GMT\" + TzDateConverter.getTimeZoneOffset(tz, daylight, false);\n    } else {\n        display = display.replace(\"GMT\", \"GMT\");\n        display = display.replace(\"UTC\", \"UTC\");\n    }\n    \n    cTimeZoneDisplayCache.putIfAbsent(key, display);\n    return display;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result != null) {\n        return result;\n    }\n    synchronized (cTimeZoneDisplayCache) {\n        result = cTimeZoneDisplayCache.get(key);\n        if (result != null) {\n            return result;\n        }\n        result = getTimeZoneDisplayName(tz, daylight, style, locale);\n        if (result.isEmpty()) {\n            result = tz.getID();\n        }\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result != null) {\n        return result;\n    }\n\n    synchronized (cTimeZoneDisplayCache) {\n        if ((result = cTimeZoneDisplayCache.get(key)) == null) {\n            String standardName = tz.getDisplayName(false, style, locale);\n            String daylightName = tz.getDisplayName(true, style, locale);\n            result = daylight ? daylightName : standardName;\n            cTimeZoneDisplayCache.put(key, result);\n        }\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        synchronized (cTimeZoneDisplayCache) {\n            result = cTimeZoneDisplayCache.get(key);\n            if (result == null) {\n                result = tz.getDisplayName(daylight, style, locale);\n                cTimeZoneDisplayCache.put(key, result);\n            }\n        }\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result != null) {\n        return result;\n    }\n    if (locale != null) {\n        result = tz.getDisplayName(daylight, style, locale);\n    } else {\n        result = tz.getDisplayName(daylight, style);\n    }\n    cTimeZoneDisplayCache.put(key, result);\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result != null) {\n        return result;\n    }\n\n    String result2;\n    if (locale == null) {\n        result2 = tz.getDisplayName(daylight, style);\n    } else {\n        result2 = tz.getDisplayName(daylight, style, locale);\n    }\n\n    cTimeZoneDisplayCache.putIfAbsent(key, result2);\n    return result2;\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    return getUnderlyingDataset().getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return getUnderlyingDataset().getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return getUnderlyingDataset().getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return getUnderlyingDataset().getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return getUnderlyingDataset().getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return getUnderlyingDataset().getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return getUnderlyingDataset().getColumnIndex(key);\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n    if(point>=lower && point<=upper)\n        return Location.INSIDE;\n    else if(Math.abs(point-lower)<=tolerance)\n        return Location.BOUNDARY;\n    else if(Math.abs(point-upper)<=tolerance)\n        return Location.BOUNDARY;\n    else\n        return Location.OUTSIDE;\n    \n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n\tif(point >= lower && point <= upper)\n\t{\n\t\treturn Location.INSIDE;\n\t}\n\telse if(point < lower && point + tolerance < lower)\n\t{\n\t\treturn Location.OUTSIDE;\n\t}\n\telse if(point > upper && point - tolerance > upper)\n\t{\n\t\treturn Location.OUTSIDE;\n\t}\n\telse\n\t{\n\t\treturn Location.BOUNDARY;\n\t}\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if(point >= lower - tolerance && point <= upper + tolerance)\n    {\n        return Location.INSIDE;\n    }\n    else if(point < lower - tolerance)\n    {\n        return Location.OUTSIDE;\n    }\n    else\n    {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point >= lower - tolerance && point <= upper + tolerance)\n    {\n        return Location.INSIDE;\n    }\n    else if (point < lower - tolerance)\n    {\n        return Location.OUTSIDE;\n    }\n    else\n    {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n\tif (this.lower + tolerance > point && point > this.upper - tolerance) {\n\t\treturn Location.BOUNDARY;\n\t} else if (this.lower <= point && point <= this.upper) {\n\t\treturn Location.INSIDE;\n\t} else {\n\t\treturn Location.OUTSIDE;\n\t}\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point > lower + tolerance && point < upper - tolerance)\n    {\n        return Location.INSIDE;\n    }\n    else if (point < lower - tolerance || point > upper + tolerance)\n    {\n        return Location.OUTSIDE;\n    }\n    else\n    {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point <= lower)\n        {\n            return Location.OUTSIDE;\n        }\n        if (point >= upper)\n        {\n            return Location.OUTSIDE;\n        }\n        if (point <= lower + tolerance)\n        {\n            return Location.BOUNDARY;\n        }\n        if (point >= upper - tolerance)\n        {\n            return Location.BOUNDARY;\n        }\n        return Location.INSIDE;\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point >= lower && point <= upper) \n        {\n            return Location.INSIDE;\n        } \n        else if (point < lower && (lower - point) <= tolerance) \n        {\n            return Location.BOUNDARY;\n        } \n        else if (point > upper && (point - upper) <= tolerance) \n        {\n            return Location.BOUNDARY;\n        } \n        else \n        {\n            return Location.OUTSIDE;\n        }\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n\tif (point >= lower - tolerance && point <= upper + tolerance) {\n\t\treturn Location.INSIDE;\n\t} else if (point < lower - tolerance) {\n\t\treturn Location.OUTSIDE;\n\t} else {\n\t\treturn Location.BOUNDARY;\n\t}\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (lower + tolerance > point && point > upper - tolerance)\n        {\n            return Location.BOUNDARY;\n        }\n        else if (lower + tolerance > point)\n        {\n            return Location.OUTSIDE;\n        }\n        else\n        {\n            return Location.INSIDE;\n        }\n}"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n\tTickUnits units = new TickUnits();\n\tNumberFormat numberFormat = NumberFormat.getInstance(locale);\n\n\tunits.add(new NumberTickUnit(0.0001, numberFormat, 2));\n\tunits.add(new NumberTickUnit(0.001, numberFormat, 2));\n\tunits.add(new NumberTickUnit(0.01, numberFormat, 2));\n\tunits.add(new NumberTickUnit(0.1, numberFormat, 2));\n\tunits.add(new NumberTickUnit(1, numberFormat, 2));\n\tunits.add(new NumberTickUnit(10, numberFormat, 2));\n\tunits.add(new NumberTickUnit(100, numberFormat, 2));\n\tunits.add(new NumberTickUnit(1000, numberFormat, 2));\n\tunits.add(new NumberTickUnit(10000, numberFormat, 2));\n\tunits.add(new NumberTickUnit(100000, numberFormat, 2));\n\tunits.add(new NumberTickUnit(1000000, numberFormat, 2));\n\tunits.add(new NumberTickUnit(10000000, numberFormat, 2));\n\tunits.add(new NumberTickUnit(100000000, numberFormat, 2));\n\tunits.add(new NumberTickUnit(1000000000, numberFormat, 2));\n\tunits.add(new NumberTickUnit(10000000000.0, numberFormat, 2));\n\treturn units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n\tTickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getInstance(locale);\n    numberFormat.setGroupingUsed(false);\n    units.add(new NumberTickUnit(1E-300, numberFormat, 3));\n    units.add(new NumberTickUnit(1E-270, numberFormat, 3));\n    units.add(new NumberTickUnit(1E-240, numberFormat, 3));\n    units.add(new NumberTickUnit(1E-210, numberFormat, 3));\n    units.add(new NumberTickUnit(1E-180, numberFormat, 3));\n    units.add(new NumberTickUnit(1E-150, numberFormat, 3));\n    units.add(new NumberTickUnit(1E-120, numberFormat, 3));\n    units.add(new NumberTickUnit(1E-90, numberFormat, 3));\n    units.add(new NumberTickUnit(1E-60, numberFormat, 3));\n    units.add(new NumberTickUnit(1E-30, numberFormat, 3));\n    units.add(new NumberTickUnit(1E-20, numberFormat, 3));\n    units.add(new NumberTickUnit(1E-10, numberFormat, 3));\n    units.add(new NumberTickUnit(1E0, numberFormat, 2));\n    units.add(new NumberTickUnit(1E10, numberFormat, 2));\n    units.add(new NumberTickUnit(1E20, numberFormat, 2));\n    units.add(new NumberTickUnit(1E30, numberFormat, 2));\n    units.add(new NumberTickUnit(1E40, numberFormat, 2));\n    units.add(new NumberTickUnit(1E50, numberFormat, 2));\n    units.add(new NumberTickUnit(1E60, numberFormat, 2));\n    units.add(new NumberTickUnit(1E70, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000000.0, numberFormat, 2));\n    \n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n\tTickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n\tTickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1E-7, numberFormat, 2));\n    units.add(new NumberTickUnit(1E-6, numberFormat, 2));\n    units.add(new NumberTickUnit(1E-5, numberFormat, 5));\n    units.add(new NumberTickUnit(1E-4, numberFormat, 2));\n    units.add(new NumberTickUnit(1E-3, numberFormat, 5));\n    units.add(new NumberTickUnit(1E-2, numberFormat, 2));\n    units.add(new NumberTickUnit(1E-1, numberFormat, 5));\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1E9, numberFormat, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n\tTickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getInstance(locale);\n    numberFormat.setMaximumFractionDigits(1);\n    units.add(new NumberTickUnit(1000000000000000000L, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000000000000L/10, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000000000000L/100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000000000000L/1000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000000000000L/10000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000000000000L/100000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000000000000L/1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000000000000L/10000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000000000000L/100000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000000000000L/1000000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(Math.pow(10, -8), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, -7), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, -6), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, -5), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, -4), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, -3), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, -2), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, -1), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 0), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 1), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 2), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 3), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 4), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 5), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 6), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 7), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 8), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 9), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 10), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 11), numberFormat));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(Math.pow(10, -6), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, -5), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, -4), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, -3), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, -2), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, -1), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 0), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 1), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 2), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 3), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 4), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 5), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 6), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 7), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 8), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 9), numberFormat, 2));\n    units.add(new NumberTickUnit(Math.pow(10, 10), numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1E-24, numberFormat, 2));\n    units.add(new NumberTickUnit(1E-21, numberFormat, 2));\n    units.add(new NumberTickUnit(1E-18, numberFormat, 2));\n    units.add(new NumberTickUnit(1E-15, numberFormat, 2));\n    units.add(new NumberTickUnit(1E-12, numberFormat, 2));\n    units.add(new NumberTickUnit(1E-9, numberFormat, 2));\n    units.add(new NumberTickUnit(1E-6, numberFormat, 2));\n    units.add(new NumberTickUnit(1E-3, numberFormat, 2));\n    units.add(new NumberTickUnit(1E0, numberFormat, 2));\n    units.add(new NumberTickUnit(1E3, numberFormat, 2));\n    units.add(new NumberTickUnit(1E6, numberFormat, 2));\n    units.add(new NumberTickUnit(1E9, numberFormat, 2));\n    units.add(new NumberTickUnit(1E12, numberFormat, 2));\n    units.add(new NumberTickUnit(1E15, numberFormat, 2));\n    units.add(new NumberTickUnit(1E18, numberFormat, 2));\n    units.add(new NumberTickUnit(1E21, numberFormat, 2));\n    units.add(new NumberTickUnit(1E24, numberFormat, 2));\n    units.add(new NumberTickUnit(1E27, numberFormat, 2));\n    units.add(new NumberTickUnit(1E30, numberFormat, 2));\n    units.add(new NumberTickUnit(1E33, numberFormat, 2));\n    units.add(new NumberTickUnit(1E36, numberFormat, 2));\n    units.add(new NumberTickUnit(1E39, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(Math.pow(10, -8), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, -7), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, -6), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, -5), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, -4), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, -3), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, -2), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, -1), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 0), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 1), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 2), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 3), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 4), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 5), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 6), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 7), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 8), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 9), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 10), numberFormat));\n    units.add(new NumberTickUnit(Math.pow(10, 11), numberFormat));\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minVal = Double.MAX_VALUE;\n    Integer pivotCol = null;\n    for (int col = 0; col < tableau.getWidth() - 1; col++) {\n        final double value = tableau.getEntry(0, col);\n        if (Precision.compareTo(value, 0d, maxUlps) < 0 && Precision.compareTo(minVal, value, maxUlps) > 0) {\n            minVal = value;\n            pivotCol = col;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // Create a list of all the columns that tie for the lowest score in the minimum ratio test (MRT)\n    List<Integer> minRatioPositions = new ArrayList<>();\n    double minRatio = Double.MAX_VALUE;\n    for (int col = 0; col < tableau.getWidth() - 1; col++) \n    {\n        final double entry = tableau.getEntry(tableau.getNumObjectiveFunctions(), col);\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) \n        {\n            final double ratio = getInvertedCoefficientSum(tableau.getTableau().getRowVector(col));\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) \n            {\n                minRatioPositions.add(col);\n            } \n            else if (cmp < 0) \n            {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<>();\n                minRatioPositions.add(col);\n            }\n        }\n    }\n    if (minRatioPositions.size() == 0) \n    {\n        return null;\n    } \n    else if (minRatioPositions.size() > 1) \n    {\n        // There's a degeneracy as indicated by a tie in the minimum ratio test\n        for (int col : minRatioPositions) \n        {\n            final double rhs = tableau.getEntry(tableau.getNumObjectiveFunctions(), tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(tableau.getNumObjectiveFunctions(), col);\n            if (Precision.compareTo(rhs / entry, minRatio, maxUlps) < 0) \n            {\n                return col;\n            }\n        }\n    }\n    return minRatioPositions.get(0);\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = -1;\n    double maxNegativeCoeff = Double.NEGATIVE_INFINITY;\n\n    for (int col = tableau.getNumObjectiveFunctions(); col < tableau.getWidth() - 1; col++) {\n        double coeffSum = tableau.getEntry(tableau.getNumObjectiveFunctions(), col);\n        for (int row = tableau.getNumObjectiveFunctions() + tableau.getNumSlackVariables(); row < tableau.getHeight(); row++) {\n            coeffSum += tableau.getEntry(row, col);\n        }\n\n        if (maxNegativeCoeff < coeffSum) {\n            maxNegativeCoeff = coeffSum;\n            pivotCol = col;\n        }\n    }\n\n    if (maxNegativeCoeff >= 0) {\n        return null; // No negative coefficients in the objective function row\n    }\n\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = 0;\n    double minCoeff = Double.MAX_VALUE;\n\n    // iterate over the columns in the objective function row\n    for (int col = tableau.getNumObjectiveFunctions(); col < tableau.getWidth(); col++) {\n        double coeff = tableau.getEntry(0, col);\n\n        // check for the column with the most negative coefficient\n        if (coeff < minCoeff) {\n            minCoeff = coeff;\n            pivotCol = col;\n        }\n    }\n\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = 0;\n    double minCoeff = Double.MAX_VALUE;\n    for (int col = 0; col < tableau.getWidth() - 1; col++) {\n        double coeff = tableau.getEntry(0, col); // assuming the first row is the objective function row\n        if (Precision.compareTo(coeff, minCoeff, maxUlps) < 0) {\n            minCoeff = coeff;\n            pivotCol = col;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minVal = Double.MAX_VALUE;\n    Integer pivotCol = null;\n    for (int col = 0; col < tableau.getWidth() - 1; col++) {\n        final double value = tableau.getEntry(0, col);\n        if (value < minVal) {\n            minVal = value;\n            pivotCol = col;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = 0;\n    double minVal = Double.MAX_VALUE;\n\n    for (int i = 0; i < tableau.getNumObjectiveFunctions(); i++) {\n        double val = tableau.getEntry(0, i);\n        if (val < minVal) {\n            minVal = val;\n            pivotCol = i;\n        }\n    }\n\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        int pivotCol = -1;\n        double minRatio = Double.MAX_VALUE;\n\n        for (int col = tableau.getNumObjectiveFunctions(); col < tableau.getWidth() - 1; col++) \n        {\n            double sum = 0.0;\n            for (int row = 0; row < tableau.getNumDecisionVariables(); row++) \n            {\n                sum += tableau.getEntry(row, col);\n            }\n\n            if (Precision.compareTo(sum, 0, maxUlps) < 0 && Precision.compareTo(tableau.getEntry(0, col), minRatio, maxUlps) <= 0) \n            {\n                minRatio = tableau.getEntry(0, col);\n                pivotCol = col;\n            }\n        }\n\n        return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        // find the negative coefficients in the objective function row\n        int pivotCol = -1;\n        double minCoeff = Double.MAX_VALUE;\n        for (int i = 0; i < tableau.getWidth() - tableau.getRhsOffset(); i++) \n        {\n            final double coeff = tableau.getEntry(0, i);\n            if (Precision.compareTo(coeff, 0d, maxUlps) < 0) \n            {\n                final int cmp = Double.compare(Math.abs(coeff), Math.abs(minCoeff));\n                if (cmp < 0) \n                {\n                    minCoeff = coeff;\n                    pivotCol = i;\n                }\n            }\n        }\n\n        return pivotCol;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoeff = Double.MAX_VALUE;\n    int pivotCol = -1;\n    for (int col = tableau.getNumObjectiveFunctions(); col < tableau.getWidth(); col++)\n    {\n        double coeff = tableau.getEntry(0, col);\n        if (Precision.compareTo(coeff, minCoeff, maxUlps) < 0)\n        {\n            minCoeff = coeff;\n            pivotCol = col;\n        }\n    }\n    return pivotCol;\n}"
    ]
  ]
}