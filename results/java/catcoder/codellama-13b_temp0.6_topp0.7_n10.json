{
  "benchmark": "javaeval_xc",
  "lastest_eval": {
    "compile@1": 0.7190954773869347,
    "pass@1": 0.44673366834170863,
    "compile@3": 0.8476968174204357,
    "pass@3": 0.5397403685092126,
    "compile@5": 0.8837241764377445,
    "pass@5": 0.5754965302703995
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }"
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    int column = getColumnIndex(columnKey);\n    return getPercentComplete(row, column);\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[r][c] = r == c ? m.getEntry(r, c) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[r][c] = r == c ? m.getEntry(r, c) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getRowDimension() == 1) {\n        return m;\n    } else {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            d[i][i] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int rd = m.getRowDimension();\n    final int cd = m.getColumnDimension();\n    if (rd == cd) {\n        final double[][] d = new double[rd][cd];\n        for (int r = 0; r < rd; r++) {\n            for (int c = 0; c < cd; c++) {\n                d[r][c] = r == c ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final double[] d = new double[rd];\n        for (int r = 0; r < rd; r++) {\n            d[r] = m.getEntry(r, r);\n        }\n        return new ArrayRealVector(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int n = m.getRowDimension();\n    final double[][] d = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        d[i][i] = m.getEntry(i, 0);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int rd = m.getRowDimension();\n    final int cd = m.getColumnDimension();\n    if (rd == cd) {\n        final double[][] d = new double[rd][cd];\n        for (int r = 0; r < rd; r++) {\n            d[r][r] = m.getEntry(r, r);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final double[] d = new double[rd];\n        for (int r = 0; r < rd; r++) {\n            d[r] = m.getEntry(r, r);\n        }\n        return new ArrayRealVector(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int n = m.getRowDimension();\n    final double[][] d = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        d[i][i] = m.getEntry(i, 0);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[r][c] = r == c ? m.getEntry(r, c) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int rd = m.getRowDimension();\n    final int cd = m.getColumnDimension();\n    final double[][] d = new double[rd][cd];\n    for (int r = 0; r < rd; r++) {\n        for (int c = 0; c < cd; c++) {\n            d[r][c] = r == c ? m.getEntry(r, c) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int rd = m.getRowDimension();\n    final int cd = m.getColumnDimension();\n    final double[][] d = new double[rd][cd];\n    for (int r = 0; r < rd; r++) {\n        for (int c = 0; c < cd; c++) {\n            d[r][c] = r == c ? m.getEntry(r, c) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) \n        {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) \n        {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) \n        {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) \n        {\n            return dtz;\n        }\n        // Handle offset\n        int offset = parseOffset(id);\n        if (offset != Integer.MIN_VALUE) \n        {\n            return forOffsetMillis(offset);\n        }\n        throw new IllegalArgumentException(\"Invalid id: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        int offset = parseOffset(id);\n        if (offset != Integer.MIN_VALUE) {\n            return fixedOffsetZone(id, offset);\n        }\n\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // handle offset in form [+-]hh:mm\n        int offset = parseOffset(id);\n        if (offset != Integer.MIN_VALUE) {\n            return fixedOffsetZone(id, offset);\n        }\n\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        int offset = parseOffset(id);\n        if (offset != Integer.MIN_VALUE) {\n            return fixedOffsetZone(id, offset);\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Parse offset\n        int offset = parseOffset(id);\n        if (offset != Integer.MIN_VALUE) {\n            return fixedOffsetZone(id, offset);\n        }\n\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) \n        {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) \n        {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) \n        {\n            return dtz;\n        }\n        dtz = cProvider.getZone(getConvertedId(id));\n        if (dtz != null) \n        {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        if (id.length() <= 3) {\n            throw new IllegalArgumentException(\"Invalid id: \" + id);\n        }\n        int offset = parseOffset(id);\n        if (offset != 0) {\n            return fixedOffsetZone(id, offset);\n        }\n        throw new IllegalArgumentException(\"Invalid id: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        try {\n            return forOffsetMillis(parseOffset(id));\n        } catch (IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Invalid id: \" + id);\n        }\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        // Parse offset\n        int offset = parseOffset(id);\n        if (offset != Integer.MIN_VALUE) {\n            return fixedOffsetZone(id, offset);\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Parse offset\n        int offset = parseOffset(id);\n        if (offset != Integer.MIN_VALUE) {\n            return fixedOffsetZone(id, offset);\n        }\n\n        // Parse zone\n        try {\n            return forTimeZone(TimeZone.getTimeZone(id));\n        } catch (RuntimeException ex) {\n            throw new IllegalArgumentException(\"Invalid ID for DateTimeZone: \" + id);\n        }\n    }"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // range check x\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, this, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // range check x\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // range check x\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for multiply by zero\n        if (x == 0) {\n            return newInstance(getZero());\n        }\n\n        // range check divisor\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        return result;\n\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (x == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        // range check divisor\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        if (rl != 0) {\n            result.shiftLeft();\n            result.mant[0] = rl;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (x == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, MULTIPLY_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        if (rl != 0) {\n            result.shiftLeft();\n            result.mant[mant.length-1] = rl;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // range check divisor\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(x), result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (x == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, MULTIPLY_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (x == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        // range check divisor\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // range check divisor\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(x), result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = rh / RADIX;\n            result.mant[i] = rh - rl * RADIX;\n        }\n\n        return result;\n    }"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n  function.setJSType(exportedFunction.getJSType());\n\n  JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n  JSDocInfo info = exportedFunction.getJSDocInfo();\n  if (info != null) {\n    builder.recordType(info.getType());\n    builder.recordReturnType(info.getReturnType());\n    for (JSTypeExpression param : info.getParameterTypeExpressions()) {\n      builder.recordParameter(param);\n    }\n  } else {\n    compiler.report(JSError.make(exportedFunction,\n        \"Exported function has no type information.\"));\n  }\n\n  function.setJSDocInfo(builder.build());\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(\n      exportedFunction.getFirstChild().cloneNode(),\n      IR.block());\n\n  function.setJSType(exportedFunction.getJSType());\n  function.setJSDocInfo(exportedFunction.getJSDocInfo());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n  function.setJSType(exportedFunction.getJSType());\n\n  JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n  builder.recordType(exportedFunction.getJSType());\n  function.setJSDocInfo(builder.build());\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n  function.setJSType(exportedFunction.getJSType());\n\n  JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n  builder.recordType(exportedFunction.getJSType());\n  function.setJSDocInfo(builder.build());\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n  function.setJSType(exportedFunction.getJSType());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  Node paramList = function.getSecondChild();\n  Node param;\n  Node exportedParam;\n  for (exportedParam = exportedFunction.getSecondChild().getFirstChild();\n       exportedParam != null;\n       exportedParam = exportedParam.getNext()) {\n    param = IR.name(exportedParam.getString());\n    param.setJSType(exportedParam.getJSType());\n    paramList.addChildToBack(param);\n  }\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(\n      exportedFunction.getFirstChild().cloneNode(),\n      IR.block());\n  function.setJSType(exportedFunction.getJSType());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n  function.setJSType(exportedFunction.getJSType());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n  function.setJSType(exportedFunction.getJSType());\n  function.setJSDocInfo(exportedFunction.getJSDocInfo());\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(\n      exportedFunction.getFirstChild().cloneNode(),\n      IR.block());\n\n  function.setJSType(exportedFunction.getJSType());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node externFunction = IR.function(\n      exportedFunction.getFirstChild().cloneNode(),\n      IR.block());\n  externFunction.copyInformationFrom(exportedFunction);\n  externFunction.setJSType(exportedFunction.getJSType());\n  return externFunction;\n}"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covar = computeCovariances(params,\n                                          covarianceSingularityThreshold);\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[] sigma = new double[params.length];\n        RealMatrix covar = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < sigma.length; ++i) {\n            sigma[i] = FastMath.sqrt(covar.getEntry(i, i));\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        // Compute the covariance matrix.\n        final double[][] covar = computeCovariances(params,\n                                                    covarianceSingularityThreshold);\n\n        // Extract the diagonal elements.\n        final int n = covar.length;\n        final double[] sigma = new double[n];\n        for (int i = 0; i < n; ++i) {\n            sigma[i] = FastMath.sqrt(covar[i][i]);\n        }\n\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; ++i) {\n        sigma[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covar = computeCovariances(params,\n                                          covarianceSingularityThreshold);\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[][] covariances = computeCovariances(params, covarianceSingularityThreshold);\n        double[] sigmas = new double[params.length];\n        for (int i = 0; i < params.length; i++) {\n            sigmas[i] = FastMath.sqrt(covariances[i][i]);\n        }\n        return sigmas;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        final RealMatrix covar = computeCovariances(params, covarianceSingularityThreshold);\n        final int n = covar.getColumnDimension();\n        final double[] sigma = new double[n];\n        for (int i = 0; i < n; ++i) {\n            sigma[i] = FastMath.sqrt(covar.getEntry(i, i));\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[][] covariances = computeCovariances(params,\n                                                    covarianceSingularityThreshold);\n        double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; i++) {\n            sigma[i] = FastMath.sqrt(covariances[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[] sigma = new double[params.length];\n        double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < params.length; i++) {\n            sigma[i] = FastMath.sqrt(covar[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[] sigma = new double[params.length];\n        double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < sigma.length; i++) {\n            sigma[i] = FastMath.sqrt(covar[i][i]);\n        }\n        return sigma;\n    }"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"Circular reference to variable \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"Circular reference to variable \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"Circular reference to variable \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) {\n            throw new IllegalStateException(\"Circular reference to variable \" + varName);\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) {\n            throw new IllegalStateException(\"Variable: \" + varName + \" has already been substituted on this pass through the stack. Check for cyclic substitution.\");\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"Circular reference to variable \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution: \" + varName);\n    }\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  Multimap<INPUT, INPUT> deps = HashMultimap.create();\n  for (INPUT input : inputs) {\n    for (String symbol : input.getRequires()) {\n      deps.put(provideMap.get(symbol), input);\n    }\n  }\n  return sorted ? topologicalStableSort(roots, deps) : roots;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = Lists.newArrayList();\n    Set<INPUT> covered = Sets.newHashSet();\n    for (INPUT root : roots) {\n      if (covered.contains(root)) {\n        continue;\n      }\n      result.add(root);\n      covered.add(root);\n      Multimap<INPUT, INPUT> deps = getDependencies();\n      List<INPUT> subGraph = findCycle(root, covered, deps, covered);\n      if (sorted) {\n        subGraph = topologicalStableSort(subGraph, deps);\n      }\n      result.addAll(subGraph);\n    }\n    return result;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  Multimap<INPUT, INPUT> deps = ArrayListMultimap.create();\n  for (INPUT input : inputs) {\n    for (String symbol : input.getRequires()) {\n      deps.put(provideMap.get(symbol), input);\n    }\n  }\n  List<INPUT> subGraph = Lists.newArrayList(roots);\n  List<INPUT> result = Lists.newArrayList();\n  for (INPUT root : roots) {\n    result.addAll(findCycle(root, subGraph, deps, Sets.<INPUT>newHashSet()));\n  }\n  if (sorted) {\n    return topologicalStableSort(result, deps);\n  } else {\n    return result;\n  }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  Multimap<INPUT, INPUT> deps = HashMultimap.create();\n  for (INPUT input : inputs) {\n    for (String symbol : input.getRequires()) {\n      INPUT candidate = provideMap.get(symbol);\n      if (candidate != null) {\n        deps.put(candidate, input);\n      }\n    }\n  }\n  if (sorted) {\n    return topologicalStableSort(roots, deps);\n  } else {\n    List<INPUT> result = Lists.newArrayList();\n    for (INPUT root : roots) {\n      result.add(root);\n      result.addAll(findCycle(root, Sets.<INPUT>newHashSet(), deps, Sets.<INPUT>newHashSet()));\n    }\n    return result;\n  }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  Multimap<INPUT, INPUT> deps = ArrayListMultimap.create();\n  for (INPUT input : inputs) {\n    for (String symbol : input.getRequires()) {\n      INPUT candidate = provideMap.get(symbol);\n      if (candidate != null) {\n        deps.put(candidate, input);\n      }\n    }\n  }\n  List<INPUT> result = new ArrayList<INPUT>();\n  for (INPUT root : roots) {\n    result.addAll(getDependenciesOf(root, deps));\n  }\n  if (sorted) {\n    result = topologicalStableSort(result, deps);\n  }\n  return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = Lists.newArrayList();\n    for (INPUT root : roots) {\n      result.addAll(getDependenciesOf(root, sorted));\n    }\n    return result;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  List<INPUT> result = Lists.newArrayList();\n  for (INPUT root : roots) {\n    result.addAll(getDependenciesOf(root, sorted));\n  }\n  return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> deps = Lists.newArrayList();\n    for (INPUT root : roots) {\n      deps.addAll(getDependenciesOf(root, sorted));\n    }\n    return deps;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  List<INPUT> result = Lists.newArrayList();\n  for (INPUT root : roots) {\n    result.addAll(getDependenciesOf(root, sorted));\n  }\n  return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = Lists.newArrayList();\n    Set<INPUT> seen = Sets.newHashSet();\n    for (INPUT root : roots) {\n      addDependenciesOf(root, sorted, seen, result);\n    }\n    return result;\n}"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp[] result = new Dfp[2];\n        int sp = 0;\n        int sig = 0;\n\n        char[] buf = a.toString().toCharArray();\n\n        for (int i = 0; i < buf.length; i++) {\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (a.getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = a.newInstance(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.toString().charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = a.newInstance(new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n\n    result[0] = a.getField().newDfp(a.getField().getRadixDigits() / 2, a.getField().getRadix());\n    result[1] = a.subtract(result[0]);\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n\n    result[0] = a.getField().newDfp(a.getField().getRadixDigits() / 2);\n    result[1] = a.subtract(result[0]);\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n\n    result[0] = a.getZero();\n    result[1] = a.getZero();\n\n    if (a.getField().getRadixDigits() == 2) {\n        result[0] = a.getField().getZero();\n        result[1] = a;\n    } else {\n        result[0] = a.getField().getZero();\n        result[1] = a.getField().getOne();\n    }\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp[] result = new Dfp[2];\n        result[0] = a.getZero();\n        result[1] = a.getZero();\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp[] result = new Dfp[2];\n\n        result[0] = a.getField().newDfp(a.getField().getRadixDigits() / 2);\n        result[1] = a.subtract(result[0]);\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n        return split(a.getField(), a.toString());\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        return split(a.getField(), a.toString());\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp[] result = new Dfp[2];\n        result[0] = a.getField().newDfp(a.getField().getRadixDigits() / 2, a.getField().getRadix());\n        result[1] = a.subtract(result[0]);\n        return result;\n    }"
    ],
    [
      "public String cssSelector()  {\n    Validate.notNull(tagName);\n\n    StringBuilder selector = StringUtil.borrowBuilder();\n    if (id().length() > 0) {\n        selector.append(\"#\").append(id());\n    } else {\n        if (parent() != null) {\n            selector.append(parent().cssSelector());\n            selector.append(\" > \");\n        }\n        selector.append(tagName);\n        if (classNames().size() > 0) {\n            selector.append(\".\");\n            Joiner.on(\".\").appendTo(selector, classNames());\n        }\n        if (siblingIndex() > 0) {\n            selector.append(\":nth-child(\").append(siblingIndex() + 1).append(\")\");\n        }\n    }\n    return StringUtil.releaseBuilder(selector);\n}",
      "public String cssSelector()  {\n    // TODO: implement this method\n    return null;\n}",
      "public String cssSelector()  {\n    Validate.isTrue(parentNode != null, \"CSS selectors can not be determined before the element has been added to the DOM\");\n\n    if (id().length() > 0)\n        return \"#\" + id();\n\n    Elements siblings = parent().children();\n    Elements mySiblings = new Elements(siblings.size());\n\n    String tagName = tag().getName();\n    for (int i = 0; i < siblings.size(); i++) {\n        Element sibling = siblings.get(i);\n        if (sibling.tagName().equals(tagName))\n            mySiblings.add(sibling);\n    }\n\n    int index = mySiblings.size() > 0 ? mySiblings.indexOf(this) : 0;\n    String combinator = index > 0 ? \":nth-child(\" + (index + 1) + \")\" : \"\";\n\n    return parent().cssSelector() + \" > \" + tagName + combinator;\n}",
      "public String cssSelector()  {\n    if (id().length() > 0)\n        return \"#\" + id();\n    else if (parent() != null)\n        return parent().cssSelector() + \" > \" + tagName().toLowerCase() + (hasClass() ? \".\" + classNames().replace(\".\", \"\\\\.\") : \"\");\n    else\n        return tagName().toLowerCase() + (hasClass() ? \".\" + classNames().replace(\".\", \"\\\\.\") : \"\");\n}",
      "public String cssSelector()  {\n    // TODO: Implement this method\n    return null;\n}",
      "public String cssSelector()  {\n    if (id().length() > 0)\n        return \"#\" + id();\n    else if (parent() == null)\n        return tagName;\n    else {\n        Elements siblings = parent().children();\n        String siblingName = tagName;\n        int i = 1, n = 0;\n        while (n < siblings.size()) {\n            if (siblings.get(n).tagName().equals(siblingName)) {\n                if (siblings.get(n) == this)\n                    return parent().cssSelector() + \" > \" + siblingName + \":nth-child(\" + i + \")\";\n                else {\n                    i++;\n                }\n            }\n            n++;\n        }\n        return parent().cssSelector() + \" > \" + tagName + \":nth-child(\" + i + \")\";\n    }\n}",
      "public String cssSelector()  {\n    // If the element has an ID, return #id\n    if (id() != null && !id().isEmpty()) \n    {\n        return \"#\" + id();\n    }\n    // Otherwise, return the parent (if any) CSS selector, followed by '>'\n    // followed by a unique selector for the element\n    else \n    {\n        Element parent = parent();\n        if (parent == null) \n        {\n            return tagName();\n        }\n        else \n        {\n            return parent.cssSelector() + \" > \" + uniqueSelector();\n        }\n    }\n}",
      "public String cssSelector()  {\n    String selector = \"\";\n    if (id() != null && !id().isEmpty())\n    {\n        selector = \"#\" + id();\n    }\n    else if (parent() != null)\n    {\n        selector = parent().cssSelector() + \" > \";\n    }\n    selector += tagName();\n    if (classNames().size() > 0)\n    {\n        selector += \".\" + String.join(\".\", classNames());\n    }\n    return selector;\n}",
      "public String cssSelector()  {\n    if (id().length() > 0)\n        return \"#\" + id();\n    else if (parent() != null)\n        return parent().cssSelector() + \" > \" + tagName() + cssNthChild();\n    else\n        return tagName();\n}",
      "public String cssSelector()  {\n    // TODO: Implement this method\n    return null;\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n  switch (n.getType()) {\n    case Token.NOT:\n      return 1;\n    case Token.AND:\n    case Token.OR:\n      return 2;\n    case Token.HOOK:\n      return 3;\n    default:\n      return 0;\n  }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  switch (n.getType()) {\n    case Token.NOT:\n      return 1;\n    case Token.HOOK:\n      return 2;\n    case Token.AND:\n    case Token.OR:\n      return 3;\n    case Token.EQ:\n    case Token.NE:\n    case Token.SHEQ:\n    case Token.SHNE:\n      return 4;\n    case Token.GE:\n    case Token.GT:\n    case Token.LE:\n    case Token.LT:\n      return 5;\n    case Token.ADD:\n    case Token.SUB:\n    case Token.MUL:\n    case Token.DIV:\n    case Token.MOD:\n    case Token.BITOR:\n    case Token.BITXOR:\n    case Token.BITAND:\n    case Token.LSH:\n    case Token.RSH:\n    case Token.URSH:\n      return 6;\n    case Token.ASSIGN_ADD:\n    case Token.ASSIGN_SUB:\n    case Token.ASSIGN_MUL:\n    case Token.ASSIGN_DIV:\n    case Token.ASSIGN_MOD:\n    case Token.ASSIGN_BITOR:\n    case Token.ASSIGN_BITXOR:\n    case Token.ASSIGN_BITAND:\n    case Token.ASSIGN_LSH:\n    case Token.ASSIGN_RSH:\n    case Token.ASSIGN_URSH:\n      return 7;\n    default:\n      return 0;\n  }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  switch (n.getType()) {\n    case Token.NOT:\n      return 1;\n    case Token.AND:\n    case Token.OR:\n      return 2;\n    case Token.HOOK:\n      return 3;\n    case Token.COMMA:\n      return 4;\n    default:\n      return 0;\n  }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  switch (n.getType()) {\n    case Token.NOT:\n      return 1;\n    case Token.AND:\n    case Token.OR:\n      return 2;\n    case Token.HOOK:\n      return 3;\n    case Token.COMMA:\n      return 4;\n    default:\n      return 0;\n  }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  switch (n.getType()) {\n    case Token.NOT:\n      return 1;\n    case Token.HOOK:\n      return 3;\n    case Token.AND:\n    case Token.OR:\n      return 2;\n    case Token.EQ:\n    case Token.NE:\n    case Token.SHEQ:\n    case Token.SHNE:\n      return 2;\n    case Token.GE:\n    case Token.GT:\n    case Token.LE:\n    case Token.LT:\n      return 2;\n    case Token.INSTANCEOF:\n      return 10;\n    case Token.IN:\n      return 10;\n    case Token.ADD:\n    case Token.BITOR:\n    case Token.BITXOR:\n    case Token.BITAND:\n    case Token.SUB:\n    case Token.MUL:\n    case Token.MOD:\n    case Token.DIV:\n    case Token.LSH:\n    case Token.RSH:\n    case Token.URSH:\n      return 2;\n    case Token.ASSIGN_ADD:\n    case Token.ASSIGN_BITOR:\n    case Token.ASSIGN_BITXOR:\n    case Token.ASSIGN_BITAND:\n    case Token.ASSIGN_LSH:\n    case Token.ASSIGN_RSH:\n    case Token.ASSIGN_SUB:\n    case Token.ASSIGN_MUL:\n    case Token.ASSIGN_MOD:\n    case Token.ASSIGN_DIV:\n    case Token.ASSIGN_URSH:\n      return 3;\n    case Token.COMMA:\n      return 1;\n    case Token.EMPTY:\n      return 0;\n    default:\n      return 1;\n  }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  switch (n.getType()) {\n    case Token.NOT:\n      return 1;\n    case Token.AND:\n    case Token.OR:\n      return 2;\n    case Token.HOOK:\n      return 3;\n    case Token.COMMA:\n      return 1;\n    case Token.EQ:\n    case Token.NE:\n    case Token.SHEQ:\n    case Token.SHNE:\n      return 2;\n    case Token.LT:\n    case Token.GT:\n    case Token.LE:\n    case Token.GE:\n    case Token.INSTANCEOF:\n    case Token.IN:\n      return 2;\n    case Token.BITOR:\n    case Token.BITXOR:\n    case Token.BITAND:\n    case Token.LSH:\n    case Token.RSH:\n    case Token.URSH:\n    case Token.SUB:\n    case Token.MUL:\n    case Token.DIV:\n    case Token.MOD:\n      return 1;\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.POS:\n    case Token.NEG:\n    case Token.BITNOT:\n      return 1;\n    case Token.ADD:\n      return n.getFirstChild().isString() ? 0 : 1;\n    case Token.CALL:\n      return PAREN_COST + estimateCostOneLevel(n.getFirstChild());\n    case Token.NAME:\n      return NAME_COST_ESTIMATE;\n    default:\n      return 0;\n  }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost = 1;\n      break;\n    case Token.HOOK:\n      cost = 3;\n      break;\n    case Token.AND:\n    case Token.OR:\n      cost = 2;\n      break;\n    case Token.EQ:\n    case Token.NE:\n    case Token.SHEQ:\n    case Token.SHNE:\n      cost = 1;\n      break;\n    case Token.LT:\n    case Token.LE:\n    case Token.GT:\n    case Token.GE:\n      cost = 1;\n      break;\n    case Token.INSTANCEOF:\n      cost = 2;\n      break;\n    case Token.IN:\n      cost = 3;\n      break;\n    case Token.COMMA:\n      cost = 1;\n      break;\n    case Token.PARAM_LIST:\n      cost = 2;\n      break;\n    case Token.CALL:\n      cost = 1;\n      break;\n    case Token.GETPROP:\n      cost = 2;\n      break;\n    case Token.NAME:\n      cost = 1;\n      break;\n    case Token.NUMBER:\n      cost = 1;\n      break;\n    case Token.STRING:\n      cost = 1;\n      break;\n    case Token.TRUE:\n    case Token.FALSE:\n    case Token.NULL:\n    case Token.THIS:\n      cost = 1;\n      break;\n    case Token.OBJECTLIT:\n      cost = 2;\n      break;\n    case Token.ARRAYLIT:\n      cost = 2;\n      break;\n    case Token.REGEXP:\n      cost = 2;\n      break;\n    case Token.EMPTY:\n      cost = 1;\n      break;\n    case Token.BLOCK:\n      cost = 2;\n      break;\n    case Token.LABEL:\n      cost = 1;\n      break;\n    case Token.IF:\n      cost = 2;\n      break;\n}\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  switch (n.getType()) {\n    case Token.NOT:\n      return 1;\n    case Token.AND:\n    case Token.OR:\n      return 2;\n    case Token.HOOK:\n      return 3;\n    case Token.COMMA:\n      return 1;\n    default:\n      return 0;\n  }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost = 1;\n      break;\n    case Token.AND:\n    case Token.OR:\n      cost = 2;\n      break;\n    case Token.HOOK:\n      cost = 3;\n      break;\n    case Token.EQ:\n    case Token.NE:\n    case Token.SHEQ:\n    case Token.SHNE:\n      cost = 4;\n      break;\n    case Token.LT:\n    case Token.LE:\n    case Token.GT:\n    case Token.GE:\n      cost = 5;\n      break;\n    case Token.INSTANCEOF:\n      cost = 6;\n      break;\n    case Token.IN:\n      cost = 7;\n      break;\n    case Token.BITOR:\n    case Token.BITXOR:\n    case Token.BITAND:\n      cost = 8;\n      break;\n    case Token.LSH:\n    case Token.RSH:\n    case Token.URSH:\n      cost = 9;\n      break;\n    case Token.ADD:\n    case Token.SUB:\n    case Token.MUL:\n    case Token.MOD:\n    case Token.DIV:\n    case Token.BITNOT:\n      cost = 10;\n      break;\n    case Token.ASSIGN_BITOR:\n    case Token.ASSIGN_BITXOR:\n    case Token.ASSIGN_BITAND:\n    case Token.ASSIGN_LSH:\n    case Token.ASSIGN_RSH:\n    case Token.ASSIGN_URSH:\n    case Token.ASSIGN_ADD:\n    case Token.ASSIGN_SUB:\n    case Token.ASSIGN_MUL:\n    case Token.ASSIGN_DIV:\n    case Token.ASSIGN_MOD:\n      cost = 11;\n      break;\n    case Token.COMMA:\n      cost = 12;\n      break;\n    case Token.SEMICOLON:\n      cost = 13;\n      break;\n}\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost = 1;\n      break;\n    case Token.OR:\n    case Token.AND:\n      cost = 2;\n      break;\n    case Token.HOOK:\n      cost = 3;\n      break;\n    case Token.EQ:\n    case Token.NE:\n    case Token.SHEQ:\n    case Token.SHNE:\n      cost = 4;\n      break;\n    case Token.LT:\n    case Token.LE:\n    case Token.GT:\n    case Token.GE:\n      cost = 5;\n      break;\n    case Token.INSTANCEOF:\n      cost = 6;\n      break;\n    case Token.IN:\n      cost = 7;\n      break;\n    case Token.BITOR:\n    case Token.BITXOR:\n    case Token.BITAND:\n    case Token.LSH:\n    case Token.RSH:\n    case Token.URSH:\n      cost = 8;\n      break;\n    case Token.ADD:\n    case Token.SUB:\n    case Token.MUL:\n    case Token.DIV:\n    case Token.MOD:\n      cost = 9;\n      break;\n    case Token.BITNOT:\n      cost = 10;\n      break;\n    case Token.POS:\n    case Token.NEG:\n      cost = 11;\n      break;\n    case Token.TYPEOF:\n      cost = 12;\n      break;\n    case Token.VOID:\n      cost = 13;\n      break;\n    case Token.NOT:\n      cost = 14;\n      break;\n    default:\n      cost = 15;\n      break;\n  }\n  return cost;\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    if (size < 2) {\n        return this;\n    }\n    int left = 0;\n    int right = size - 1;\n    while (left < right) {\n        char swap = buffer[left];\n        buffer[left++] = buffer[right];\n        buffer[right--] = swap;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) {\n        return this;\n    }\n    int left = 0;\n    int right = size - 1;\n    while (left < right) {\n        char swap = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = swap;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) {\n        return this;\n    }\n    int left = 0;\n    int right = size - 1;\n    while (left < right) {\n        char leftChar = buffer[left];\n        char rightChar = buffer[right];\n        buffer[left] = rightChar;\n        buffer[right] = leftChar;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size < 2) {\n        return this;\n    }\n    int left = 0;\n    int right = size - 1;\n    while (left < right) {\n        char swap = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = swap;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) {\n        return this;\n    }\n    final char[] buf = buffer;\n    for (int i = 0, j = size - 1; j > i; i++, j--) {\n        final char temp = buf[i];\n        buf[i] = buf[j];\n        buf[j] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) \n    {\n        return this;\n    }\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        char temp = buffer[left];\n        buffer[left++] = buffer[right];\n        buffer[right--] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) {\n        return this;\n    }\n    final char[] buf = buffer;\n    for (int i = 0, j = size - 1; j > i; i++, j--) {\n        final char temp = buf[i];\n        buf[i] = buf[j];\n        buf[j] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) \n    {\n        return this;\n    }\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        char leftChar = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = leftChar;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) {\n        return this;\n    }\n    final char[] buf = buffer;\n    for (int i = 0, j = size - 1; j > i; i++, j--) {\n        final char temp = buf[i];\n        buf[i] = buf[j];\n        buf[j] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size > 1) \n    {\n        int mid = size >> 1;\n        for (int i = 0, j = size - 1; i < mid; i++, j--) \n        {\n            char swap = buffer[i];\n            buffer[i] = buffer[j];\n            buffer[j] = swap;\n        }\n    }\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > getWholeText().length()) {\n        throw new IndexOutOfBoundsException(\"Split offset must be in bounds\");\n    }\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n    text(head);\n    TextNode tailNode = new TextNode(tail);\n    if (parent() != null) {\n        parent().addChildren(siblingIndex() + 1, tailNode);\n    }\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    // Validate the offset\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n\n    // Get the current text\n    String text = getWholeText();\n\n    // Split the text into two strings\n    String[] splitText = text.split(String.valueOf(text.charAt(offset)));\n\n    // Create a new text node with the remaining text\n    TextNode newTextNode = new TextNode(splitText[1]);\n\n    // Set the text of the current node to the first part of the split text\n    text(splitText[0]);\n\n    // Insert the new text node after the current node\n    parentNode.insertChildren(siblingIndex() + 1, newTextNode);\n\n    // Return the new text node\n    return newTextNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n    TextNode headNode = new TextNode(head);\n    TextNode tailNode = new TextNode(tail);\n    this.text(head);\n    this.parent().addChildren(this.siblingIndex() + 1, tailNode);\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n\n    TextNode headNode = new TextNode(head);\n    TextNode tailNode = new TextNode(tail);\n\n    this.text(head);\n    this.parentNode.addChildren(this.siblingIndex() + 1, Arrays.asList(tailNode));\n\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n\n    TextNode headNode = new TextNode(head);\n    TextNode tailNode = new TextNode(tail);\n\n    this.text(head);\n    this.parentNode.addChildren(siblingIndex() + 1, Collections.singletonList(tailNode));\n\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n\n    TextNode headNode = new TextNode(head);\n    TextNode tailNode = new TextNode(tail);\n\n    this.text(head);\n    this.parentNode.addChildren(siblingIndex() + 1, Collections.singletonList(tailNode));\n\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n    TextNode tailNode = new TextNode(tail);\n    text(head);\n    if (parentNode != null)\n        parentNode.addChildren(siblingIndex + 1, Collections.singletonList(tailNode));\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    // If the offset is out of bounds, return an empty text node\n    if (offset < 0 || offset > text().length())\n        return new TextNode(\"\");\n\n    // Create a new text node containing the text after the offset\n    TextNode newTextNode = new TextNode(text().substring(offset));\n\n    // Update the text of this node to contain the text up to the offset\n    text(text().substring(0, offset));\n\n    // Insert the new text node after this node\n    parentNode.insertChildren(siblingIndex() + 1, Collections.singletonList(newTextNode));\n\n    return newTextNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n\n    TextNode headNode = new TextNode(head);\n    TextNode tailNode = new TextNode(tail);\n\n    this.text(head);\n    this.parentNode.addChildren(this.siblingIndex() + 1, Arrays.asList(tailNode));\n\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Split offset must be not be negative\");\n    Validate.isTrue(offset < getWholeText().length(), \"Split offset must not be greater than current text length\");\n    String head = getWholeText().substring(0, offset);\n    String tail = getWholeText().substring(offset);\n    text(head);\n    TextNode tailNode = new TextNode(tail);\n    if (parent() != null)\n    {\n        parent().addChildren(siblingIndex() + 1, tailNode);\n    }\n    return tailNode;\n}"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, Math.max(helper.max(obj), helper.min(obj)) - Math.min(helper.max(obj), helper.min(obj)));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, Math.abs(helper.max(obj) - helper.min(obj)));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> union = union(a, b);\n    final Collection<O> intersection = intersection(a, b);\n    return subtract(union, intersection);\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, Math.max(helper.max(obj), helper.min(obj)) - Math.min(helper.max(obj), helper.min(obj)));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> union = union(a, b);\n    final Collection<O> intersection = intersection(a, b);\n    return subtract(union, intersection);\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, Math.max(helper.max(obj), helper.min(obj)) - Math.min(helper.max(obj), helper.min(obj)));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, Math.abs(helper.max(obj) - helper.min(obj)));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> union = CollectionUtils.union(a, b);\n    final Collection<O> intersection = CollectionUtils.intersection(a, b);\n    return CollectionUtils.subtract(union, intersection);\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> union = union(a, b);\n    final Collection<O> intersection = intersection(a, b);\n    return subtract(union, intersection);\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, Math.abs(helper.max(obj) - helper.min(obj)));\n    }\n    return helper.list();\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] temp = value.toByteArray();\n    int start = (temp.length == 8) ? 0 : 1;\n    int length = (temp.length <= 8) ? temp.length : 8;\n    System.arraycopy(temp, start, result, 8 - length, length);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] byteArray = value.toByteArray();\n    int start = byteArray.length > 8 ? byteArray.length - 8 : 0;\n    for (int i = start; i < byteArray.length; i++) \n    {\n        result[i - start] = byteArray[i];\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    ByteUtils.toLittleEndian(result, value, 0, 8);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] temp = value.toByteArray();\n    int length = temp.length;\n    if (length > 8) {\n        throw new IllegalArgumentException(\"Byte array must not be more than 8 bytes\");\n    }\n    int offset = 8 - length;\n    for (int i = 0; i < length; i++) {\n        result[i + offset] = temp[i];\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    ByteUtils.toLittleEndian(result, value, 0, 8);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] byteArray = value.toByteArray();\n    int length = byteArray.length;\n    if (length > 8) {\n        length = 8;\n    }\n    for (int i = 0; i < length; i++) {\n        result[i] = byteArray[i];\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] byteValue = value.toByteArray();\n    if (byteValue.length > 8) {\n        throw new IllegalArgumentException(\"Byte array too large: \" + byteValue.length);\n    }\n    for (int i = 0; i < byteValue.length; i++) {\n        result[7 - i] = byteValue[byteValue.length - 1 - i];\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    putLong(value.longValue(), result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] byteValue = value.toByteArray();\n    int offset = 8 - byteValue.length;\n    for (int i = 0; i < byteValue.length; i++) \n    {\n        result[i + offset] = byteValue[i];\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] bytes = value.toByteArray();\n    int bytesLength = bytes.length;\n    if (bytesLength > 8) {\n        throw new IllegalArgumentException(\"input too large to convert to eight byte array\");\n    }\n    int srcPos = (bytesLength == 8) ? 0 : (8 - bytesLength);\n    int destPos = 8 - srcPos;\n    System.arraycopy(bytes, srcPos, result, destPos, bytesLength);\n    return result;\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}\n// CharSetUtils.java\n// Modify",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}\n//-----------------------------------------------------------------------",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}\n//-----------------------------------------------------------------------",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}\n\n//-----------------------------------------------------------------------",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder builder = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            builder.append(c);\n        }\n    }\n    return builder.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}\n//-----------------------------------------------------------------------",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}"
    ],
    [
      "public RealMatrix getSquareRoot()  {\n    if (hasComplexEigenvalues()) {\n        throw new MathUnsupportedOperationException();\n    }\n    final RealMatrix l = getL();\n    final RealMatrix lt = getLT();\n    final RealMatrix ltL = lt.multiply(l);\n    final RealMatrix ltLPlusI = ltL.add(MatrixUtils.createRealIdentityMatrix(l.getRowDimension()));\n    final RealMatrix ltLPlusISqrt = squareRoot(ltLPlusI);\n    return l.multiply(ltLPlusISqrt);\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n    return new Array2DRowRealMatrix(MatrixUtils.createRealSquareMatrixFromSymmetricPackedArray(MatrixUtils.createRealSymmetricPackedMatrixFromSquareArray(getData())), false);\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n    if (!isPositiveDefinite) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n    if (cachedV == null) {\n        cachedV = transformer.getQ();\n    }\n    if (cachedD == null) {\n        cachedD = cachedV.multiply(cachedV.transpose());\n    }\n    if (cachedVt == null) {\n        cachedVt = cachedV.transpose();\n    }\n    return cachedVt.multiply(cachedD.sqrt()).multiply(cachedV);\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n    if (!isPositiveDefinite) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE);\n    }\n    if (cachedSqrt == null) {\n        cachedSqrt = transformToSchur(transformer.getT()).getSquareRoot();\n    }\n    return cachedSqrt;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC_MATRIX);\n    }\n    if (!isPositiveDefinite) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE_MATRIX);\n    }\n    if (cachedV == null) {\n        transformToTridiagonal(main, secondary);\n        transformToSchur(main, secondary);\n        findEigenVectorsFromSchur(main, secondary);\n        cachedV = MatrixUtils.createRealMatrix(eigenvectors);\n    }\n    return cachedV;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC,\n                                                     getClass().getSimpleName());\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE,\n                                                     getClass().getSimpleName());\n    }\n    final int n = getRowDimension();\n    final double[][] l = new double[n][n];\n    for (int i = 0; i < n; ++i) {\n        final double[] row = l[i];\n        for (int j = 0; j <= i; ++j) {\n            double sum = 0;\n            for (int k = 0; k < j; ++k) {\n                sum += l[i][k] * l[j][k];\n            }\n            if (i == j) {\n                row[j] = FastMath.sqrt(getEntry(i, i) - sum);\n            } else {\n                row[j] = (getEntry(i, j) - sum) / row[j - 1];\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(l, false);\n}\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n    if (hasComplexEigenvalues()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.COMPLEX_EIGENVALUES);\n    }\n    return transformer.getSquareRoot(main, secondary);\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC,\n                                                     getClass().getName());\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_POSITIVE_DEFINITE,\n                                                     getClass().getName());\n    }\n    return new CholeskyDecomposition(this).getSquareRoot();\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SYMMETRIC);\n    }\n    if (hasComplexEigenvalues()) {\n        throw new MathUnsupportedOperationException(LocalizedFormats.COMPLEX_EIGENVALUES);\n    }\n    return transformToSchur(matrix).getSquareRoot();\n}",
      "public RealMatrix getSquareRoot()  {\n    if (isSymmetric) {\n        final EigenDecomposition dec = new EigenDecomposition(transformer.getT());\n        final double[] realEigenvalues = dec.getRealEigenvalues();\n        final double[] imagEigenvalues = dec.getImagEigenvalues();\n        final ArrayRealVector[] eigenvectors = dec.getEigenVectors();\n        final int n = realEigenvalues.length;\n        final double[][] sqrt = new double[n][n];\n        for (int i = 0; i < n; ++i) {\n            final double eigenvalue = realEigenvalues[i];\n            final double imaginary = imagEigenvalues[i];\n            if (imaginary > 0) {\n                throw new MathUnsupportedOperationException();\n            }\n            final ArrayRealVector eigenvector = eigenvectors[i];\n            final double sqrtEigenvalue = FastMath.sqrt(eigenvalue);\n            for (int j = 0; j < n; ++j) {\n                sqrt[j][i] = eigenvector.getEntry(j) / sqrtEigenvalue;\n            }\n        }\n        return new Array2DRowRealMatrix(sqrt, false);\n    } else {\n        throw new MathUnsupportedOperationException();\n    }\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case START_OBJECT:\n            return vanillaDeserialize(p, ctxt);\n        case END_ARRAY:\n            return ctxt.handleUnexpectedToken(getValueType(), p);\n        case VALUE_STRING:\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT:\n            return p.getNumberValue();\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case VALUE_NULL:\n            return null;\n        default:\n            return ctxt.handleUnexpectedToken(getValueType(), p);\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // Ok: must point to START_OBJECT or FIELD_NAME\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n            return (Map<Object,Object>) ctxt.handleUnexpectedToken(getMapClass(), p);\n        }\n        // 21-Apr-2017, tatu: Need separate methods to do proper merging\n        if (_standardStringKey) {\n            _readAndUpdateStringKeyMap(p, ctxt, result);\n            return result;\n        }\n        _readAndUpdate(p, ctxt, result);\n        return result;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case START_OBJECT:\n            return deserializeFromObject(p, ctxt);\n        case START_ARRAY:\n            return deserializeFromArray(p, ctxt);\n        case END_ARRAY:\n        case END_OBJECT:\n        case FIELD_NAME:\n        case NOT_AVAILABLE:\n            // should never occur\n            break;\n        case VALUE_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_NULL:\n            return null;\n        case VALUE_NUMBER_INT:\n            return _numberDeserializer.deserialize(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n            return _numberFloatDeserializer.deserialize(p, ctxt);\n        case VALUE_STRING:\n            return _stringDeserializer.deserialize(p, ctxt);\n        default:\n            throw ctxt.mappingException(handledType());\n        }\n        throw ctxt.mappingException(handledType());\n    }\n\n    protected final Object _deserializeOther(JsonParser p, DeserializationContext ctxt, JsonToken t) throws IOException {\n        switch (t) {\n        case VALUE_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_NULL:\n            return null;\n        case VALUE_NUMBER_INT:\n            return _numberDeserializer.deserialize(p, ctxt);\n        case VALUE_NUMBER_FLOAT:\n            return _numberFloatDeserializer.deserialize(p, ctxt);\n        case VALUE_STRING:\n            return _stringDeserializer.deserialize(p, ctxt);\n        default:\n            throw ctxt.mappingException(handledType());\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     ",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT:\n            return p.getNumberValue();\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case START_ARRAY:\n            return deserializeFromArray(p, ctxt);\n        case START_OBJECT:\n            return deserializeFromObject(p, ctxt);\n        case END_ARRAY:\n        case END_OBJECT:\n        case FIELD_NAME:\n        case NOT_AVAILABLE:\n            break;\n        }\n        throw ctxt.mappingException(_valueClass, t);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT:\n            return p.getNumberValue();\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case VALUE_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case START_ARRAY:\n            return deserializeFromArray(p, ctxt);\n        case FIELD_NAME:\n            return deserializeFromObject(p, ctxt);\n        case END_ARRAY:\n        case END_OBJECT:\n        case NOT_AVAILABLE:\n            return null;\n        case START_OBJECT:\n            return deserializeFromObject(p, ctxt);\n        case VALUE_NULL:\n            return null;\n        default:\n            throw ctxt.mappingException(handledType());\n        }\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \tswitch (t) {\n    \tcase VALUE_STRING:\n    \t\treturn p.getText();\n    \tcase VALUE_NUMBER_INT:\n    \t\treturn p.getNumberValue();\n    \tcase VALUE_NUMBER_FLOAT:\n    \t\treturn p.getNumberValue();\n    \tcase VALUE_TRUE:\n    \t\treturn Boolean.TRUE;\n    \tcase VALUE_FALSE:\n    \t\treturn Boolean.FALSE;\n    \tcase VALUE_EMBEDDED_OBJECT:\n    \t\treturn p.getEmbeddedObject();\n    \tcase START_ARRAY:\n    \t\treturn deserializeFromArray(p, ctxt);\n    \tcase START_OBJECT:\n    \t\treturn deserializeFromObject(p, ctxt);\n    \tcase FIELD_NAME:\n    \t\treturn deserializeFromObject(p, ctxt);\n    \tcase END_ARRAY:\n    \tcase END_OBJECT:\n    \tcase END_INPUT:\n    \t\treturn null;\n    \tcase NOT_AVAILABLE: // should only get this for START_OBJECT?\n    \t\treturn deserializeFromObject(p, ctxt);\n    \tdefault:\n    \t\tthrow ctxt.mappingException(\"Don't know how to deserialize \"+t);\n    \t}\n     }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_STRING) {\n            return p.getText();\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return p.getNumberValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return p.getNumberValue();\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return Boolean.TRUE;\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return Boolean.FALSE;\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return null;\n        }\n        if (t == JsonToken.START_ARRAY) {\n            return deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.START_OBJECT) {\n            return deserializeFromObject(p, ctxt);\n        }\n        throw ctxt.mappingException(\"Don't know how to deserialize \"+t);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        switch (t) {\n        case VALUE_STRING:\n            return p.getText();\n        case VALUE_NUMBER_INT:\n            return p.getNumberValue();\n        case VALUE_NUMBER_FLOAT:\n            return p.getNumberValue();\n        case VALUE_TRUE:\n            return Boolean.TRUE;\n        case VALUE_FALSE:\n            return Boolean.FALSE;\n        case START_ARRAY:\n            return deserializeFromArray(p, ctxt);\n        case START_OBJECT:\n            return deserializeFromObject(p, ctxt);\n        case END_ARRAY:\n        case END_OBJECT:\n        case FIELD_NAME:\n        case NOT_AVAILABLE:\n            // should never get these\n            throw new IllegalStateException();\n        case VALUE_EMBEDDED_OBJECT:\n            return p.getEmbeddedObject();\n        case VALUE_NULL:\n            return null;\n        default:\n        }\n        throw new IllegalStateException();\n    }\n\n    /*\n    /**********************************************************\n    /* Helper methods, non-standard creation\n    /**********************************************************",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t// 21-Apr-2017, tatu: Assign current value, to be accessible by custom deserializers\n    \tp.setCurrentValue(result);\n    \t\n    \t// Ok: must point to START_OBJECT or FIELD_NAME\n    \tif (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n    \t\treturn (Map<Object,Object>) ctxt.handleUnexpectedToken(getMapClass(), p);\n    \t}\n    \t// 21-Apr-2017, tatu: Need separate methods to do proper merging\n    \tif (_standardStringKey) {\n    \t\t_readAndUpdateStringKeyMap(p, ctxt, result);\n    \t\treturn result;\n    \t}\n    \t_readAndUpdate(p, ctxt, result);\n    \treturn result;\n     }\n\n    /*\n    /**********************************************************\n    /* Internal methods, non-merging deserialization\n    /**********************************************************"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0d;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0d;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0d;\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 1) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < n; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_head == null) {\n             _head = _tail = new LinkedNode<>(fullChunk);\n         } else {\n             _tail = _tail.next = new LinkedNode<>(fullChunk);\n         }\n         _size += fullChunk.length;\n         return new Object[MAX_CHUNK];\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // append the chunk to the end of the linked list\n         if (_tail == null) {\n             _head = _tail = new LinkedNode<Object[]>(fullChunk);\n         } else {\n             _tail.next = new LinkedNode<Object[]>(fullChunk);\n             _tail = _tail.next;\n         }\n         // increment the size\n         _size += fullChunk.length;\n         // return a new chunk to fill\n         return new Object[MAX_CHUNK];\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         LinkedNode<Object[]> node = new LinkedNode<Object[]>(fullChunk);\n         if (_head == null) {\n             _head = _tail = node;\n         } else {\n             _tail.setNext(node);\n             _tail = node;\n         }\n         _size += fullChunk.length;\n         return resetAndStart();\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_tail == null) {\n             _head = _tail = new LinkedNode<Object[]>(fullChunk);\n         } else {\n             _tail.next = new LinkedNode<Object[]>(fullChunk);\n             _tail = _tail.next;\n         }\n         _size += fullChunk.length;\n         return resetAndStart();\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        // If we have space in current tail chunk, let's use it.\n        if (_tail != null) {\n            int free = MAX_CHUNK - _tail._count;\n            if (free >= fullChunk.length) {\n                System.arraycopy(fullChunk, 0, _tail._buffer, _tail._count, fullChunk.length);\n                _tail._count += fullChunk.length;\n                _size += fullChunk.length;\n                return _tail._buffer;\n            }\n        }\n        // Otherwise need to create a new chunk\n        LinkedNode<Object[]> newChunk = new LinkedNode<Object[]>(fullChunk, fullChunk.length);\n        if (_head == null) {\n            _head = _tail = newChunk;\n        } else {\n            _tail._next = newChunk;\n            _tail = newChunk;\n        }\n        _size += fullChunk.length;\n        return newChunk._buffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_tail == null) {\n             _head = _tail = new LinkedNode<>(fullChunk);\n         } else {\n             _tail.next = new LinkedNode<>(fullChunk);\n             _tail = _tail.next;\n         }\n         _size += fullChunk.length;\n         return resetAndStart();\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        // Append the completed chunk to the end of the linked list\n        LinkedNode<Object[]> newNode = new LinkedNode<Object[]>(fullChunk);\n        if (_head == null) {\n            _head = newNode;\n        } else {\n            _tail.next = newNode;\n        }\n        _tail = newNode;\n        _size += fullChunk.length;\n        // Return a new chunk for the caller to fill\n        return resetAndStart();\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_tail == null) {\n             _head = _tail = new LinkedNode<Object[]>(fullChunk);\n         } else {\n             _tail.next = new LinkedNode<Object[]>(fullChunk);\n             _tail = _tail.next;\n         }\n         _size += fullChunk.length;\n         return new Object[MAX_CHUNK];\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         LinkedNode<Object[]> newNode = new LinkedNode<Object[]>(fullChunk);\n         if (_head == null) {\n             _head = newNode;\n             _tail = newNode;\n         } else {\n             _tail.setNext(newNode);\n             _tail = newNode;\n         }\n         _size += fullChunk.length;\n         return resetAndStart();\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (_head == null) {\n            _head = _tail = new LinkedNode<Object[]>(fullChunk);\n        } else {\n            _tail.next = new LinkedNode<Object[]>(fullChunk);\n            _tail = _tail.next;\n        }\n        _size += fullChunk.length;\n        return resetAndStart();\n     }"
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.LC) {\n    return parseUnionType(next());\n  } else if (token == JsDocToken.LT) {\n    return parseArrayType(next());\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.FUNCTION) {\n    return parseFunctionType(next());\n  } else if (token == JsDocToken.RECORD) {\n    return parseRecordType(next());\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.LP) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseUnionType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else if (token == JsDocToken.LT) {\n    return parseRecordType(token);\n  } else {\n    return reportGenericTypeSyntaxWarning();\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.LP) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) {\n    case STAR:\n      return newNode(Token.STAR);\n    case NULL:\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      return newNode(Token.UNDEFINED);\n    case LC:\n      return parseTypeName(next());\n    case FUNCTION:\n      return parseFunctionType(next());\n    case LB:\n      return parseArrayType(next());\n    case LT:\n      return parseRecordType(next());\n    default:\n      return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) {\n    case STAR:\n      return newNode(Token.STAR);\n    case NULL:\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      return newNode(Token.VOID);\n    case LC:\n      return parseRecordType(next());\n    case LB:\n      return parseArrayType(next());\n    case LR:\n      return parseFunctionType(next());\n    case LT:\n      return parseUnionType(next());\n    case STRING:\n      return parseTypeName(token);\n    default:\n      return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) {\n    case STAR:\n      return newNode(Token.STAR);\n    case NULL:\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      return newNode(Token.UNDEFINED);\n    case LC:\n      return parseRecordType(next());\n    case LB:\n      return parseArrayType(next());\n    case LR:\n      return parseUnionType(next());\n    case LC:\n      return parseFunctionType(next());\n    case STRING:\n      return parseTypeName(token);\n    default:\n      return reportTypeSyntaxWarning();\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.LC) {\n    return parseUnionType(next());\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(next());\n  } else if (token == JsDocToken.LT) {\n    return parseRecordType(next());\n  } else if (token == JsDocToken.FUNCTION) {\n    return parseFunctionType(next());\n  } else {\n    return parseTypeName(token);\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) {\n    case STAR:\n      return newNode(Token.STAR);\n    case NULL:\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      return newNode(Token.UNDEFINED);\n    case LC:\n      return parseRecordType(next());\n    case LB:\n      return parseArrayType(next());\n    case FUNCTION:\n      return parseFunctionType(next());\n    case LT:\n      return parseUnionType(next());\n    case STRING:\n      return parseTypeName(token);\n    default:\n      return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) {\n    case STAR:\n      return newNode(Token.STAR);\n    case NULL:\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      return newNode(Token.VOID);\n    case LC:\n      return parseRecordType(next());\n    case LB:\n      return parseArrayType(next());\n    case LT:\n      return parseUnionType(next());\n    case FUNCTION:\n      return parseFunctionType(next());\n    case STRING:\n      return parseTypeName(token);\n    default:\n      return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) {\n    case STAR:\n      return newNode(Token.STAR);\n    case NULL:\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      return newNode(Token.VOID);\n    case LC:\n      return parseRecordType(next());\n    case LB:\n      return parseArrayType(next());\n    case FUNCTION:\n      return parseFunctionType(next());\n    case LT:\n      return parseUnionType(next());\n    case STRING:\n      return parseTypeName(token);\n    default:\n      return null;\n  }\n}"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    this.deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    this.deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    this.deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    this.deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    this.deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n      throw new IllegalStateException();\n    }\n    this.deferredName = name;\n    return this;\n}"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element) {\n            return true;\n        }\n    }\n    return false;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final boolean element : array) {\n        if (element) {\n            return true;\n        }\n    }\n    return false;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final boolean element : array) \n    {\n        if (element) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final boolean element : array) \n    {\n        if (element) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final boolean element : array) \n    {\n        if (element) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final boolean element : array) {\n        if (element) {\n            return true;\n        }\n    }\n    return false;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element) {\n            return true;\n        }\n    }\n    return false;\n}"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) \n    {\n        return \"\";\n    }\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final char[] buffer = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            lastWasGap = true;\n        } \n        else \n        {\n            if (lastWasGap) \n            {\n                buffer[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str.substring(0,1);\n    }\n    final char[] buffer = new char[strLen / delimLen + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buffer[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) \n    {\n        return str.substring(0,1);\n    }\n    final char[] buffer = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            lastWasGap = true;\n        } \n        else \n        {\n            if (lastWasGap) \n            {\n                buffer[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) \n    {\n        return str.substring(0,1);\n    }\n    final char[] buffer = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            lastWasGap = true;\n        } \n        else if (lastWasGap) \n        {\n            buffer[count++] = ch;\n            lastWasGap = false;\n        } \n        else \n        {\n            // ignore ch\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    int strLen = str.length();\n    char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str.substring(0,1);\n    }\n    final char[] buffer = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buffer[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str.substring(0,1);\n    }\n    final char[] buffer = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buffer[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return \"\";\n    }\n    int strLen = str.length();\n    char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else {\n            if (lastWasGap) {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str.substring(0,1);\n    }\n    final char[] buffer = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buffer[count++] = ch;\n            lastWasGap = false;\n        } else {\n            // ignore ch\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) \n    {\n        return \"\";\n    }\n    int strLen = str.length();\n    char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            lastWasGap = true;\n        } \n        else \n        {\n            if (lastWasGap) \n            {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / getScaleX();\n    double y = (screenPoint.getY() - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / getScaleX();\n    double y = (screenPoint.getY() - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / getScaleX();\n    double y = (screenPoint.getY() - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / getScaleX();\n    double y = (screenPoint.getY() - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / getScaleX();\n    double y = (screenPoint.getY() - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return ListOrderedSet.listOrderedSet(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<E>(list);\n    final List<E> ordered = new ArrayList<E>(set);\n    return new ListOrderedSet<E>(set, ordered);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(new HashSet<E>(), list);\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(new HashSet<E>(), list);\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(new HashSet<E>(), list);\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(new HashSet<E>(), list);\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>());\n    sl.addAll(temp);\n    return sl;\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null)  {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext())  {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            result = Range.combine(result, plot.getDataRange(axis));\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null)  {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext())  {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range subrange = plot.getDataRange(axis);\n            if (subrange != null)  {\n                if (result == null)  {\n                    result = subrange;\n                }\n                else  {\n                    result = result.add(subrange);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null)  {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext())  {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range subplotRange = plot.getDataRange(axis);\n            if (subplotRange != null)  {\n                if (result == null)  {\n                    result = subplotRange;\n                }\n                else  {\n                    result = result.add(subplotRange);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null)  {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext())  {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range r = plot.getDataRange(axis);\n            if (r != null)  {\n                if (result == null)  {\n                    result = r;\n                }\n                else  {\n                    result = result.add(r);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null)  {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext())  {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            result = Range.combine(result, plot.getDataRange(axis));\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null)  {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext())  {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range subplotRange = plot.getDataRange(axis);\n            if (subplotRange != null)  {\n                if (result == null)  {\n                    result = subplotRange;\n                }\n                else  {\n                    result = result.add(subplotRange);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == null) \n    {\n        return null;\n    }\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range r = plot.getDataRange(axis);\n            if (r != null) \n            {\n                if (result == null) \n                {\n                    result = r;\n                } \n                else \n                {\n                    result = Range.combine(result, r);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range subplotRange = plot.getDataRange(axis);\n            if (subplotRange != null) \n            {\n                if (result == null) \n                {\n                    result = subplotRange;\n                }\n                else \n                {\n                    result = result.add(subplotRange);\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null)  {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext())  {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            result = Range.combine(result, plot.getDataRange(axis));\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            result = Range.combine(result, plot.getDataRange(axis));\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) - Math.log(10.0)) / LOG10_VALUE; //invert switchedLog10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) - 1.0; //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = Math.log(val) / LOG10_VALUE; //invert switchedLog10\n    } \n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) - SMALL_LOG_VALUE) / LOG10_VALUE; //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) - 1.0; //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = (Math.log(val) / LOG10_VALUE) - 1.0; //invert adjustedPow10\n    } \n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = Math.log(val) / LOG10_VALUE; //invert switchedLog10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = Math.log(val) / LOG10_VALUE; //invert switchedLog10\n    }\n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val * 9.0 + 10.0) / LOG10_VALUE) - 1.0; //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) - Math.log(10.0)) / LOG10_VALUE; //invert switchedLog10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    DiGraphNode<Node, ControlFlowGraph.Branch> entry = cfg.getEntry();\n    DiGraphNode<Node, ControlFlowGraph.Branch> implicitReturn = cfg.getImplicitReturn();\n    CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> test =\n        new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n            cfg, entry, implicitReturn, IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE);\n    return test.allPathsSatisfyPredicate();\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // TODO(johnlenz): implement\n    return false;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  DiGraphNode<Node, ControlFlowGraph.Branch> entry = cfg.getEntry();\n  DiGraphNode<Node, ControlFlowGraph.Branch> implicitReturn = cfg.getImplicitReturn();\n  CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> test =\n      new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n          cfg, entry, implicitReturn, IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE);\n  return test.allPathsSatisfyPredicate();\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // TODO(johnlenz): This is a very simplistic check.  It is not\n  // clear that it is faster than the more complete check.\n  // It is also not clear that it is correct.\n  //\n  // The more complete check is:\n  //\n  // 1) Find all paths from the entry node to the implicit return node.\n  // 2) For each path, check that at least one node on the path\n  //    is a return statement.\n  //\n  // The more complete check is more complex, but it is correct.\n  //\n  // The simplistic check is faster, but it is not correct.\n  //\n  // The simplistic check is:\n  //\n  // 1) Find all paths from the entry node to the implicit return node.\n  // 2) For each path, check that the last node on the path is a return\n  //    statement.\n  //\n  // The simplistic check is correct if there is a path from the entry\n  // node to the implicit return node that contains a return statement.\n  //\n  // The simplistic check is incorrect if there is a path from the entry\n  // node to the implicit return node that does not contain a return\n  // statement.\n  //\n  // The simplistic check is incorrect if there is a path from the entry\n  // node to the implicit return node that contains a return statement\n  // but is not the last node on the path.\n  //\n  // The simplistic check is incorrect if there is a path from the entry\n  // node to the implicit return node that does not contain a return\n  // statement but is the last node on the path.\n  //\n  // The simplistic check is incorrect if there is a path from the entry\n  // node to the implicit return node that contains a return statement\n  // but is not the last node on the path and there is another path from\n  // the entry node to the implicit return node that does not contain a\n  // return statement.\n  //\n  // The simplistic check is incorrect if there is a path from the entry\n  // node to the implicit return node that does not contain a return\n  // statement but is the last node on the path and there is another path\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // Optimization: Most functions don't have a return statement.\n    if (cfg.getImplicitReturn() == null) {\n      return true;\n    }\n\n    DiGraphNode<Node, ControlFlowGraph.Branch> entry = cfg.getEntry();\n    DiGraphNode<Node, ControlFlowGraph.Branch> implicitReturn = cfg.getImplicitReturn();\n\n    // If there is no path from the entry to the implicit return, then\n    // there is no return statement.\n    if (!cfg.hasPath(entry, implicitReturn)) {\n      return false;\n    }\n\n    // If there is a path from the entry to the implicit return, then\n    // there must be a return statement.\n    return true;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // If the function has no return statements, it is missing a return.\n    if (cfg.getImplicitReturn() == null) {\n      return false;\n    }\n\n    // If the function has a return statement, it returns.\n    if (cfg.getReturnNodes().size() > 0) {\n      return true;\n    }\n\n    // If the function has no return statements, it is missing a return.\n    if (cfg.getImplicitReturn() == null) {\n      return false;\n    }\n\n    // If the function has no return statements, it is missing a return.\n    if (cfg.getImplicitReturn() == null) {\n      return false;\n    }\n\n    // If the function has no return statements, it is missing a return.\n    if (cfg.getImplicitReturn() == null) {\n      return false;\n    }\n\n    // If the function has no return statements, it is missing a return.\n    if (cfg.getImplicitReturn() == null) {\n      return false;\n    }\n\n    // If the function has no return statements, it is missing a return.\n    if (cfg.getImplicitReturn() == null) {\n      return false;\n    }\n\n    // If the function has no return statements, it is missing a return.\n    if (cfg.getImplicitReturn() == null) {\n      return false;\n    }\n\n    // If the function has no return statements, it is missing a return.\n    if (cfg.getImplicitReturn() == null) {\n      return false;\n    }\n\n    // If the function has no return statements, it is missing a return.\n    if (cfg.getImplicitReturn() == null) {\n      return false;\n    }\n\n    // If the function has no return statements, it is missing a return.\n    if (cfg.getImplicitReturn() == null) {\n      return false;\n    }\n\n    // If the function has no return statements, it is missing a return.\n    if (cfg.getImplicitReturn() == null) {\n      return false;\n    }\n\n    // If the function has no return statements, it is missing a return.\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    DiGraphNode<Node, ControlFlowGraph.Branch> implicitReturn = cfg.getImplicitReturn();\n    DiGraphNode<Node, ControlFlowGraph.Branch> entry = cfg.getEntry();\n    CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> test =\n        new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n            cfg, entry, implicitReturn, IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE);\n    return test.allPathsSatisfyPredicate();\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    return cfg.isImplicitReturn(cfg.getImplicitReturn())\n        && cfg.getImplicitReturn().getInEdges().size() == 1;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  DiGraphNode<Node, ControlFlowGraph.Branch> entry = cfg.getEntry();\n  DiGraphNode<Node, ControlFlowGraph.Branch> implicitReturn = cfg.getImplicitReturn();\n\n  // Check that all paths from entry to implicitReturn contain a return statement.\n  CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> test =\n      new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n          cfg, entry, implicitReturn, IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE);\n\n  return test.allPathsSatisfyPredicate();\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  DiGraphNode<Node, ControlFlowGraph.Branch> implicitReturn = cfg.getImplicitReturn();\n  DiGraphNode<Node, ControlFlowGraph.Branch> entry = cfg.getEntry();\n  return cfg.allPathsSatisfyPredicate(entry, implicitReturn, IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE);\n}"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp[] x = new Dfp[2];\n        Dfp[] x2 = new Dfp[2];\n        Dfp[] y = new Dfp[2];\n        Dfp[] a2 = new Dfp[2];\n\n        split(a, x);\n\n        /* Set X = (x-1)/(x+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a2);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a2, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n\n        //x[0] -= 1.0;\n        //resplit(x);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x2, a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n        }\n\n        splitMult(y, x, a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n\n        return y;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp[] x = new Dfp[2];\n        Dfp[] x2 = new Dfp[2];\n        Dfp[] y = new Dfp[2];\n        Dfp[] a2 = new Dfp[2];\n        Dfp[] a3 = new Dfp[2];\n        Dfp[] a4 = new Dfp[2];\n        Dfp[] a5 = new Dfp[2];\n        Dfp[] a6 = new Dfp[2];\n        Dfp[] a7 = new Dfp[2];\n        Dfp[] a8 = new Dfp[2];\n        Dfp[] a9 = new Dfp[2];\n        Dfp[] a10 = new Dfp[2];\n        Dfp[] a11 = new Dfp[2];\n        Dfp[] a12 = new Dfp[2];\n        Dfp[] a13 = new Dfp[2];\n        Dfp[] a14 = new Dfp[2];\n        Dfp[] a15 = new Dfp[2];\n        Dfp[] a16 = new Dfp[2];\n        Dfp[] a17 = new Dfp[2];\n        Dfp[] a18 = new Dfp[2];\n        Dfp[] a19 = new Dfp[2];\n        Dfp[] a20 = new Dfp[2];\n        Dfp[] a21 = new Dfp[2];\n        Dfp[] a22 = new Dfp[2];\n        Dfp[] a23 = new Dfp[2];\n        Dfp[] a24 = new Dfp[2];\n        Dfp[] a25 = new Dfp[2];\n        Dfp[] a26 = new Dfp[2];\n        Dfp[] a27 = new Dfp[2];\n        Dfp[] a28 = new Dfp[2];\n        Dfp[] a29 = new Dfp[2];\n        Dfp[] a30 = new Dfp[2];\n        Dfp[] a31 = new Dfp[2];\n        Dfp[] a32 = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp[] x = new Dfp[2];\n        Dfp[] x2 = new Dfp[2];\n        Dfp[] y = new Dfp[2];\n        Dfp[] a2 = new Dfp[2];\n        Dfp[] a3 = new Dfp[2];\n        Dfp[] a4 = new Dfp[2];\n        Dfp[] a5 = new Dfp[2];\n        Dfp[] a6 = new Dfp[2];\n        Dfp[] a7 = new Dfp[2];\n        Dfp[] a8 = new Dfp[2];\n        Dfp[] a9 = new Dfp[2];\n        Dfp[] a10 = new Dfp[2];\n        Dfp[] a11 = new Dfp[2];\n        Dfp[] a12 = new Dfp[2];\n        Dfp[] a13 = new Dfp[2];\n        Dfp[] a14 = new Dfp[2];\n        Dfp[] a15 = new Dfp[2];\n        Dfp[] a16 = new Dfp[2];\n        Dfp[] a17 = new Dfp[2];\n        Dfp[] a18 = new Dfp[2];\n        Dfp[] a19 = new Dfp[2];\n        Dfp[] a20 = new Dfp[2];\n        Dfp[] a21 = new Dfp[2];\n        Dfp[] a22 = new Dfp[2];\n        Dfp[] a23 = new Dfp[2];\n        Dfp[] a24 = new Dfp[2];\n        Dfp[] a25 = new Dfp[2];\n        Dfp[] a26 = new Dfp[2];\n        Dfp[] a27 = new Dfp[2];\n        Dfp[] a28 = new Dfp[2];\n        Dfp[] a29 = new Dfp[2];\n        Dfp[] a30 = new Dfp[2];\n        Dfp[] a31 = new Dfp[2];\n        Dfp[] a32 = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp[] x = new Dfp[2];\n        Dfp[] x2 = new Dfp[2];\n        Dfp[] y = new Dfp[2];\n        Dfp[] a2 = new Dfp[2];\n\n        splitReciprocal(a, a2);\n        splitAdd(a2, a, x);\n        splitMult(x, a2, x);\n        splitMult(x, x, x2);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x2, a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n        }\n\n        splitMult(y, x, a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n\n        return y;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp[] x = new Dfp[2];\n        Dfp[] x2 = new Dfp[2];\n        Dfp[] y = new Dfp[2];\n        Dfp[] a2 = new Dfp[2];\n\n        split(a, x);\n\n        /* Set X = (a-1)/(a+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a2);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a2, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n\n        //x[0] -= 1.0;\n        //resplit(x);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x2, a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n        }\n\n        splitMult(y, x, a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n\n        return y;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp[] x = new Dfp[2];\n        Dfp[] x2 = new Dfp[2];\n        Dfp[] y = new Dfp[2];\n        Dfp[] a2 = new Dfp[2];\n\n        splitReciprocal(a, x);\n        splitMult(x, a, a2);\n        splitAdd(a2, x, x);\n\n        /* Set X = (x-1)/(x+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a2);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a2, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x2, a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n        }\n\n        splitMult(y, x, a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n\n        return y;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp[] x = new Dfp[2];\n        Dfp[] x2 = new Dfp[2];\n        Dfp[] y = new Dfp[2];\n        Dfp[] a2 = new Dfp[2];\n\n        splitReciprocal(a, a2);\n        splitMult(a, a2, x);\n\n        /* Set X = (x-1)/(x+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a2);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a2, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n\n        //x[0] -= 1.0;\n        //resplit(x);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x2, a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n        }\n\n        splitMult(y, x, a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n\n        return y;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp[] x = new Dfp[2];\n        Dfp[] x2 = new Dfp[2];\n        Dfp[] y = new Dfp[2];\n        Dfp[] a2 = new Dfp[2];\n\n        split(a, x);\n\n        /* Set X = (a-1)/(a+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a2);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a2, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n\n        //x[0] -= 1.0;\n        //resplit(x);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x2, a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n        }\n\n        splitMult(y, x, a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n\n        return y;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp[] x = new Dfp[2];\n        Dfp[] x2 = new Dfp[2];\n        Dfp[] y = new Dfp[2];\n        Dfp[] a2 = new Dfp[2];\n\n        splitReciprocal(a, a2);\n        splitMult(a, a2, x);\n\n        /* Set X = (x-1)/(x+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a2);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a2, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x2, a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a2);\n            y[0] = a2[0];\n            y[1] = a2[1];\n        }\n\n        splitMult(y, x, a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n\n        return y;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp[] x = new Dfp[2];\n        Dfp[] x2 = new Dfp[2];\n        Dfp[] y = new Dfp[2];\n        Dfp[] a2 = new Dfp[2];\n        Dfp[] a3 = new Dfp[2];\n        Dfp[] a4 = new Dfp[2];\n        Dfp[] a5 = new Dfp[2];\n        Dfp[] a6 = new Dfp[2];\n        Dfp[] a7 = new Dfp[2];\n        Dfp[] a8 = new Dfp[2];\n        Dfp[] a9 = new Dfp[2];\n        Dfp[] a10 = new Dfp[2];\n        Dfp[] a11 = new Dfp[2];\n        Dfp[] a12 = new Dfp[2];\n        Dfp[] a13 = new Dfp[2];\n        Dfp[] a14 = new Dfp[2];\n        Dfp[] a15 = new Dfp[2];\n        Dfp[] a16 = new Dfp[2];\n        Dfp[] a17 = new Dfp[2];\n        Dfp[] a18 = new Dfp[2];\n        Dfp[] a19 = new Dfp[2];\n        Dfp[] a20 = new Dfp[2];\n        Dfp[] a21 = new Dfp[2];\n        Dfp[] a22 = new Dfp[2];\n        Dfp[] a23 = new Dfp[2];\n        Dfp[] a24 = new Dfp[2];\n        Dfp[] a25 = new Dfp[2];\n        Dfp[] a26 = new Dfp[2];\n        Dfp[] a27 = new Dfp[2];\n        Dfp[] a28 = new Dfp[2];\n        Dfp[] a29 = new Dfp[2];\n        Dfp[] a30 = new Dfp[2];\n        Dfp[] a31 = new Dfp[2];\n        Dfp[] a32 = new Dfp[2];\n}"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        final boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            decorated().remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll != null) {\n            return coll.remove(value);\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        final boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            decorated().remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        final boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            decorated().remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = decorated().get(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() != Token.STRING) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}\n\n@Override\nNode processArrayLiteral(ArrayLiteral literalNode) {\n  if (literalNode.isDestructuring()) {\n    reportDestructuringAssign(literalNode);\n  }\n\n  Node node = newNode(Token.ARRAYLIT);\n  for (AstNode child : literalNode.getElements()) {\n    Node c = transformAsString(child);\n    node.addChildToBack(c);\n  }\n  return node;\n}\n\n@Override\nNode processAssignment(Assignment assignmentNode) {\n  Node assign = processInfixExpression(assignmentNode);\n  Node target = assign.getFirstChild();\n  if (!validAssignmentTarget(target)) {\n    errorReporter.error(\n      \"invalid assignment target\",\n      sourceName,\n      target.getLineno(), \"\", 0);\n  }\n  return assign;\n}\n\n@Override\nNode processAstRoot(AstRoot rootNode) {\n  Node node = newNode(Token.SCRIPT);\n  for (com.google.javascript.rhino.head.Node child : rootNode) {\n    node.addChildToBack(transformAsString(child));\n  }\n  parseDirectives(node);\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() != Token.STRING) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}\n\n@Override\nNode processArrayLiteral(ArrayLiteral literalNode) {\n  if (literalNode.isDestructuring()) {\n    reportDestructuringAssign(literalNode);\n  }\n\n  Node node = newNode(Token.ARRAYLIT);\n  for (AstNode child : literalNode.getElements()) {\n    Node c = transform(child);\n    node.addChildToBack(c);\n  }\n  return node;\n}\n\n@Override\nNode processAssignment(Assignment assignmentNode) {\n  Node assign = processInfixExpression(assignmentNode);\n  Node target = assign.getFirstChild();\n  if (!validAssignmentTarget(target)) {\n    errorReporter.error(\n      \"invalid assignment target\",\n      sourceName,\n      target.getLineno(), \"\", 0);\n  }\n  return assign;\n}\n\n@Override\nNode processAstRoot(AstRoot rootNode) {\n  Node node = newNode(Token.SCRIPT);\n  for (com.google.javascript.rhino.head.Node child : rootNode) {\n    node.addChildToBack(transform((AstNode) child));\n  }\n  parseDirectives(node);\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() != Token.STRING) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  } else if (node.getType() != Token.STRING) {\n    node.setType(Token.STRING);\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  } else if (node.getType() != Token.STRING) {\n    node.setType(Token.STRING);\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() != Token.STRING) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n    node.setQuotedString();\n  }\n  return node;\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        int column = dataset.getColumnIndex(category);\n        double total = 0.0;\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            Number n = dataset.getValue(row, column);\n            if (n != null) {\n                double v = n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n                result.add(new Double(v));\n            }\n        }\n        result.add(new Double(base));\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        // the list to return...\n        List result = new ArrayList();\n\n        // the total value for the stack...\n        double total = 0.0;\n\n        // the number of items in the stack...\n        int itemCount = 0;\n\n        // the maximum value in the stack...\n        double max = 0.0;\n\n        // the minimum value in the stack...\n        double min = 0.0;\n\n        // the average value in the stack...\n        double average = 0.0;\n\n        // the sum of the logarithms of the values in the stack...\n        double logTotal = 0.0;\n\n        // the number of non-null values in the stack...\n        int nonNullCount = 0;\n\n        // the range of values in the stack...\n        Range range = null;\n\n        // the minimum and maximum values in the stack...\n        double minValue = Double.POSITIVE_INFINITY;\n        double maxValue = Double.NEGATIVE_INFINITY;\n\n        // the running total for each item in the stack...\n        double runningTotal = 0.0;\n\n        // the total for each item in the stack...\n        double[] totalForItem = new double[includedRows.length];\n\n        // the number of items in each series...\n        int[] itemCountForSeries = new int[includedRows.length];\n\n        // the maximum value for each series...\n        double[] maxForSeries = new double[includedRows.length];\n\n        // the minimum value for each series...\n        double[] minForSeries = new double[includedRows.length];\n\n        // the average value for each series...\n        double[] averageForSeries = new double[includedRows.length];\n\n        // the logarithm of the total for each series...\n        double[] logTotalForSeries = new double[includedRows.length];\n\n        // the number of non-null values for each series...\n        int[] nonNullCountForSeries = new int[includedRows.length];\n\n        // the range for each series...\n        Range[] rangeForSeries = new Range[includedRows.length];\n\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        // calculate the total for the stack\n        double total = 0.0;\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            Number n = dataset.getValue(row, column);\n            if (n != null) {\n                total += n.doubleValue();\n            }\n        }\n\n        // calculate the values for each series in the stack\n        List result = new ArrayList();\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            Number n = dataset.getValue(row, column);\n            double v = 0.0;\n            if (n != null) {\n                v = n.doubleValue();\n            }\n            if (asPercentages) {\n                v = v / total;\n            }\n            result.add(new Double(v + base));\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        Number n = dataset.getValue(row, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            result.add(new Double(base + v));\n        }\n        else {\n            result.add(null);\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        Number n = dataset.getValue(row, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            result.add(new Double(v + base));\n        }\n        else {\n            result.add(null);\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // get the values for the category and series...\n    List result = new ArrayList();\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        Number n = dataset.getValue(row, column);\n        double v = 0.0;\n        if (n != null) {\n            v = n.doubleValue();\n        }\n        if (asPercentages) {\n            double total = DataUtilities.calculateColumnTotal(dataset,\n                    column);\n            v = v / total;\n        }\n        result.add(new Double(v));\n    }\n    // add the base value...\n    result.add(new Double(base));\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        int seriesCount = dataset.getColumnCount();\n        List result = new ArrayList(seriesCount);\n        for (int i = 0; i < seriesCount; i++) {\n            if (includedRows[i]) {\n                double v = base;\n                double total = 0.0;\n                if (asPercentages) {\n                    total = DataUtilities.calculateColumnTotal(dataset, i);\n                }\n                Number n = dataset.getValue(i, category);\n                if (n != null) {\n                    v += n.doubleValue();\n                    if (asPercentages) {\n                        v = v / total;\n                    }\n                }\n                result.add(new Double(v));\n            }\n            else {\n                result.add(null);\n            }\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category));\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        Number n = dataset.getValue(row, dataset.getColumnIndex(category));\n        double v = base;\n        if (n != null) {\n            v += n.doubleValue();\n        }\n        if (asPercentages) {\n            v = v / total;\n        }\n        result.add(new Double(v));\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset,\n                    dataset.getColumnIndex(category));\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            Number n = dataset.getValue(row, dataset.getColumnIndex(category));\n            double v = base;\n            if (n != null) {\n                v += n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n            }\n            result.add(new Double(v));\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    int column = dataset.getColumnIndex(category);\n    double total = 0.0;\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        Number n = dataset.getValue(row, column);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            result.add(new Double(v + base));\n            base += v;\n        }\n        else {\n            result.add(null);\n        }\n    }\n    return result;\n}"
    ],
    [
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) \n    {\n        List<Element> children = new ArrayList<>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element) \n            {\n                children.add((Element) node);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(children);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    List<Element> elements = shadowChildrenRef != null ? shadowChildrenRef.get() : null;\n    if (elements == null) \n    {\n        elements = new ArrayList<>();\n        for (Node node : ensureChildNodes()) \n        {\n            if (node instanceof Element) \n            {\n                elements.add((Element) node);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(elements);\n    }\n    return elements;\n}",
      "private List<Element> childElementsList()  {\n        if (shadowChildrenRef == null) {\n            List<Node> nodes = ensureChildNodes();\n            List<Element> elements = new ArrayList<>(nodes.size());\n            for (Node node : nodes) {\n                if (node instanceof Element) {\n                    elements.add((Element) node);\n                }\n            }\n            shadowChildrenRef = new WeakReference<>(elements);\n        }\n        return shadowChildrenRef.get();\n    }",
      "private List<Element> childElementsList()  {\n        List<Element> elements = shadowChildrenRef;\n        if (elements == null) {\n            elements = new ArrayList<>();\n            for (Node node : ensureChildNodes()) {\n                if (node instanceof Element)\n                    elements.add((Element) node);\n            }\n            shadowChildrenRef = elements;\n        }\n        return elements;\n    }",
      "private List<Element> childElementsList()  {\n    List<Element> elements = shadowChildrenRef == null ? null : shadowChildrenRef.get();\n    if (elements == null) \n    {\n        elements = new ArrayList<>();\n        for (Node node : ensureChildNodes()) \n        {\n            if (node instanceof Element) \n            {\n                elements.add((Element) node);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(elements);\n    }\n    return elements;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) \n    {\n        List<Element> children = new ArrayList<>();\n        for (Node node : ensureChildNodes()) \n        {\n            if (node instanceof Element) \n            {\n                children.add((Element) node);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(children);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n        if (shadowChildrenRef == null) {\n            List<Node> nodes = ensureChildNodes();\n            List<Element> elements = new ArrayList<>(nodes.size());\n            for (Node node : nodes) {\n                if (node instanceof Element) {\n                    elements.add((Element) node);\n                }\n            }\n            shadowChildrenRef = new WeakReference<>(elements);\n        }\n        return shadowChildrenRef.get();\n    }",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) \n    {\n        shadowChildrenRef = new WeakReference<>(new NodeList(this, childNodeSize()));\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) \n    {\n        List<Element> children = new ArrayList<>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element) \n            {\n                children.add((Element) node);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(children);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n        List<Element> elements = shadowChildrenRef;\n        if (elements == null) {\n            elements = new ArrayList<>();\n            for (Node node : ensureChildNodes()) {\n                if (node instanceof Element)\n                    elements.add((Element) node);\n            }\n            shadowChildrenRef = elements;\n        }\n        return elements;\n    }"
    ],
    [
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return Math.abs(hash % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return Math.abs(hash % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r - c >= k) \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r - c < k) \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r - c < k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r - c < k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r - c >= k) \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r + k <= c) \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r - c > k) \n            {\n                d[r][c] = 0;\n            } \n            else \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r < c - k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r - c >= k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r - c >= k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n            switch (skew) {\n            case LEFT_HIGH:\n                skew = Skew.BALANCED;\n                return true;\n            case RIGHT_HIGH:\n                if (right.skew == Skew.RIGHT_HIGH) {\n                    rotateCCW();\n                    skew      = Skew.BALANCED;\n                    left.skew = Skew.BALANCED;\n                    return true;\n                } else if (right.skew == Skew.BALANCED) {\n                    rotateCCW();\n                    skew      = Skew.LEFT_HIGH;\n                    left.skew = Skew.RIGHT_HIGH;\n                    return false;\n                } else {\n                    final Skew s = right.left.skew;\n                    right.rotateCW();\n                    rotateCCW();\n                    switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                    }\n                    skew = Skew.BALANCED;\n                    return true;\n                }\n            default:\n                skew = Skew.RIGHT_HIGH;\n                return false;\n            }\n        }",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n            switch (skew) {\n            case LEFT_HIGH:\n                skew = Skew.BALANCED;\n                return true;\n            case RIGHT_HIGH:\n                if (right.skew == Skew.RIGHT_HIGH) {\n                    rotateCCW();\n                    skew      = Skew.BALANCED;\n                    left.skew = Skew.BALANCED;\n                    return true;\n                } else if (right.skew == Skew.BALANCED) {\n                    rotateCCW();\n                    skew      = Skew.LEFT_HIGH;\n                    left.skew = Skew.RIGHT_HIGH;\n                    return false;\n                } else {\n                    final Skew s = right.left.skew;\n                    right.rotateCW();\n                    rotateCCW();\n                    switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                    }\n                    skew = Skew.BALANCED;\n                    return true;\n                }\n            default:\n                skew = Skew.RIGHT_HIGH;\n                return false;\n            }\n        }",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) {\n            rotateCCW();\n            skew      = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n            return true;\n        } else if (right.skew == Skew.BALANCED) {\n            rotateCCW();\n            skew      = Skew.LEFT_HIGH;\n            left.skew = Skew.RIGHT_HIGH;\n            return false;\n        } else {\n            final Skew s = right.left.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        }\n    default:\n        skew = Skew.RIGHT_HIGH;\n        return false;\n    }\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // check for negligible elements\n    for (int i = startIdx; i < matrixT.length; i++) {\n        if (FastMath.abs(matrixT[i][i]) + norm == norm) {\n            return i;\n        }\n    }\n\n    return matrixT.length - 1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n        int im = startIdx;\n        while (im > 0) {\n            final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n            final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) +\n                                                        FastMath.abs(z) +\n                                                        FastMath.abs(matrixT[im + 1][im + 1]));\n\n            if (lhs < epsilon * rhs) {\n                break;\n            }\n            im--;\n        }\n\n        return im;\n    }",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // check for small sub-diagonal element\n    for (int i = startIdx; i < matrixT.length; i++) {\n        if (FastMath.abs(matrixT[i][i]) <= epsilon * norm) {\n            return i;\n        }\n    }\n\n    return matrixT.length - 1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    final int n = matrixT.length;\n    int idx = startIdx;\n    while (idx < n - 1) {\n        final double lhs = FastMath.abs(matrixT[idx][idx]) * (FastMath.abs(matrixT[idx + 1][idx]) + FastMath.abs(matrixT[idx + 2][idx]));\n        final double rhs = FastMath.abs(matrixT[idx][idx + 1]) * (FastMath.abs(matrixT[idx][idx]) + FastMath.abs(matrixT[idx + 1][idx + 1]) + FastMath.abs(matrixT[idx + 2][idx + 2]));\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    final int n = matrixT.length;\n    int im = startIdx;\n    while (im >= 0) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) +\n                                                    FastMath.abs(z) +\n                                                    FastMath.abs(matrixT[im + 1][im + 1]));\n\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im--;\n    }\n\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n        int im = startIdx;\n        while (im >= 0) {\n            // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n            final double lhs = FastMath.abs(matrixT[im][im]) + FastMath.abs(matrixT[im + 1][im]);\n            final double rhs = norm * epsilon;\n\n            if (lhs < rhs) {\n                break;\n            }\n            im--;\n        }\n\n        return im;\n    }",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx > 0) {\n        final double lhs = FastMath.abs(matrixT[idx][idx - 1]);\n        final double rhs = norm * epsilon;\n        if (lhs <= rhs) {\n            break;\n        }\n        idx--;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // check for quick return\n    if (norm == 0.0) {\n        return startIdx;\n    }\n\n    // search for small sub-diagonal element\n    for (int i = startIdx; i < matrixT.length; i++) {\n        if (FastMath.abs(matrixT[i][i]) <= epsilon * norm) {\n            return i;\n        }\n    }\n\n    return matrixT.length - 1;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    final int n = matrixT.length;\n    int idx = startIdx;\n    while (idx > 0) {\n        // check for negligible elements\n        if (FastMath.abs(matrixT[idx][idx - 1]) < epsilon * norm) {\n            break;\n        }\n        idx--;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    while (im > 0) {\n        // check for negligible elements\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) +\n                                                    FastMath.abs(z) +\n                                                    FastMath.abs(matrixT[im + 1][im + 1]));\n\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im--;\n    }\n\n    return im;\n}"
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n        Node candidate = null;\n        for (Node node = top; node != null;) {\n            if (node.element.compareTo(reference) < 0) {\n                if (node.right == null) {\n                    return candidate;\n                }\n                node = node.right;\n            } else {\n                candidate = node;\n                if (node.left == null) {\n                    return candidate;\n                }\n                node = node.left;\n            }\n        }\n        return null;\n    }",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n        Node candidate = null;\n        for (Node node = top; node != null;) {\n            if (node.element.compareTo(reference) < 0) {\n                if (node.right == null) {\n                    return candidate;\n                }\n                node = node.right;\n            } else {\n                candidate = node;\n                if (node.left == null) {\n                    return candidate;\n                }\n                node = node.left;\n            }\n        }\n        return null;\n    }",
      "public Node getNotSmaller(final T reference)  {\n        Node candidate = null;\n        for (Node node = top; node != null;) {\n            if (node.element.compareTo(reference) < 0) {\n                if (node.right == null) {\n                    return candidate;\n                }\n                node = node.right;\n            } else {\n                candidate = node;\n                if (node.left == null) {\n                    return candidate;\n                }\n                node = node.left;\n            }\n        }\n        return null;\n    }",
      "public Node getNotSmaller(final T reference)  {\n        Node candidate = null;\n        for (Node node = top; node != null;) {\n            if (node.element.compareTo(reference) < 0) {\n                if (node.right == null) {\n                    return candidate;\n                }\n                node = node.right;\n            } else {\n                candidate = node;\n                if (node.left == null) {\n                    return candidate;\n                }\n                node = node.left;\n            }\n        }\n        return null;\n    }",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        while (index >= 0) {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        while (index >= 0) {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        while (index >= 0) {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        while (index >= 0) {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n    irNode = maybeInjectCastNode(node, node.getJSDocInfo(), irNode);\n  }\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n    JSDocInfo info = handleJsDoc(node, irNode);\n    if (info != null) {\n      irNode.setJSDocInfo(info);\n    }\n  }\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n    JSDocInfo info = handleJsDoc(node, irNode);\n    if (info != null) {\n      irNode.setJSDocInfo(info);\n    }\n  }\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n    JSDocInfo info = handleJsDoc(node, irNode);\n    if (info != null) {\n      irNode.setJSDocInfo(info);\n    }\n  }\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n    irNode.setJSType(getDeclaredType(node.getJSDocInfo(), node, null));\n  }\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n    JSDocInfo info = handleJsDoc(node, irNode);\n    if (info != null) {\n      irNode.setJSDocInfo(info);\n    }\n  }\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n    JSDocInfo info = node.getJSDocInfo();\n    if (info != null) {\n      irNode.setJSDocInfo(info);\n    }\n  }\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n    JSDocInfo info = node.getJSDocInfo();\n    if (info != null) {\n      Node newNode = newNode(Token.NAME, node.getString());\n      newNode.setJSDocInfo(info);\n      return newNode;\n    }\n  }\n  return transform(node);\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  if (node.getType() == com.google.javascript.rhino.head.Token.NAME) {\n    JSDocInfo info = node.getJSDocInfo();\n    if (info != null) {\n      irNode.setJSType(info.getType());\n    }\n  }\n  return irNode;\n}"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>(list));\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>(list));\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>(list));\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>(list));\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    if (elementTypeList == null)\n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n  Node elementTypeList = parseElementTypeList(token);\n  if (elementTypeList == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n  arrayType.addChildToBack(elementTypeList);\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n  Node elementTypeList = parseElementTypeList(token);\n\n  if (elementTypeList == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  arrayType.addChildToBack(elementTypeList);\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n\n  do {\n    Node elementType = parseTypeExpression(token);\n\n    if (elementType == null) {\n      return null;\n    }\n\n    arrayType.addChildToBack(elementType);\n\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n      break;\n    }\n\n    // Move to the comma token.\n    next();\n\n    // Move to the token passed the comma.\n    skipEOLs();\n    token = next();\n  } while (true);\n\n  skipEOLs();\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n\n  next();\n\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n\n  if (token == JsDocToken.ELLIPSIS) {\n    token = next();\n    if (token == JsDocToken.RB) {\n      // EMPTY represents the UNKNOWN type in the Type AST.\n      return wrapNode(Token.ELLIPSIS, IR.empty());\n    }\n    arrayType.addChildToBack(wrapNode(Token.ELLIPSIS, parseTypeExpression(token)));\n  } else {\n    Node elementType = parseTypeExpression(token);\n    if (elementType == null) {\n      return null;\n    }\n    arrayType.addChildToBack(elementType);\n\n    while (match(JsDocToken.COMMA)) {\n      next();\n      skipEOLs();\n      token = next();\n      if (token == JsDocToken.ELLIPSIS) {\n        token = next();\n        if (token == JsDocToken.RB) {\n          // EMPTY represents the UNKNOWN type in the Type AST.\n          arrayType.addChildToBack(wrapNode(Token.ELLIPSIS, IR.empty()));\n          break;\n        }\n        arrayType.addChildToBack(wrapNode(Token.ELLIPSIS, parseTypeExpression(token)));\n      } else {\n        Node elementType = parseTypeExpression(token);\n        if (elementType == null) {\n          return null;\n        }\n        arrayType.addChildToBack(elementType);\n      }\n    }\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n\n  next();\n\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n  Node elementTypeList = parseElementTypeList(token);\n  if (elementTypeList == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n  arrayType.addChildToBack(elementTypeList);\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n  if (token == JsDocToken.ELLIPSIS) {\n    token = next();\n    if (token == JsDocToken.RB) {\n      // EMPTY represents the UNKNOWN type in the Type AST.\n      return wrapNode(Token.ELLIPSIS, IR.empty());\n    }\n    Node typeExpression = parseTypeExpression(token);\n    if (typeExpression != null) {\n      arrayType.addChildToBack(typeExpression);\n      skipEOLs();\n      if (!match(JsDocToken.RB)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n      } else {\n        next();\n      }\n    }\n  } else {\n    Node typeExpression = parseTypeExpression(token);\n    if (typeExpression != null) {\n      arrayType.addChildToBack(typeExpression);\n      skipEOLs();\n      if (match(JsDocToken.COMMA)) {\n        next();\n        skipEOLs();\n        token = next();\n        if (token == JsDocToken.ELLIPSIS) {\n          token = next();\n          if (token == JsDocToken.RB) {\n            // EMPTY represents the UNKNOWN type in the Type AST.\n            return wrapNode(Token.ELLIPSIS, IR.empty());\n          }\n          Node typeExpression = parseTypeExpression(token);\n          if (typeExpression != null) {\n            arrayType.addChildToBack(typeExpression);\n            skipEOLs();\n            if (!match(JsDocToken.RB)) {\n              reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n            } else {\n              next();\n            }\n          }\n        } else {\n          while (match(JsDocToken.COMMA)) {\n            next();\n            skipEOLs();\n            token = next();\n            typeExpression = parseTypeExpression(token);\n            if (typeExpression != null) {\n              arrayType.addChildToBack(typeExpression);\n            } else {\n              return reportGenericTypeSyntaxWarning();\n            }\n}\n}\n}\n}\n}\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n\n  do {\n    Node elementType = parseTypeExpression(token);\n\n    if (elementType == null) {\n      return null;\n    }\n\n    arrayType.addChildToBack(elementType);\n\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n      break;\n    }\n\n    // Move to the comma token.\n    next();\n\n    // Move to the token passed the comma.\n    skipEOLs();\n    token = next();\n  } while (true);\n\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n\n  next();\n\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n\n  if (token != JsDocToken.RB) {\n    do {\n      Node elementType = parseTypeExpression(token);\n      if (elementType == null) {\n        return null;\n      }\n\n      arrayType.addChildToBack(elementType);\n\n      skipEOLs();\n      if (!match(JsDocToken.COMMA)) {\n        break;\n      }\n\n      // Move to the comma token.\n      next();\n\n      // Move to the token passed the comma.\n      skipEOLs();\n      token = next();\n    } while (true);\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n\n  next();\n\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    if (elementTypeList == null)\n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n}"
    ],
    [
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n        return new Vector3D(1, 0, 0);\n    } else if (q0 < 0) {\n        return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                            q2 / FastMath.sqrt(squaredSine),\n                            q3 / FastMath.sqrt(squaredSine));\n    }\n    return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                        q2 / FastMath.sqrt(squaredSine),\n                        q3 / FastMath.sqrt(squaredSine));\n}",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n        return new Vector3D(1, 0, 0);\n    } else if (q0 < 0) {\n        return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                            q2 / FastMath.sqrt(squaredSine),\n                            q3 / FastMath.sqrt(squaredSine));\n    }\n    return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                        q2 / FastMath.sqrt(squaredSine),\n                        q3 / FastMath.sqrt(squaredSine)).negate();\n}",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n        return new Vector3D(1, 0, 0);\n    } else if (q0 < 0) {\n        return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                            q2 / FastMath.sqrt(squaredSine),\n                            q3 / FastMath.sqrt(squaredSine));\n    }\n    return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                        q2 / FastMath.sqrt(squaredSine),\n                        q3 / FastMath.sqrt(squaredSine));\n}",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n        return new Vector3D(1, 0, 0);\n    } else if (q0 < 0) {\n        return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                            q2 / FastMath.sqrt(squaredSine),\n                            q3 / FastMath.sqrt(squaredSine));\n    }\n    return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                        q2 / FastMath.sqrt(squaredSine),\n                        q3 / FastMath.sqrt(squaredSine)).negate();\n}",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n        return new Vector3D(1, 0, 0);\n    } else if (q0 < 0) {\n        return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                            q2 / FastMath.sqrt(squaredSine),\n                            q3 / FastMath.sqrt(squaredSine));\n    }\n    return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                        q2 / FastMath.sqrt(squaredSine),\n                        q3 / FastMath.sqrt(squaredSine)).negate();\n}",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n        return new Vector3D(1, 0, 0);\n    } else if (q0 < 0) {\n        return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                            q2 / FastMath.sqrt(squaredSine),\n                            q3 / FastMath.sqrt(squaredSine));\n    }\n    return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                        q2 / FastMath.sqrt(squaredSine),\n                        q3 / FastMath.sqrt(squaredSine)).negate();\n}",
      "public Vector3D getAxis()  {\n    final double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n        return new Vector3D(1, 0, 0);\n    } else if (q0 < 0) {\n        return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                            q2 / FastMath.sqrt(squaredSine),\n                            q3 / FastMath.sqrt(squaredSine));\n    }\n    return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                        q2 / FastMath.sqrt(squaredSine),\n                        q3 / FastMath.sqrt(squaredSine));\n}",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n        return new Vector3D(1, 0, 0);\n    } else if (q0 < 0) {\n        return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                            q2 / FastMath.sqrt(squaredSine),\n                            q3 / FastMath.sqrt(squaredSine));\n    }\n    return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                        q2 / FastMath.sqrt(squaredSine),\n                        q3 / FastMath.sqrt(squaredSine));\n}",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n        return new Vector3D(1, 0, 0);\n    } else if (q0 < 0) {\n        return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                            q2 / FastMath.sqrt(squaredSine),\n                            q3 / FastMath.sqrt(squaredSine));\n    }\n    return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                        q2 / FastMath.sqrt(squaredSine),\n                        q3 / FastMath.sqrt(squaredSine)).negate();\n}",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n        return new Vector3D(1, 0, 0);\n    } else if (q0 < 0) {\n        return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                            q2 / FastMath.sqrt(squaredSine),\n                            q3 / FastMath.sqrt(squaredSine));\n    }\n    return new Vector3D(q1 / FastMath.sqrt(squaredSine),\n                        q2 / FastMath.sqrt(squaredSine),\n                        q3 / FastMath.sqrt(squaredSine)).negate();\n}"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    final byte b1 = (byte) parseHexByte(bytes, i + 1);\n                    final byte b2 = (byte) parseHexByte(bytes, i + 3);\n                    buffer.write((b1 << 4) + b2);\n                    i += 3;\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding: \", e);\n                }\n            } else {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                final byte b1 = bytes[++i];\n                final byte b2 = bytes[++i];\n                b = (HEX_DECODING[(b1 >> 4) & 0xf] << 4) + HEX_DECODING[b1 & 0xf];\n                b = (b << 4) + HEX_DECODING[(b2 >> 4) & 0xf];\n                b = (b << 4) + HEX_DECODING[b2 & 0xf];\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final byte b1 = (byte) Character.digit((char) bytes[++i], RADIX);\n                final byte b2 = (byte) Character.digit((char) bytes[++i], RADIX);\n                b = (b1 << 4 | b2);\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final byte b1 = (byte) Character.digit((char) bytes[++i], RADIX);\n                final byte b2 = (byte) Character.digit((char) bytes[++i], RADIX);\n                b = (b1 << 4 | b2);\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    final byte b1 = bytes[++i];\n                    final byte b2 = bytes[++i];\n                    b = (Hex.decodeHex(new char[] {(char) b1, (char) b2})[0] & 0xFF);\n                } catch (final DecoderException e) {\n                    throw new DecoderException(\"Invalid URL encoding: \", e);\n                }\n            }\n            buffer.write(b);\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final byte b1 = java.lang.Byte.decode(\"0x\" + new String(bytes, i + 1, 2, \"UTF-8\")).byteValue();\n                buffer.write(b1);\n                i += 2;\n                continue;\n            } catch (final Exception e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final byte b1 = (byte) Character.digit((char) bytes[++i], RADIX);\n                final byte b2 = (byte) Character.digit((char) bytes[++i], RADIX);\n                b = (b1 << 4 | b2);\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final byte b1 = bytes[++i];\n                final byte b2 = bytes[++i];\n                b = (byte) ((b1 - 65) * 16 + (b2 - 65));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final byte b1 = java.lang.Byte.decode(\"0x\" + new String(bytes, i + 1, 2)).byteValue();\n                buffer.write(b1);\n                i += 2;\n                continue;\n            } catch (final NumberFormatException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    final byte b1 = (byte) Character.digit((char) bytes[++i], RADIX);\n                    final byte b2 = (byte) Character.digit((char) bytes[++i], RADIX);\n                    b = (b1 << 4 | b2);\n                    if (b < 0) {\n                        b = 256 + b;\n                    }\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding: \", e);\n                }\n            }\n            buffer.write(b);\n        }\n        return buffer.toByteArray();\n    }"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    Chronology chrono = partial.getChronology();\n    DateTimeFieldType[] types = new DateTimeFieldType[size];\n    for (int i = 0; i < size; i++) {\n        types[i] = partial.getFieldType(i);\n    }\n    for (int i = 1; i < size; i++) {\n        DateTimeFieldType type = types[i - 1];\n        DateTimeFieldType nextType = types[i];\n        if (type.getDurationType() != nextType) {\n            return false;\n        }\n        DurationField field = chrono.fields().get(type);\n        DurationField nextField = chrono.fields().get(nextType);\n        if (field.getUnitMillis() != nextField.getUnitMillis()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    List<DateTimeFieldType> types = partial.getFieldTypes();\n    int size = types.size();\n    if (size == 0) {\n        return false;\n    }\n    DateTimeFieldType type = types.get(0);\n    DateTimeFieldType nextType = types.get(1);\n    if (type.getRangeDurationType() != nextType) {\n        return false;\n    }\n    for (int i = 1; i < size; i++) {\n        type = types.get(i);\n        nextType = types.get(i + 1);\n        if (type.getRangeDurationType() != nextType) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size == 0) {\n        return false;\n    }\n    DateTimeFieldType[] types = new DateTimeFieldType[size];\n    for (int i = 0; i < size; i++) {\n        types[i] = partial.getFieldType(i);\n    }\n    for (int i = 0; i < size - 1; i++) {\n        DateTimeFieldType type = types[i];\n        DateTimeFieldType nextType = types[i + 1];\n        if (type.getRangeDurationField() != nextType) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeFieldType[] types = partial.getFieldTypes();\n    DateTimeFieldType previous = types[size - 1];\n    for (int i = size - 2; i >= 0; i--) {\n        DateTimeFieldType current = types[i];\n        if (previous.getRangeDurationField() != current) {\n            return false;\n        }\n        previous = current;\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    if (partial.size() < 2) {\n        return true;\n    }\n    DateTimeFieldType[] types = partial.getFieldTypes();\n    DateTimeFieldType range = types[0].getRangeDurationField().getType();\n    for (int i = 1; i < types.length; i++) {\n        if (types[i] != range) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size == 0) {\n        return false;\n    }\n    DateTimeFieldType lastType = partial.getFieldType(size - 1);\n    DateTimeFieldType firstType = partial.getFieldType(0);\n    if (lastType == null || firstType == null) {\n        return false;\n    }\n    DurationField lastRange = lastType.getDurationType().getRangeDurationField();\n    DurationField firstRange = firstType.getDurationType().getRangeDurationField();\n    if (lastRange == null || firstRange == null) {\n        return false;\n    }\n    return lastRange.equals(firstRange);\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size == 0) {\n        return false;\n    }\n    DateTimeFieldType lastType = partial.getFieldType(size - 1);\n    DateTimeFieldType thisType = partial.getFieldType(0);\n    if (thisType.getRangeDurationField() != lastType) {\n        return false;\n    }\n    for (int i = 1; i < size; i++) {\n        thisType = partial.getFieldType(i);\n        if (thisType.getRangeDurationField() != lastType) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeFieldType[] types = partial.getFieldTypes();\n    for (int i = 1; i < size; i++) {\n        if (types[i - 1].getRangeDurationField() != types[i]) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    if (partial.size() < 2) {\n        return true;\n    }\n    DurationFieldType lastType = partial.getFieldType(partial.size() - 1);\n    DurationFieldType nextType = partial.getFieldType(0);\n    if (lastType.getRangeDurationField() != nextType) {\n        return false;\n    }\n    return isContiguous(partial.subtract(1));\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial must not be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeFieldType[] types = partial.getFieldTypes();\n    for (int i = 1; i < size; i++) {\n        if (types[i - 1].getRangeDurationField() != types[i]) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Collection<O> result = new ArrayList<O>();\n    for (final O element : a) {\n        result.add(element);\n    }\n    for (final O element : b) {\n        result.add(element);\n    }\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final ArrayList<O> list = new ArrayList<O>();\n    final HashBag<O> bag = new HashBag<O>();\n    for (final O element : a) {\n        bag.add(element);\n    }\n    for (final O element : b) {\n        if (!bag.remove(element, 1)) {\n            list.add(element);\n        }\n    }\n    list.addAll(bag.uniqueSet());\n    return list;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final ArrayList<O> list = new ArrayList<O>();\n    final HashBag<O> bag = new HashBag<O>();\n    for (final O element : a) {\n        bag.add(element);\n    }\n    for (final O element : b) {\n        if (!bag.remove(element, 1)) {\n            list.add(element);\n        }\n    }\n    return list;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node child = params.getFirstChild();\n       child != null;\n       child = child.getNext()) {\n    strings.add(Node.newString(child.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> strings = Lists.newArrayList();\n  for (Node param : params.children()) {\n    Preconditions.checkArgument(param.isStringKey());\n    strings.add(param.cloneNode());\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> strings = Lists.newArrayList();\n  for (Node child = params.getFirstChild(); child != null; child = child.getNext()) {\n    if (child.isName()) {\n      strings.add(NodeUtil.newString(child.getString()));\n    }\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = Lists.newArrayList();\n  for (Node param = params.getFirstChild();\n       param != null;\n       param = param.getNext()) {\n    if (param.isName()) {\n      strings.add(new StringNode(Token.STRING, param.getString()));\n    }\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param : params.children()) {\n    strings.add(NodeUtil.newString(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = Lists.newArrayList();\n  for (Node param = params.getFirstChild(); param != null;\n      param = param.getNext()) {\n    if (param.isName()) {\n      strings.add(Node.newString(param.getString()));\n    } else if (param.isDefaultValue()) {\n      strings.add(Node.newString(param.getFirstChild().getString()));\n    }\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> strings = Lists.newArrayList();\n  for (Node child = params.getFirstChild(); child != null; child = child.getNext()) {\n    if (child.isString()) {\n      strings.add(child);\n    }\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> strings = Lists.newArrayList();\n  for (Node param = params.getFirstChild();\n      param != null;\n      param = param.getNext()) {\n    if (param.isString()) {\n      strings.add(param);\n    }\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  Preconditions.checkArgument(params.isParamList());\n  List<Node> strings = Lists.newArrayList();\n  for (Node child = params.getFirstChild();\n       child != null;\n       child = child.getNext()) {\n    if (child.isName()) {\n      strings.add(NodeUtil.newString(child.getString()));\n    } else {\n      throw new IllegalArgumentException(\"Expected NAME node but got \" +\n          child.toStringTree());\n    }\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = Lists.newArrayList();\n  for (Node param = params.getFirstChild();\n       param != null;\n       param = param.getNext()) {\n    strings.add(new StringNode(Token.STRING, param.getString()));\n  }\n  return strings;\n}"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    return capitalize(str, delimiters);\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    String newId = (String) cZoneIdConversion.get(id);\n    if (newId == null) \n    {\n        newId = id;\n    }\n    return newId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"EST\", \"America/New_York\");\n        cZoneIdConversion.put(\"EDT\", \"America/New_York\");\n        cZoneIdConversion.put(\"CST\", \"America/Chicago\");\n        cZoneIdConversion.put(\"CDT\", \"America/Chicago\");\n        cZoneIdConversion.put(\"MST\", \"America/Denver\");\n        cZoneIdConversion.put(\"MDT\", \"America/Denver\");\n        cZoneIdConversion.put(\"PST\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"PDT\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"GMT\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"UTC\", \"Etc/UTC\");\n        cZoneIdConversion.put(\"WET\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"WST\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"CET\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"MET\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"MEWT\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"MEST\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"CEST\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"EET\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"EEST\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"MSK\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"MSD\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"IST\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"IDT\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"GST\", \"Etc/GMT\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"WET\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"WEST\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"CET\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"MET\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"MIT\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"EET\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"EEST\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"MSK\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"MSD\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"AST\", \"America/Anchorage\");\n        cZoneIdConversion.put(\"ADT\", \"America/Anchorage\");\n        cZoneIdConversion.put(\"AWT\", \"America/Anchorage\");\n        cZoneIdConversion.put(\"AST\", \"America/Anchorage\");\n        cZoneIdConversion.put(\"NST\", \"America/St_Johns\");\n        cZoneIdConversion.put(\"NDT\", \"America/St_Johns\");\n        cZoneIdConversion.put(\"YST\", \"America/Yakutat\");\n        cZoneIdConversion.put(\"YDT\", \"America/Yakutat\");\n        cZoneIdConversion.put(\"HST\", \"Pacific/Honolulu\");\n        cZoneIdConversion.put(\"HDT\", \"Pacific/Honolulu\");\n        cZoneIdConversion.put(\"CAT\", \"America/St_Johns\");\n        cZoneIdConversion.put(\"SAST\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"EAST\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"GST\", \"Etc/GMT\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    String newId = (String)cZoneIdConversion.get(id);\n    if (newId == null) \n    {\n        newId = id;\n    }\n    return newId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    String newId = null;\n    if (cZoneIdConversion == null) {\n        cZoneIdConversion = new HashMap<String, String>();\n        for (String oldId : cAvailableIDs) {\n            if (oldId.startsWith(\"GMT\") || oldId.startsWith(\"UTC\")) {\n                String newId = oldId.replace(\"GMT\", \"UTC\");\n                cZoneIdConversion.put(oldId, newId);\n            }\n        }\n    }\n    newId = cZoneIdConversion.get(id);\n    if (newId == null) {\n        newId = id;\n    }\n    return newId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    if (cZoneIdConversion == null) {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"EST\", \"America/New_York\");\n        cZoneIdConversion.put(\"MST\", \"America/Denver\");\n        cZoneIdConversion.put(\"HST\", \"Pacific/Honolulu\");\n        cZoneIdConversion.put(\"ACT\", \"Australia/Darwin\");\n        cZoneIdConversion.put(\"AET\", \"Australia/Sydney\");\n        cZoneIdConversion.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n        cZoneIdConversion.put(\"ART\", \"Africa/Cairo\");\n        cZoneIdConversion.put(\"AST\", \"America/Halifax\");\n        cZoneIdConversion.put(\"BET\", \"America/Sao_Paulo\");\n        cZoneIdConversion.put(\"BST\", \"Europe/London\");\n        cZoneIdConversion.put(\"CAT\", \"Africa/Harare\");\n        cZoneIdConversion.put(\"CNT\", \"America/St_Johns\");\n        cZoneIdConversion.put(\"CST\", \"America/Chicago\");\n        cZoneIdConversion.put(\"CTT\", \"Asia/Shanghai\");\n        cZoneIdConversion.put(\"EAT\", \"Africa/Addis_Ababa\");\n        cZoneIdConversion.put(\"ECT\", \"Europe/Paris\");\n        cZoneIdConversion.put(\"IET\", \"America/Indiana/Indianapolis\");\n        cZoneIdConversion.put(\"IST\", \"Asia/Kolkata\");\n        cZoneIdConversion.put(\"JST\", \"Asia/Tokyo\");\n        cZoneIdConversion.put(\"MIT\", \"Pacific/Apia\");\n        cZoneIdConversion.put(\"NET\", \"Asia/Yerevan\");\n        cZoneIdConversion.put(\"NST\", \"Pacific/Auckland\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"WET\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"BST\", \"Europe/London\");\n        cZoneIdConversion.put(\"IST\", \"Asia/Kolkata\");\n        cZoneIdConversion.put(\"EST\", \"America/New_York\");\n        cZoneIdConversion.put(\"EDT\", \"America/New_York\");\n        cZoneIdConversion.put(\"CST\", \"America/Chicago\");\n        cZoneIdConversion.put(\"CDT\", \"America/Chicago\");\n        cZoneIdConversion.put(\"MST\", \"America/Denver\");\n        cZoneIdConversion.put(\"MDT\", \"America/Denver\");\n        cZoneIdConversion.put(\"PST\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"PDT\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"ACT\", \"Australia/Darwin\");\n        cZoneIdConversion.put(\"ADE\", \"Australia/Darwin\");\n        cZoneIdConversion.put(\"ACW\", \"Australia/Eucla\");\n        cZoneIdConversion.put(\"ACST\", \"Australia/Adelaide\");\n        cZoneIdConversion.put(\"ACDT\", \"Australia/Adelaide\");\n        cZoneIdConversion.put(\"NFT\", \"Pacific/Norfolk\");\n        cZoneIdConversion.put(\"SST\", \"Pacific/Midway\");\n        cZoneIdConversion.put(\"SST\", \"Pacific/Samoa\");\n        cZoneIdConversion.put(\"HST\", \"Pacific/Honolulu\");\n        cZoneIdConversion.put(\"TAHT\", \"Pacific/Tahiti\");\n        cZoneIdConversion.put(\"MIT\", \"Pacific/Apia\");\n        cZoneIdConversion.put(\"SST\", \"Pacific/Samoa\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"EST\", \"America/New_York\");\n        cZoneIdConversion.put(\"EDT\", \"America/New_York\");\n        cZoneIdConversion.put(\"CST\", \"America/Chicago\");\n        cZoneIdConversion.put(\"CDT\", \"America/Chicago\");\n        cZoneIdConversion.put(\"MST\", \"America/Denver\");\n        cZoneIdConversion.put(\"MDT\", \"America/Denver\");\n        cZoneIdConversion.put(\"PST\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"PDT\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"GMT\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"UTC\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"UT\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"Z\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"WET\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"WST\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"CET\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"MET\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"MEWT\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"MEST\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"CEST\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"MESZ\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"FWT\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"FST\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"EET\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"EEST\", \"Etc/GMT\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    if (cZoneIdConversion == null) {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"EST\", \"America/New_York\");\n        cZoneIdConversion.put(\"EDT\", \"America/New_York\");\n        cZoneIdConversion.put(\"CST\", \"America/Chicago\");\n        cZoneIdConversion.put(\"CDT\", \"America/Chicago\");\n        cZoneIdConversion.put(\"MST\", \"America/Denver\");\n        cZoneIdConversion.put(\"MDT\", \"America/Denver\");\n        cZoneIdConversion.put(\"PST\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"PDT\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"GMT\", \"Europe/London\");\n        cZoneIdConversion.put(\"IST\", \"Europe/Dublin\");\n        cZoneIdConversion.put(\"BST\", \"Europe/Dublin\");\n        cZoneIdConversion.put(\"WET\", \"Europe/Lisbon\");\n        cZoneIdConversion.put(\"WEST\", \"Europe/Lisbon\");\n        cZoneIdConversion.put(\"CET\", \"Europe/Paris\");\n        cZoneIdConversion.put(\"MET\", \"Europe/Paris\");\n        cZoneIdConversion.put(\"CEST\", \"Europe/Paris\");\n        cZoneIdConversion.put(\"MEST\", \"Europe/Paris\");\n        cZoneIdConversion.put(\"EET\", \"Europe/Helsinki\");\n        cZoneIdConversion.put(\"EEST\", \"Europe/Helsinki\");\n        cZoneIdConversion.put(\"MSK\", \"Europe/Moscow\");\n        cZoneIdConversion.put(\"MSD\", \"Europe/Moscow\");\n        cZoneIdConversion.put(\"AST\", \"America/Halifax\");\n        cZoneIdConversion.put(\"ADT\", \"America/Halifax\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    if (cZoneIdConversion == null) {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"GMT\", \"UTC\");\n        cZoneIdConversion.put(\"UTC\", \"UTC\");\n        cZoneIdConversion.put(\"WET\", \"WET\");\n        cZoneIdConversion.put(\"BST\", \"BST\");\n        cZoneIdConversion.put(\"MET\", \"CET\");\n        cZoneIdConversion.put(\"MEST\", \"CEST\");\n        cZoneIdConversion.put(\"MESZ\", \"CEST\");\n        cZoneIdConversion.put(\"MET DST\", \"CEST\");\n        cZoneIdConversion.put(\"MEST DST\", \"CEST\");\n        cZoneIdConversion.put(\"MESZ DST\", \"CEST\");\n        cZoneIdConversion.put(\"Mitteleurop\u00e4ische Sommerzeit\", \"CEST\");\n        cZoneIdConversion.put(\"Mitteleurop\u00e4ische Sommerzeit DST\", \"CEST\");\n        cZoneIdConversion.put(\"Mitteleurop\u00e4ische Zeit\", \"CET\");\n        cZoneIdConversion.put(\"Mitteleurop\u00e4ische Zeit DST\", \"CEST\");\n        cZoneIdConversion.put(\"Oesterreichische Sommerzeit\", \"CEST\");\n        cZoneIdConversion.put(\"Oesterreichische Sommerzeit DST\", \"CEST\");\n        cZoneIdConversion.put(\"Oesterreichische Zeit\", \"CET\");\n        cZoneIdConversion.put(\"Oesterreichische Zeit DST\", \"CEST\");\n        cZoneIdConversion.put(\"West-Europa (La Plata) Sommerzeit\", \"CEST\");\n        cZoneIdConversion.put(\"West-Europa (La Plata) Sommerzeit DST\", \"CEST\");\n        cZoneIdConversion.put(\"West-Europa (La Plata) Zeit\", \"CET\");\n        cZoneIdConversion.put(\"West-Europa (La Plata) Zeit DST\", \"CEST\");\n}\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Compute the Jacobian matrix.\n    final double[][] jacobian = jF.value(params);\n\n    // Compute the weighted Jacobian.\n    final RealMatrix weightedJacobian = new Array2DRowRealMatrix(jacobian);\n    weightedJacobian.multiply(weightMatrixSqrt);\n\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // TODO: Implement this method\n    return null;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Get the weight matrix.\n    RealMatrix weightMatrix = getWeightSquareRoot();\n    // Compute the Jacobian.\n    RealMatrix jacobian = computeJacobian(params);\n    // Return the weighted Jacobian.\n    return weightMatrix.multiply(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix weightedJacobian = computeWeightMatrixSqrt().multiply(jF.computeJacobian(params));\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // compute the Jacobian matrix\n    final double[][] jacobian = jF.value(params);\n    final int nR = jacobian.length;\n    final int nC = jacobian[0].length;\n    // weighted Jacobian\n    final double[][] weightedJacobian = new double[nR][nC];\n    // weight matrix\n    final RealMatrix weightMatrix = getWeightSquareRoot();\n    for (int i = 0; i < nR; i++) {\n        for (int j = 0; j < nC; j++) {\n            weightedJacobian[i][j] = weightMatrix.getEntry(i, i) * jacobian[i][j];\n        }\n    }\n    return new Array2DRowRealMatrix(weightedJacobian, false);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix weightedJacobian = computeWeightSquareRoot().multiply(jacobian.value(params));\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix weightedJacobian = computeJacobian(params);\n    return weightMatrixSqrt.multiply(weightedJacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix weightedJacobian = computeWeight(params).scalarMultiply(-1).getData();\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Compute the weighted Jacobian matrix.\n    RealMatrix weightedJacobian = new Array2DRowRealMatrix(computeJacobian(params));\n    weightedJacobian = weightedJacobian.scalarMultiply(1 / Math.sqrt(weightMatrix.getEntry(0, 0)));\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix weightedJacobian = computeWeightSquareRoot().multiply(jacobian.value(params));\n    return weightedJacobian;\n}"
    ],
    [
      "private int least()  {\n    int least = 0;\n    for (int i = 1; i < values.size(); i++) {\n        if (comparator.compare(values.get(least), values.get(i)) > 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator has been set\");\n    }\n    int least = 0;\n    for (int i = 1; i < values.size(); i++) {\n        if (comparator.compare(values.get(least), values.get(i)) > 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator\");\n    }\n    int least = -1;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (set(i)) {\n            if (least < 0) {\n                least = i;\n            } else {\n                if (comparator.compare(values.get(i), values.get(least)) < 0) {\n                    least = i;\n                }\n            }\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    int least = -1;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (valueSet.get(i)) {\n            if (least == -1) {\n                least = i;\n            } else {\n                if (comparator.compare(values.get(i), values.get(least)) < 0) {\n                    least = i;\n                }\n            }\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator has been set\");\n    }\n    int least = 0;\n    for (int i = 1; i < iterators.size(); i++) {\n        if (anyValueSet(valueSet) && comparator.compare(values.get(i), values.get(least)) < 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (least == -1) {\n                least = i;\n            } else {\n                if (comparator.compare(values.get(i), values.get(least)) < 0) {\n                    least = i;\n                }\n            }\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    int least = -1;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (valueSet.get(i)) {\n            if (least == -1 || comparator.compare(values.get(i), values.get(least)) < 0) {\n                least = i;\n            }\n        }\n    }\n    if (least == -1) {\n        throw new NoSuchElementException(\"No more elements\");\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator has been set\");\n    }\n    int least = -1;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (valueSet.get(i)) {\n            if (least == -1) {\n                least = i;\n            } else {\n                if (comparator.compare(values.get(i), values.get(least)) < 0) {\n                    least = i;\n                }\n            }\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = -1;\n    E leastValue = null;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (valueSet.get(i)) {\n            E value = values.get(i);\n            if (leastValue == null || comparator.compare(value, leastValue) < 0) {\n                least = i;\n                leastValue = value;\n            }\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator has been set\");\n    }\n    int least = -1;\n    for (int i = 0; i < iterators.size(); i++) {\n        if (valueSet.get(i)) {\n            if (least == -1) {\n                least = i;\n            } else {\n                if (comparator.compare(values.get(i), values.get(least)) < 0) {\n                    least = i;\n                }\n            }\n        }\n    }\n    return least;\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodeTest test = step.getNodeTest();\n    if (test instanceof NodeNameTest) {\n        NodeNameTest nameTest = (NodeNameTest) test;\n        QName name = nameTest.getNodeName();\n        if (name.getPrefix() != null) {\n            String namespaceURI = parentPointer.getNamespaceURI(\n                    name.getPrefix());\n            if (namespaceURI == null) {\n                throw new JXPathInvalidSyntaxException(\n                        \"Unknown namespace prefix: \" + name.getPrefix());\n            }\n            name = new QName(namespaceURI, name.getLocalPart());\n        }\n        return parentPointer.createChild(name, 0);\n    }\n    return parentPointer.createChild(test.getNodeName(), 0);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_ATTRIBUTE) {\n            return new AttributePointer(parentPointer);\n        }\n        if (axis == Compiler.AXIS_CHILD) {\n            return new ChildNodePointer(parentPointer);\n        }\n        if (axis == Compiler.AXIS_SELF) {\n            return parentPointer;\n        }\n        throw new IllegalArgumentException(\n            \"Unsupported axis: \" + axis);\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodeTest nodeTest = step.getNodeTest();\n    if (nodeTest instanceof NodeNameTest) {\n        NodeNameTest nameTest = (NodeNameTest) nodeTest;\n        QName name = nameTest.getNodeName();\n        return parentPointer.getPropertyPointer(name);\n    } else {\n        return parentPointer.getPropertyPointer(null);\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n        NodePointer childPointer = parentPointer.createChild(name);\n        if (childPointer == null) {\n            // Property does not exist - return a null pointer\n            return createNullPointer(\n                parentPointer,\n                step.getPredicates(),\n                step.getAxis() == Compiler.AXIS_ATTRIBUTE);\n        }\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodeTest nodeTest = step.getNodeTest();\n        if (nodeTest instanceof NodeNameTest) {\n            NodeNameTest nameTest = (NodeNameTest) nodeTest;\n            QName name = nameTest.getNodeName();\n            return parentPointer.createChild(name, WHOLE_COLLECTION);\n        } else {\n            return parentPointer.createChild(null, WHOLE_COLLECTION);\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    NodePointer childPointer =\n        parentPointer.createChild(name.getPrefix(), name.getName());\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    int axis = step.getAxis();\n    NodeTest nodeTest = step.getNodeTest();\n    if (axis == Compiler.AXIS_ATTRIBUTE) {\n        QName name = ((NodeNameTest) nodeTest).getNodeName();\n        return parentPointer.attributePointer(name);\n    } else if (axis == Compiler.AXIS_CHILD) {\n        QName name = ((NodeNameTest) nodeTest).getNodeName();\n        return parentPointer.childPointer(name);\n    } else if (axis == Compiler.AXIS_SELF) {\n        return parentPointer;\n    } else {\n        throw new UnsupportedAxisException(axis);\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    return parentPointer.createChild(name, WHOLE_COLLECTION);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_CHILD) {\n            return parentPointer.createChild(\n                step.getNodeTest().getNodeName());\n        }\n        if (axis == Compiler.AXIS_ATTRIBUTE) {\n            return parentPointer.createAttribute(\n                step.getNodeTest().getNodeName());\n        }\n        if (axis == Compiler.AXIS_SELF) {\n            return parentPointer;\n        }\n        throw new IllegalArgumentException(\n            \"Unsupported axis: \" + axis);\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_ATTRIBUTE) {\n            return new AttributePointer(parentPointer, step.getNodeTest());\n        }\n        if (axis == Compiler.AXIS_CHILD) {\n            return new ChildPointer(parentPointer, step.getNodeTest());\n        }\n        return new SelfPointer(parentPointer);\n    }"
    ],
    [
      "public double getInf()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  inf  = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf  = op.getLocation().getX();\n            node = op.isDirect() ? node.getMinus() : node.getPlus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }",
      "public double getInf()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  inf  = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf  = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }",
      "public double getInf()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  inf  = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf  = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  inf  = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf  = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  inf  = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf  = op.getLocation().getX();\n            node = op.isDirect() ? node.getMinus() : node.getPlus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            return inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            strategy= inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            strategy= inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            strategy= inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            return inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            return inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            return inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            strategy= inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            return inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            strategy= inCache;\n        }\n    }\n    return strategy;\n}"
    ],
    [
      "private boolean setNextObject()  {\n        if (nextObjectSet) {\n            return true;\n        }\n        while (iterator.hasNext()) {\n            nextObject = iterator.next();\n            if (predicate.evaluate(nextObject)) {\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        nextObject = null;\n        nextObjectSet = false;\n        return false;\n    }",
      "private boolean setNextObject()  {\n        while (iterator.hasNext()) {\n            nextObject = iterator.next();\n            if (predicate.evaluate(nextObject)) {\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        nextObjectSet = false;\n        return false;\n    }",
      "private boolean setNextObject()  {\n        while (iterator.hasNext()) {\n            nextObject = iterator.next();\n            if (predicate.evaluate(nextObject)) {\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        nextObjectSet = false;\n        return false;\n    }",
      "private boolean setNextObject()  {\n        if (nextObjectSet) {\n            return true;\n        }\n        while (iterator.hasNext()) {\n            nextObject = iterator.next();\n            if (predicate.evaluate(nextObject)) {\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        return false;\n    }",
      "private boolean setNextObject()  {\n        while (iterator.hasNext()) {\n            nextObject = iterator.next();\n            if (predicate.evaluate(nextObject)) {\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        nextObjectSet = false;\n        return false;\n    }",
      "private boolean setNextObject()  {\n    if (iterator == null) {\n        return false;\n    }\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n        while (iterator.hasNext()) {\n            final E current = iterator.next();\n            if (predicate.evaluate(current)) {\n                nextObject = current;\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        nextObject = null;\n        nextObjectSet = false;\n        return false;\n    }",
      "private boolean setNextObject()  {\n        while (iterator.hasNext()) {\n            nextObject = iterator.next();\n            if (predicate.evaluate(nextObject)) {\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        nextObjectSet = false;\n        return false;\n    }",
      "private boolean setNextObject()  {\n        while (iterator.hasNext()) {\n            nextObject = iterator.next();\n            if (predicate.evaluate(nextObject)) {\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        nextObjectSet = false;\n        return false;\n    }",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) {\n        nextObject = iterator.next();\n        if (predicate.evaluate(nextObject)) {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObjectSet = false;\n    return false;\n}"
    ],
    [
      "private double[] repair(final double[] x)  {\n            double[] repaired = new double[x.length];\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                } else if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        repaired[i] = Math.max(x[i], lowerBound[i]);\n        repaired[i] = Math.min(repaired[i], upperBound[i]);\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        double lB = CMAESOptimizer.this.getLowerBound()[i];\n        double uB = CMAESOptimizer.this.getUpperBound()[i];\n        if (x[i] < lB) {\n            repaired[i] = lB;\n        } else if (x[i] > uB) {\n            repaired[i] = uB;\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        repaired[i] = Math.max(x[i], lowerBound[i]);\n        repaired[i] = Math.min(repaired[i], upperBound[i]);\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            repaired[i] = lB[i];\n        } \n        else if (x[i] > uB[i]) \n        {\n            repaired[i] = uB[i];\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                } else if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to Schur form\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    final double[][] matrixT = transformer.getT().getData();\n    final double[][] matrixP = transformer.getP().getData();\n\n    // compute eigenvalues\n    final int n = matrixT.length;\n    realEigenvalues = new double[n];\n    imagEigenvalues = new double[n];\n    for (int i = 0; i < n; i++) {\n        realEigenvalues[i] = matrixT[i][i];\n        imagEigenvalues[i] = 0;\n    }\n\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to Schur form\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    final double[][] matrixT = transformer.getT().getData();\n    final double[][] matrixP = transformer.getP().getData();\n\n    final int n = matrixT.length;\n\n    // compute matrix norm\n    double norm = 0.0;\n    for (int i = 0; i < n; i++) {\n       for (int j = FastMath.max(i - 1, 0); j < n; j++) {\n          norm = norm + FastMath.abs(matrixT[i][j]);\n       }\n    }\n\n    // we can not handle a matrix with zero norm\n    if (Precision.equals(norm, 0.0, EPSILON)) {\n       throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    // Backsubstitute to find vectors of upper triangular form\n\n    double r = 0.0;\n    double s = 0.0;\n    double z = 0.0;\n\n    for (int idx = n - 1; idx >= 0; idx--) {\n        double p = realEigenvalues[idx];\n        double q = imagEigenvalues[idx];\n\n        int l = idx + 1;\n        for (int i = l; i < n; i++) {\n            int k = i;\n            double scale = FastMath.abs(matrixT[i][idx]);\n            if (FastMath.abs(matrixT[k][idx]) > scale) {\n                k = l;\n                scale = FastMath.abs(matrixT[k][idx]);\n            }\n            if (scale != 0.0) {\n                // Compute the transformation\n                double h = matrixT[i][idx] / matrixT[k][idx];\n                double hh = h * h;\n                double w = r - (q / (matrixT[k][idx] * (r - hh + z)));\n}\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to Schur form\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    // get the Schur form of the matrix\n    final RealMatrix schur = transformer.getT();\n    // compute the eigenvalues\n    final double[] realEigenvalues = new double[schur.getRowDimension()];\n    final double[] imagEigenvalues = new double[schur.getRowDimension()];\n    for (int i = 0; i < schur.getRowDimension(); i++) {\n        realEigenvalues[i] = schur.getEntry(i, i);\n        imagEigenvalues[i] = 0;\n    }\n    this.realEigenvalues = realEigenvalues;\n    this.imagEigenvalues = imagEigenvalues;\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    return new SchurTransformer(matrix);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    final RealMatrix schurT = transformer.getT();\n    final RealMatrix schurP = transformer.getP();\n    final double[][] schurTData = schurT.getData();\n    final double[][] schurPData = schurP.getData();\n\n    // transform matrix\n    transformer.transform();\n\n    // extract eigenvalues\n    final int n = schurT.getRowDimension();\n    realEigenvalues = new double[n];\n    imagEigenvalues = new double[n];\n    for (int i = 0; i < n; i++) {\n        realEigenvalues[i] = schurTData[i][i];\n        imagEigenvalues[i] = schurTData[i][i + 1];\n    }\n\n    // extract eigenvectors\n    eigenvectors = new ArrayRealVector[n];\n    for (int i = 0; i < n; i++) {\n        final double[] v = new double[n];\n        for (int j = 0; j < n; j++) {\n            v[j] = schurPData[j][i];\n        }\n        eigenvectors[i] = new ArrayRealVector(v);\n    }\n\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to Schur form\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    // get the Schur form of the matrix\n    final RealMatrix schur = transformer.getT();\n    // get the eigenvalues of the Schur form\n    final double[] schurEigenvalues = new double[schur.getColumnDimension()];\n    for (int i = 0; i < schurEigenvalues.length; i++) {\n        schurEigenvalues[i] = schur.getEntry(i, i);\n    }\n    // set the eigenvalues\n    realEigenvalues = schurEigenvalues;\n    // set the imaginary eigenvalues\n    imagEigenvalues = new double[realEigenvalues.length];\n    // set the eigenvectors\n    eigenvectors = new ArrayRealVector[realEigenvalues.length];\n    for (int i = 0; i < realEigenvalues.length; i++) {\n        eigenvectors[i] = transformer.getP().getColumnVector(i);\n    }\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    final RealMatrix t = transformer.getT();\n    final RealMatrix p = transformer.getP();\n    final double[][] tData = t.getData();\n    final double[][] pData = p.getData();\n    final int n = tData.length;\n    final double[] realEigenvalues = new double[n];\n    final double[] imagEigenvalues = new double[n];\n    for (int i = 0; i < n; i++) {\n        realEigenvalues[i] = tData[i][i];\n        imagEigenvalues[i] = 0;\n    }\n    this.realEigenvalues = realEigenvalues;\n    this.imagEigenvalues = imagEigenvalues;\n    this.cachedV = p;\n    this.cachedD = t;\n    this.cachedVt = p.transpose();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    final double[][] matrixT = transformer.getT().getData();\n    final double[][] matrixP = transformer.getP().getData();\n\n    final int n = matrixT.length;\n\n    // compute matrix norm\n    double norm = 0.0;\n    for (int i = 0; i < n; i++) {\n       for (int j = FastMath.max(i - 1, 0); j < n; j++) {\n          norm = norm + FastMath.abs(matrixT[i][j]);\n       }\n    }\n\n    // we can not handle a matrix with zero norm\n    if (Precision.equals(norm, 0.0, EPSILON)) {\n       throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    // Backsubstitute to find vectors of upper triangular form\n\n    double r = 0.0;\n    double s = 0.0;\n    double z = 0.0;\n\n    for (int idx = n - 1; idx >= 0; idx--) {\n        double p = realEigenvalues[idx];\n        double q = imagEigenvalues[idx];\n        // ...\n    }\n\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    return new SchurTransformer(matrix);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to Schur form\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    return transformer;\n}"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    // Your code here\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long v = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((v & 1) == 1) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n            v >>= 1;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E constant : enumClass.getEnumConstants()) {\n        final int ordinal = constant.ordinal();\n        final int index = ordinal / Long.SIZE;\n        final int bit = ordinal % Long.SIZE;\n        if ((values[index] & (1 << bit)) != 0) {\n            result.add(constant);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E constant : enumClass.getEnumConstants()) {\n        final int ordinal = constant.ordinal();\n        final int bitIndex = ordinal % Long.SIZE;\n        final int arrayIndex = ordinal / Long.SIZE;\n        if ((values[arrayIndex] & (1L << bitIndex)) != 0) {\n            result.add(constant);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    //Check if the array is null\n    Validate.notNull(values);\n    //Check if the array is empty\n    Validate.validState(values.length != 0, \"The array of longs is empty\");\n    //Check if the array contains negative values\n    Validate.validState(Arrays.stream(values).allMatch(x -> x >= 0), \"The array of longs contains negative values\");\n    //Check if the array contains values greater than the maximum value of a long\n    Validate.validState(Arrays.stream(values).allMatch(x -> x <= Long.MAX_VALUE), \"The array of longs contains values greater than the maximum value of a long\");\n    //Check if the array contains values greater than the maximum value of a long\n    Validate.validState(Arrays.stream(values).allMatch(x -> x >= 0), \"The array of longs contains negative values\");\n    //Check if the array contains values greater than the maximum value of a long\n    Validate.validState(Arrays.stream(values).allMatch(x -> x <= Long.MAX_VALUE), \"The array of longs contains values greater than the maximum value of a long\");\n    //Check if the array contains values greater than the maximum value of a long\n    Validate.validState(Arrays.stream(values).allMatch(x -> x <= Long.MAX_VALUE), \"The array of longs contains values greater than the maximum value of a long\");\n    //Check if the array contains values greater than the maximum value of a long\n    Validate.validState(Arrays.stream(values).allMatch(x -> x <= Long.MAX_VALUE), \"The array of longs contains values greater than the maximum value of a long\");\n    //Check if the array contains values greater than the maximum value of a long\n    Validate.validState(Arrays.stream(values).allMatch(x -> x <= Long.MAX_VALUE), \"The array of longs contains values greater than the maximum value of a long\");\n    //Check if the array contains values greater than the maximum value of a long\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E constant : enumClass.getEnumConstants()) {\n        final int ordinal = constant.ordinal();\n        final int index = ordinal / Long.SIZE;\n        final int bit = ordinal % Long.SIZE;\n        if ((values[index] & (1L << bit)) != 0) {\n            result.add(constant);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n        final EnumSet<E> result = EnumSet.noneOf(enumClass);\n        for (int i = 0; i < values.length; i++) {\n            for (int j = 0; j < Long.SIZE; j++) {\n                if ((values[i] & (1 << j)) != 0) {\n                    result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n                }\n            }\n        }\n        return result;\n    }",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((values[i] & (1 << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((values[i] & (1 << j)) != 0) {\n                result.add(Enum.valueOf(enumClass, Integer.toString(j + i * Long.SIZE)));\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) \n    {\n        for (int j = 0; j < Long.SIZE; j++) \n        {\n            if ((values[i] & (1L << j)) != 0) \n            {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long local = oldInstant + offset;\n    return local - newZone.getOffset(local);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = getDefault();\n    }\n    if (newZone == this) {\n        return oldInstant;\n    }\n    // get the offset at instantLocal (first estimate)\n    int offsetLocal = getOffset(oldInstant);\n    // adjust instantLocal using the estimate and recalc the offset\n    int offset = newZone.getOffset(oldInstant - offsetLocal);\n    // if the offsets differ, we must be near a DST boundary\n    if (offsetLocal != offset) {\n        // if strict then always check if in DST gap\n        // otherwise only check if zone in Western hemisphere (as the\n        // value of offset is already correct for Eastern hemisphere)\n        if (strict || offsetLocal < 0) {\n            // determine if we are in the DST gap\n            long nextLocal = nextTransition(oldInstant - offsetLocal);\n            if (nextLocal == (oldInstant - offsetLocal)) {\n                nextLocal = Long.MAX_VALUE;\n            }\n            long nextAdjusted = nextTransition(oldInstant - offset);\n            if (nextAdjusted == (oldInstant - offset)) {\n                nextAdjusted = Long.MAX_VALUE;\n            }\n            if (nextLocal != nextAdjusted) {\n                // yes we are in the DST gap\n                if (strict) {\n                    // DST gap is not acceptable\n                    throw new IllegalInstantException(\"Illegal instant due to time zone offset transition: \" + oldInstant);\n                }\n                // try to adjust to the previous offset\n                offset = newZone.getOffset(oldInstant - offsetLocal - 1);\n                if (offset != offsetLocal) {\n                    // found a valid offset\n                    return oldInstant - offsetLocal - 1;\n                }\n                // try to adjust to the next offset\n                offset = newZone.getOffset(oldInstant - offsetLocal + 1);\n                if (offset != offsetLocal) {\n                    // found a valid offset\n                    return oldInstant - offsetLocal + 1;\n                }\n                // unable to adjust, throw exception\n}\n}\n}\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long local = oldInstant + offset;\n    int newOffset = newZone.getOffset(local);\n    long newInstant = local - newOffset;\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long instantLocal = oldInstant + offset;\n    int newOffset = newZone.getOffset(instantLocal);\n    return instantLocal - newOffset;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long instant = oldInstant - offset;\n    int newOffset = newZone.getOffset(instant);\n    return instant + newOffset;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // get the offset at oldInstant (first estimate)\n    int offset = getOffset(oldInstant);\n    // adjust oldInstant using the estimate and recalc the offset\n    offset = newZone.getOffset(oldInstant - offset);\n    // if the offsets differ, we must be near a DST boundary\n    if (offset != getOffset(oldInstant)) {\n        // determine if we are in the DST gap\n        long nextLocal = nextTransition(oldInstant - offset);\n        if (nextLocal == (oldInstant - offset)) {\n            nextLocal = Long.MAX_VALUE;\n        }\n        long nextAdjusted = newZone.nextTransition(oldInstant - offset);\n        if (nextAdjusted == (oldInstant - offset)) {\n            nextAdjusted = Long.MAX_VALUE;\n        }\n        if (nextLocal != nextAdjusted) {\n            // yes we are in the DST gap\n            // return the instant that will be adjusted to the correct offset\n            return oldInstant - offset;\n        }\n    }\n    // no DST gap, just return the adjusted instant\n    return oldInstant - offset;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long local = oldInstant + offset;\n    int newOffset = newZone.getOffset(local);\n    return local - newOffset;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long local = oldInstant + offset;\n    int newOffset = newZone.getOffset(local);\n    long newInstant = local - newOffset;\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long local = oldInstant + offset;\n    int newOffset = newZone.getOffset(local);\n    return local - newOffset;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long instantLocal = oldInstant + offset;\n    return newZone.convertLocalToUTC(instantLocal, false);\n}"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n\n    if (unit.getUnitType() == DateTickUnitType.SECOND) {\n        return new Date(date.getTime() + unit.getSize() * 1000);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.MINUTE) {\n        return new Date(date.getTime() + unit.getSize() * 60 * 1000);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.HOUR) {\n        return new Date(date.getTime() + unit.getSize() * 60 * 60 * 1000);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.DAY) {\n        return new Date(date.getTime() + unit.getSize() * 24 * 60 * 60 * 1000);\n    }\n    else if (unit.getUnitType() == DateTickUnitType.MONTH) {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.MONTH, unit.getMultiple());\n        return calendar.getTime();\n    }\n    else if (unit.getUnitType() == DateTickUnitType.YEAR) {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.YEAR, unit.getMultiple());\n        return calendar.getTime();\n    }\n    else {\n        throw new IllegalArgumentException(\"The 'unit' argument has a \" +\n                \"value that is not recognised.\");\n    }\n\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    calendar.set(unit.getCalendarField(), value + count);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // as far as I know, the Locale for the calendar only affects week\n    // number calculations, and since DateTickUnit doesn't do week\n    // arithmetic, the default locale (whatever it is) should be fine\n    // here...\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    if (unit.getRollUnitType() != null) {\n        int rollCount = unit.getRollMultiple();\n        int rollField = unit.getRollUnitType().getCalendarField();\n        calendar.add(rollField, rollCount);\n    }\n    calendar.add(unit.getCalendarField(), count);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n\n    switch (unit.getUnitType()) {\n        case MILLISECOND:\n            milliseconds = value + count;\n            calendar.set(Calendar.MILLISECOND, milliseconds);\n            break;\n        case SECOND:\n            seconds = value + count;\n            calendar.set(Calendar.SECOND, seconds);\n            break;\n        case MINUTE:\n            minutes = value + count;\n            calendar.set(Calendar.MINUTE, minutes);\n            break;\n        case HOUR:\n            hours = value + count;\n            calendar.set(Calendar.HOUR_OF_DAY, hours);\n            break;\n        case DAY:\n            days = value + count;\n            calendar.set(Calendar.DAY_OF_MONTH, days);\n            break;\n        case WEEK:\n            days = value + (count * 7);\n            calendar.set(Calendar.DAY_OF_MONTH, days);\n            break;\n        case MONTH:\n            months = value + count;\n            calendar.set(Calendar.MONTH, months);\n            break;\n        case YEAR:\n            years = value + count;\n            calendar.set(Calendar.YEAR, years);\n            break;\n        default:\n            throw new IllegalArgumentException(\"The 'unit' argument has a \" +\n                    \"value that is not recognised.\");\n    }\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    if (value == current) {\n        value += count;\n    }\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n\n    if (unit.getUnitType() == DateTickUnitType.MILLISECOND) \n    {\n        milliseconds = value + count;\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n    } \n    else if (unit.getUnitType() == DateTickUnitType.SECOND) \n    {\n        seconds = value + count;\n        calendar.set(Calendar.SECOND, seconds);\n    } \n    else if (unit.getUnitType() == DateTickUnitType.MINUTE) \n    {\n        minutes = value + count;\n        calendar.set(Calendar.MINUTE, minutes);\n    } \n    else if (unit.getUnitType() == DateTickUnitType.HOUR) \n    {\n        hours = value + count;\n        calendar.set(Calendar.HOUR_OF_DAY, hours);\n    } \n    else if (unit.getUnitType() == DateTickUnitType.DAY) \n    {\n        days = value + count;\n        calendar.set(Calendar.DAY_OF_MONTH, days);\n    } \n    else if (unit.getUnitType() == DateTickUnitType.MONTH) \n    {\n        months = value + count;\n        calendar.set(Calendar.MONTH, months);\n    } \n    else if (unit.getUnitType() == DateTickUnitType.YEAR) \n    {\n        years = value + count;\n        calendar.set(Calendar.YEAR, years);\n    }\n\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    // as far as I know, the Locale for the calendar only affects week\n    // number calculations, and since DateTickUnit doesn't do week\n    // arithmetic, the default locale (whatever it is) should be fine\n    // here...\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    calendar.set(unit.getCalendarField(), value + count);\n    return calendar.getTime();\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // resolve the variable to a value\n    final String value = getVariableResolver().lookup(variableName);\n    \n    // if the value is null, we don't want to remove the variable from the buf\n    if (value == null) {\n        return null;\n    }\n    \n    // remove the variable from the buf\n    buf.delete(startPos, endPos);\n    \n    // return the value\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // check if substitution is allowed in variable names\n    if (isEnableSubstitutionInVariables() == false) {\n        return null;\n    }\n\n    // resolve the variable to a value\n    final String value = getVariableResolver().lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n\n    // check if the resolved value references another variable\n    if (value.startsWith(getVariablePrefix()) && value.endsWith(getVariableSuffix())) {\n        final String nestedVar = value.substring(getVariablePrefix().length(), value.length() - getVariableSuffix().length());\n        final String nestedValue = resolveVariable(nestedVar, buf, startPos, endPos);\n        if (nestedValue != null) {\n            return nestedValue;\n        }\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String value = null;\n    if (this.variableResolver != null) \n    {\n        value = this.variableResolver.lookup(variableName);\n    }\n    if (value == null) \n    {\n        if (this.enableSubstitutionInVariables) \n        {\n            value = substitute(variableName, buf, startPos, endPos);\n        }\n        else \n        {\n            value = \"$\" + variableName;\n        }\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // check if the variable is in the map\n    Object value = getVariableResolver().lookup(variableName);\n\n    // if the value is null, check if it is allowed to substitute variables in variables\n    if (value == null && isEnableSubstitutionInVariables()) \n    {\n        // if it is allowed, substitute the value of the variable\n        value = substitute(variableName, buf, startPos, endPos);\n    }\n\n    return value == null ? null : value.toString();\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // check if the variable is to be ignored\n    if (ignoreUnresolvableVariable && variableName.equals(IGNORE_UNRESOLVABLE_VARIABLE_KEY)) \n    {\n        return null;\n    }\n\n    // check if the variable is to be ignored\n    if (ignoreEmptyVariable && variableName.equals(IGNORE_EMPTY_VARIABLE_KEY)) \n    {\n        return null;\n    }\n\n    // check if the variable is to be ignored\n    if (ignoreMissingVariable && variableName.equals(IGNORE_MISSING_VARIABLE_KEY)) \n    {\n        return null;\n    }\n\n    // check if the variable is to be ignored\n    if (ignoreUnresolvableVariable && variableName.equals(IGNORE_UNRESOLVABLE_VARIABLE_KEY)) \n    {\n        return null;\n    }\n\n    // check if the variable is to be ignored\n    if (ignoreEmptyVariable && variableName.equals(IGNORE_EMPTY_VARIABLE_KEY)) \n    {\n        return null;\n    }\n\n    // check if the variable is to be ignored\n    if (ignoreMissingVariable && variableName.equals(IGNORE_MISSING_VARIABLE_KEY)) \n    {\n        return null;\n    }\n\n    // check if the variable is to be ignored\n    if (ignoreUnresolvableVariable && variableName.equals(IGNORE_UNRESOLVABLE_VARIABLE_KEY)) \n    {\n        return null;\n    }\n\n    // check if the variable is to be ignored\n    if (ignoreEmptyVariable && variableName.equals(IGNORE_EMPTY_VARIABLE_KEY)) \n    {\n        return null;\n    }\n\n    // check if the variable is to be ignored\n    if (ignoreMissingVariable && variableName.equals(IGNORE_MISSING_VARIABLE_KEY)) \n    {\n        return null;\n    }\n\n    // check if the variable is to be ignored\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String resolvedValue = null;\n    if (isEnableSubstitutionInVariables()) \n    {\n        // Recursive variable substitution\n        resolvedValue = substitute(variableName, buf, startPos, endPos);\n    }\n    else \n    {\n        // Standard variable substitution\n        resolvedValue = getVariableResolver().lookup(variableName);\n    }\n    return resolvedValue;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // get the value of the variable\n    final Object value = getVariableResolver().lookup(variableName);\n    \n    // if the value is null, return the original variable\n    if (value == null) \n    {\n        return null;\n    }\n    \n    // if the value is a string, return it\n    if (value instanceof String) \n    {\n        return (String) value;\n    }\n    \n    // otherwise, convert the value to a string\n    return value.toString();\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String resolvedValue = null;\n    if (variableResolver != null) \n    {\n        resolvedValue = variableResolver.lookup(variableName);\n    }\n    if (enableSubstitutionInVariables && resolvedValue != null) \n    {\n        final StrBuilder working = new StrBuilder(resolvedValue);\n        substitute(working, 0, working.length());\n        resolvedValue = working.toString();\n    }\n    return resolvedValue;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String value = null;\n    if (this.variableResolver != null) \n    {\n        value = this.variableResolver.lookup(variableName);\n    }\n    if (value == null) \n    {\n        if (this.enableSubstitutionInVariables) \n        {\n            value = substitute(variableName, buf, startPos, endPos);\n        } \n        else \n        {\n            value = \"${\" + variableName + \"}\";\n        }\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String value = null;\n    if (this.enableSubstitutionInVariables) {\n        value = substitute(variableName, buf, startPos, endPos);\n    }\n    if (value == null) {\n        value = this.variableResolver.lookup(variableName);\n    }\n    return value;\n}"
    ],
    [
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n        str = str.toUpperCase(Locale.ENGLISH);\n        final int len = str.length();\n        if (len == 0) {\n            return str;\n        }\n        final char[] chars = new char[len];\n        int count = 0;\n        char prevChar = '\\0';\n        char prevPrevChar = '\\0';\n        for (int i = 0; i < len; i++) {\n            final char ch = str.charAt(i);\n            if (ch == prevChar) {\n                continue;\n            }\n            if (i > 0) {\n                if (prevChar == prevPrevChar) {\n                    count--;\n                }\n                prevPrevChar = prevChar;\n            }\n            prevChar = ch;\n            if (Character.isLetter(ch)) {\n                chars[count++] = map(ch);\n            }\n        }\n        if (count == 0) {\n            return str;\n        }\n        final StringBuilder buf = new StringBuilder(count);\n        buf.append(chars[0]);\n        for (int i = 1; i < count; i++) {\n            if (chars[i] != chars[i - 1]) {\n                buf.append(chars[i]);\n            }\n        }\n        if (count < len) {\n            buf.append(str.substring(len - count));\n        }\n        return buf.toString();\n    }",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n        str = str.toUpperCase(Locale.ENGLISH);\n        final int len = str.length();\n        if (len == 0) {\n            return str;\n        }\n        final char[] in = new char[len];\n        for (int i = 0; i < len; i++) {\n            in[i] = map(str.charAt(i));\n        }\n        final StringBuilder sBuf = new StringBuilder();\n        sBuf.append(in[0]);\n        int count = 1;\n        for (int i = 1; i < len; i++) {\n            final char c = in[i];\n            if (c != '0') {\n                if (count < this.maxLength) {\n                    sBuf.append(c);\n                    count++;\n                }\n            }\n        }\n        while (sBuf.length() < this.maxLength) {\n            sBuf.append('0');\n        }\n        return sBuf.toString();\n    }",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final char[] soundex = new char[4];\n    soundex[0] = str.charAt(0);\n    int count = 1;\n    for (int i = 1; i < str.length(); i++) {\n        final char c = map(str.charAt(i));\n        if (c != '0') {\n            if (soundex[count - 1] != c) {\n                soundex[count] = c;\n                count++;\n            }\n        }\n    }\n    return new String(soundex, 0, count);\n}",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n        str = str.toUpperCase(Locale.ENGLISH);\n        final int len = str.length();\n        if (len == 0) {\n            return str;\n        }\n        final char[] in = new char[len];\n        for (int i = 0; i < len; i++) {\n            in[i] = map(str.charAt(i));\n        }\n        final StringBuilder sBuf = new StringBuilder();\n        sBuf.append(in[0]);\n        boolean lastWasBlank = false;\n        for (int i = 1; i < len; i++) {\n            if (in[i] != 0) {\n                if (lastWasBlank) {\n                    sBuf.append(in[i]);\n                    lastWasBlank = false;\n                } else if (in[i] != in[i - 1]) {\n                    sBuf.append(in[i]);\n                }\n            } else {\n                lastWasBlank = true;\n            }\n        }\n        final String outStr = sBuf.toString();\n        if (outStr.length() <= maxLength) {\n            return outStr;\n        }\n        return outStr.substring(0, maxLength);\n    }",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final char[] chars = str.toCharArray();\n    final StringBuilder soundex = new StringBuilder(chars[0]);\n    char last = '0';\n    for (int i = 1; i < chars.length; i++) {\n        final char c = map(chars[i]);\n        if (c != '0' && c != last) {\n            soundex.append(c);\n            last = c;\n        }\n    }\n    while (soundex.length() < this.maxLength) {\n        soundex.append('0');\n    }\n    return soundex.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase(Locale.ENGLISH);\n    final int len = str.length();\n    if (len == 0) {\n        return str;\n    }\n    final char[] in = new char[len];\n    for (int i = 0; i < len; i++) {\n        in[i] = map(str.charAt(i));\n    }\n    final int[] codes = new int[len];\n    int maxCode = 0;\n    for (int i = 0; i < len; i++) {\n        final int code = in[i];\n        if (code != 0) {\n            codes[i] = code;\n            if (code > maxCode) {\n                maxCode = code;\n            }\n        }\n    }\n    final StringBuilder buffer = new StringBuilder(maxCode <= 6 ? 4 : 5);\n    buffer.append(in[0]);\n    for (int i = 1; i < len; i++) {\n        final int code = codes[i];\n        if (code != 0 && code != maxCode) {\n            buffer.append((char) code);\n        }\n    }\n    return buffer.toString();\n}",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n        final char[] chars = str.toUpperCase().toCharArray();\n        final StringBuilder sb = new StringBuilder();\n        sb.append(chars[0]);\n        for (int i = 1; i < chars.length; i++) {\n            final char c = chars[i];\n            final char mapped = map(c);\n            if (mapped != '0') {\n                sb.append(mapped);\n            }\n        }\n        return sb.toString();\n    }",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n        str = SoundexUtils.clean(str);\n        if (str.length() == 0) {\n            return str;\n        }\n        final char[] chars = str.toUpperCase(Locale.ENGLISH).toCharArray();\n        final StringBuilder soundex = new StringBuilder(chars[0]);\n        char last = '0';\n        for (final char c : chars) {\n            final char mapped = map(c);\n            if (mapped != '0') {\n                if (mapped != last) {\n                    soundex.append(mapped);\n                }\n                last = mapped;\n            }\n        }\n        while (soundex.length() < this.maxLength) {\n            soundex.append('0');\n        }\n        return soundex.toString();\n    }",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = SoundexUtils.clean(str);\n    if (str.length() == 0) {\n        return str;\n    }\n    final char[] chars = str.toCharArray();\n    final StringBuilder sb = new StringBuilder();\n    sb.append(chars[0]);\n    for (int i = 1; i < chars.length; i++) {\n        final char c = chars[i];\n        final char mapped = map(c);\n        if (mapped != '0') {\n            sb.append(mapped);\n        }\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n        str = str.toUpperCase(Locale.ENGLISH);\n        final int len = str.length();\n        if (len == 0) {\n            return str;\n        }\n        final char[] chars = new char[len];\n        int count = 0;\n        char lastChar = '\\0';\n        for (int i = 0; i < len; i++) {\n            final char c = str.charAt(i);\n            if (c >= 'A' && c <= 'Z') {\n                if (count < chars.length) {\n                    chars[count++] = c;\n                }\n                lastChar = c;\n            }\n        }\n        if (count == 0) {\n            return str;\n        }\n        final char firstChar = chars[0];\n        chars[0] = '0';\n        final StringBuilder buf = new StringBuilder(count);\n        buf.append(firstChar);\n        for (int i = 1; i < count; i++) {\n            final char c = chars[i];\n            if (c != lastChar) {\n                buf.append(c);\n            }\n        }\n        return buf.toString();\n    }"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // ok to have no types (\"raw\")\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // 15-Sep-2015, tatu: Prior to 2.7, we constructed new instance for each call.\n    //    This may have been due to potential mutability of the instance; but that\n    //    should not be issue any more, and creation is somewhat wasteful. So let's\n    //    try reusing singleton/flyweight instance.\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // 15-Sep-2015, tatu: Prior to 2.7, we constructed new instance for each call.\n    //    This may have been due to potential mutability of the instance; but that\n    //    should not be issue any more, and creation is somewhat wasteful. So let's\n    //    try reusing singleton/flyweight instance.\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // 15-Sep-2015, tatu: Prior to 2.7, we constructed new instance for each call.\n    //    This may have been due to potential mutability of the instance; but that\n    //    should not be issue any more, and creation is somewhat wasteful. So let's\n    //    try reusing singleton/flyweight instance.\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // ok to have no types (\"raw\")\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // 22-Apr-2015, tatu: For now let's just hard-code a few well-known types\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Boolean.class) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isExprResult()) {\n    Node expr = n.getFirstChild();\n    if (expr.isAssign()) {\n      Node lhs = expr.getFirstChild();\n      if (lhs.isGetProp() && lhs.getLastChild().getString().equals(\"prototype\")) {\n        return new PrototypeMemberDeclaration(lhs, n);\n      }\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isExprResult() && n.getFirstChild().isAssign()) {\n    Node lhs = n.getFirstChild().getFirstChild();\n    if (lhs.isGetProp() && lhs.getFirstChild().isName()\n        && lhs.getLastChild().getString().equals(\"prototype\")) {\n      return new PrototypeMemberDeclaration(lhs, n);\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n      if (!n.isExprResult()) {\n        return null;\n      }\n      Node lhs = n.getFirstChild().getFirstChild();\n      if (lhs == null || !lhs.isGetProp() || !lhs.getLastChild().getString().equals(\"prototype\")) {\n        return null;\n      }\n      return new PrototypeMemberDeclaration(lhs, n);\n    }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isExprResult() && n.getFirstChild().isAssign()) {\n    Node lhs = n.getFirstChild().getFirstChild();\n    if (lhs.isGetProp() && lhs.getLastChild().getString().equals(\"prototype\")) {\n      return new PrototypeMemberDeclaration(lhs, n);\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  Node lhs = n.getFirstChild();\n  if (NodeUtil.isAssignmentOp(n) &&\n      lhs.isGetProp() &&\n      lhs.getLastChild().getString().equals(\"prototype\")) {\n    return new PrototypeMemberDeclaration(lhs, n);\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n      if (n.isExprResult()) {\n        Node expr = n.getFirstChild();\n        if (expr.isAssign()) {\n          Node lhs = expr.getFirstChild();\n          if (lhs.isGetProp() && lhs.getFirstChild().isName()) {\n            return new PrototypeMemberDeclaration(lhs, n);\n          }\n        }\n      }\n      return null;\n    }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n      Node lhs = n.getFirstChild();\n      if (lhs == null || !lhs.isGetProp()) {\n        return null;\n      }\n      Node parent = lhs.getFirstChild();\n      if (parent == null || !parent.isGetProp()) {\n        return null;\n      }\n      Node grandparent = parent.getFirstChild();\n      if (grandparent == null || !grandparent.isName()) {\n        return null;\n      }\n      String name = grandparent.getString();\n      if (!name.equals(\"prototype\")) {\n        return null;\n      }\n      return new PrototypeMemberDeclaration(lhs, n);\n    }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n      if (n.isExprResult() && n.getFirstChild().isAssign()) {\n        Node lhs = n.getFirstChild().getFirstChild();\n        if (lhs.isGetProp() && lhs.getFirstChild().isName()\n            && lhs.getLastChild().getString().equals(\"prototype\")) {\n          return new PrototypeMemberDeclaration(lhs, n);\n        }\n      }\n      return null;\n    }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isExprResult()) {\n    Node expr = n.getFirstChild();\n    if (expr.isAssign()) {\n      Node lhs = expr.getFirstChild();\n      if (lhs.isGetProp() && lhs.getLastChild().getString().equals(\"prototype\")) {\n        return new PrototypeMemberDeclaration(lhs, n);\n      }\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  Node lhs = n.getFirstChild();\n  if (NodeUtil.isGetProp(lhs) &&\n      NodeUtil.isPrototypeProperty(lhs) &&\n      NodeUtil.isObjectLit(n.getLastChild())) {\n    return new PrototypeMemberDeclaration(lhs, n);\n  }\n  return null;\n}"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            final double val = mat.getEntry(r, c);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r * n + i][c * m + j] = val;\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r * n + i][c * m + j] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r * n + i][c * m + j] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r * n + i][c * m + j] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r * n + i][c * m + j] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r * n + i][c * m + j] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r * n + i][c * m + j] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r * n + i][c * m + j] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r * n + i][c * m + j] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r * n + i][c * m + j] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n        Node candidate = null;\n        for (Node node = top; node != null;) {\n            if (node.element.compareTo(reference) > 0) {\n                if (node.left == null) {\n                    return candidate;\n                }\n                node = node.left;\n            } else {\n                candidate = node;\n                if (node.right == null) {\n                    return candidate;\n                }\n                node = node.right;\n            }\n        }\n        return null;\n    }",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  {\n    final long totalBytesRead = current.bytesReadFromStream;\n    final long totalBytesConsumed = inf.getBytesWritten();\n    if (totalBytesConsumed > totalBytesRead) {\n        return totalBytesConsumed;\n    }\n    final long totalBytesConsumedLow = totalBytesConsumed & 0xffffffffL;\n    if (totalBytesConsumedLow > totalBytesRead) {\n        return totalBytesConsumedLow;\n    }\n    return totalBytesRead;\n}",
      "private long getBytesInflated()  {\n    long result = inf.getBytesRead();\n    if (result < 0) {\n        result = 0;\n    }\n    return result;\n}",
      "private long getBytesInflated()  {\n    final long infBytes = inf.getBytesWritten();\n    final long bytesRead = getBytesRead();\n    if (infBytes < bytesRead) {\n        return bytesRead;\n    }\n    return infBytes;\n}",
      "private long getBytesInflated()  {\n    final long bytesInflated = inf.getBytesWritten();\n    final long bytesRead = current.bytesReadFromStream;\n    if (bytesInflated < bytesRead) {\n        return bytesRead;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = current.bytesRead;\n    final long bytesInflated = inf.getBytesWritten();\n    if (bytesInflated > bytesRead) {\n        return bytesInflated;\n    }\n    return bytesRead - bytesInflated + inf.getRemaining();\n}",
      "private long getBytesInflated()  {\n    long infBytes = inf.getBytesRead();\n    long streamBytes = current.bytesReadFromStream;\n    if (infBytes < streamBytes) {\n        infBytes += TWO_EXP_32;\n    }\n    return infBytes;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesRead();\n    if (bytesInflated < current.bytesRead) {\n        bytesInflated += TWO_EXP_32;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long infBytes = inf.getBytesRead();\n    if (infBytes < 0) {\n        infBytes += 0x100000000L;\n    }\n    return infBytes;\n}",
      "private long getBytesInflated()  {\n    final long infBytes = inf.getBytesWritten();\n    final long bytesRead = this.bytesRead;\n    if (infBytes > bytesRead) {\n        return infBytes;\n    }\n    return bytesRead - infBytes;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = current.bytesReadFromStream;\n    if (bytesInflated > TWO_EXP_32) {\n        bytesInflated -= TWO_EXP_32;\n    }\n    return bytesInflated;\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    } \n    else if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    } \n    else if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    } \n    else if (object.getClass().isArray()) \n    {\n        return Array.getLength(object) == 0;\n    } \n    else if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    } \n    else if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } \n    else \n    {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    } \n    else if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    } \n    else if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    } \n    else if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    } \n    else if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    } \n    else if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } \n    else \n    {\n        try \n        {\n            return Array.getLength(object) == 0;\n        } \n        catch (final IllegalArgumentException ex) \n        {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n    return TokenStream.isJSQualifiedName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return TokenStream.isJSQualifiedName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return TokenStream.isJSQualifiedName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return TokenStream.isJSQualifiedName(name) &&\n        !TokenStream.isKeyword(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, Unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        isLatin(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return TokenStream.isJSQualifiedName(name) &&\n        !TokenStream.isKeyword(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, Unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        isLatin(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return TokenStream.isJSQualifiedName(name) &&\n        !TokenStream.isKeyword(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, Unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        isLatin(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return TokenStream.isJSQualifiedName(name) &&\n        !TokenStream.isKeyword(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, Unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        isLatin(name);\n  }"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize the vector u with the elements of the matrix\n    // from position (il, il) to position (iu, iu)\n    for (int i = il; i <= iu; i++) {\n        hVec[i - il] = matrixT[i][i];\n    }\n\n    // Apply the similarity transformation to hVec and return the updated hVec\n    return applySimilarityTransformation(il, iu, shift, hVec);\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // initialize the householder vectors\n    hVec[0] = matrixT[iu][iu] - shift.exShift;\n    hVec[1] = matrixT[iu - 1][iu];\n    hVec[2] = 0.0;\n\n    // compute the initial householder vector\n    double scale = FastMath.abs(hVec[0]) + FastMath.abs(hVec[1]);\n    if (scale == 0.0) {\n        scale = FastMath.abs(hVec[2]);\n    }\n    double hVecNorm = FastMath.sqrt(hVec[0] * hVec[0] + hVec[1] * hVec[1] + hVec[2] * hVec[2]);\n    if (hVecNorm == 0.0) {\n        hVecNorm = scale;\n    }\n    hVec[0] /= hVecNorm;\n    hVec[1] /= hVecNorm;\n    hVec[2] /= hVecNorm;\n\n    // initialize the start index for the QR step\n    int im = iu;\n    if (iu > il + 1) {\n        im = iu - 2;\n    }\n\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // initialize the householder vectors\n    double[][] v = new double[3][matrixT.length];\n    v[0][il] = 1.0;\n    v[1][il] = matrixT[il][il];\n    v[2][il] = matrixT[il + 1][il];\n    return il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    int im = iu;\n    if (il == iu) {\n        hVec[0] = 1.0;\n        hVec[1] = 0.0;\n        hVec[2] = 0.0;\n    } else {\n        hVec[0] = matrixT[il + 1][il];\n        hVec[1] = matrixT[il][il];\n        hVec[2] = 0.0;\n        if (il == 0) {\n            return il;\n        }\n        for (int i = il - 1; i >= 0; i--) {\n            double scale = FastMath.abs(hVec[0]) + FastMath.abs(hVec[1]);\n            if (i < n - 2) {\n                scale += FastMath.abs(hVec[2]);\n            }\n            if (FastMath.abs(matrixT[i][i]) <= epsilon * scale) {\n                matrixT[i][i] = 0.0;\n                im = i;\n                break;\n            }\n            if (i != 0) {\n                hVec[2] = matrixT[i][i - 1];\n            }\n            double p = matrixT[i][i] - shift.exShift;\n            double q = hVec[0];\n            double r = hVec[1];\n            if (i != 0) {\n                double s = FastMath.abs(hVec[2]) + FastMath.abs(p);\n                double t = FastMath.abs(q) + FastMath.abs(r);\n                if (s == 0.0) {\n                    s = t;\n                }\n                if (t == 0.0) {\n                    t = s;\n                }\n                double tau = FastMath.min(s, t);\n                p = p / tau;\n                q = q / tau;\n                r = r / tau;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // initialize the householder vector\n    hVec[0] = matrixT[iu][iu] - shift.exShift;\n    hVec[1] = matrixT[iu - 1][iu];\n    hVec[2] = 0.0;\n    int im = iu;\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n\n        final int n = matrixT.length;\n        double p = 0.0;\n        double q = 0.0;\n        double r = 0.0;\n        int im = iu;\n\n        // compute the initial householder vector\n        for (int k = iu; k >= il; k--) {\n            p = matrixT[k][k];\n            q = matrixT[k + 1][k];\n            r = k != (iu - 1) ? matrixT[k + 2][k] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            hVec[k - il] = s * shift.x;\n            im = k + 1;\n        }\n\n        return im;\n    }",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // Initialize the first householder vector\n    double scale = 0.0;\n    double h = 0.0;\n    for (int k = il; k <= iu; k++) {\n        scale = scale + FastMath.abs(matrixT[k][k]);\n    }\n    if (scale == 0.0) {\n        hVec[0] = 0.0;\n        hVec[1] = 0.0;\n        hVec[2] = 0.0;\n        return il;\n    }\n    for (int k = il; k <= iu; k++) {\n        matrixT[k][k] = matrixT[k][k] / scale;\n        h = h + matrixT[k][k] * matrixT[k][k];\n    }\n    double f = matrixT[iu][iu];\n    double g = (f > 0) ? -FastMath.sqrt(h) : FastMath.sqrt(h);\n    hVec[0] = f - g;\n    hVec[1] = matrixT[iu - 1][iu];\n    hVec[2] = matrixT[iu - 2][iu];\n    double norm = FastMath.abs(hVec[0]) + FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]);\n    if (norm == 0.0) {\n        return il;\n    }\n    hVec[0] = hVec[0] / norm;\n    hVec[1] = hVec[1] / norm;\n    hVec[2] = hVec[2] / norm;\n    return il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // initialize the householder vectors\n    hVec[0] = matrixT[il][il];\n    hVec[1] = matrixT[il + 1][il];\n    hVec[2] = matrixT[il + 2][il];\n\n    // compute the norm of the householder vectors\n    double norm = FastMath.sqrt(hVec[0] * hVec[0] + hVec[1] * hVec[1] + hVec[2] * hVec[2]);\n\n    // scale the householder vectors\n    hVec[0] /= norm;\n    hVec[1] /= norm;\n    hVec[2] /= norm;\n\n    // return the start index for the QR step\n    return il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu;\n    while (im >= il) {\n        double h = matrixT[im][im];\n        double s = FastMath.abs(h) + FastMath.abs(matrixT[im + 1][im]);\n        if (s == 0.0) {\n            s = getNorm();\n        }\n        if (FastMath.abs(matrixT[im][im - 1]) <= epsilon * s) {\n            break;\n        }\n        im--;\n    }\n    hVec[0] = hVec[1] = hVec[2] = 0.0;\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = matrixT[iu][iu - 1];\n    double q = matrixT[iu - 1][iu - 2];\n    double r = (iu - 2 >= 0) ? matrixT[iu - 2][iu - 2] : 0.0;\n    double x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n    if (!Precision.equals(x, 0.0, epsilon)) {\n        p = p / x;\n        q = q / x;\n        r = r / x;\n    }\n    double s = FastMath.sqrt(p * p + q * q + r * r);\n    if (p < 0.0) {\n        s = -s;\n    }\n    hVec[0] = matrixT[iu][iu] - s;\n    hVec[1] = matrixT[iu - 1][iu - 1] - s * (q / p + r / (p + s));\n    hVec[2] = matrixT[iu - 2][iu - 2] - s * (q * (r / (p + s) - 1.0) - 1.0);\n    int im = iu - 2;\n    while (im >= il) {\n        double z = hVec[im];\n        hVec[im + 1] = z;\n        if (im == il - 1) {\n            break;\n        }\n        double y = hVec[im - 1];\n        double w = hVec[im - 2];\n        double d = FastMath.abs(y) + FastMath.abs(z) + FastMath.abs(w);\n        if (d == 0.0) {\n            d = norm;\n        }\n        if (FastMath.abs(hVec[im]) <= epsilon * d) {\n            break;\n        }\n        im--;\n    }\n    return im;\n}"
    ],
    [
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n        List<TextNode> textNodes = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof TextNode) {\n                TextNode textNode = (TextNode) node;\n                textNodes.add(textNode);\n            }\n        }\n        return Collections.unmodifiableList(textNodes);\n    }",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n        List<TextNode> textNodes = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof TextNode)\n                textNodes.add((TextNode) node);\n        }\n        return Collections.unmodifiableList(textNodes);\n    }",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inExceptionSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inExceptionSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n        for (Segment segment = getSegment(this.segmentStart);\n            segment.getSegmentStart() < this.segmentEnd;\n            segment.inc()) {\n            if (!segment.inExceptionSegments()) {\n                return (false);\n            }\n        }\n        return true;\n    }",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n        for (Segment segment = getSegment(this.segmentStart);\n            segment.getSegmentStart() < this.segmentEnd;\n            segment.inc()) {\n            if (!segment.inExceptionSegments()) {\n                return (false);\n            }\n        }\n        return true;\n    }",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePeriod object must not be null\");\n    }\n    int size = start.size();\n    int[] startValues = new int[size];\n    int[] endValues = new int[size];\n    for (int i = 0; i < size; i++) {\n        startValues[i] = start.getValue(i);\n        endValues[i] = end.getValue(i);\n    }\n    int[] zeroValues = zeroInstance.getValues();\n    int[] diff = new int[size];\n    for (int i = 0; i < size; i++) {\n        diff[i] = endValues[i] - startValues[i];\n    }\n    int amount = 0;\n    for (int i = 0; i < size; i++) {\n        int diffValue = diff[i];\n        if (diffValue != 0) {\n            int zeroValue = zeroValues[i];\n            if (zeroValue == 0) {\n                amount = diffValue;\n                break;\n            }\n            if (diffValue > zeroValue) {\n                amount = diffValue / zeroValue;\n                break;\n            }\n            if (diffValue < -zeroValue) {\n                amount = diffValue / zeroValue - 1;\n                break;\n            }\n        }\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance must not be null\");\n    }\n    int size = start.size();\n    int[] startValues = new int[size];\n    int[] endValues = new int[size];\n    for (int i = 0; i < size; i++) {\n        startValues[i] = start.getValue(i);\n        endValues[i] = end.getValue(i);\n    }\n    int[] zeroValues = zeroInstance.getValues();\n    int[] diff = new int[size];\n    for (int i = 0; i < size; i++) {\n        diff[i] = endValues[i] - startValues[i];\n    }\n    int amount = 0;\n    for (int i = 0; i < size; i++) {\n        if (diff[i] < 0) {\n            for (int j = i + 1; j < size; j++) {\n                if (diff[j] >= 0) {\n                    amount += zeroValues[j];\n                }\n            }\n            amount++;\n            break;\n        }\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"Zero instance must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    int size = start.size();\n    int[] startValues = new int[size];\n    int[] endValues = new int[size];\n    for (int i = 0; i < size; i++) {\n        startValues[i] = start.getValue(i);\n        endValues[i] = end.getValue(i);\n    }\n    int[] zeroValues = zeroInstance.getValues();\n    int[] durations = zeroInstance.getFieldTypes();\n    int[] durationsValues = new int[size];\n    for (int i = 0; i < size; i++) {\n        durationsValues[i] = durations[i].getDifference(endValues[i], startValues[i]);\n    }\n    int amount = 0;\n    for (int i = 0; i < size; i++) {\n        amount = Math.addExact(amount, Math.multiplyExact(durationsValues[i], durations[i].getUnitMillis()));\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int size = start.size();\n    if (size != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    int[] startValues = new int[size];\n    int[] endValues = new int[size];\n    for (int i = 0; i < size; i++) {\n        DurationFieldType fieldType = start.getFieldType(i);\n        startValues[i] = start.get(fieldType);\n        endValues[i] = end.get(fieldType);\n    }\n    int[] durations = chrono.get(zeroInstance, startValues, endValues);\n    int amount = 0;\n    for (int i = 0; i < size; i++) {\n        amount = FieldUtils.safeAdd(amount, durations[i]);\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int size = start.size();\n    if (size != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    int[] startValues = new int[size];\n    int[] endValues = new int[size];\n    for (int i = 0; i < size; i++) {\n        startValues[i] = start.getValue(i);\n        endValues[i] = end.getValue(i);\n    }\n    int[] resultValues = chrono.get(zeroInstance, startValues, endValues);\n    return resultValues[0];\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePeriod object must not be null\");\n    }\n    int[] startValues = new int[start.size()];\n    int[] endValues = new int[end.size()];\n    for (int i = 0; i < start.size(); i++) {\n        startValues[i] = start.getValue(i);\n        endValues[i] = end.getValue(i);\n    }\n    int[] zeroValues = zeroInstance.getValues();\n    int[] diff = new int[start.size()];\n    for (int i = 0; i < start.size(); i++) {\n        diff[i] = endValues[i] - startValues[i];\n    }\n    int amount = 0;\n    for (int i = 0; i < start.size(); i++) {\n        if (diff[i] != 0) {\n            amount = diff[i];\n            break;\n        }\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePeriod object must not be null\");\n    }\n    int[] startValues = new int[start.size()];\n    int[] endValues = new int[end.size()];\n    start.getValues(startValues);\n    end.getValues(endValues);\n    int[] zeroValues = new int[start.size()];\n    zeroInstance.getValues(zeroValues);\n    int[] diff = new int[start.size()];\n    for (int i = 0; i < start.size(); i++) {\n        diff[i] = endValues[i] - startValues[i];\n    }\n    int amount = 0;\n    for (int i = 0; i < start.size(); i++) {\n        if (diff[i] < 0) {\n            amount = 0;\n            break;\n        } else if (diff[i] > 0) {\n            amount++;\n        }\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    int[] startValues = new int[start.size()];\n    int[] endValues = new int[end.size()];\n    for (int i = 0; i < start.size(); i++) {\n        startValues[i] = start.getValue(i);\n        endValues[i] = end.getValue(i);\n    }\n    int[] minValues = new int[start.size()];\n    int[] maxValues = new int[start.size()];\n    for (int i = 0; i < start.size(); i++) {\n        DurationFieldType type = start.getFieldType(i);\n        minValues[i] = zeroInstance.get(type);\n        maxValues[i] = minValues[i] + type.getRangeDurationField().getUnitMillis();\n    }\n    int[] minDiff = new int[start.size()];\n    int[] maxDiff = new int[start.size()];\n    for (int i = 0; i < start.size(); i++) {\n        minDiff[i] = minValues[i] - startValues[i];\n        maxDiff[i] = endValues[i] - maxValues[i];\n    }\n    int minTotal = 0;\n    int maxTotal = 0;\n    for (int i = 0; i < start.size(); i++) {\n        minTotal += minDiff[i];\n        maxTotal += maxDiff[i];\n    }\n    int amount = (maxTotal - minTotal) / start.size();\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int size = start.size();\n    if (size != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    int[] startValues = new int[size];\n    int[] endValues = new int[size];\n    for (int i = 0; i < size; i++) {\n        DurationFieldType field = start.getFieldType(i);\n        startValues[i] = start.getValue(i);\n        endValues[i] = end.getValue(i);\n        if (field != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n    }\n    int[] sum = new int[size];\n    for (int i = 0; i < size; i++) {\n        DurationFieldType field = start.getFieldType(i);\n        int min = field.getRangeDurationField().getMinimumValue(start.getChronology());\n        int max = field.getRangeDurationField().getMaximumValue(start.getChronology());\n        if (startValues[i] < min || startValues[i] > max) {\n            throw new IllegalArgumentException(\"ReadablePartial values must be within the range of the field\");\n        }\n        if (endValues[i] < min || endValues[i] > max) {\n            throw new IllegalArgumentException(\"ReadablePartial values must be within the range of the field\");\n        }\n        int range = max - min + 1;\n        int startWrap = startValues[i] - min;\n        int endWrap = endValues[i] - min;\n        int diff = (endWrap - startWrap) + (range * (endValues[i] < startValues[i] ? 1 : -1));\n        sum[i] = diff;\n    }\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int size = start.size();\n    if (size != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    int[] startValues = new int[size];\n    int[] endValues = new int[size];\n    for (int i = 0; i < size; i++) {\n        DurationFieldType field = start.getFieldType(i);\n        startValues[i] = start.getValue(i);\n        endValues[i] = end.getValue(i);\n        if (field != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n    }\n    int[] zeroValues = zeroInstance.getValues();\n    int[] diff = chrono.get(start.getChronology()).getDifference(startValues, endValues, zeroValues);\n    return diff[0];\n}"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.subtitles.size()) \n    {\n        return null;\n    }\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles == null || index < 0 || index >= this.subtitles.size()) \n    {\n        return null;\n    }\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles == null) {\n        return null;\n    }\n    int count = 0;\n    for (int i = 0; i < this.subtitles.size(); i++) {\n        Title title = (Title) this.subtitles.get(i);\n        if (title instanceof LegendTitle) {\n            if (count == index) {\n                return (LegendTitle) title;\n            }\n            count++;\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle legend = null;\n    if (this.subtitles != null && index < this.subtitles.size()) \n    {\n        Object obj = this.subtitles.get(index);\n        if (obj instanceof LegendTitle) \n        {\n            legend = (LegendTitle) obj;\n        }\n    }\n    return legend;\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle legend = null;\n    if (this.subtitles != null && this.subtitles.size() > index) \n    {\n        Object obj = this.subtitles.get(index);\n        if (obj instanceof LegendTitle) \n        {\n            legend = (LegendTitle) obj;\n        }\n    }\n    return legend;\n}",
      "public LegendTitle getLegend(int index)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= getSubtitleCount()) {\n        return null;\n    }\n    return (LegendTitle) getSubtitle(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles != null && this.subtitles.size() > index) \n    {\n        Object obj = this.subtitles.get(index);\n        if (obj instanceof LegendTitle) \n        {\n            return (LegendTitle) obj;\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles == null) {\n        return null;\n    }\n    if (index < 0 || index >= this.subtitles.size()) {\n        throw new IllegalArgumentException(\"Index out of bounds.\");\n    }\n    Title title = (Title) this.subtitles.get(index);\n    if (title instanceof LegendTitle) {\n        return (LegendTitle) title;\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    // check argument\n    if (index < 0) {\n        throw new IllegalArgumentException(\"Index must be positive.\");\n    }\n\n    // check for null list\n    if (this.subtitles == null) {\n        return null;\n    }\n\n    // check for index out of bounds\n    if (index >= this.subtitles.size()) {\n        return null;\n    }\n\n    // check for null item\n    Object item = this.subtitles.get(index);\n    if (item == null) {\n        return null;\n    }\n\n    // check for correct type\n    if (!(item instanceof LegendTitle)) {\n        return null;\n    }\n\n    // cast and return\n    return (LegendTitle) item;\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  Node paramType = null;\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    token = next();\n    if (token == JsDocToken.ELLIPSIS) {\n      paramType = wrapNode(Token.ELLIPSIS, parseTopLevelTypeExpression(next()));\n      skipEOLs();\n    } else {\n      paramType = parseTopLevelTypeExpression(token);\n    }\n    if (paramType != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n  } else {\n    paramType = parseTopLevelTypeExpression(token);\n  }\n  return paramType;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  Node paramType = null;\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    token = next();\n    if (token == JsDocToken.ELLIPSIS) {\n      next();\n      paramType = wrapNode(Token.ELLIPSIS, parseTypeExpression(next()));\n    } else {\n      paramType = parseTopLevelTypeExpression(token);\n    }\n    skipEOLs();\n    if (!match(JsDocToken.RC)) {\n      reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n    } else {\n      next();\n    }\n  } else {\n    paramType = parseTypeExpression(token);\n  }\n  return paramType;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTopLevelTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTopLevelTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTopLevelTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node paramType = parseTopLevelTypeExpression(next());\n    if (paramType != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return paramType;\n  } else {\n    return parseTopLevelTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } else {\n                next();\n            }\n        }\n\n        return typeNode;\n    } else {\n        return parseTopLevelTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) \n    {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) \n        {\n            traceStarted = true;\n            list.add(token);\n        } \n        else if (traceStarted) \n        {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) \n    {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) \n        {\n            traceStarted = true;\n            list.add(token);\n        } \n        else if (traceStarted) \n        {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) \n    {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) \n        {\n            traceStarted = true;\n            list.add(token);\n        } \n        else if (traceStarted) \n        {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        // Determine if the line starts with <whitespace>at\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n            list.add(token);\n        } else if (traceStarted) {\n            break;\n        }\n    }\n    return list;\n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } else {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } else {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } else {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } else {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node args = call.getLastChild();\n  for (Node c = args.getFirstChild(); c != null; c = c.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(c)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node firstArg = call.getFirstChild().getNext();\n  for (Node arg = firstArg; arg != null; arg = arg.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getFirstChild().getNext();\n       arg != null;\n       arg = arg.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getFirstChild().getNext();\n       arg != null;\n       arg = arg.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node first = call.getFirstChild().getNext();\n  for (Node n = first; n != null; n = n.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(n)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getSecondChild(); arg != null; arg = arg.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node arg = call.getFirstChild().getNext();\n  while (arg != null) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n    arg = arg.getNext();\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node child = call.getFirstChild().getNext();\n         child != null;\n         child = child.getNext()) {\n      if (NodeUtil.mayHaveSideEffects(child)) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getSecondChild(); arg != null; arg = arg.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg = call.getFirstChild().getNext(); arg != null;\n         arg = arg.getNext()) {\n      if (NodeUtil.mayHaveSideEffects(arg)) {\n        return true;\n      }\n    }\n    return false;\n  }"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    }",
      "public FieldMatrix<T> getP()  {\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    }",
      "public FieldMatrix<T> getP()  {\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    }",
      "public FieldMatrix<T> getP()  {\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    }",
      "public FieldMatrix<T> getP()  {\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    }",
      "public FieldMatrix<T> getP()  {\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    }",
      "public FieldMatrix<T> getP()  {\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    }",
      "public FieldMatrix<T> getP()  {\n        if ((cachedP == null) && !singular) {\n            final int m = pivot.length;\n            cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                cachedP.setEntry(i, pivot[i], field.getOne());\n            }\n        }\n        return cachedP;\n    }",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0 && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount = lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0 && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount = lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0 && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount = lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  sup  = Double.NEGATIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            sup  = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n    }",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  sup  = Double.NEGATIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            sup  = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n    }",
      "public double getSup()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  sup  = Double.NEGATIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            sup  = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n    }",
      "public double getSup()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  sup  = Double.NEGATIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            sup  = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n    }",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    while (token.type == INVALID) \n    {\n        // ignore whitespaces at beginning of a token\n        if (ignoreSurroundingSpaces) \n        {\n            while (isWhitespace(ch) && !eol) \n            {\n                ch = reader.read();\n                eol = readEndOfLine(ch);\n            }\n        }\n\n        // ok, start of token reached: encapsulated, or token\n        if (isDelimiter(ch)) \n        {\n            // empty token return TOKEN(\"\")\n            token.type = TOKEN;\n        } \n        else if (eol) \n        {\n            // empty token return EORECORD(\"\")\n            // noop: token.content.append(\"\");\n            token.type = EORECORD;\n        } \n        else if (isQuoteChar(ch)) \n        {\n            // consume encapsulated token\n            parseEncapsulatedToken(token);\n        } \n        else if (isEndOfFile(ch)) \n        {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        } \n        else \n        {\n            // next token must be a simple token\n            // add removed blanks when not ignoring whitespace chars...\n            parseSimpleToken(token, ch);\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        // save current line number in case needed for IOE\n        final long startLineNumber = getCurrentLineNumber();\n        boolean eol = false;\n        boolean escaped = false;\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (isWhitespace(ch) && !eol) {\n                    ch = reader.read();\n                    eol = readEndOfLine(ch);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(ch)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isEndOfFile(ch)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                while (true) {\n                    if (isEscape(ch)) {\n                        escaped = true;\n                        ch = reader.read();\n                    } else if (isDelimiter(ch) && !escaped) {\n                        break;\n                    } else if (isEndOfFile(ch) && !escaped) {\n                        break;\n                    } else if (isEndOfLine(ch) && !escaped) {\n                        eol = true;\n                        break;\n                    } else if (isMetaChar(ch) && !escaped) {\n                        break;\n                    } else {\n                        token.content.append((char) ch);\n                    }\n                    escaped = false;\n                    ch = reader.read();\n                }\n            }\n        }\n        return token;\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        // save current line number in case needed for IOE\n        final long startLineNumber = getCurrentLineNumber();\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (isWhitespace(ch) && !eol) {\n                    ch = reader.read();\n                    eol = readEndOfLine(ch);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(ch)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(ch)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(ch)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                token.content.append((char) ch);\n                ch = reader.read();\n                while (ch != -1 && !isDelimiter(ch) && !eol && !isEndOfFile(ch)) {\n                    token.content.append((char) ch);\n                    ch = reader.read();\n                }\n                token.type = TOKEN;\n            }\n        }\n        return token;\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (token.type == INVALID) {\n        // add removed blanks when not ignoring whitespace chars...\n        if (ignoreSurroundingSpaces) {\n            while (isWhitespace(ch) && !eol) {\n                ch = reader.read();\n                eol = readEndOfLine(ch);\n            }\n        }\n\n        // ok, start of token reached: encapsulated, or token\n        if (isDelimiter(ch)) {\n            // empty token return TOKEN(\"\")\n            token.type = TOKEN;\n        } else if (eol) {\n            // empty token return EORECORD(\"\")\n            // noop: token.content.append(\"\");\n            token.type = EORECORD;\n        } else if (isQuoteChar(ch)) {\n            // consume encapsulated token\n            parseEncapsulatedToken(token);\n        } else if (isEndOfFile(ch)) {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        } else {\n            // next token must be a simple token\n            // add removed blanks when not ignoring whitespace chars...\n            token.content.append((char) ch);\n            ch = reader.read();\n            eol = readEndOfLine(ch);\n            if (eol) {\n                token.type = EORECORD;\n            } else if (isDelimiter(ch)) {\n                token.type = TOKEN;\n            } else if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // error: invalid char\n                token.type = INVALID;\n            }\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    while (token.type == INVALID) \n    {\n        // ignore whitespaces at beginning of a token\n        if (ignoreSurroundingSpaces) \n        {\n            while (isWhitespace(ch) && !eol) \n            {\n                ch = reader.read();\n                eol = readEndOfLine(ch);\n            }\n        }\n\n        // ok, start of token reached: encapsulated, or token\n        if (isDelimiter(ch)) \n        {\n            // empty token return TOKEN(\"\")\n            token.type = TOKEN;\n        } \n        else if (eol) \n        {\n            // empty token return EORECORD(\"\")\n            // noop: token.content.append(\"\");\n            token.type = EORECORD;\n        } \n        else if (isQuoteChar(ch)) \n        {\n            // consume encapsulated token\n            parseEncapsulatedToken(token);\n        } \n        else if (isEndOfFile(ch)) \n        {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        } \n        else \n        {\n            // next token must be a simple token\n            // add removed blanks when not ignoring whitespace chars...\n            token.content.append((char) ch);\n            ch = reader.read();\n            eol = readEndOfLine(ch);\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    boolean eol = false;\n    while (token.type == INVALID) {\n        // ignore whitespaces at beginning of a token\n        if (ignoreSurroundingSpaces) {\n            while (isWhitespace(ch) && !eol) {\n                ch = reader.read();\n                eol = readEndOfLine(ch);\n            }\n        }\n\n        // ok, start of token reached: encapsulated, or token\n        if (isDelimiter(ch)) {\n            // empty token return TOKEN(\"\")\n            token.type = TOKEN;\n        } else if (eol) {\n            // empty token return EORECORD(\"\")\n            // noop: token.content.append(\"\");\n            token.type = EORECORD;\n        } else if (isEndOfFile(ch)) {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        } else {\n            // next token must be a simple token\n            // add removed blanks when not ignoring whitespace chars...\n            token.content.append((char) ch);\n            ch = reader.read();\n            while (!isDelimiter(ch) && !eol && !isEndOfFile(ch)) {\n                if (isEscape(ch)) {\n                    ch = readEscape();\n                }\n                token.content.append((char) ch);\n                ch = reader.read();\n            }\n            token.type = TOKEN;\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    boolean eol = readEndOfLine(ch);\n    while (token.type == INVALID) {\n        // ignore whitespaces at beginning of a token\n        if (ignoreSurroundingSpaces) {\n            while (isWhitespace(ch) && !eol) {\n                ch = reader.read();\n                eol = readEndOfLine(ch);\n            }\n        }\n\n        // ok, start of token reached: encapsulated, or token\n        if (isDelimiter(ch)) {\n            // empty token return TOKEN(\"\")\n            token.type = TOKEN;\n        } else if (eol) {\n            // empty token return EORECORD(\"\")\n            // noop: token.content.append(\"\");\n            token.type = EORECORD;\n        } else if (isQuoteChar(ch)) {\n            // consume encapsulated token\n            parseEncapsulatedToken(token);\n        } else if (isEndOfFile(ch)) {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        } else {\n            // next token must be a simple token\n            // add removed blanks when not ignoring whitespace chars...\n            token.content.append((char) ch);\n            ch = reader.read();\n            eol = readEndOfLine(ch);\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (true) {\n        c = reader.read();\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (isWhitespace(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    boolean eol = false;\n    while (token.type == INVALID) {\n        // ignore whitespaces at beginning of a token\n        if (ignoreSurroundingSpaces) {\n            while (isWhitespace(ch) && !eol) {\n                ch = reader.read();\n                eol = readEndOfLine(ch);\n            }\n        }\n\n        // ok, start of token reached: encapsulated, or token\n        if (isDelimiter(ch)) {\n            // empty token return TOKEN(\"\")\n            token.type = TOKEN;\n        } else if (eol) {\n            // empty token return EORECORD(\"\")\n            // noop: token.content.append(\"\");\n            token.type = EORECORD;\n        } else if (isQuoteChar(ch)) {\n            // consume encapsulated token\n            parseEncapsulatedToken(token);\n        } else if (isEndOfFile(ch)) {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        } else {\n            // next token must be a simple token\n            // add removed blanks when not ignoring whitespace chars...\n            token.content.append((char) ch);\n            ch = reader.read();\n            eol = readEndOfLine(ch);\n            while (!isDelimiter(ch) && !eol && !isEndOfFile(ch)) {\n                token.content.append((char) ch);\n                ch = reader.read();\n                eol = readEndOfLine(ch);\n            }\n            token.type = TOKEN;\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    while (token.type == INVALID) \n    {\n        // ignore whitespaces at beginning of a token\n        if (ignoreSurroundingSpaces) \n        {\n            while (isWhitespace(ch) && !eol) \n            {\n                ch = reader.read();\n                eol = readEndOfLine(ch);\n            }\n        }\n\n        // ok, start of token reached: encapsulated, or token\n        if (isDelimiter(ch)) \n        {\n            // empty token return TOKEN(\"\")\n            token.type = TOKEN;\n        } \n        else if (eol) \n        {\n            // empty token return EORECORD(\"\")\n            // noop: token.content.append(\"\");\n            token.type = EORECORD;\n        } \n        else if (isQuoteChar(ch)) \n        {\n            // consume encapsulated token\n            parseEncapsulatedToken(token);\n        } \n        else if (isEndOfFile(ch)) \n        {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        } \n        else \n        {\n            // next token must be a simple token\n            // add removed blanks when not ignoring whitespace chars...\n            parseSimpleToken(token, ch);\n        }\n    }\n    return token;\n}"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(index, 0, getSize() - 1);\n    }\n    int[] counts = new int[dimension];\n    int[] uniCounterOffset = new int[dimension];\n    int tS = size[last];\n    for (int i = 0; i < last; i++) {\n        int count = 1;\n        for (int j = i + 1; j < dimension; j++) {\n            count *= size[j];\n        }\n        uniCounterOffset[i] = count;\n        tS *= size[i];\n    }\n    uniCounterOffset[last] = 0;\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize - 1);\n        }\n        int[] counts = new int[dimension];\n        for (int i = 0; i < dimension; i++) {\n            counts[i] = index / uniCounterOffset[i];\n            index -= counts[i] * uniCounterOffset[i];\n        }\n        counts[last] += index;\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    counts[last] += index;\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= getSize()) {\n        throw new OutOfRangeException(index, 0, getSize() - 1);\n    }\n    int[] counts = new int[dimension];\n    int remainder = index;\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = remainder / uniCounterOffset[i];\n        remainder = remainder % uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i] % size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize - 1);\n        }\n        int[] counts = new int[dimension];\n        int count = index;\n        for (int i = 0; i < dimension; i++) {\n            counts[i] = count / uniCounterOffset[i];\n            count %= uniCounterOffset[i];\n        }\n        counts[last] += count;\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i] % size[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    counts[last] += index;\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize - 1);\n        }\n        int[] counts = new int[dimension];\n        int[] uniCounterOffset = new int[dimension];\n        int tS = size[last];\n        for (int i = 0; i < last; i++) {\n            int count = 1;\n            for (int j = i + 1; j < dimension; j++) {\n                count *= size[j];\n            }\n            uniCounterOffset[i] = count;\n            tS *= size[i];\n        }\n        uniCounterOffset[last] = 0;\n        int c = index;\n        for (int i = 0; i < dimension; i++) {\n            counts[i] = c / uniCounterOffset[i];\n            c %= uniCounterOffset[i];\n        }\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize - 1);\n        }\n        int[] counts = new int[dimension];\n        int[] uniCounterOffset = new int[dimension];\n        for (int i = 0; i < dimension; i++) {\n            int count = 1;\n            for (int j = i + 1; j < dimension; j++) {\n                count *= size[j];\n            }\n            uniCounterOffset[i] = count;\n        }\n        for (int i = 0; i < dimension; i++) {\n            counts[i] = index / uniCounterOffset[i] % size[i];\n        }\n        return counts;\n    }"
    ],
    [
      "public JsonPointer last()  {\n    JsonPointer p = this;\n    while (p._nextSegment != null) {\n        p = p._nextSegment;\n    }\n    return p;\n}",
      "public JsonPointer last()  {\n    if (_nextSegment == null) {\n        return this;\n    }\n    return _nextSegment.last();\n}",
      "public JsonPointer last()  {\n    if (_nextSegment == null) {\n        return this;\n    }\n    return _nextSegment.last();\n}",
      "public JsonPointer last()  {\n    JsonPointer p = this;\n    while (p._nextSegment != null) {\n        p = p._nextSegment;\n    }\n    return p;\n}",
      "public JsonPointer last()  {\n    JsonPointer curr = this;\n    while (curr._nextSegment != null) {\n        curr = curr._nextSegment;\n    }\n    return curr;\n}",
      "public JsonPointer last()  {\n    if (_nextSegment == null) {\n        return this;\n    }\n    return _nextSegment.last();\n}",
      "public JsonPointer last()  {\n    JsonPointer curr = this;\n    while (curr._nextSegment != null) {\n        curr = curr._nextSegment;\n    }\n    return curr;\n}",
      "public JsonPointer last()  {\n    JsonPointer p = this;\n    while (p._nextSegment != null) {\n        p = p._nextSegment;\n    }\n    return p;\n}",
      "public JsonPointer last()  {\n    JsonPointer curr = this;\n    while (curr._nextSegment != null) {\n        curr = curr._nextSegment;\n    }\n    return curr;\n}",
      "public JsonPointer last()  {\n    JsonPointer p = this;\n    while (p._nextSegment != null) {\n        p = p._nextSegment;\n    }\n    return p;\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because obj is checked to be an instance of cls\n            T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (Exception ex) {\n            throw new CloneFailedException(cls, ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            return (T) cls.getMethod(\"clone\", new Class[0]).invoke(obj, new Object[0]);\n        } catch (Exception ex) {\n            throw new CloneFailedException(cls, ex);\n        }\n    } else {\n        return null;\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    T clone = null;\n    if (obj instanceof Cloneable) {\n        try {\n            final Class<?> cls = obj.getClass();\n            final Method cloneMethod = cls.getMethod(\"clone\");\n            clone = cls.cast(cloneMethod.invoke(obj));\n        } catch (final NoSuchMethodException | IllegalAccessException | InvocationTargetException ex) {\n            throw new CloneFailedException(ex);\n        }\n    }\n    return clone;\n}\n//-----------------------------------------------------------------------",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            return (T) cls.getMethod(\"clone\").invoke(obj);\n        } catch (Exception ex) {\n            throw new CloneFailedException(cls, ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because obj is verified to be of type Cloneable\n            T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (Exception ex) {\n            throw new CloneFailedException(cls, ex);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    T clone = null;\n    if (obj instanceof Cloneable) {\n        try {\n            final Class<?> cls = obj.getClass();\n            final Method cloneMethod = cls.getMethod(\"clone\");\n            clone = cls.cast(cloneMethod.invoke(obj));\n        } catch (final NoSuchMethodException | IllegalAccessException | InvocationTargetException ex) {\n            throw new CloneFailedException(ex);\n        }\n    }\n    return clone;\n}",
      "public static <T> T clone(final T obj)  {\n    T clone = null;\n    if (obj instanceof Cloneable) {\n        try {\n            final Class<?> cls = obj.getClass();\n            clone = (T) cls.newInstance();\n            final Field[] fields = cls.getDeclaredFields();\n            AccessibleObject.setAccessible(fields, true);\n            for (final Field field : fields) {\n                final Object oldValue = field.get(obj);\n                if (oldValue instanceof Cloneable) {\n                    final Object newValue = clone(oldValue);\n                    field.set(clone, newValue);\n                }\n            }\n        } catch (final Exception ex) {\n            throw new CloneFailedException(ex);\n        }\n    }\n    return clone;\n}",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) \n        {\n            return null;\n        }\n        if (obj instanceof Cloneable) \n        {\n            Class<?> cls = obj.getClass();\n            try \n            {\n                return cls.cast(cls.getMethod(\"clone\", new Class[0]).invoke(obj, new Object[0]));\n            } \n            catch (Exception ex) \n            {\n                throw new CloneFailedException(ex);\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        Class<?> cls = obj.getClass();\n        try {\n            @SuppressWarnings(\"unchecked\") // OK because obj is checked to be an instance of cls\n            final T clone = (T) cls.getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Exception ex) {\n            throw new CloneFailedException(cls, ex);\n        }\n    }\n    return null;\n}\n// cloning\n//-----------------------------------------------------------------------",
      "public static <T> T clone(final T obj)  {\n    T clone = null;\n    if (obj instanceof Cloneable) \n    {\n        try \n        {\n            final Class<?> cls = obj.getClass();\n            final Method cloneMethod = cls.getMethod(\"clone\");\n            clone = cls.cast(cloneMethod.invoke(obj));\n        } \n        catch (final NoSuchMethodException | IllegalAccessException | InvocationTargetException ex) \n        {\n            throw new CloneFailedException(ex);\n        }\n    }\n    return clone;\n}"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  for (ObjectType.Property prop : type.getOwnPropertyNames()) {\n    if (prop.getName().equals(paramName)) {\n      return prop.getSymbol();\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  for (ObjectType.Property prop : type.getOwnPropertyNames()) {\n    if (prop.getName().equals(paramName)) {\n      return prop.getSymbol();\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  return type.getParameter(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  for (String param : type.getParameterNames()) {\n    if (param.equals(paramName)) {\n      return sym.scope.getQualifiedSlot(param);\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  for (ObjectType.Property prop : type.getProperties().values()) {\n    if (prop.getName().equals(paramName)) {\n      return prop.getSymbol();\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n\n  for (ObjectType.Property p : type.getProperties().values()) {\n    if (p.getName().equals(paramName)) {\n      return p.getSymbol();\n    }\n  }\n\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n\n  for (String param : type.getParameterNames()) {\n    if (param.equals(paramName)) {\n      return getSymbolForName(type.getSource(), param);\n    }\n  }\n\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  for (ObjectType.Property prop : type.getOwnProperty(\"prototype\").getProperties()) {\n    if (prop.getName().equals(paramName)) {\n      return prop.getSymbol();\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n\n  for (ObjectType.Property prop : type.getProperties().values()) {\n    if (prop.getName().equals(paramName)) {\n      return prop.getSymbol();\n    }\n  }\n\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n\n  for (String param : type.getParameters()) {\n    if (param.equals(paramName)) {\n      return getSymbolForName(sym.getDeclarationNode(), param);\n    }\n  }\n\n  return null;\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int n = matrix.getColumnDimension();\n        if (n < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA_FOR_COVARIANCE_MATRIX, n, 2);\n        }\n        RealMatrix m = matrix.subtract(matrix.getColumnMean());\n        if (biasCorrected) {\n            m = m.scalarMultiply(n/(n-1d));\n        }\n        return m.multiply(m.transpose());\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    if (matrix.getColumnDimension() < 1) {\n        throw new MathIllegalArgumentException(LocalizedFormats.AT_LEAST_TWO_COLUMNS);\n    }\n    if (matrix.getRowDimension() < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.AT_LEAST_TWO_ROWS);\n    }\n    final int nCols = matrix.getColumnDimension();\n    final int nRows = matrix.getRowDimension();\n    final RealMatrix covarianceMatrix =\n        matrix.getSubMatrix(0, nRows - 1, 0, nCols - 1).copy();\n    if (biasCorrected) {\n        final double n = matrix.getRowDimension();\n        for (int i = 0; i < nCols; i++) {\n            for (int j = i; j < nCols; j++) {\n                final double cov = covarianceMatrix.getEntry(i, j);\n                final double devI = matrix.getColumnVector(i).getNorm();\n                final double devJ = matrix.getColumnVector(j).getNorm();\n                covarianceMatrix.setEntry(i, j, cov * (n - 1) / (n - 2) * devI * devJ);\n                covarianceMatrix.setEntry(j, i, covarianceMatrix.getEntry(i, j));\n            }\n        }\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Compute covariance matrix\n    RealMatrix covarianceMatrix = matrix.transpose().multiply(matrix);\n\n    // Bias-corrected covariance matrix\n    if (biasCorrected) {\n        double n = matrix.getRowDimension();\n        covarianceMatrix = covarianceMatrix.scalarMultiply((n - 1) / n);\n    }\n\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int n = matrix.getRowDimension();\n    RealMatrix covarianceMatrix = matrix.subtract(matrix.getColumn(0).outerProduct(matrix.getColumn(0).transpose()));\n    covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / (n - (biasCorrected ? 1 : 0)));\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    final int nCols = matrix.getColumnDimension();\n    final int nRows = matrix.getRowDimension();\n    final RealMatrix m = matrix.subtract(matrix.getColumnMeans());\n    final RealMatrix covarianceMatrix = m.multiply(m.transpose());\n    if (biasCorrected) {\n        final double n = matrix.getRowDimension();\n        for (int i = 0; i < nCols; i++) {\n            for (int j = i; j < nCols; j++) {\n                final double factor = n / (n - 1);\n                covarianceMatrix.setEntry(i, j, covarianceMatrix.getEntry(i, j) * factor);\n                covarianceMatrix.setEntry(j, i, covarianceMatrix.getEntry(j, i) * factor);\n            }\n        }\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        if (matrix.getColumnDimension() < 1) {\n            throw new MathIllegalArgumentException(LocalizedFormats.AT_LEAST_TWO_COLUMNS,\n                                                   matrix.getColumnDimension(), 1);\n        }\n        if (matrix.getRowDimension() < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.AT_LEAST_TWO_ROWS,\n                                                   matrix.getRowDimension(), 2);\n        }\n        int nCols = matrix.getColumnDimension();\n        RealMatrix m = matrix.subMatrix(0, matrix.getRowDimension() - 1,\n                                        0, nCols - 1);\n        RealMatrix c = m.transpose().multiply(m);\n        if (biasCorrected) {\n            c = c.scalarMultiply((1.0 / (m.getRowDimension() - 1)));\n        } else {\n            c = c.scalarMultiply((1.0 / m.getRowDimension()));\n        }\n        return c;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int nCols = matrix.getColumnDimension();\n        int nRows = matrix.getRowDimension();\n        if (nRows < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA_FOR_COVARIANCE_MATRIX, nRows, 2);\n        }\n        if (nCols < 1) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA_FOR_COVARIANCE_MATRIX, nCols, 1);\n        }\n        RealMatrix covarianceMatrix = matrix.subtract(matrix.getColumn(0).outerProduct(matrix.getColumn(0).getColumnVector(0)));\n        for (int i = 1; i < nCols; i++) {\n            covarianceMatrix = covarianceMatrix.add(matrix.getColumn(i).outerProduct(matrix.getColumn(i).getColumnVector(0)));\n        }\n        if (biasCorrected) {\n            covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / (nRows - 1));\n        } else {\n            covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / nRows);\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        // check for sufficient data\n        checkSufficientData(matrix);\n\n        // get number of observations\n        int n = matrix.getRowDimension();\n\n        // get the means of the columns\n        double[] means = matrix.getColumnMeans();\n\n        // get the deviations of the columns\n        RealMatrix deviations = matrix.subtract(means);\n\n        // compute the covariance matrix\n        RealMatrix covarianceMatrix = deviations.transpose().multiply(deviations);\n\n        // divide by (n - 1) if bias-corrected\n        if (biasCorrected) {\n            covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / (n - 1));\n        }\n\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // TODO: Implement this method\n    return null;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        int n = matrix.getColumnDimension();\n        if (n < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.AT_LEAST_TWO_COLUMNS, n);\n        }\n        RealMatrix m = matrix.subMatrix(0, matrix.getRowDimension() - 1, 0, n - 1);\n        double[][] data = m.getData();\n        double[] mean = new double[n];\n        for (int i = 0; i < n; i++) {\n            double sum = 0;\n            for (int j = 0; j < data.length; j++) {\n                sum += data[j][i];\n            }\n            mean[i] = sum / data.length;\n        }\n        RealMatrix centered = m.subtract(new Array2DRowRealMatrix(mean, false));\n        RealMatrix covariance = centered.transpose().multiply(centered);\n        if (biasCorrected) {\n            covariance = covariance.scalarMultiply(data.length / (data.length - 1.0));\n        }\n        return covariance;\n    }"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (ensureCache(count)) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE + \" but is \" + count);\n    }\n    if (count == 0) {\n        return 0l;\n    }\n    if (ensureCache(count)) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached = bitsCached >>> count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    return -1l;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    long bitsOut;\n    if (bitsCachedSize >= count) {\n        // bits are already in the cache\n        bitsOut = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n    } else {\n        // bits are not all in the cache\n        bitsOut = processBitsGreater57(count);\n    }\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE + \" but is \" + count);\n    }\n    if (count == 0) {\n        return 0;\n    }\n    if (count <= bitsCachedSize) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    if (ensureCache(count)) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be a positive number not bigger than \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (ensureCache(count)) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (ensureCache(count)) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    if (count <= bitsCachedSize) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n\n    final int bitsToRead = count - bitsCachedSize;\n    final int bytesToRead = bitsToRead / 8;\n    final int bitsToCache = bitsToRead % 8;\n\n    if (bitsCachedSize > 0) {\n        final long bitsOut = bitsCached;\n        bitsCached = 0;\n        bitsCachedSize = 0;\n        return bitsOut | (readBits(bitsToRead) << bitsCachedSize);\n    }\n\n    if (ensureCache(bytesToRead)) {\n        final long bitsOut = bitsCached & MASKS[bitsToCache];\n        bitsCached >>= bitsToCache;\n        bitsCachedSize -= bitsToCache;\n        return bitsOut;\n    }\n\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be a positive number not bigger than \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (count == 0) {\n        return 0;\n    }\n    if (ensureCache(count)) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE + \": \" + count);\n    }\n    if (ensureCache(count)) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be a positive number not bigger than \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (ensureCache(count)) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    return -1;\n}"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.data.length;\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.data.length;\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.data.length;\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.data.length;\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.data.length;\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n        final int m = data.length;\n        final int n = v.data.length;\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.data[j]));\n            }\n        }\n        return out;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.data.length;\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node labelNode = target.getFirstChild();\n  return labelNode != null && labelNode.getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.isLabel()) {\n      return label.equals(target.getFirstChild().getString());\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.isLabel()) {\n      return label.equals(target.getFirstChild().getString());\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.isLabel()) {\n      return label.equals(target.getFirstChild().getString());\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.isLabel()) {\n      return target.getFirstChild().getString().equals(label);\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target.isLabel()) {\n    return target.getFirstChild().getString().equals(label);\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    Node labelNode = target.getFirstChild();\n    return labelNode != null && labelNode.getString().equals(label);\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.isLabel()) {\n      return target.getFirstChild().getString().equals(label);\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.isLabel()) {\n      return label.equals(target.getFirstChild().getString());\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node labelNode = target.getFirstChild();\n  return labelNode != null && labelNode.getString().equals(label);\n}"
    ],
    [
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) \n    {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) \n    {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) \n    {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) \n    {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) \n    {\n        return (String) urls.get(item);\n    } \n    else \n    {\n        return null;\n    }\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) \n    {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    int ch = str.charAt(0);\n    if (ch < '0' || ch > '9') {\n        return -1;\n    }\n    int value = ch - '0';\n    for (int i = 1; i < len; ++i) {\n        ch = str.charAt(i);\n        if (ch < '0' || ch > '9') {\n            return -1;\n        }\n        value = value * 10 + (ch - '0');\n    }\n    return value;\n}\n\nprotected JsonPointer _parseTail(String input) \n{\n    int i = 0;\n    while (i < input.length() && input.charAt(i) == '/') {\n        ++i;\n    }\n    if (i == input.length()) {\n        return EMPTY;\n    }\n    int j = i;\n    while (j < input.length() && input.charAt(j) != '/') {\n        ++j;\n    }\n    if (j == i) {\n        return null;\n    }\n    String segment = input.substring(i, j);\n    if (segment.length() == 0) {\n        return null;\n    }\n    JsonPointer next = _parseTail(input.substring(j));\n    if (segment.charAt(0) == '~') {\n        if (segment.length() == 1) {\n            return null;\n        }\n        if (segment.charAt(1) == '0') {\n            if (segment.length() == 2) {\n                return null;\n            }\n            if (segment.charAt(2) != '0') {\n                return null;\n            }\n            if (segment.length() == 3) {\n                return null;\n            }\n            if (segment.charAt(3) != '0') {\n                return null;\n            }\n            if (segment.length() == 4) {\n                return null;\n            }\n}\n}\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    if (str.charAt(0) == '0') {\n        if (len == 1) {\n            return 0;\n        }\n        if (str.charAt(1) == '0') {\n            if (len == 2) {\n                return 0;\n            }\n            if (str.charAt(2) == '0') {\n                if (len == 3) {\n                    return 0;\n                }\n                if (str.charAt(3) == '0') {\n                    if (len == 4) {\n                        return 0;\n                    }\n                    if (str.charAt(4) == '0') {\n                        if (len == 5) {\n                            return 0;\n                        }\n                        if (str.charAt(5) == '0') {\n                            if (len == 6) {\n                                return 0;\n                            }\n                            if (str.charAt(6) == '0') {\n                                if (len == 7) {\n                                    return 0;\n                                }\n                                if (str.charAt(7) == '0') {\n                                    if (len == 8) {\n                                        return 0;\n                                    }\n                                    if (str.charAt(8) == '0') {\n                                        if (len == 9) {\n                                            return 0;\n                                        }\n                                        if (str.charAt(9) == '0') {\n                                            if (len == 10) {\n                                                return 0;\n                                            }\n                                            if (str.charAt(10) == '0') {\n                                                if (len == 11) {\n                                                    return 0;\n                                                }\n                                                if (str.charAt(11) == '0') {\n                                                    if (len == 12) {\n                                                        return 0;\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    int ch = str.charAt(0);\n    if (ch < '0' || ch > '9') {\n        return -1;\n    }\n    int value = ch - '0';\n    for (int i = 1; i < len; ++i) {\n        ch = str.charAt(i);\n        if (ch < '0' || ch > '9') {\n            return -1;\n        }\n        value = value * 10 + (ch - '0');\n    }\n    return value;\n}\n\nprotected JsonPointer _parseTail(String input) \n{\n    int i = 0;\n    int len = input.length();\n    while (i < len) {\n        char ch = input.charAt(i);\n        if (ch == '/') {\n            return _parseTail(input, i + 1);\n        }\n        if (ch == '~') {\n            return _parseQuotedTail(input, i + 1);\n        }\n        ++i;\n    }\n    return null;\n}\n\nprotected JsonPointer _parseQuotedTail(String input, int i) \n{\n    int len = input.length();\n    while (i < len) {\n        char ch = input.charAt(i);\n        if (ch == '~') {\n            return _parseQuotedTail(input, i + 1);\n        }\n        ++i;\n    }\n    return null;\n}",
      "private final static int _parseIndex(String str)  {\n    int ix = str.indexOf('[');\n    if (ix < 0) {\n        return -1;\n    }\n    int end = str.indexOf(']', ix);\n    if (end < 0) {\n        return -1;\n    }\n    String numStr = str.substring(ix+1, end);\n    int num = Integer.parseInt(numStr);\n    return num;\n}\n\nprotected JsonPointer _parseTail(String input) \n{\n    int ix = input.indexOf('/');\n    if (ix < 0) {\n        return null;\n    }\n    String tail = input.substring(ix+1);\n    return _parseTail(tail);\n}\n\nprotected JsonPointer _parseTail(String input) \n{\n    int ix = input.indexOf('/');\n    if (ix < 0) {\n        return null;\n    }\n    String segment = input.substring(0, ix);\n    int matchIndex = _parseIndex(segment);\n    if (matchIndex >= 0) {\n        return _parseQuotedTail(input, ix);\n    }\n    return _parseQuotedTail(input, ix);\n}\n\nprotected JsonPointer _parseQuotedTail(String input, int ix) \n{\n    String segment = input.substring(0, ix);\n    String tail = input.substring(ix+1);\n    JsonPointer next = _parseTail(tail);\n    return new JsonPointer(input, segment, matchIndex, next);\n}\n\nprotected JsonPointer _constructHead() \n{\n    return new JsonPointer();\n}\n\nprotected JsonPointer _constructHead(int suffixLength, JsonPointer last) \n{\n    return new JsonPointer();\n}",
      "private final static int _parseIndex(String str)  {\n    int ix = str.indexOf(']');\n    if (ix < 0) {\n        throw new IllegalArgumentException(\"Missing ']'\");\n    }\n    if (ix != str.length() - 1) {\n        throw new IllegalArgumentException(\"Unexpected trailing characters after ']'\");\n    }\n    return Integer.parseInt(str.substring(1, ix));\n}\n\nprotected JsonPointer _parseTail(String input) \n{\n    int ix = input.indexOf('/');\n    if (ix < 0) {\n        return null;\n    }\n    return _parseTail(input.substring(ix + 1));\n}\n\nprotected JsonPointer _parseQuotedTail(String input, int i) \n{\n    int ix = input.indexOf('/');\n    if (ix < 0) {\n        return null;\n    }\n    return _parseQuotedTail(input.substring(ix + 1), i);\n}\n\nprotected JsonPointer _parseTail(String input) \n{\n    if (input.startsWith(\"-\")) {\n        return new JsonPointer(input, input, _parseIndex(input), null);\n    }\n    if (input.startsWith(\"\\\"\")) {\n        return _parseQuotedTail(input, 1);\n    }\n    return new JsonPointer(input, input, null);\n}\n\nprotected JsonPointer _parseQuotedTail(String input, int i) \n{\n    int ix = input.indexOf('\\\"');\n    if (ix < 0) {\n        throw new IllegalArgumentException(\"Missing '\\\"'\");\n    }\n    if (ix != input.length() - 1) {\n        throw new IllegalArgumentException(\"Unexpected trailing characters after '\\\"'\");\n    }\n    return new JsonPointer(input, input, _parseIndex(input), null);\n}\n\nprotected JsonPointer _constructHead() \n{\n    return _head;\n}\n\nprotected JsonPointer _constructHead(int suffixLength, JsonPointer last) \n{\n    return last;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    int ch = str.charAt(0);\n    if (ch < '0' || ch > '9') {\n        return -1;\n    }\n    int value = ch - '0';\n    for (int i = 1; i < len; ++i) {\n        ch = str.charAt(i);\n        if (ch < '0' || ch > '9') {\n            return -1;\n        }\n        value = value * 10 + (ch - '0');\n    }\n    return value;\n}\n\nprotected JsonPointer _parseTail(String input)\n{\n    if (input.length() == 0) {\n        return EMPTY;\n    }\n    if (input.charAt(0) == '/') {\n        return _parseTail(input.substring(1));\n    }\n    int slash = input.indexOf('/');\n    if (slash < 0) {\n        return _parseTail(input.substring(slash + 1));\n    }\n    String segment = input.substring(0, slash);\n    if (segment.length() == 0) {\n        return _parseTail(input.substring(slash + 1));\n    }\n    if (segment.charAt(0) == '~') {\n        if (segment.length() == 1) {\n            return _parseTail(input.substring(slash + 1));\n        }\n        if (segment.charAt(1) == '0') {\n            return _parseTail(input.substring(slash + 1));\n        }\n        if (segment.charAt(1) == '1') {\n            return _parseTail(input.substring(slash + 1));\n        }\n    }\n    return _parseTail(input.substring(slash + 1));\n}\n\nprotected JsonPointer _parseQuotedTail(String input, int i)\n{\n    if (input.length() == 0) {\n        return EMPTY;\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    int ch = str.charAt(0);\n    if (ch >= '0' && ch <= '9') {\n        return ch - '0';\n    }\n    if (ch >= 'A' && ch <= 'Z') {\n        return ch - 'A' + 10;\n    }\n    if (ch >= 'a' && ch <= 'z') {\n        return ch - 'a' + 10;\n    }\n    return -1;\n}\n\nprotected JsonPointer _parseTail(String input)\n{\n    if (input.length() == 0) {\n        return this;\n    }\n    int ix = 0;\n    if (input.charAt(0) == '/') {\n        ix = 1;\n    }\n    int ix2 = input.indexOf('/', ix);\n    if (ix2 < 0) {\n        ix2 = input.length();\n    }\n    String segment = input.substring(ix, ix2);\n    if (segment.length() == 0) {\n        return this;\n    }\n    int matchIndex = _parseIndex(segment);\n    if (matchIndex >= 0) {\n        return new JsonPointer(input, segment, matchIndex, _parseTail(input.substring(ix2)));\n    }\n    return new JsonPointer(input, segment, _parseTail(input.substring(ix2)));\n}\n\nprotected JsonPointer _parseQuotedTail(String input, int i)\n{\n    if (input.length() == 0) {\n        return this;\n    }\n    int ix = i + 1;\n    int ix2 = input.indexOf('\"', ix);\n    if (ix2 < 0) {\n        ix2 = input.length();\n    }\n    String segment = input.substring(ix, ix2);\n    if (segment.length() == 0) {\n        return this;\n    }\n    int matchIndex = _parseIndex(segment);\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    if (len > 1) {\n        if (str.charAt(0) == '0') {\n            return -1;\n        }\n        if (str.charAt(0) > '9' || str.charAt(0) < '1') {\n            return -1;\n        }\n    }\n    int ix = 0;\n    for (int i = 1; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c > '9' || c < '0') {\n            return -1;\n        }\n        ix = ix * 10 + (c - '0');\n    }\n    return ix;\n}\n\nprotected static JsonPointer _parseTail(String input) \n{\n    if (input.length() == 0) {\n        return EMPTY;\n    }\n    int ix = _parseIndex(input);\n    if (ix >= 0) {\n        return new JsonPointer(input, input, ix, EMPTY);\n    }\n    if (input.charAt(0) == '/') {\n        return new JsonPointer(input, input.substring(1), EMPTY);\n    }\n    return null;\n}\n\nprotected static JsonPointer _parseQuotedTail(String input, int i) \n{\n    if (input.length() == 0) {\n        return EMPTY;\n    }\n    int ix = _parseIndex(input);\n    if (ix >= 0) {\n        return new JsonPointer(input, input, ix, EMPTY);\n    }\n    if (input.charAt(0) == '/') {\n        return new JsonPointer(input, input.substring(1), EMPTY);\n    }\n    return null;\n}\n\nprotected JsonPointer _constructHead() \n{\n    return _head;\n}\n\nprotected JsonPointer _constructHead(int suffixLength, JsonPointer last) \n{\n    return _head;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        throw new IllegalArgumentException(\"Invalid index: \\\"\\\"\");\n    }\n    char c = str.charAt(0);\n    if (c < '0' || c > '9') {\n        throw new IllegalArgumentException(\"Invalid index: \"+str);\n    }\n    int value = c - '0';\n    for (int i = 1; i < len; ++i) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Invalid index: \"+str);\n        }\n        value = value * 10 + (c - '0');\n    }\n    return value;\n}\n\nprotected JsonPointer _parseTail(String input) \n{\n    int i = input.indexOf('/', 1);\n    if (i < 0) {\n        return null;\n    }\n    String segment = input.substring(1, i);\n    String rest = input.substring(i+1);\n    JsonPointer next = _parseTail(rest);\n    return new JsonPointer(input, segment, next);\n}\n\nprotected JsonPointer _parseQuotedTail(String input, int i) \n{\n    int start = i+1;\n    while (i < input.length()) {\n        char c = input.charAt(i);\n        if (c == '\\\\') {\n            ++i;\n            if (i >= input.length()) {\n                throw new IllegalArgumentException(\"Invalid pointer expression: \"+input);\n            }\n            ++i;\n        } else if (c == '\"') {\n            break;\n        }\n        ++i;\n    }\n    String segment = input.substring(start, i);\n    String rest = input.substring(i+1);\n    JsonPointer next = _parseTail(rest);\n    return new JsonPointer(input, segment, next);\n}\n\nprotected JsonPointer _constructHead() \n{\n    return new JsonPointer(null, null, this);\n}",
      "private final static int _parseIndex(String str)  {\n    // 01-Apr-2020, tatu: As per [databind#2530], need to support\n    //    negative indexes as well as positive ones\n    int ix = Integer.parseInt(str);\n    if (ix < 0) {\n        ix = str.length() + ix;\n    }\n    return ix;\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        return nextPermutation(c.size(), k);\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        return nextPermutation(c.size(), k);\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node call = new Node(Token.CALL,\n                           new Node(Token.GETPROP,\n                                    new Node(Token.NAME, \"goog\"),\n                                    new Node(Token.STRING, methodName)),\n                           argumentNode);\n      call.copyInformationFromForTree(srcref);\n      return call;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node call = new Node(Token.CALL,\n                           new Node(Token.GETPROP,\n                                    new Node(Token.THIS),\n                                    new Node(Token.STRING, methodName)),\n                           argumentNode);\n      call.useSourceInfoIfMissingFromForTree(srcref);\n      return call;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = new Node(Token.CALL,\n                               Node.newString(Token.NAME, methodName),\n                               argumentNode);\n      callNode.setSourceEncodedPositionForTree(srcref.getSourceEncodedPosition());\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node call = new Node(Token.CALL,\n                           Node.newString(Token.NAME, methodName),\n                           argumentNode);\n      call.useSourceInfoIfMissingFromForTree(srcref);\n      return call;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node call = new Node(Token.CALL,\n                           new Node(Token.GETPROP,\n                                    new Node(Token.THIS),\n                                    Node.newString(compiler, methodName)),\n                           argumentNode);\n      call.setSourceFileForNode(srcref);\n      return call;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node call = new Node(Token.CALL,\n                           Node.newString(Token.NAME, methodName),\n                           argumentNode);\n      call.useSourceInfoIfMissingFromForTree(srcref);\n      return call;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = new Node(Token.CALL,\n                               Node.newString(Token.NAME, methodName),\n                               argumentNode);\n      callNode.setSourceEncodedPositionForTree(srcref.getSourceEncodedPosition());\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = new Node(Token.CALL,\n                               new Node(Token.GETPROP,\n                                        new Node(Token.NAME, \"goog\"),\n                                        new Node(Token.STRING, methodName)),\n                               argumentNode);\n      callNode.copyInformationFrom(srcref);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = new Node(Token.CALL,\n                               new Node(Token.GETPROP,\n                                        new Node(Token.THIS),\n                                        new Node(Token.STRING, methodName)),\n                               argumentNode);\n      callNode.copyInformationFrom(srcref);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node call = new Node(Token.CALL,\n                           Node.newString(Token.NAME, methodName),\n                           argumentNode);\n      call.useSourceInfoIfMissingFromForTree(srcref);\n      return call;\n    }"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n        final int[] indices = new int[doubles.length];\n        for (int i = 0; i < indices.length; i++) {\n            indices[i] = i;\n        }\n        final DoubleIndex[] d = new DoubleIndex[doubles.length];\n        for (int i = 0; i < d.length; i++) {\n            d[i] = new DoubleIndex(doubles[i], i);\n        }\n        Arrays.sort(d);\n        for (int i = 0; i < d.length; i++) {\n            indices[i] = d[i].index;\n        }\n        return indices;\n    }",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    final DoubleIndex[] sorted = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        sorted[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(sorted);\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = sorted[i].index;\n    }\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    final DoubleIndex[] sorted = new DoubleIndex[doubles.length];\n    for (int i = 0; i < sorted.length; i++) {\n        sorted[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(sorted);\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = sorted[i].index;\n    }\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n        final int[] indices = new int[doubles.length];\n        for (int i = 0; i < indices.length; i++) {\n            indices[i] = i;\n        }\n        Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n        final int[] indices = new int[doubles.length];\n        for (int i = 0; i < indices.length; i++) {\n            indices[i] = i;\n        }\n        final DoubleIndex[] d = new DoubleIndex[doubles.length];\n        for (int i = 0; i < d.length; i++) {\n            d[i] = new DoubleIndex(doubles[i], i);\n        }\n        Arrays.sort(d);\n        for (int i = 0; i < indices.length; i++) {\n            indices[i] = d[i].index;\n        }\n        return indices;\n    }",
      "private int[] sortedIndices(final double[] doubles)  {\n        final int[] indices = new int[doubles.length];\n        for (int i = 0; i < indices.length; i++) {\n            indices[i] = i;\n        }\n        Arrays.sort(indices, new Comparator<Integer>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = i;\n    }\n    final DoubleIndex[] d = new DoubleIndex[doubles.length];\n    for (int i = 0; i < d.length; i++) {\n        d[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(d);\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = d[i].index;\n    }\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n        final int[] indices = new int[doubles.length];\n        for (int i = 0; i < indices.length; i++) {\n            indices[i] = i;\n        }\n        final DoubleIndex[] doubleIndices = new DoubleIndex[doubles.length];\n        for (int i = 0; i < doubleIndices.length; i++) {\n            doubleIndices[i] = new DoubleIndex(doubles[i], i);\n        }\n        Arrays.sort(doubleIndices);\n        for (int i = 0; i < indices.length; i++) {\n            indices[i] = doubleIndices[i].index;\n        }\n        return indices;\n    }"
    ],
    [
      "public RealMatrix getQT()  {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            final double[][] qt = new double[m][m];\n            for (int i = 0; i < m; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    qt[i][j] = householderVectors[i][j];\n                }\n            }\n            cachedQt = MatrixUtils.createRealMatrix(qt);\n        }\n        return cachedQt;\n    }",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        final double[][] qt = new double[m][m];\n        for (int i = 0; i < m; ++i) \n        {\n            for (int j = 0; j < m; ++j) \n            {\n                qt[i][j] = householderVectors[i][j];\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qt);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = householderVectors.length;\n        final double[][] qt = new double[m][m];\n        for (int i = 0; i < m; ++i) {\n            qt[i][i] = 1;\n            for (int j = i + 1; j < m; ++j) {\n                qt[i][j] = householderVectors[i][j];\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qt);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = householderVectors.length;\n        final double[][] qt = new double[m][m];\n        for (int i = 0; i < m; ++i) {\n            qt[i][i] = 1;\n            for (int j = 0; j < i; ++j) {\n                qt[i][j] = householderVectors[i][j];\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qt);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = householderVectors.length;\n        final double[][] qt = new double[m][m];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < m; ++j) {\n                double sum = 0;\n                for (int k = 0; k < m; ++k) {\n                    sum += householderVectors[i][k] * householderVectors[j][k];\n                }\n                qt[i][j] = sum;\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qt);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = householderVectors.length;\n        final double[][] qt = new double[m][m];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < m; ++j) {\n                double sum = 0;\n                for (int k = 0; k < m; ++k) {\n                    sum += householderVectors[i][k] * householderVectors[j][k];\n                }\n                qt[i][j] = sum;\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qt);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) \n    {\n        double runningTotal = 0;\n        int itemCount = dataset.getItemCount(s);\n        for (int i = 0; i < itemCount; i++) \n        {\n            double value = dataset.getValue(s, i);\n            if (!Double.isNaN(value)) \n            {\n                runningTotal = runningTotal + value;\n                if (runningTotal < minimum) \n                {\n                    minimum = runningTotal;\n                }\n                if (runningTotal > maximum) \n                {\n                    maximum = runningTotal;\n                }\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // TODO: implement this method\n    return null;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    int itemCount = dataset.getItemCount();\n    for (int s = 0; s < seriesCount; s++) \n    {\n        double runningTotal = 0;\n        for (int i = 0; i < itemCount; i++) \n        {\n            double value = dataset.getValue(s, i);\n            if (!Double.isNaN(value)) \n            {\n                runningTotal += value;\n                if (runningTotal < minimum) \n                {\n                    minimum = runningTotal;\n                }\n                if (runningTotal > maximum) \n                {\n                    maximum = runningTotal;\n                }\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) \n    {\n        double total = 0.0;\n        for (int s = 0; s < seriesCount; s++) \n        {\n            double value = dataset.getValue(s, i);\n            if (!Double.isNaN(value)) \n            {\n                total = total + value;\n            }\n        }\n        if (total < minimum) \n        {\n            minimum = total;\n        }\n        if (total > maximum) \n        {\n            maximum = total;\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    }\n    else {\n        result = iterateToFindRangeBounds(dataset, true);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // TODO: implement this method\n    return null;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int series = 0; series < seriesCount; series++) \n    {\n        int itemCount = dataset.getItemCount(series);\n        double runningTotal = 0.0;\n        for (int item = 0; item < itemCount; item++) \n        {\n            double value = dataset.getValue(series, item);\n            runningTotal += value;\n            if (runningTotal < minimum) \n            {\n                minimum = runningTotal;\n            }\n            if (runningTotal > maximum) \n            {\n                maximum = runningTotal;\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    int itemCount = dataset.getItemCount();\n    for (int item = 0; item < itemCount; item++) \n    {\n        double total = 0;\n        for (int series = 0; series < seriesCount; series++) \n        {\n            double value = dataset.getValue(series, item);\n            if (!Double.isNaN(value)) \n            {\n                total = total + value;\n            }\n        }\n        if (total < minimum) \n        {\n            minimum = total;\n        }\n        if (total > maximum) \n        {\n            maximum = total;\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int series = 0; series < seriesCount; series++) \n    {\n        double runningTotal = 0.0;\n        int itemCount = dataset.getItemCount(series);\n        for (int item = 0; item < itemCount; item++) \n        {\n            double value = dataset.getValue(series, item);\n            if (!Double.isNaN(value)) \n            {\n                runningTotal += value;\n                minimum = Math.min(minimum, runningTotal);\n                maximum = Math.max(maximum, runningTotal);\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    }\n    else {\n        result = iterateToFindRangeBounds(dataset, true);\n    }\n    return result;\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) \n    {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) \n    {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) \n    {\n        throw new IllegalArgumentException(\"Minutes out of range for positive hours: \" + minutesOffset);\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) \n    {\n        return DateTimeZone.UTC;\n    }\n    int millis = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    if (millis < -DateTimeZone.MAX_MILLIS || millis > DateTimeZone.MAX_MILLIS) \n    {\n        throw new IllegalArgumentException(\"Offset out of range: \" + millis);\n    }\n    return new FixedDateTimeZone(\"Offset\", millis);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour offset is invalid: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute offset is invalid: \" + minutesOffset);\n    }\n    if (hoursOffset >= 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minute offset must be positive when hour is positive\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    int offset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    return new FixedDateTimeZone(\"FixedOffset\" + hoursOffset + \":\" + minutesOffset, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minute offset must be positive when hour offset is positive\");\n    }\n    int offset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    return new FixedDateTimeZone(\"\", offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) \n    {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) \n    {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset >= 0 && minutesOffset < 0) \n    {\n        throw new IllegalArgumentException(\"Minutes out of range for positive hours: \" + minutesOffset);\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) \n    {\n        throw new IllegalArgumentException(\"Minutes out of range for negative hours: \" + minutesOffset);\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes > 1439 || totalMinutes < -1439) \n    {\n        throw new IllegalArgumentException(\"Offset out of range: \" + totalMinutes);\n    }\n    return new FixedDateTimeZone(\"Offset\", totalMinutes * DateTimeConstants.MILLIS_PER_MINUTE, null);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minute offset must be positive when hour offset is positive\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    String id = \"GMT\" + (hoursOffset >= 0 ? \"+\" : \"\") + hoursOffset + (minutesOffset == 0 ? \"\" : \":\") + minutesOffset;\n    return fixedOffsetZone(id, hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    // Check for invalid values\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes negative when hours positive: \" + hoursOffset + \":\" + minutesOffset);\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    // Create the fixed offset zone\n    String id = \"GMT\" + (hoursOffset >= 0 ? \"+\" : \"\") + hoursOffset + \":\" + (minutesOffset < 10 ? \"0\" : \"\") + minutesOffset;\n    return new FixedDateTimeZone(id, hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    // Check the input values\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    // Calculate the total offset\n    int totalOffset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    // Check the total offset\n    if (totalOffset < -23 * 60 * 60 * 1000 || totalOffset > 23 * 60 * 60 * 1000) {\n        throw new IllegalArgumentException(\"Total offset out of range: \" + totalOffset);\n    }\n    // Return the zone\n    return fixedOffsetZone(DateTimeZone.printOffset(totalOffset), totalOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour offset too large: \" + hoursOffset);\n    }\n    if (hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Hour offset too small: \" + hoursOffset);\n    }\n    if (minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute offset too large: \" + minutesOffset);\n    }\n    if (minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Minute offset too small: \" + minutesOffset);\n    }\n    if (hoursOffset >= 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minute offset must be positive when hour is positive\");\n    }\n    if (hoursOffset <= 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minute offset must be negative when hour is negative\");\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes > 1439) {\n        throw new IllegalArgumentException(\"Total offset too large: \" + totalMinutes);\n    }\n    if (totalMinutes < -1439) {\n        throw new IllegalArgumentException(\"Total offset too small: \" + totalMinutes);\n    }\n    return new FixedDateTimeZone(\"\", totalMinutes * 60 * 1000);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    // Validate the parameters\n    if (hoursOffset < -23 || hoursOffset > 23) \n    {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) \n    {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) \n    {\n        throw new IllegalArgumentException(\"Minutes must be positive when hours are positive\");\n    }\n    // Calculate the offset in millis\n    int millis = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    // Validate the offset\n    if (millis < -23 * 60 * 60 * 1000 || millis > 23 * 60 * 60 * 1000) \n    {\n        throw new IllegalArgumentException(\"Offset exceeds +/- 23:59:59.000\");\n    }\n    // Return the fixed offset zone\n    return fixedOffsetZone(DateTimeZone.printOffset(millis), millis);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23) \n    {\n        throw new IllegalArgumentException(\"Hour offset too large: \" + hoursOffset);\n    }\n    if (hoursOffset < -23) \n    {\n        throw new IllegalArgumentException(\"Hour offset too small: \" + hoursOffset);\n    }\n    if (minutesOffset > 59) \n    {\n        throw new IllegalArgumentException(\"Minute offset too large: \" + minutesOffset);\n    }\n    if (minutesOffset < -59) \n    {\n        throw new IllegalArgumentException(\"Minute offset too small: \" + minutesOffset);\n    }\n    if (hoursOffset >= 0 && minutesOffset < 0) \n    {\n        throw new IllegalArgumentException(\"Minute offset negative when hour is positive\");\n    }\n    if (hoursOffset <= 0 && minutesOffset > 0) \n    {\n        throw new IllegalArgumentException(\"Minute offset positive when hour is negative\");\n    }\n    return forOffsetMillis(hoursOffset * 3600000 + minutesOffset * 60000);\n}"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n    int start = this.pos;\n    int end = this.pos;\n    int depth = 0;\n    while (this.remainingLength() > 0) \n    {\n        char c = this.queue.charAt(this.pos);\n        if (c == open) \n        {\n            depth++;\n        } \n        else if (c == close) \n        {\n            depth--;\n            if (depth <= 0) \n            {\n                break;\n            }\n        }\n        this.pos++;\n        end++;\n    }\n    if (depth > 0) \n    {\n        throw new IllegalStateException(\"Unbalanced brackets\");\n    }\n    String unescaped = this.unescape(this.queue.substring(start, end));\n    this.pos++;\n    return unescaped;\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = this.pos;\n    if (this.isEmpty()) \n    {\n        return \"\";\n    }\n    char c = this.queue.charAt(pos);\n    if (c != open) \n    {\n        return \"\";\n    }\n    int depth = 1;\n    int end = this.queue.length();\n    while (pos < end) \n    {\n        pos++;\n        c = this.queue.charAt(pos);\n        if (c == close) \n        {\n            depth--;\n            if (depth == 0) \n            {\n                break;\n            }\n        }\n        else if (c == open) \n        {\n            depth++;\n        }\n    }\n    return this.queue.substring(start, pos + 1);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = this.pos;\n    int end = this.pos;\n    int depth = 0;\n    while (this.remainingLength() > 0) \n    {\n        char c = this.queue.charAt(this.pos);\n        if (c == open) \n        {\n            depth++;\n        } \n        else if (c == close) \n        {\n            depth--;\n            if (depth <= 0) \n            {\n                break;\n            }\n        }\n        this.pos++;\n        end++;\n    }\n    return this.queue.substring(start, end);\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty()) \n        return \"\";\n    \n    int start = -1;\n    int end = -1;\n    int depth = 0;\n    int i = pos;\n    while (i < queue.length()) \n    {\n        char c = queue.charAt(i);\n        if (c == close) \n        {\n            depth--;\n            if (depth < 0) \n            {\n                end = i;\n                break;\n            }\n        }\n        else if (c == open) \n        {\n            depth++;\n        }\n        i++;\n    }\n    \n    if (start == -1 || end == -1) \n        return \"\";\n    \n    String unquoted = queue.substring(start + 1, end);\n    return unescape(unquoted);\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty())\n        return \"\";\n    \n    int start = pos;\n    int depth = 0;\n    String seq = \"\";\n    seq += open;\n    seq += close;\n    while (!isEmpty()) {\n        char c = consume();\n        if (c == ESC) {\n            consume();\n        }\n        else if (c == open) {\n            depth++;\n        }\n        else if (c == close) {\n            if (depth == 0)\n                break;\n            depth--;\n        }\n    }\n    return queue.substring(start, pos - 1);\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty())\n        return \"\";\n    \n    int start = -1;\n    int end = -1;\n    int depth = 0;\n    char last = 0;\n    boolean inQuote = false;\n    boolean escaped = false;\n    \n    for (int i = pos; i < queue.length(); i++) {\n        char c = queue.charAt(i);\n        \n        if (c == ESC) {\n            escaped = true;\n            continue;\n        }\n        \n        if (escaped) {\n            escaped = false;\n            continue;\n        }\n        \n        if (inQuote) {\n            if (c == last)\n                inQuote = false;\n            continue;\n        }\n        \n        if (c == '\\'' || c == '\"') {\n            inQuote = true;\n            last = c;\n            continue;\n        }\n        \n        if (c == open) {\n            depth++;\n            if (start == -1)\n                start = i;\n            continue;\n        }\n        \n        if (c == close) {\n            if (depth == 0)\n                throw new IllegalStateException(\"Found closer when not in group\");\n            depth--;\n            if (depth == 0) {\n                end = i;\n                break;\n            }\n        }\n    }\n    \n    if (start == -1 || end == -1 || start > end)\n        throw new IllegalStateException(\"Could not find balanced marker\");\n    \n    String unbalanced = queue.substring(pos, start);\n    String balanced = queue.substring(start+1, end);\n    String remainder = queue.substring(end+1);\n    \n    pos = pos + unbalanced.length() + balanced.length();\n    return unescape(unbalanced + balanced) + remainder;\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty()) \n        return \"\";\n    \n    int start = -1;\n    int end = -1;\n    int depth = 0;\n    int i = pos;\n    while (i < queue.length()) \n    {\n        char c = queue.charAt(i);\n        if (c == open) \n        {\n            if (depth++ == 0) \n                start = i;\n        }\n        else if (c == close) \n        {\n            if (--depth <= 0) \n            {\n                end = i;\n                break;\n            }\n        }\n        i++;\n    }\n    \n    if (start == -1 || end == -1) \n        return \"\";\n    \n    String unbalanced = queue.substring(start, end + 1);\n    queue = queue.substring(end + 1);\n    pos = 0;\n    return unbalanced;\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty())\n        return \"\";\n\n    int start = -1;\n    int end = -1;\n    int depth = 0;\n    int i = pos;\n    while (i < queue.length()) {\n        char c = queue.charAt(i);\n        if (c == open) {\n            if (depth++ == 0)\n                start = i;\n        }\n        else if (c == close) {\n            if (--depth <= 0) {\n                end = i;\n                break;\n            }\n        }\n        i++;\n    }\n\n    if (start == -1 || end == -1)\n        return \"\";\n\n    String unbalanced = queue.substring(start, end + 1);\n    pos += unbalanced.length();\n    return unbalanced;\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty())\n        return \"\";\n    \n    int start = pos;\n    int depth = 0;\n    StringBuffer buffer = StringUtil.borrowBuilder();\n    char last = 0;\n    \n    // look through queue to find closing bracket, keeping track of depth\n    while (!isEmpty()) {\n        char c = consume();\n        if (c == close && depth-- == 0)\n            break;\n        \n        if (c == open)\n            depth++;\n        \n        if (c == ESC) {\n            if (last != 0 && last == ESC)\n                buffer.append(c);\n        }\n        else \n            buffer.append(c);\n        last = c;\n    }\n    \n    return StringUtil.releaseBuilder(buffer).substring(start, pos-1);\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = this.pos;\n    int depth = 0;\n    while (!this.isEmpty()) \n    {\n        char c = this.consume();\n        if (c == open) \n        {\n            depth++;\n        } \n        else if (c == close) \n        {\n            depth--;\n            if (depth <= 0) \n            {\n                return this.queue.substring(start, this.pos - 1);\n            }\n        }\n    }\n    throw new IllegalStateException(\"Unbalanced brackets\");\n}"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix R = qr.getR();\n        final int p = qr.getRank();\n        // No try-catch or advertised NotStrictlyPositiveException - NPE above if p < 3\n        Array2DRowRealMatrix RT = new Array2DRowRealMatrix(p, R.getColumnDimension());\n        double[][] RTData = RT.getDataRef();\n        for (int i = 0; i < p; i++) {\n            for (int j = 0; j < R.getColumnDimension(); j++) {\n                RTData[i][j] = R.getEntry(i, j);\n            }\n        }\n\n        // Compute and return variance-covariance matrix\n        // No DME advertised - args valid if we get here\n        return RT.transpose().multiply(RT).inverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // QR decomposition of X\n        final RealMatrix QR = qr.getQR();\n        final int p = qr.getRank();\n        final int n = QR.getColumnDimension();\n        final int m = QR.getRowDimension();\n        // No try-catch or advertised NotStrictlyPositiveException - NPE above if n < 3\n        final Array2DRowRealMatrix R = new Array2DRowRealMatrix(p, n);\n        final double[][] RData = R.getDataRef();\n        final double[][] QRData = QR.getData();\n        for (int i = 0; i < p; i++) {\n            for (int j = 0; j < n; j++) {\n                RData[i][j] = QRData[i][j];\n            }\n        }\n\n        // Compute and return variance-covariance matrix\n        // No DME advertised - args valid if we get here\n        return R.transpose().multiply(R).inverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int p = getX().getColumnDimension();\n        final RealMatrix XTX = getX().transpose().multiply(getX());\n        final RealMatrix XTXInv = new LUDecomposition(XTX).getSolver().getInverse();\n        final RealMatrix R = qr.getR();\n        final RealMatrix RInv = new LUDecomposition(R.getSubMatrix(0, p - 1, 0, p - 1)).getSolver().getInverse();\n        return RInv.multiply(XTXInv).multiply(R.transpose());\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int p = getX().getColumnDimension();\n        final RealMatrix r = qr.getR();\n        final RealMatrix rT = r.transpose();\n        final RealMatrix rTR = rT.multiply(r);\n        final RealMatrix rTRInv = rTR.inverse();\n        final RealMatrix xT = getX().transpose();\n        final RealMatrix xTX = xT.multiply(getX());\n        final RealMatrix xTXInv = xTX.inverse();\n        return rTRInv.multiply(xTXInv);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Get QR decomposition of X matrix\n        final RealMatrix X = getX();\n        final QRDecomposition qr = new QRDecomposition(X);\n\n        // Get R matrix\n        final RealMatrix R = qr.getR();\n\n        // Get p, the number of columns in X\n        final int p = X.getColumnDimension();\n\n        // Create augmented identity matrix\n        final int n = R.getColumnDimension();\n        final Array2DRowRealMatrix augI = new Array2DRowRealMatrix(n, n);\n        final double[][] augIData = augI.getDataRef();\n        for (int i = 0; i < n; i++) {\n            for (int j =0; j < n; j++) {\n                if (i == j && i < p) {\n                    augIData[i][j] = 1d;\n                } else {\n                    augIData[i][j] = 0d;\n                }\n            }\n        }\n\n        // Compute and return Hat matrix\n        // No DME advertised - args valid if we get here\n        return R.transpose().multiply(augI).multiply(R).inverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Compute QR decomposition of X matrix\n        final QRDecomposition qr = new QRDecomposition(getX(), threshold);\n\n        // Compute R matrix\n        final RealMatrix R = qr.getR();\n\n        // Compute R inverse\n        final RealMatrix RInverse = qr.getSolver().getInverse();\n\n        // Compute RT R\n        final RealMatrix RTR = R.transpose().multiply(R);\n\n        // Compute RT R inverse\n        final RealMatrix RTRInverse = RTR.multiply(RInverse);\n\n        // Return RT R inverse\n        return RTRInverse;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix QR = qr.getR();\n        final int p = QR.getRowDimension();\n        final int n = QR.getColumnDimension();\n        // No try-catch or advertised NotStrictlyPositiveException - NPE above if n < 3\n        Array2DRowRealMatrix inv = new Array2DRowRealMatrix(n, n);\n        double[][] invData = inv.getDataRef();\n        for (int i = 0; i < n; i++) {\n            for (int j =0; j < n; j++) {\n                if (i == j && i < p) {\n                    invData[i][j] = 1d / QR.getEntry(i, i);\n                } else {\n                    invData[i][j] = 0d;\n                }\n            }\n        }\n\n        // Compute and return inverse of hat matrix\n        // No DME advertised - args valid if we get here\n        return QR.transpose().multiply(inv).multiply(QR.transpose());\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix XtX = xMatrix.transpose().multiply(xMatrix);\n        RealMatrix XtXInv = new LUDecomposition(XtX).getSolver().getInverse();\n        RealMatrix R = qr.getR();\n        int p = getBeta().getDimension();\n        RealMatrix RtR = R.getSubMatrix(0, p - 1, 0, p - 1).transpose().multiply(R.getSubMatrix(0, p - 1, 0, p - 1));\n        RealMatrix RtRInv = new LUDecomposition(RtR).getSolver().getInverse();\n        return XtXInv.multiply(RtRInv);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Get the QR decomposition of X\n        QRDecomposition qr = new QRDecomposition(getX());\n        // Get the upper triangular R matrix\n        RealMatrix r = qr.getR();\n        // Get the diagonal elements of R\n        double[] rDiag = r.getColumn(0);\n        // Get the number of independent variables\n        int n = rDiag.length;\n        // Get the number of dependent variables\n        int m = getY().getDimension();\n        // Create the beta variance-covariance matrix\n        Array2DRowRealMatrix betaVariance = new Array2DRowRealMatrix(n, n);\n        // Fill the beta variance-covariance matrix\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) {\n                    betaVariance.setEntry(i, j, rDiag[i] * rDiag[i]);\n                } else if (i < j) {\n                    betaVariance.setEntry(i, j, 0d);\n                } else {\n                    betaVariance.setEntry(i, j, r.getEntry(i, j) * r.getEntry(j, j));\n                }\n            }\n        }\n        // Return the beta variance-covariance matrix\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Get QR decomposition of X matrix\n        QRDecomposition qr = new QRDecomposition(getX());\n\n        // Get R matrix\n        RealMatrix r = qr.getR();\n\n        // Get Q matrix\n        RealMatrix q = qr.getQ();\n\n        // Get QT matrix\n        RealMatrix qt = q.transpose();\n\n        // Get inverse of R matrix\n        RealMatrix rInv = qr.getSolver().getInverse();\n\n        // Compute and return variance-covariance matrix\n        // No DME advertised - args valid if we get here\n        return qt.multiply(rInv).multiply(r);\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n        return offsetFormatter().print(offset);\n    }",
      "private static String printOffset(int offset)  {\n        if (offset == 0) {\n            return \"Z\";\n        }\n        String sign = offset > 0 ? \"+\" : \"-\";\n        offset = Math.abs(offset);\n        int hours = offset / (60 * 60 * 1000);\n        int minutes = (offset - (hours * 60 * 60 * 1000)) / (60 * 1000);\n        int seconds = (offset - (hours * 60 * 60 * 1000) - (minutes * 60 * 1000)) / 1000;\n        return sign + String.format(\"%02d:%02d\", hours, minutes);\n    }",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n    // Calculate the offset in hours and minutes\n    int hours = Math.abs(offset) / (60 * 60 * 1000);\n    int minutes = Math.abs(offset) / (60 * 1000) - (hours * 60);\n    // Build the string\n    StringBuffer buf = new StringBuffer();\n    if (offset < 0) {\n        buf.append('-');\n    } else {\n        buf.append('+');\n    }\n    if (hours < 10) {\n        buf.append('0');\n    }\n    buf.append(hours);\n    buf.append(':');\n    if (minutes < 10) {\n        buf.append('0');\n    }\n    buf.append(minutes);\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n        StringBuffer buf = new StringBuffer(6);\n        if (offset < 0) {\n            buf.append('-');\n            offset = -offset;\n        } else {\n            buf.append('+');\n        }\n        int hours = offset / (60 * 60 * 1000);\n        int minutes = offset / (60 * 1000) - hours * 60;\n        int seconds = offset / 1000 - hours * 60 * 60 - minutes * 60;\n        int millis = offset - hours * 60 * 60 * 1000 - minutes * 60 * 1000 - seconds * 1000;\n        if (hours < 10) {\n            buf.append('0');\n        }\n        buf.append(hours);\n        buf.append(':');\n        if (minutes < 10) {\n            buf.append('0');\n        }\n        buf.append(minutes);\n        buf.append(':');\n        if (seconds < 10) {\n            buf.append('0');\n        }\n        buf.append(seconds);\n        if (millis != 0) {\n            buf.append('.');\n            if (millis < 100) {\n                buf.append('0');\n            }\n            if (millis < 10) {\n                buf.append('0');\n            }\n            buf.append(millis);\n        }\n        return buf.toString();\n    }",
      "private static String printOffset(int offset)  {\n        if (offset == 0) {\n            return \"Z\";\n        }\n        String sign = (offset < 0 ? \"-\" : \"+\");\n        offset = Math.abs(offset);\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        int minutes = (offset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n        return sign + String.format(\"%02d:%02d\", hours, minutes);\n    }",
      "private static String printOffset(int offset)  {\n    StringBuffer buf = new StringBuffer(6);\n    if (offset < 0) {\n        buf.append('-');\n        offset = -offset;\n    } else {\n        buf.append('+');\n    }\n    int hours = offset / (60 * 60 * 1000);\n    int minutes = (offset / (60 * 1000)) % 60;\n    int seconds = (offset / 1000) % 60;\n    int millis = offset % 1000;\n    buf.append(hours);\n    buf.append(':');\n    if (minutes < 10) {\n        buf.append('0');\n    }\n    buf.append(minutes);\n    buf.append(':');\n    if (seconds < 10) {\n        buf.append('0');\n    }\n    buf.append(seconds);\n    if (millis > 0) {\n        buf.append('.');\n        if (millis < 10) {\n            buf.append('0');\n        }\n        if (millis < 100) {\n            buf.append('0');\n        }\n        buf.append(millis);\n    }\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    // Can't use a real chronology if called during class\n    // initialization. Offset printer doesn't need it anyhow.\n}",
      "private static String printOffset(int offset)  {\n        if (offset == 0) {\n            return \"Z\";\n        }\n        StringBuilder buf = new StringBuilder(6);\n        if (offset < 0) {\n            buf.append('-');\n            offset = -offset;\n        } else {\n            buf.append('+');\n        }\n        int hours = offset / (60 * 60 * 1000);\n        int minutes = (offset - hours * 60 * 60 * 1000) / (60 * 1000);\n        int seconds = (offset - hours * 60 * 60 * 1000 - minutes * 60 * 1000) / 1000;\n        int millis = offset - hours * 60 * 60 * 1000 - minutes * 60 * 1000 - seconds * 1000;\n        if (hours < 10) {\n            buf.append('0');\n        }\n        buf.append(hours);\n        buf.append(':');\n        if (minutes < 10) {\n            buf.append('0');\n        }\n        buf.append(minutes);\n        if (seconds > 0 || millis > 0) {\n            buf.append(':');\n            if (seconds < 10) {\n                buf.append('0');\n            }\n            buf.append(seconds);\n            if (millis > 0) {\n                buf.append('.');\n                if (millis < 100) {\n                    buf.append('0');\n                }\n                if (millis < 10) {\n                    buf.append('0');\n                }\n                buf.append(millis);\n            }\n        }\n        return buf.toString();\n    }"
    ],
    [
      "public int getIndex(Comparable key)  {\n    // TODO: implement this method\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = this.indexMap.get(key);\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = -1;\n    for (int i = 0; i < this.keys.size(); i++) \n    {\n        Comparable k = (Comparable) this.keys.get(i);\n        if (k.compareTo(key) == 0) \n        {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = -1;\n    for (int i = 0; i < this.keys.size(); i++) \n    {\n        Comparable k = (Comparable) this.keys.get(i);\n        if (k.compareTo(key) == 0) \n        {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        int result = -1;\n        if (this.indexMap.containsKey(key)) {\n            result = (Integer) this.indexMap.get(key);\n        }\n        return result;\n    }",
      "public int getIndex(Comparable key)  {\n    // TODO: implement this method\n}",
      "public int getIndex(Comparable key)  {\n    // Check arguments\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n\n    // Try to find the key\n    int result = this.indexMap.get(key);\n    if (result == null) {\n        result = -1;\n    }\n\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = -1;\n    for (int i = 0; i < this.keys.size(); i++) {\n        Comparable current = (Comparable) this.keys.get(i);\n        if (current.equals(key)) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.indexMap.get(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = -1;\n    for (int i = 0; i < this.keys.size(); i++) {\n        Comparable current = (Comparable) this.keys.get(i);\n        if (current.equals(key)) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n\n    // Add all the slots from the parent scope.\n    if (parent != null) {\n      slots.putAll(parent.allFlowSlots());\n    }\n\n    // Add all the slots from this scope.\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n\n    // Start with the parent's slots.\n    if (parent != null) {\n      slots.putAll(parent.allFlowSlots());\n    }\n\n    // Add in this scope's slots.\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    for (StaticSlot<JSType> slot : cache.symbols.values()) {\n      slots.put(slot.getName(), slot);\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n\n    // Add all the slots from the parent scope.\n    if (parent != null) {\n      slots.putAll(parent.allFlowSlots());\n    }\n\n    // Add all the slots from the current scope.\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n\n    if (parent != null) {\n      slots.putAll(parent.allFlowSlots());\n    }\n\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    LinkedFlowScope current = this;\n    while (current != null) {\n      for (StaticSlot<JSType> slot : current.cache.symbols.values()) {\n        if (!slots.containsKey(slot.getName())) {\n          slots.put(slot.getName(), slot);\n        }\n      }\n      current = current.parent;\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n\n    // Add all the slots from the parent.\n    if (parent != null) {\n      slots.putAll(parent.allFlowSlots());\n    }\n\n    // Add all the slots from this scope.\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    if (cache != null) {\n      for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n          slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n      }\n\n      return slots;\n    }\n\n    if (parent != null) {\n      slots.putAll(parent.allFlowSlots());\n    }\n\n    if (lastSlot != null) {\n      slots.put(lastSlot.getName(), lastSlot);\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    LinkedFlowScope current = this;\n    while (current != null) {\n      for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : current.cache.symbols.entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n          slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n      }\n\n      current = current.parent;\n    }\n\n    return slots;\n  }"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        if (nRows == 0) {\n            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n        }\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }"
    ],
    [
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n    double absAtanh;\n    if (a > 0.167) {\n        absAtanh = FastMath.log(FastMath.sqrt(a * a - 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    // atanh(x) = log(x + sqrt(1 + x^2)) / sqrt(1 + x^2)\n    // atanh(x) = log(x + sqrt(1 - x^2)) / sqrt(1 - x^2)\n    // atanh(x) = log(x + sqrt(1 - x^2)) / sqrt(1 - x^2)\n    // atanh(x) = log(x + sqrt(1 - x^2)) / sqrt(1 - x^2)\n    // atanh(x) = log(x + sqrt(1 - x^2)) / sqrt(1 - x^2)\n    // atanh(x) = log(x + sqrt(1 - x^2)) / sqrt(1 - x^2)\n    // atanh(x) = log(x + sqrt(1 - x^2)) / sqrt(1 - x^2)\n    // atanh(x) = log(x + sqrt(1 - x^2)) / sqrt(1 - x^2)\n    // atanh(x) = log(x + sqrt(1 - x^2)) / sqrt(1 - x^2)\n    // atanh(x) = log(x + sqrt(1 - x^2)) / sqrt(1 - x^2)\n    // atanh(x) = log(x + sqrt(1 - x^2)) / sqrt(1 - x^2)\n    // atanh(x) = log(x + sqrt(1 - x^2)) / sqrt(1 - x^2)\n    // atanh(x) = log(x + sqrt(1 - x^2)) / sqrt(1 - x^2)\n    // atanh(x) = log(x + sqrt(1 - x^2)) / sqrt(1 - x^2)\n    // atanh(x) = log(x + sqrt(1 - x^2)) / sqrt(1 - x^2)\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) \n    {\n        negate = true;\n        a = -a;\n    }\n    double absAtanh;\n    if (a > 0.167) \n    {\n        absAtanh = log(sqrt(a * a + 1) + a);\n    } \n    else \n    {\n        final double a2 = a * a;\n        if (a > 0.097) \n        {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } \n        else if (a > 0.036) \n        {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } \n        else if (a > 0.0036) \n        {\n}\n}\n}",
      "public static double atanh(double a)  {\n    if (a < -1 || a > 1) {\n        throw new IllegalArgumentException(\"Illegal argument in atanh: \" + a);\n    }\n    if (a == 0) {\n        return a;\n    }\n    if (a == -1) {\n        return -Math.PI / 2;\n    }\n    if (a == 1) {\n        return Math.PI / 2;\n    }\n    return Math.log((1 + a) / (1 - a)) / 2;\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    if (a > 0.167) {\n        return negate ? -FastMath.log(FastMath.sqrt(1 - a * a) + a) : FastMath.log(FastMath.sqrt(1 - a * a) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            return negate ? -a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * (F_1_17 - a2 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2)) : a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * (F_1_17 - a2 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2));\n        } else if (a > 0.036) {\n}\n}\n}",
      "public static double atanh(double a)  {\n    if (a < -1.0 || a > 1.0) {\n        throw new IllegalArgumentException(\"Illegal argument \" + a + \" for function atanh\");\n    }\n    if (a == -1.0) {\n        return -Math.PI / 2.0;\n    }\n    if (a == 1.0) {\n        return Math.PI / 2.0;\n    }\n    if (a == 0.0) {\n        return a;\n    }\n    if (a < 0.0) {\n        return -atanh(-a);\n    }\n    return Math.log((1.0 + a) / (1.0 - a)) / 2.0;\n}",
      "public static double atanh(double a)  {\n    // atanh(x) = log(1+x)/x\n    return FastMath.log(1+a)/a;\n}",
      "public static double atanh(double a)  {\n    if (a < -1.0 || a > 1.0) {\n        throw new IllegalArgumentException(\"Illegal argument \" + a + \" for function atanh\");\n    }\n    if (a == 0) {\n        return 0;\n    }\n    if (a < 0) {\n        return -atanh(-a);\n    }\n    if (a == 1) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (a == -1) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return 0.5 * FastMath.log((1 + a) / (1 - a));\n}",
      "public static double atanh(double a)  {\n    if (a < -1.0 || a > 1.0) {\n        throw new IllegalArgumentException(\"Illegal argument \" + a + \" for atanh function\");\n    }\n    return 0.5 * FastMath.log((1 + a) / (1 - a));\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n    double absAtanh;\n    if (a > 0.167) {\n        absAtanh = FastMath.log(FastMath.sqrt(a * a - 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n}\n}\n}"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        if (normalizedSum == Double.POSITIVE_INFINITY ||\n            normalizedSum == Double.NEGATIVE_INFINITY ||\n            Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_INFINITE_OR_NAN,\n                                                   normalizedSum);\n        }\n        double sum = Sum.of(values).getResult();\n        if (sum == Double.POSITIVE_INFINITY ||\n            sum == Double.NEGATIVE_INFINITY ||\n            sum == 0.0) {\n            throw new MathArithmeticException(LocalizedFormats.NORMALIZED_SUM_INFINITE_OR_ZERO,\n                                              sum);\n        }\n        double[] out = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                out[i] = values[i];\n            } else {\n                out[i] = values[i] * normalizedSum / sum;\n            }\n        }\n        return out;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        double sum = Sum.of(values).getResult();\n        if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_INFINITE_OR_NAN,\n                                                   normalizedSum);\n        }\n        if (Double.isInfinite(sum)) {\n            throw new MathArithmeticException(LocalizedFormats.INFINITE_SUM);\n        }\n        if (sum == 0.0) {\n            throw new MathArithmeticException(LocalizedFormats.SUM_ZERO);\n        }\n        double[] out = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                out[i] = values[i];\n            } else {\n                out[i] = values[i] * normalizedSum / sum;\n            }\n        }\n        return out;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n        if (Double.isInfinite(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE_SUM,\n                                                   normalizedSum);\n        }\n\n        if (Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN_SUM,\n                                                   normalizedSum);\n        }\n\n        double sum = Sum.of(values).getResult();\n\n        if (Double.isInfinite(sum)) {\n            throw new MathArithmeticException(LocalizedFormats.INFINITE_SUM,\n                                              sum);\n        }\n\n        if (sum == 0.0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_SUM);\n        }\n\n        double[] normalized = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            normalized[i] = values[i] * normalizedSum / sum;\n        }\n\n        return normalized;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_INFINITE_OR_NAN,\n                                               normalizedSum);\n    }\n    double sum = Sum.of(values).getResult();\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_OF_INFINITE_VALUES,\n                                          sum);\n    }\n    if (sum == 0.0) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_OF_ZERO_VALUES,\n                                          sum);\n    }\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        out[i] = values[i] * normalizedSum / sum;\n    }\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n        if (Double.isInfinite(normalizedSum)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NORMALIZE_INFINITE_SUM,\n                    normalizedSum);\n        }\n        if (Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NORMALIZE_NAN_SUM,\n                    normalizedSum);\n        }\n\n        double sum = Sum.of(values).getResult();\n        if (Double.isInfinite(sum)) {\n            throw new MathArithmeticException(\n                    LocalizedFormats.INFINITE_SUM,\n                    sum);\n        }\n        if (sum == 0.0) {\n            throw new MathArithmeticException(\n                    LocalizedFormats.ZERO_SUM);\n        }\n\n        double[] normalized = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                normalized[i] = values[i];\n            } else {\n                normalized[i] = values[i] * normalizedSum / sum;\n            }\n        }\n\n        return normalized;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n    double sum = Sum.of(values).getResult();\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_INFINITE_OR_NAN,\n                                               normalizedSum);\n    }\n    if (Double.isInfinite(sum) || Double.isNaN(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_OF_INFINITE_OR_NAN,\n                                          sum);\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_OF_VALUES_IS_ZERO,\n                                          sum);\n    }\n\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            result[i] = values[i];\n        } else {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = Sum.of(values).getResult();\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_INFINITE_OR_NAN,\n                                               normalizedSum);\n    }\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_INFINITE, sum);\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_ZERO);\n    }\n    double[] normalized = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            normalized[i] = values[i];\n        } else {\n            normalized[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return normalized;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        double sum = Sum.of(values).getResult();\n        if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_INFINITE_OR_NAN,\n                                                   normalizedSum);\n        }\n        if (Double.isInfinite(sum) || Double.isNaN(sum)) {\n            throw new MathArithmeticException(LocalizedFormats.SUM_OF_INFINITE_OR_NAN);\n        }\n        if (sum == 0) {\n            throw new MathArithmeticException(LocalizedFormats.SUM_OF_VALUES_IS_ZERO);\n        }\n        double[] normalized = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                normalized[i] = values[i];\n            } else {\n                normalized[i] = values[i] * normalizedSum / sum;\n            }\n        }\n        return normalized;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = Sum.of(values);\n    if (Double.isInfinite(sum) || Double.isNaN(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_TO_SUM_OF_INFINITE_OR_NAN, sum);\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_IS_INFINITE_OR_NAN, normalizedSum);\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_SUM_TO_ZERO);\n    }\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = values[i];\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n        if (Double.isInfinite(normalizedSum)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NORMALIZED_SUM_INFINITE,\n                    normalizedSum);\n        }\n        if (Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(\n                    LocalizedFormats.NORMALIZED_SUM_NAN,\n                    normalizedSum);\n        }\n\n        double sum = Sum.of(values).getResult();\n        if (Double.isInfinite(sum)) {\n            throw new MathArithmeticException(\n                    LocalizedFormats.SUM_OF_INFINITE_VALUES,\n                    sum);\n        }\n        if (sum == 0.0) {\n            throw new MathArithmeticException(\n                    LocalizedFormats.SUM_OF_ZERO_VALUES,\n                    sum);\n        }\n\n        double[] normalized = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                normalized[i] = values[i];\n            } else {\n                normalized[i] = values[i] * normalizedSum / sum;\n            }\n        }\n        return normalized;\n    }"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    MutableDateTime dateTime = new MutableDateTime();\n    parseInto(dateTime, text, 0);\n    return dateTime;\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    MutableDateTime mdt = new MutableDateTime();\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            mdt.setMillis(millis);\n            mdt.setChronology(chrono);\n            if (iZone != null) {\n                mdt.setZone(iZone);\n            }\n            return mdt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    MutableDateTime dt = new MutableDateTime();\n    dt.setMillis(parseMillis(text));\n    return dt;\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n\n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIy = getX().transpose().multiply(OI).operate(yVector);\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIy);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIy = getX().transpose().multiply(OI).operate(yVector);\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIy);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XTOIX = getX().transpose().multiply(getOmegaInverse()).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(getOmegaInverse()).multiply(yVector);\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XTOIX = getX().transpose().multiply(getOmegaInverse()).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(getOmegaInverse()).multiply(yVector);\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIy = getX().transpose().multiply(OI).operate(yVector);\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIy);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XTOIX = getX().transpose().multiply(getOmegaInverse()).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(getOmegaInverse()).multiply(yVector);\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    if (id == null)\n    {\n        throw new IllegalArgumentException(\"Id cannot be null\");\n    }\n    if (id.equals(this.id()))\n    {\n        return this;\n    }\n    Elements elements = this.getElementsByAttributeValue(\"id\", id);\n    if (elements.size() > 0)\n    {\n        return elements.get(0);\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null)\n        throw new IllegalArgumentException(\"ID must not be null\");\n\n    if (id.equals(this.id()))\n        return this;\n\n    Elements elements = this.select(\"[id=\" + id + \"]\");\n    return elements.isEmpty() ? null : elements.first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    if (id.equals(this.id())) {\n        return this;\n    }\n    Elements elements = this.select(\"[id=\" + id + \"]\");\n    return elements.size() > 0 ? elements.first() : null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n\n    if (id.equals(this.id())) {\n        return this;\n    }\n\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.size() > 0 ? elements.get(0) : null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null) \n    {\n        throw new IllegalArgumentException(\"id must not be null\");\n    }\n    if (id.isEmpty()) \n    {\n        throw new IllegalArgumentException(\"id must not be empty\");\n    }\n    if (id.equals(this.id())) \n    {\n        return this;\n    }\n    Elements elements = this.select(\"[id=\" + id + \"]\");\n    if (elements.isEmpty()) \n    {\n        return null;\n    }\n    return elements.first();\n}",
      "public Element getElementById(String id)  {\n    if (id == null)\n        throw new IllegalArgumentException(\"id cannot be null\");\n    if (id.isEmpty())\n        throw new IllegalArgumentException(\"id cannot be empty\");\n    if (id.startsWith(\"#\"))\n        throw new IllegalArgumentException(\"id cannot start with #\");\n\n    Elements elements = Collector.collect(new Evaluator.Id(id), this);\n    return elements.size() > 0 ? elements.get(0) : null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    if (id.equals(this.id())) \n    {\n        return this;\n    }\n    Elements elements = this.select(\"[id=\" + id + \"]\");\n    if (elements.size() > 0) \n    {\n        return elements.first();\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null)\n        return null;\n    if (id.equals(this.id()))\n        return this;\n    Elements elements = this.getElementsByAttributeValue(\"id\", id);\n    if (elements.size() > 0)\n        return elements.get(0);\n    return null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    if (id.equals(this.id())) \n    {\n        return this;\n    }\n    Elements elements = this.select(\"[id=\" + id + \"]\");\n    return elements.isEmpty() ? null : elements.first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    if (id.equals(this.id())) {\n        return this;\n    }\n    Elements els = this.select(\"[id=\" + id + \"]\");\n    return els.size() > 0 ? els.get(0) : null;\n}"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder sb = new StringBuilder(pattern.length());\n    final String[] patternArray = pattern.split(\"\\\\\" + START_FE);\n    for (int i = 0; i < patternArray.length; i++) \n    {\n        final String[] subPattern = patternArray[i].split(\"\\\\\" + END_FE);\n        sb.append(subPattern[0]);\n        if (subPattern.length > 1) \n        {\n            final String desc = subPattern[1];\n            final String customPattern = customPatterns.get(i);\n            if (customPattern != null) \n            {\n                sb.append(START_FE);\n                sb.append(desc);\n                sb.append(END_FE);\n                sb.append(customPattern);\n            } \n            else \n            {\n                sb.append(START_FE);\n                sb.append(desc);\n                sb.append(END_FE);\n                sb.append(desc);\n            }\n        }\n    }\n    return sb.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder sb = new StringBuilder(pattern.length() + customPatterns.size() * 8);\n    int last = 0;\n    int pos = 0;\n    while (pos < pattern.length()) {\n        if (pattern.charAt(pos) == START_FE) {\n            sb.append(pattern.substring(last, pos));\n            pos = parseFormatDescription(pattern, new ParsePosition(pos + 1));\n            sb.append(customPatterns.remove(0));\n            last = pos + 1;\n        }\n        pos++;\n    }\n    sb.append(pattern.substring(last));\n    return sb.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns.isEmpty()) {\n        return pattern;\n    }\n    final StringBuilder buf = new StringBuilder(pattern.length() + 32 * customPatterns.size());\n    int pos = 0;\n    for (final String customPattern : customPatterns) {\n        final int start = pattern.indexOf(customPattern, pos);\n        if (start == -1) {\n            throw new IllegalArgumentException(\"Custom pattern not found\");\n        }\n        buf.append(pattern.substring(pos, start));\n        buf.append(START_FE);\n        buf.append(customPattern);\n        buf.append(END_FE);\n        pos = start + customPattern.length();\n    }\n    buf.append(pattern.substring(pos));\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder sb = new StringBuilder(pattern.length() + customPatterns.size() * 10);\n    int pos = 0;\n    for (final String desc : customPatterns) {\n        sb.append(pattern.substring(pos, pos = pattern.indexOf(desc, pos)));\n        sb.append(desc);\n    }\n    sb.append(pattern.substring(pos));\n    return sb.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length());\n    final String[] patternParts = pattern.split(\"\\\\{\");\n    for (int i = 0; i < patternParts.length; i++) {\n        final String part = patternParts[i];\n        if (i == 0) {\n            result.append(part);\n        } else {\n            final String[] partParts = part.split(\"\\\\}\");\n            result.append(\"{\");\n            result.append(partParts[0]);\n            if (partParts.length > 1) {\n                result.append(\"}\");\n                result.append(customPatterns.get(Integer.parseInt(partParts[0]) - 1));\n                result.append(\"}\");\n                result.append(partParts[1]);\n            }\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder sb = new StringBuilder(pattern.length() + customPatterns.size() * 10);\n    final String[] patterns = pattern.split(\"\\\\\" + START_FE);\n    for (int i = 0; i < patterns.length; i++) {\n        final String[] parts = patterns[i].split(\"\\\\\" + END_FE);\n        sb.append(parts[0]);\n        if (parts.length > 1) {\n            final String desc = parts[1];\n            final String custom = customPatterns.remove(0);\n            sb.append(START_FE).append(desc).append(END_FE);\n            sb.append(custom);\n        }\n    }\n    return sb.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length() * 2);\n    int pos = 0;\n    for (final String desc : customPatterns) {\n        final int index = pattern.indexOf(desc, pos);\n        if (index == -1) {\n            throw new IllegalArgumentException(\"Custom pattern not found: \" + desc);\n        }\n        result.append(pattern.substring(pos, index));\n        result.append(desc);\n        pos = index + desc.length();\n    }\n    result.append(pattern.substring(pos));\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length() * 2);\n    final String[] elements = pattern.split(\"'\");\n    for (int i = 0; i < elements.length; i++) \n    {\n        if (i > 0) \n        {\n            result.append(\"'\");\n        }\n        if (i % 2 == 0) \n        {\n            result.append(elements[i]);\n        } \n        else \n        {\n            result.append(customPatterns.get(i / 2 - 1));\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder buf = new StringBuilder(pattern.length());\n    final ParsePosition pos = new ParsePosition(0);\n    for (;;) {\n        seekNonWs(pattern, pos);\n        if (pos.getIndex() >= pattern.length()) {\n            break;\n        }\n        if (pattern.charAt(pos.getIndex()) == START_FE) {\n            final int start = pos.getIndex();\n            pos.setIndex(pos.getIndex() + 1);\n            final int arg = readArgumentIndex(pattern, pos);\n            final String desc = parseFormatDescription(pattern, pos);\n            final String custom = customPatterns.get(arg);\n            buf.append(pattern, start, pos.getIndex());\n            buf.append(custom);\n            buf.append(desc);\n        } else {\n            buf.append(pattern, pos.getIndex(), pattern.length());\n            break;\n        }\n    }\n    return buf.toString();\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // Check that to and from are parameterized with same number of type variables\n    if (from.getActualTypeArguments().length != to.getActualTypeArguments().length) {\n      return false;\n    }\n\n    // Check that raw types are equal\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    // Check that owner types are equal\n    if (from.getOwnerType() != null && to.getOwnerType() != null) {\n      if (!from.getOwnerType().equals(to.getOwnerType())) {\n        return false;\n      }\n    } else if (from.getOwnerType() == null && to.getOwnerType() != null) {\n      return false;\n    }\n\n    // Check that type arguments are equal\n    for (int i = 0; i < from.getActualTypeArguments().length; i++) {\n      Type fromArg = from.getActualTypeArguments()[i];\n      Type toArg = to.getActualTypeArguments()[i];\n\n      // If type argument is a type variable, check if it is equivalent to\n      // the corresponding type variable in the other parameterized type\n      if (fromArg instanceof TypeVariable) {\n        TypeVariable fromVar = (TypeVariable) fromArg;\n        TypeVariable toVar = (TypeVariable) toArg;\n        if (!fromVar.getName().equals(toVar.getName())) {\n          return false;\n        }\n        if (typeVarMap.get(fromVar.getName()) == null) {\n          typeVarMap.put(fromVar.getName(), toVar);\n        } else if (!typeVarMap.get(fromVar.getName()).equals(toVar)) {\n          return false;\n        }\n      }\n\n      // If type argument is a wildcard, check if it is equivalent to the\n      // corresponding wildcard in the other parameterized type\n      if (fromArg instanceof WildcardType) {\n        WildcardType fromWild = (WildcardType) fromArg;\n        WildcardType toWild = (WildcardType) toArg;\n}\n}\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // check if they are equivalent under our current mapping.\n    if (to.equals(from)) {\n      return true;\n    }\n\n    // check if the raw types are equal\n    if (!to.getRawType().equals(from.getRawType())) {\n      return false;\n    }\n\n    // check if the owner types are equal\n    if (!$Gson$Types.equals(to.getOwnerType(), from.getOwnerType())) {\n      return false;\n    }\n\n    // check if the type arguments are equal\n    Type[] toArgs = to.getActualTypeArguments();\n    Type[] fromArgs = from.getActualTypeArguments();\n    for (int i = 0; i < toArgs.length; i++) {\n      Type toArg = toArgs[i];\n      Type fromArg = fromArgs[i];\n      while (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(((TypeVariable<?>) fromArg).getName());\n      }\n      if (!$Gson$Types.equals(toArg, fromArg)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      if (fromArg instanceof TypeVariable<?>) {\n        TypeVariable<?> fromVar = (TypeVariable<?>) fromArg;\n        fromArg = typeVarMap.get(fromVar.getName());\n      }\n      if (toArg instanceof TypeVariable<?>) {\n        TypeVariable<?> toVar = (TypeVariable<?>) toArg;\n        toArg = typeVarMap.get(toVar.getName());\n      }\n      if (!fromArg.equals(toArg)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.equals(to)) {\n      return true;\n    }\n\n    // First figure out the class and any type information.\n    Class<?> clazz = $Gson$Types.getRawType(from);\n    ParameterizedType ptype = null;\n    if (from instanceof ParameterizedType) {\n      ptype = (ParameterizedType) from;\n    }\n\n    // Load up parameterized variable info if it was parameterized.\n    if (ptype != null) {\n      Type[] tArgs = ptype.getActualTypeArguments();\n      TypeVariable<?>[] tParams = clazz.getTypeParameters();\n      for (int i = 0; i < tArgs.length; i++) {\n        Type arg = tArgs[i];\n        TypeVariable<?> var = tParams[i];\n        while (arg instanceof TypeVariable<?>) {\n          TypeVariable<?> v = (TypeVariable<?>) arg;\n          arg = typeVarMap.get(v.getName());\n        }\n        typeVarMap.put(var.getName(), arg);\n      }\n\n      // check if they are equivalent under our current mapping.\n      if (typeEquals(ptype, to, typeVarMap)) {\n        return true;\n      }\n    }\n\n    for (Type itype : clazz.getGenericInterfaces()) {\n      if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\n        return true;\n      }\n    }\n\n    // Interfaces didn't work, try the superclass.\n    Type sType = clazz.getGenericSuperclass();\n    return isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap));\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // Check that to and from are parameterized types.\n    if (from == null || to == null) {\n      return false;\n    }\n\n    // Check that the raw types are equal.\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    // Check that the owner types are equal.\n    if (!$Gson$Types.equals(from.getOwnerType(), to.getOwnerType())) {\n      return false;\n    }\n\n    // Check that the type arguments are equal.\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // Check that to contains all of from's type parameters\n    for (Type fromArg : from.getActualTypeArguments()) {\n      boolean argFound = false;\n      for (Type toArg : to.getActualTypeArguments()) {\n        if (matches(fromArg, toArg, typeVarMap)) {\n          argFound = true;\n          break;\n        }\n      }\n      if (!argFound) {\n        return false;\n      }\n    }\n\n    // Now check that from contains all of to's type parameters\n    for (Type toArg : to.getActualTypeArguments()) {\n      boolean argFound = false;\n      for (Type fromArg : from.getActualTypeArguments()) {\n        if (matches(toArg, fromArg, typeVarMap)) {\n          argFound = true;\n          break;\n        }\n      }\n      if (!argFound) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // Check that to and from are parameterized types.\n    if (from == null || to == null) {\n      return false;\n    }\n\n    // Check that the raw types are equal.\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    // Check that the owner types are equal.\n    if (!$Gson$Types.equals(from.getOwnerType(), to.getOwnerType())) {\n      return false;\n    }\n\n    // Check that the type arguments are equal.\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      if (!$Gson$Types.equals(fromArg, toArg)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      if (fromArg instanceof TypeVariable<?>) {\n        TypeVariable<?> fromVar = (TypeVariable<?>) fromArg;\n        fromArg = typeVarMap.get(fromVar.getName());\n      }\n      if (toArg instanceof TypeVariable<?>) {\n        TypeVariable<?> toVar = (TypeVariable<?>) toArg;\n        toArg = typeVarMap.get(toVar.getName());\n      }\n      if (!fromArg.equals(toArg)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // check if they are equivalent under our current mapping.\n    if (to.equals(from)) {\n      return true;\n    }\n\n    // Load up parameterized variable info if it was parameterized.\n    if (ptype != null) {\n      Type[] tArgs = ptype.getActualTypeArguments();\n      TypeVariable<?>[] tParams = clazz.getTypeParameters();\n      for (int i = 0; i < tArgs.length; i++) {\n        Type arg = tArgs[i];\n        TypeVariable<?> var = tParams[i];\n        while (arg instanceof TypeVariable<?>) {\n          TypeVariable<?> v = (TypeVariable<?>) arg;\n          arg = typeVarMap.get(v.getName());\n        }\n        typeVarMap.put(var.getName(), arg);\n      }\n\n      // check if they are equivalent under our current mapping.\n      if (typeEquals(ptype, to, typeVarMap)) {\n        return true;\n      }\n    }\n\n    for (Type itype : clazz.getGenericInterfaces()) {\n      if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\n        return true;\n      }\n    }\n\n    // Interfaces didn't work, try the superclass.\n    Type sType = clazz.getGenericSuperclass();\n    return isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap));\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  // check if they are equivalent under our current mapping.\n  if (to.equals(from)) {\n    return true;\n  }\n\n  // Load up parameterized variable info if it was parameterized.\n  if (ptype != null) {\n    Type[] tArgs = ptype.getActualTypeArguments();\n    TypeVariable<?>[] tParams = clazz.getTypeParameters();\n    for (int i = 0; i < tArgs.length; i++) {\n      Type arg = tArgs[i];\n      TypeVariable<?> var = tParams[i];\n      while (arg instanceof TypeVariable<?>) {\n        TypeVariable<?> v = (TypeVariable<?>) arg;\n        arg = typeVarMap.get(v.getName());\n      }\n      typeVarMap.put(var.getName(), arg);\n    }\n\n    // check if they are equivalent under our current mapping.\n    if (to.equals(from)) {\n      return true;\n    }\n  }\n\n  for (Type itype : clazz.getGenericInterfaces()) {\n    if (isAssignableFrom(itype, to, new HashMap<String, Type>(typeVarMap))) {\n      return true;\n    }\n  }\n\n  // Interfaces didn't work, try the superclass.\n  Type sType = clazz.getGenericSuperclass();\n  return isAssignableFrom(sType, to, new HashMap<String, Type>(typeVarMap));\n}"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return iPeriodConverters.add(converter, null);\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return (PeriodConverter) iPeriodConverters.add(converter, null);\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    ConverterSet set = iPeriodConverters;\n    Converter[] removed = new Converter[1];\n    set = set.add(converter, removed);\n    if (set != iPeriodConverters) {\n        iPeriodConverters = set;\n        return (PeriodConverter)removed[0];\n    }\n    return null;\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    ConverterSet set = iPeriodConverters;\n    Converter[] removed = new Converter[1];\n    set = set.add(converter, removed);\n    if (removed[0] != null) {\n        return (PeriodConverter) removed[0];\n    } else {\n        return null;\n    }\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        return (PeriodConverter) iPeriodConverters.add(converter, null);\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    ConverterSet set = iPeriodConverters;\n    Converter[] removed = new Converter[1];\n    set = set.add(converter, removed);\n    if (removed[0] != null) {\n        return (PeriodConverter) removed[0];\n    }\n    return null;\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    ConverterSet set = iPeriodConverters;\n    Converter[] removed = new Converter[1];\n    set = set.add(converter, removed);\n    if (removed[0] != null) {\n        return (PeriodConverter) removed[0];\n    } else {\n        return null;\n    }\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return (PeriodConverter) iPeriodConverters.add(converter, null);\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        ConverterSet set = iPeriodConverters;\n        Converter[] removed = new Converter[1];\n        set = set.add(converter, removed);\n        if (removed[0] != null) {\n            return (PeriodConverter) removed[0];\n        } else {\n            return null;\n        }\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return (PeriodConverter) iPeriodConverters.add(converter, null);\n}"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        return UnmodifiableIterator.unmodifiableIterator(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n  Color color = node.getAnnotation();\n  N superNode = colorToNodeMap[color.value];\n  if (superNode == null) {\n    superNode = node;\n    colorToNodeMap[color.value] = node;\n  }\n  return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = (Color) graph.getNode(node).getAnnotation();\n  if (color == null) {\n    return node;\n  }\n  N superNode = colorToNodeMap[color.value];\n  if (superNode == null) {\n    superNode = node;\n    colorToNodeMap[color.value] = superNode;\n  }\n  return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = node.getAnnotation();\n  if (color == null) {\n    return null;\n  }\n  return colorToNodeMap[color.value];\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = (Color) graph.getNode(node).getAnnotation();\n  if (color == null) {\n    return null;\n  }\n  return colorToNodeMap[color.value];\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = (Color) node.getAnnotation();\n  if (color == null) {\n    return node;\n  }\n  N superNode = colorToNodeMap[color.value];\n  if (superNode == null) {\n    colorToNodeMap[color.value] = node;\n    return node;\n  }\n  return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = (Color) graph.getNode(node).getAnnotation();\n  if (color == null) {\n    return node;\n  }\n  return colorToNodeMap[color.value];\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = (Color) node.getAnnotation();\n  if (color == null) {\n    return node;\n  }\n  return colorToNodeMap[color.value];\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = (Color) graph.getNode(node).getAnnotation();\n  if (color == null) {\n    return null;\n  }\n  N superNode = colorToNodeMap[color.value];\n  if (superNode == null) {\n    superNode = node;\n    colorToNodeMap[color.value] = superNode;\n  }\n  return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = node.getAnnotation();\n  N superNode = colorToNodeMap[color.value];\n  if (superNode == null) {\n    superNode = node;\n    colorToNodeMap[color.value] = node;\n  }\n  return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = (Color) graph.getNode(node).getAnnotation();\n  if (color == null) {\n    return null;\n  }\n  N superNode = colorToNodeMap[color.value];\n  if (superNode == null) {\n    colorToNodeMap[color.value] = node;\n    superNode = node;\n  }\n  return superNode;\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(ranks[i].getPosition());\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(ranks[i].getPosition());\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n        List<Integer> nanPositions = new ArrayList<Integer>();\n        for (int i = 0; i < ranks.length; i++) {\n            if (Double.isNaN(ranks[i].getValue())) {\n                nanPositions.add(ranks[i].getPosition());\n            }\n        }\n        return nanPositions;\n    }",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += weights[i] * f.value(points[i]);\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) \n    {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    boolean result = true;\n    if (map1.size() != map2.size()) {\n        result = false;\n    }\n    else {\n        Set keys = map1.keySet();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Paint p1 = (Paint) map1.get(key);\n            Paint p2 = (Paint) map2.get(key);\n            if (!p1.equals(p2)) {\n                result = false;\n                break;\n            }\n        }\n    }\n    return result;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    boolean result = true;\n    if (map1.size() != map2.size()) {\n        result = false;\n    }\n    else {\n        Set keySet = map1.keySet();\n        Iterator iterator = keySet.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Paint p1 = (Paint) map1.get(key);\n            Paint p2 = (Paint) map2.get(key);\n            if (!p1.equals(p2)) {\n                result = false;\n                break;\n            }\n        }\n    }\n    return result;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null && map2 == null) \n    {\n        return true;\n    }\n    else if (map1 == null || map2 == null) \n    {\n        return false;\n    }\n    else \n    {\n        if (map1.size() != map2.size()) \n        {\n            return false;\n        }\n        Set keySet = map1.keySet();\n        Iterator iterator = keySet.iterator();\n        while (iterator.hasNext()) \n        {\n            Comparable key = (Comparable) iterator.next();\n            if (!map2.containsKey(key)) \n            {\n                return false;\n            }\n            Paint p1 = (Paint) map1.get(key);\n            Paint p2 = (Paint) map2.get(key);\n            if (!p1.equals(p2)) \n            {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    for (Object key : keys) {\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    boolean result = false;\n    if (map1 == map2) {\n        result = true;\n    }\n    else if (map1.size() != map2.size()) {\n        result = false;\n    }\n    else {\n        Set keys = map1.keySet();\n        Iterator iterator = keys.iterator();\n        while (iterator.hasNext()) {\n            Comparable key = (Comparable) iterator.next();\n            Paint p1 = (Paint) map1.get(key);\n            Paint p2 = (Paint) map2.get(key);\n            if (!p1.equals(p2)) {\n                result = false;\n                break;\n            }\n        }\n    }\n    return result;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    for (Iterator iterator = keys.iterator(); iterator.hasNext();) {\n        Comparable key = (Comparable) iterator.next();\n        if (!map1.get(key).equals(map2.get(key))) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keySet = map1.keySet();\n    Iterator iterator = keySet.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    boolean result = false;\n    if (map1 == null) \n    {\n        result = (map2 == null);\n    } \n    else \n    {\n        result = (map2 != null);\n        if (result) \n        {\n            result = map1.size() == map2.size();\n            if (result) \n            {\n                Set keys = map1.keySet();\n                for (Object key : keys) \n                {\n                    Comparable c1 = (Comparable) key;\n                    Paint p1 = (Paint) map1.get(c1);\n                    Paint p2 = (Paint) map2.get(c1);\n                    result = p1.equals(p2);\n                    if (!result) \n                    {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // TODO(johnlenz): this is a very incomplete implementation.\n    //    1) We should handle more types of expressions.\n    //    2) We should handle more types of strings.\n    //    3) We should handle string concatenation.\n    //    4) We should handle string literals.\n    //    5) We should handle string constants.\n    //    6) We should handle string escapes.\n    //    7) We should handle string substitutions.\n    //    8) We should handle string comparisons.\n    //    9) We should handle string concatenation.\n    //   10) We should handle string comparisons.\n    //   11) We should handle string comparisons.\n    //   12) We should handle string comparisons.\n    //   13) We should handle string comparisons.\n    //   14) We should handle string comparisons.\n    //   15) We should handle string comparisons.\n    //   16) We should handle string comparisons.\n    //   17) We should handle string comparisons.\n    //   18) We should handle string comparisons.\n    //   19) We should handle string comparisons.\n    //   20) We should handle string comparisons.\n    //   21) We should handle string comparisons.\n    //   22) We should handle string comparisons.\n    //   23) We should handle string comparisons.\n    //   24) We should handle string comparisons.\n    //   25) We should handle string comparisons.\n    //   26) We should handle string comparisons.\n    //   27) We should handle string comparisons.\n    //   28) We should handle string comparisons.\n    //   29) We should handle string comparisons.\n    //   30) We should handle string comparisons.\n    //   31) We should handle string comparisons.\n    //   32) We should handle string comparisons.\n    //   33) We should handle string comparisons.\n    //   34) We should handle string comparisons.\n    //   35) We should handle string comparisons.\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n      String key = expr.getString();\n      if (functions.containsKey(key)) {\n        Config config = functions.get(key);\n        if (config.parameter == Config.REPLACE_ALL_VALUE) {\n          // Replace all parameters.\n          Node firstParam = parent.getFirstChild().getNext();\n          for (Node arg = firstParam; arg != null; arg = arg.getNext()) {\n            arg = replaceExpression(t, arg, parent);\n          }\n        } else {\n          // Replace the parameter.\n          Node arg = parent.getChildAtIndex(config.parameter);\n          if (arg != null) {\n            replaceExpression(t, arg, parent);\n          }\n        }\n      }\n    }\n    return expr;\n  }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    Preconditions.checkArgument(expr.isString());\n    Preconditions.checkArgument(expr.isFirstChildOf(parent));\n    Preconditions.checkArgument(parent.isAdd());\n\n    // TODO(johnlenz): add support for other types of expressions.\n\n    // Build the replacement key.\n    StringBuilder keyBuilder = new StringBuilder();\n    Node prefix = buildReplacement(expr, null, keyBuilder);\n    String key = keyBuilder.toString();\n\n    // Get the replacement value.\n    String replacement = getReplacement(key);\n\n    // Replace the expression.\n    Node replacementNode = IR.string(replacement);\n    replacementNode.copyInformationFrom(expr);\n    parent.replaceChild(expr, replacementNode);\n\n    // Record the location of the replacement.\n    recordReplacement(expr, key);\n\n    return replacementNode;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String key = expr.getString();\n    String replacement = getReplacement(key);\n    if (replacement != null) {\n      Node replacementNode = IR.string(replacement);\n      replacementNode.copyInformationFromForTree(expr);\n      parent.replaceChild(expr, replacementNode);\n      recordReplacement(expr, key);\n      return replacementNode;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // If the expression is a string literal, replace it with a placeholder.\n  if (expr.isString()) {\n    // Create a replacement string.\n    String replacement = getReplacement(expr.getString());\n\n    // Create a new node with the replacement string.\n    Node replacementNode = IR.string(replacement);\n\n    // Replace the expression with the new node.\n    parent.replaceChild(expr, replacementNode);\n\n    // Record the location of the replacement.\n    recordReplacement(expr, expr.getString());\n\n    // Return the replacement node.\n    return replacementNode;\n  }\n\n  // If the expression is not a string literal, return it.\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) {\n    String key = expr.getString();\n    String replacement = getReplacement(key);\n    if (replacement != null) {\n      Node replacementNode = IR.string(replacement);\n      recordReplacement(expr, key);\n      parent.replaceChild(expr, replacementNode);\n      return replacementNode;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  String key = expr.getString();\n  if (key != null) {\n    String replacement = getReplacement(key);\n    if (replacement != null) {\n      Node replacementNode = IR.string(replacement);\n      replacementNode.copyInformationFrom(expr);\n      parent.replaceChild(expr, replacementNode);\n      recordReplacement(expr, key);\n      return replacementNode;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  String key = getKey(expr);\n  if (key != null) {\n    Node replacement = IR.string(getReplacement(key));\n    replacement.copyInformationFrom(expr);\n    parent.replaceChild(expr, replacement);\n    recordReplacement(expr, key);\n    return replacement;\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String key = expr.getString();\n        String replacement = getReplacement(key);\n        if (replacement != null) {\n            Node replacementNode = IR.string(replacement);\n            parent.replaceChild(expr, replacementNode);\n            recordReplacement(expr, key);\n            return replacementNode;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // TODO(user): Implement this.\n    return expr;\n}"
    ],
    [
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n        double[] out = new double[a.length];\n        System.arraycopy(a, 0, out, 0, a.length);\n        return out;\n    }",
      "public double[] getCoefficients()  {\n        double[] out = new double[a.length];\n        System.arraycopy(a, 0, out, 0, a.length);\n        return out;\n    }",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n        double[] out = new double[a.length];\n        System.arraycopy(a, 0, out, 0, a.length);\n        return out;\n    }",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n        double[] out = new double[a.length];\n        System.arraycopy(a, 0, out, 0, a.length);\n        return out;\n    }",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    if (info.hasDescription()) {\n      builder.setDesc(info.getDescription());\n      builder.setIsHidden(info.isHidden());\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo docInfo = node.getJSDocInfo();\n  if (docInfo != null) {\n    if (docInfo.hasDescription()) {\n      builder.setDesc(docInfo.getDescription());\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    if (info.hasDescription()) {\n      builder.setDesc(info.getDescription());\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    if (info.hasDescription()) {\n      builder.setDesc(info.getDescription());\n      builder.setIsHidden(info.isHidden());\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    String desc = info.getDescription();\n    if (desc != null) {\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo docInfo = node.getJSDocInfo();\n  if (docInfo != null) {\n    if (docInfo.hasDescription()) {\n      builder.setDesc(docInfo.getDescription());\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    if (info.hasDescription()) {\n      builder.setDesc(info.getDescription());\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo docInfo = node.getJSDocInfo();\n  if (docInfo != null) {\n    String desc = docInfo.getDescription();\n    if (desc != null) {\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    String desc = info.getDescription();\n    if (desc != null) {\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo docInfo = node.getJSDocInfo();\n  if (docInfo != null) {\n    if (docInfo.hasDescription()) {\n      builder.setDesc(docInfo.getDescription());\n      return true;\n    }\n  }\n  return false;\n}"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    }\n    double sum = 0;\n    double sumX = 0;\n    double sumY = 0;\n    double sumX2 = 0;\n    double sumY2 = 0;\n    double sumXY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        double x = xArray[i];\n        double y = yArray[i];\n        sum++;\n        sumX += x;\n        sumY += y;\n        sumX2 += x * x;\n        sumY2 += y * y;\n        sumXY += x * y;\n    }\n    double covariance = (sumXY - sumX * sumY / sum) / (sum - 1);\n    if (biasCorrected) {\n        covariance *= sum / (sum - 1);\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIFFERENT_LENGTHS,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    }\n    double xmean = new Mean().evaluate(xArray);\n    double ymean = new Mean().evaluate(yArray);\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - xmean) * (yArray[i] - ymean);\n    }\n    if (biasCorrected) {\n        sum /= (xArray.length - 1);\n    } else {\n        sum /= xArray.length;\n    }\n    return sum;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH,\n                                               xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, 2);\n    } else {\n        double sum = 0;\n        double sumX = 0;\n        double sumY = 0;\n        double sumX2 = 0;\n        double sumY2 = 0;\n        for(int i=0; i<xArray.length; i++) {\n            sum += xArray[i] * yArray[i];\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumX2 += xArray[i] * xArray[i];\n            sumY2 += yArray[i] * yArray[i];\n        }\n        double covariance = (sum - sumX * sumY / xArray.length) / (xArray.length - 1);\n        if (biasCorrected) {\n            covariance *= xArray.length / (xArray.length - 1);\n        }\n        return covariance;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    }\n    double xMean = mean(xArray);\n    double yMean = mean(yArray);\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - xMean) * (yArray[i] - yMean);\n    }\n    if (biasCorrected) {\n        sum /= (xArray.length - 1);\n    } else {\n        sum /= xArray.length;\n    }\n    return sum;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    }\n    double xMean = new Mean().evaluate(xArray);\n    double yMean = new Mean().evaluate(yArray);\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - xMean) * (yArray[i] - yMean);\n    }\n    if (biasCorrected) {\n        return sum / (xArray.length - 1);\n    } else {\n        return sum / xArray.length;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    }\n    double sum = 0;\n    double sumX = 0;\n    double sumY = 0;\n    double sumX2 = 0;\n    double sumY2 = 0;\n    double sumXY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum++;\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumX2 += xArray[i] * xArray[i];\n        sumY2 += yArray[i] * yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n    double covariance = (sumXY - sumX * sumY / sum) / (sum - 1);\n    if (biasCorrected) {\n        covariance *= sum / (sum - 1);\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    }\n    double sumX = 0;\n    double sumY = 0;\n    double sumX2 = 0;\n    double sumY2 = 0;\n    double sumXY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumX2 += xArray[i] * xArray[i];\n        sumY2 += yArray[i] * yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n    double n = xArray.length;\n    double denom = n * (n - 1);\n    double covariance = (sumXY - sumX * sumY / n) / denom;\n    if (biasCorrected) {\n        covariance *= n / (n - 1);\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTHS,\n                                               xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, 2);\n    }\n    double sumX = 0;\n    double sumY = 0;\n    double sumXY = 0;\n    double sumX2 = 0;\n    double sumY2 = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumX2 += xArray[i] * xArray[i];\n        sumY2 += yArray[i] * yArray[i];\n    }\n    double covariance = (sumXY - sumX * sumY / xArray.length) / (xArray.length - 1);\n    if (biasCorrected) {\n        covariance *= xArray.length / (xArray.length - 1);\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH,\n                                               xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, 2);\n    }\n    double sumX = 0;\n    double sumY = 0;\n    double sumXY = 0;\n    double sumX2 = 0;\n    double sumY2 = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        double x = xArray[i];\n        double y = yArray[i];\n        sumX += x;\n        sumY += y;\n        sumXY += x * y;\n        sumX2 += x * x;\n        sumY2 += y * y;\n    }\n    double covariance = (sumXY - sumX * sumY / xArray.length) / (xArray.length - 1);\n    if (biasCorrected) {\n        covariance *= xArray.length / (xArray.length - 1);\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    }\n    double xMean = new Mean().evaluate(xArray);\n    double yMean = new Mean().evaluate(yArray);\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        double x = xArray[i];\n        double y = yArray[i];\n        sum += (x - xMean) * (y - yMean);\n    }\n    if (biasCorrected) {\n        sum /= xArray.length - 1;\n    } else {\n        sum /= xArray.length;\n    }\n    return sum;\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    if (value <= 0) {\n        return;\n    }\n    final long skipped = in.skip(value);\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value <= 0) {\n        return;\n    }\n    final long skipped = in.skip(value);\n    count(skipped);\n    if (skipped < value) {\n        final long rem = value - skipped;\n        final byte[] buf = new byte[(int) (skipBuf.length > rem ? rem : skipBuf.length)];\n        final int x = read(buf);\n        if (x == -1) {\n            throw new EOFException();\n        }\n        count(x);\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value > 0) {\n        final long skipped = in.skip(value);\n        count(skipped);\n        if (skipped != value) {\n            throw new IOException(\"Failed to skip \" + value + \" bytes, only \" + skipped + \" bytes were skipped\");\n        }\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long n = in.read(buf.array(), 0, (int) Math.min(buf.capacity(), remaining));\n        if (n < 0) {\n            throw new EOFException(\"Truncated ZIP entry: \"\n                                   + ArchiveUtils.sanitize(current.entry.getName()));\n        }\n        count(n);\n        remaining -= n;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = readOneByte();\n        if (x == -1) {\n            return;\n        }\n        skipped++;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value <= 0) {\n        return;\n    }\n    final long skipped = in.skip(value);\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        final long rem = value - skipped;\n        final int x = readOneByte();\n        if (x == -1) \n        {\n            return;\n        }\n        skipped++;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long n = in.skip(remaining);\n        if (n < 0) {\n            throw new EOFException();\n        }\n        count(n);\n        remaining -= n;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long n = in.read(skipBuf, 0, (int) Math.min(skipBuf.length, remaining));\n        if (n < 0) {\n            throw new EOFException(\"Truncated ZIP entry: \"\n                                   + ArchiveUtils.sanitize(current.entry.getName()));\n        }\n        count(n);\n        remaining -= n;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value > 0) \n    {\n        final long skipped = in.skip(value);\n        count(skipped);\n    }\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(FP.fingerprint(tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    String projectScopedMeaning = (projectId != null ? (projectId + \": \") : \"\") + meaning;\n    return String.valueOf(MessageId.generateId(tcValue, projectScopedMeaning));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    long fp = 0;\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            fp = mix64(fp, word64At(\n                ((PlaceholderReference) part).getName().getBytes(Charsets.UTF_8), 0), 0);\n        } else {\n            fp = mix64(fp, word64At(part.toString().getBytes(Charsets.UTF_8), 0), 0);\n        }\n    }\n    return Long.toString(fp, 36).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(FP.fingerprint(tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n      // The fingerprint is based on the first 63 bits of the 64-bit\n      // fingerprint of the message parts.\n      long fingerprint = FP.fingerprint(messageParts);\n      return Long.toString(fingerprint, 36).toUpperCase();\n    }",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    String projectScopedMeaning = (projectId != null ? (projectId + \": \") : \"\") + meaning;\n    return String.valueOf(MessageId.generateId(tcValue, projectScopedMeaning));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n      long hash = 0;\n      for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n          hash = mix64(hash, fingerprint(((PlaceholderReference) part).getName()), 0);\n        } else {\n          hash = mix64(hash, fingerprint(part.toString()), 0);\n        }\n      }\n      return Long.toString(hash, 36).toUpperCase();\n    }",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    long fp = FP.fingerprint(tcValue);\n    return Long.toString(fp, Character.MAX_RADIX).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n      if (part instanceof PlaceholderReference) {\n        sb.append(CaseFormat.LOWER_CAMEL.to(\n            CaseFormat.UPPER_UNDERSCORE,\n            ((PlaceholderReference) part).getName()));\n      } else {\n        sb.append(part);\n      }\n    }\n    String tcValue = sb.toString();\n    long fingerprint = FP.fingerprint(tcValue);\n    return Long.toString(fingerprint, Character.MAX_RADIX).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // TODO: Implement this method\n    return null;\n}"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long minDistance = Math.min(minDistanceFromEnd, maxDistanceFromEnd);\n        long maxDistance = Math.max(minDistanceFromEnd, maxDistanceFromEnd);\n        long pos = archive.size() - minDistance;\n        if (pos < 0) {\n            return false;\n        }\n        while (pos < archive.size() - maxDistance) {\n            archive.position(pos);\n            int n = IOUtils.readFully(archive, wordBuf);\n            if (n < WORD) {\n                return false;\n            }\n            if (Arrays.equals(sig, wordBuf)) {\n                archive.position(pos);\n                return true;\n            }\n            pos++;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long currentPosition = archive.size();\n        long minPosition = currentPosition - minDistanceFromEnd;\n        long maxPosition = currentPosition - maxDistanceFromEnd;\n        if (minPosition < 0) {\n            minPosition = 0;\n        }\n        if (maxPosition < 0) {\n            maxPosition = 0;\n        }\n        while (currentPosition > maxPosition) {\n            currentPosition--;\n            archive.position(currentPosition);\n            byte[] buf = new byte[sig.length];\n            int read = archive.read(buf);\n            if (read != sig.length) {\n                throw new IOException(\"Error reading archive\");\n            }\n            if (Arrays.equals(buf, sig)) {\n                return true;\n            }\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distance = Math.min(minDistanceFromEnd, maxDistanceFromEnd);\n    long start = archive.size() - distance;\n    while (distance >= 0) {\n        archive.position(start);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(wordBuf, sig)) {\n            return true;\n        }\n        distance -= WORD;\n        start -= WORD;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    boolean found = false;\n    long distanceFromEnd = minDistanceFromEnd;\n    while (!found && distanceFromEnd < maxDistanceFromEnd) {\n        final long pos = archive.size() - distanceFromEnd;\n        archive.position(pos);\n        skipBytes(distanceFromEnd);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        found = Arrays.equals(sig, wordBuf);\n        distanceFromEnd *= 2;\n    }\n    return found;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.size();\n    long minPosition = currentPosition - minDistanceFromEnd;\n    long maxPosition = currentPosition - maxDistanceFromEnd;\n    if (minPosition < 0) {\n        minPosition = 0;\n    }\n    if (maxPosition < 0) {\n        maxPosition = 0;\n    }\n    long position = currentPosition;\n    while (position >= minPosition) {\n        archive.position(position);\n        if (readAndCheckSignature(sig)) {\n            return true;\n        }\n        position--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    boolean found = false;\n    long distance = Math.min(minDistanceFromEnd, maxDistanceFromEnd);\n    long stopSearching = Math.max(archive.size() - maxDistanceFromEnd, 0);\n    while (!found && distance >= minDistanceFromEnd && archive.position() >= stopSearching) {\n        archive.position(archive.position() - distance);\n        distance = Math.max(distance / 2, minDistanceFromEnd);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        found = Arrays.equals(sig, wordBuf);\n    }\n    return found;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distanceFromEnd = minDistanceFromEnd;\n    while (distanceFromEnd < maxDistanceFromEnd) {\n        final long offset = archive.size() - distanceFromEnd;\n        archive.position(offset);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(sig, wordBuf)) {\n            return true;\n        }\n        distanceFromEnd += WORD;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.size();\n    long newPosition = currentPosition - minDistanceFromEnd;\n    if (newPosition < 0) {\n        newPosition = 0;\n    }\n    while (newPosition < maxDistanceFromEnd) {\n        archive.position(newPosition);\n        byte[] buf = new byte[WORD];\n        int read = archive.read(buf);\n        if (read != WORD) {\n            return false;\n        }\n        if (Arrays.equals(buf, sig)) {\n            return true;\n        }\n        newPosition++;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    boolean found = false;\n    long currentPosition = archive.size();\n    long newPosition = currentPosition - minDistanceFromEnd;\n    if (newPosition < 0) {\n        newPosition = 0;\n    }\n    archive.position(newPosition);\n    while (!found && newPosition < maxDistanceFromEnd) {\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        found = Arrays.equals(sig, wordBuf);\n        if (!found) {\n            newPosition++;\n            archive.position(newPosition);\n        }\n    }\n    if (found) {\n        archive.position(newPosition);\n    }\n    return found;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distance = Math.min(minDistanceFromEnd, maxDistanceFromEnd);\n    long startPos = archive.size() - distance;\n    long pos = startPos;\n    boolean found = false;\n    while (!found && pos >= 0) {\n        archive.position(pos);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        found = Arrays.equals(sig, wordBuf);\n        if (!found) {\n            distance = Math.min(distance + WORD, maxDistanceFromEnd);\n            pos = startPos - distance;\n        }\n    }\n    if (found) {\n        archive.position(pos);\n    }\n    return found;\n}"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}"
    ],
    [
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    return new InputStream() {\n        int _ptr = 0;\n        int _mark = 0;\n        int _marked = 0;\n        int _limit = _bufferedLength;\n}\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new SequenceInputStream(_originalStream, new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength));\n}",
      "public InputStream getDataStream()  {\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section < this.dataset.getItemCount()) \n    {\n        key = this.dataset.getKey(section);\n    }\n    if (key == null) \n    {\n        key = \"Section \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section < this.dataset.getItemCount()) \n    {\n        key = this.dataset.getKey(section);\n    }\n    if (key == null) \n    {\n        key = \"SECTION\" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section < this.dataset.getItemCount()) \n    {\n        key = this.dataset.getKey(section);\n    }\n    if (key == null) \n    {\n        key = Integer.valueOf(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section < this.dataset.getColumnCount()) \n    {\n        key = this.dataset.getColumnKey(section);\n    }\n    if (key == null) \n    {\n        key = \"Section \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    // check for a key in the dataset...\n    key = this.dataset.getKey(this.pieIndex, section);\n    if (key == null) \n    {\n        // no key found, so generate one...\n        key = \"SECTION_\" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section < this.dataset.getItemCount()) \n    {\n        key = this.dataset.getColumnKey(section);\n    }\n    else \n    {\n        key = new Integer(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section < this.dataset.getItemCount()) \n    {\n        key = this.dataset.getKey(section);\n    }\n    if (key == null) \n    {\n        key = \"Section \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section < this.dataset.getItemCount()) \n    {\n        key = this.dataset.getKey(section);\n    }\n    if (key == null) \n    {\n        key = Integer.valueOf(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    // check for a key in the dataset...\n    if (this.dataset != null) \n    {\n        key = this.dataset.getKey(section);\n    }\n    // if there is no key in the dataset, generate one...\n    if (key == null) \n    {\n        key = \"Section \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    // do we have a dataset?\n    if (this.dataset != null) \n    {\n        // get the key from the dataset\n        key = this.dataset.getColumnKey(section);\n    }\n    // if the key is null, generate a unique key\n    if (key == null) \n    {\n        key = \"SECTION\" + section;\n    }\n    return key;\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            return (_currToken == JsonToken.VALUE_NUMBER_FLOAT) && (_currentNumericValue.isNaN());\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT || _currToken == JsonToken.VALUE_NUMBER_INT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return ((Double) ob).isNaN();\n                }\n                if (ob instanceof Float) {\n                    return ((Float) ob).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT || _currToken == JsonToken.VALUE_NUMBER_INT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return ((Double) ob).isNaN();\n                }\n                if (ob instanceof Float) {\n                    return ((Float) ob).isNaN();\n                }\n                if (ob instanceof BigDecimal) {\n                    return ((BigDecimal) ob).compareTo(BigDecimal.ZERO) != 0;\n                }\n                if (ob instanceof BigInteger) {\n                    return ((BigInteger) ob).compareTo(BigInteger.ZERO) != 0;\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return (_numberDouble == Double.POSITIVE_INFINITY);\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return ((Double) ob).isNaN();\n                }\n                if (ob instanceof Float) {\n                    return ((Float) ob).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return ((Double) ob).isNaN();\n                }\n                if (ob instanceof Float) {\n                    return ((Float) ob).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return Double.isNaN((Double) _currentObject());\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT || _currToken == JsonToken.VALUE_NUMBER_INT) {\n                Object ob = _currentObject();\n                if (ob instanceof Double) {\n                    return ((Double) ob).isNaN();\n                }\n                if (ob instanceof Float) {\n                    return ((Float) ob).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return (_numberFloat == Float.NaN);\n            }\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return (_numberInt == 0 && _numberDouble != 0.0);\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            // Simple, but need to look for START_OBJECT/ARRAY's \"off-by-one\" thing:\n            JsonStreamContext ctxt = _parsingContext;\n            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n                ctxt = ctxt.getParent();\n            }\n            if (ctxt instanceof TokenBufferReadContext) {\n                try {\n                    return ((TokenBufferReadContext) ctxt).isNaN();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return false;\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    for (int i = 0; i < prefix.length(); i++) \n    {\n        final char strChar = str.charAt(i);\n        final char prefixChar = prefix.charAt(i);\n        if (strChar != prefixChar && !Character.toLowerCase(strChar) == Character.toLowerCase(prefixChar)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}"
    ],
    [
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  ",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) \n    {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) \n    {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) \n    {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  ",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    } \n    else if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n    if (symbolName != null && !symbolName.isEmpty()) {\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        return index;\n      } else {\n        int id = originalNameMap.size();\n        originalNameMap.put(symbolName, id);\n        return id;\n      }\n    }\n    return UNMAPPED;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastMapping.originalName) {\n      lastMapping.originalName = symbolName;\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        lastMapping.id = index;\n      } else {\n        lastMapping.id = originalNameMap.size();\n        originalNameMap.put(symbolName, lastMapping.id);\n      }\n    }\n    return lastMapping.id;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastMapping.originalName) {\n      lastMapping.originalName = symbolName;\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        lastMapping.originalName = index;\n      } else {\n        lastMapping.originalName = originalNameMap.size();\n        originalNameMap.put(symbolName, lastMapping.originalName);\n      }\n    }\n    return lastMapping.originalName;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastMapping.originalName) {\n      lastMapping.originalName = symbolName;\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        lastMapping.id = index;\n      } else {\n        lastMapping.id = originalNameMap.size();\n        originalNameMap.put(symbolName, lastMapping.id);\n      }\n    }\n    return lastMapping.id;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null && !symbolName.isEmpty()) {\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        return index;\n      } else {\n        int newIndex = originalNameMap.size();\n        originalNameMap.put(symbolName, newIndex);\n        return newIndex;\n      }\n    } else {\n      return 0;\n    }\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastMapping.originalName) {\n      lastMapping.originalName = symbolName;\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        lastMapping.id = index;\n      } else {\n        lastMapping.id = originalNameMap.size();\n        originalNameMap.put(symbolName, lastMapping.id);\n      }\n    }\n    return lastMapping.id;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastMapping.originalName) {\n      lastMapping.originalName = symbolName;\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        lastMapping.id = index;\n      } else {\n        lastMapping.id = originalNameMap.size();\n        originalNameMap.put(symbolName, lastMapping.id);\n      }\n    }\n    return lastMapping.id;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null && !symbolName.isEmpty()) {\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        return index;\n      } else {\n        index = originalNameMap.size();\n        originalNameMap.put(symbolName, index);\n        return index;\n      }\n    } else {\n      return UNMAPPED;\n    }\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastMapping.originalName) {\n      lastMapping.originalName = symbolName;\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        lastMapping.originalName = index;\n      } else {\n        lastMapping.originalName = originalNameMap.size();\n        originalNameMap.put(symbolName, lastMapping.originalName);\n      }\n    }\n    return lastMapping.originalName;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastMapping.originalName) {\n      lastMapping.originalName = symbolName;\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        lastMapping.id = index;\n      } else {\n        lastMapping.id = originalNameMap.size();\n        originalNameMap.put(symbolName, lastMapping.id);\n      }\n    }\n    return lastMapping.id;\n  }"
    ],
    [
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    double result = Double.parseDouble(peekedString);\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n      result = (double) peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n      result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n      result = (double) peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n      result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double)peekedLong;\n    }\n    if (p == PEEKED_NUMBER) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      String s = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n      return Double.parseDouble(s);\n    }\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n      result = (double) peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n      result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    double result = Double.parseDouble(peekedString);\n    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n      result = (double) peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n      result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double)peekedLong;\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = nextQuotedValue('\"');\n      peeked = PEEKED_BUFFERED;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      peeked = PEEKED_BUFFERED;\n    } else if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n      peeked = PEEKED_BUFFERED;\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    double result = Double.parseDouble(peekedString);\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double)peekedLong;\n    }\n\n    if (p == PEEKED_NUMBER) {\n      peekedString = nextQuotedValue('\"');\n      peeked = PEEKED_BUFFERED;\n    }\n\n    double result = Double.parseDouble(peekedString);\n    if (!isLenient() && (Double.isNaN(result) || Double.isInfinite(result))) {\n      throw new NumberFormatException(\"JSON forbids NaN and infinities: \" + result);\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n        result = (double)peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n        result = Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) \n        {\n            return null;\n        }\n        if (repeat <= 0) \n        {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) \n        {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) \n        {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) \n        {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) \n                {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) \n                {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n    if(str == null) \n    {\n        return null;\n    }\n    // given this implementation, positive repeats are moved to the left, \n    // negative to the right.\n    if(repeat < 0) \n    {\n        return repeat(str, repeat + 1);\n    }\n    final int inputLength = str.length();\n    if(repeat == 1 || inputLength == 0) \n    {\n        return str;\n    }\n    if(repeat == 0) \n    {\n        return EMPTY;\n    }\n    final int outputLength = inputLength * repeat;\n    switch(inputLength) \n    {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for(int i = repeat * 2 - 2; i >= 0; i--, i--) \n            {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for(int i = 0; i < repeat; i++) \n            {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}\n// StringUtils.java\n// Substring",
      "public static String repeat(final String str, final int repeat)  {\n    if(str == null) \n    {\n        return null;\n    }\n    // given this implementation, positive repeats are moved here\n    if(repeat < 0) \n    {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if(repeat == 0 || inputLength == 0) \n    {\n        return EMPTY;\n    }\n    if(repeat == 1 || inputLength == 1) \n    {\n        return str;\n    }\n    final int outputLength = inputLength * repeat;\n    switch(inputLength) \n    {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for(int i = repeat * 2 - 2; i >= 0; i--, i--) \n            {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for(int i = 0; i < repeat; i++) \n            {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) \n        {\n            return null;\n        }\n        final int inputLength = str.length();\n        if (repeat <= 0) \n        {\n            return EMPTY;\n        }\n        if (repeat == 1 || inputLength == 0) \n        {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) \n        {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) \n        {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) \n                {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) \n                {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1:\n                return repeat(str.charAt(0), repeat);\n            case 2:\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default:\n                final StringBuilder repeated = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    repeated.append(str);\n                }\n                return repeated.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) \n        {\n            return null;\n        }\n        if (repeat <= 0) \n        {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) \n        {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) \n        {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) \n        {\n            case 1:\n                return repeat(str.charAt(0), repeat);\n            case 2:\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) \n                {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default:\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) \n                {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) \n        {\n            return null;\n        }\n        if (repeat <= 0) \n        {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) \n        {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) \n        {\n            return repeat(str.charAt(0), repeat);\n        }\n\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) \n        {\n            case 1:\n                return repeat(str.charAt(0), repeat);\n            case 2:\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) \n                {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default:\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) \n                {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField ze = null;\n    Class<?> c = implementations.get(headerId);\n    if (c != null) {\n        ze = (ZipExtraField) c.newInstance();\n    }\n    if (ze == null) {\n        ze = new UnrecognizedExtraField(headerId);\n    }\n    return ze;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField ze = implementations.get(headerId);\n    if (ze == null) {\n        ze = new UnrecognizedExtraField();\n        ze.setHeaderId(headerId);\n    }\n    return (ZipExtraField) ze.getClass().newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> c = implementations.get(headerId);\n    if (c != null) {\n        return (ZipExtraField) c.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField extraField = null;\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        extraField = (ZipExtraField) clazz.newInstance();\n    } else {\n        extraField = new UnrecognizedExtraField();\n    }\n    extraField.setHeaderId(headerId);\n    return extraField;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField ze = implementations.get(headerId);\n    if (ze == null) {\n        ze = new UnrecognizedExtraField();\n        ze.setHeaderId(headerId);\n    }\n    return (ZipExtraField) ze.getClass().newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return (ZipExtraField) clazz.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> c = get(headerId);\n    if (c != null) {\n        return (ZipExtraField) c.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField extraField = implementations.get(headerId);\n    if (extraField == null) {\n        extraField = new UnrecognizedExtraField();\n    }\n    extraField.setHeaderId(headerId);\n    return extraField;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return (ZipExtraField) clazz.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        clazz = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) clazz.newInstance();\n}"
    ],
    [
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    Iterator iterator = clone.entrySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        entry.setValue((Marker) entry.getValue().clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    for (Iterator iterator = clone.entrySet().iterator(); iterator.hasNext();) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        entry.setValue((Marker) ObjectUtilities.clone(entry.getValue()));\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    Iterator iterator = clone.entrySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Marker marker = (Marker) entry.getValue();\n        if (marker instanceof PublicCloneable) \n        {\n            PublicCloneable pc = (PublicCloneable) marker;\n            Marker cloneMarker = (Marker) pc.clone();\n            entry.setValue(cloneMarker);\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = (Map) ObjectUtilities.deepClone(map);\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) ObjectUtilities.deepClone(map);\n    return clone;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    return ExtraFieldUtils.mergeCentralDirectoryData(data);\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (set.contains(e)) {\n                continue;\n            }\n            toAdd.add(e);\n            changed = true;\n        }\n        if (changed) {\n            super.addAll(index, toAdd);\n            set.addAll(toAdd);\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (set.contains(e)) {\n                continue;\n            }\n            toAdd.add(e);\n            changed = true;\n        }\n        super.addAll(index, toAdd);\n        set.addAll(toAdd);\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) \n        {\n            if (set.contains(e)) \n            {\n                continue;\n            }\n            toAdd.add(e);\n            changed = true;\n        }\n        // add all elements in one go\n        super.addAll(index, toAdd);\n        // add all elements to the set\n        set.addAll(toAdd);\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds elements if unique\n        for (final E element : coll) {\n            add(index, element);\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (set.contains(e)) {\n                continue;\n            }\n            toAdd.add(e);\n            changed = true;\n        }\n        // add all elements to the list\n        for (final E e : toAdd) {\n            super.add(index++, e);\n        }\n        // add all elements to the set\n        set.addAll(toAdd);\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (set.contains(e) == false) {\n                toAdd.add(e);\n                changed = true;\n            }\n        }\n        super.addAll(index, toAdd);\n        set.addAll(toAdd);\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e : coll) {\n            if (set.contains(e) == false) {\n                super.add(index++, e);\n                set.add(e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e : coll) {\n            if (set.contains(e) == false) {\n                super.add(index++, e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e : coll) {\n            if (set.contains(e) == false) {\n                super.add(index, e);\n                set.add(e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (set.contains(e)) {\n                continue;\n            }\n            toAdd.add(e);\n            changed = true;\n        }\n        super.addAll(index, toAdd);\n        set.addAll(toAdd);\n        return changed;\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n        evaluations.incrementCount();\n        return f.value(x);\n    }",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}"
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n        for (LinearConstraint constraint : originalConstraints) {\n            constraints.add(normalize(constraint));\n        }\n        return constraints;\n    }",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n        for (LinearConstraint constraint : originalConstraints) {\n            constraints.add(normalize(constraint));\n        }\n        return constraints;\n    }",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        constraints.add(normalize(constraint));\n    }\n    return constraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n        for (LinearConstraint constraint : originalConstraints) {\n            constraints.add(normalize(constraint));\n        }\n        return constraints;\n    }",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n        for (LinearConstraint constraint : originalConstraints) {\n            constraints.add(normalize(constraint));\n        }\n        return constraints;\n    }",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n        for (LinearConstraint constraint : originalConstraints) {\n            constraints.add(normalize(constraint));\n        }\n        return constraints;\n    }",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n        List<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n        for (LinearConstraint constraint : originalConstraints) {\n            constraints.add(normalize(constraint));\n        }\n        return constraints;\n    }",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        constraints.add(normalize(constraint));\n    }\n    return constraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        constraints.add(normalize(constraint));\n    }\n    return constraints;\n}"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound > bin.upperBound) \n    {\n        return false;\n    } \n    else if (this.upperBound < bin.lowerBound) \n    {\n        return false;\n    } \n    else \n    {\n        return true;\n    }\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound <= bin.lowerBound && this.upperBound >= bin.lowerBound) \n    {\n        return true;\n    } \n    else if (this.lowerBound >= bin.lowerBound && this.lowerBound <= bin.upperBound) \n    {\n        return true;\n    } \n    else \n    {\n        return false;\n    }\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound <= bin.lowerBound && this.upperBound >= bin.lowerBound)\n    {\n        return true;\n    }\n    else if (this.lowerBound >= bin.lowerBound && this.lowerBound <= bin.upperBound)\n    {\n        return true;\n    }\n    else if (this.upperBound >= bin.lowerBound && this.upperBound <= bin.upperBound)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound) \n    {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound <= bin.lowerBound && this.upperBound >= bin.lowerBound) \n    {\n        return true;\n    }\n    if (this.lowerBound >= bin.lowerBound && this.upperBound <= bin.upperBound) \n    {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound <= bin.lowerBound && this.upperBound >= bin.lowerBound)\n    {\n        return true;\n    }\n    else if (this.lowerBound >= bin.lowerBound && this.upperBound <= bin.upperBound)\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound <= bin.getUpperBound() && this.upperBound >= bin.getLowerBound())\n    {\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound < bin.upperBound && this.upperBound > bin.lowerBound)\n    {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (this.lowerBound < bin.lowerBound) \n    {\n        if (this.upperBound < bin.lowerBound) \n        {\n            return false;\n        }\n        else \n        {\n            return true;\n        }\n    }\n    else \n    {\n        if (this.lowerBound > bin.upperBound) \n        {\n            return false;\n        }\n        else \n        {\n            return true;\n        }\n    }\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final char[] c = str.toCharArray();\n    final List<String> list = new ArrayList<>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        final int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[0]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final char[] c = str.toCharArray();\n    final List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        final int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return new String[0];\n    }\n    char[] c = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    char[] chars = str.toCharArray();\n    List<String> list = new ArrayList<>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new String[0];\n    }\n    char[] c = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return new String[0];\n    }\n    char[] chars = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(chars[tokenStart]);\n    for (int pos = tokenStart + 1; pos < chars.length; pos++) {\n        int type = Character.getType(chars[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(chars, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(chars, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(chars, tokenStart, chars.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    char[] c = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final char[] c = str.toCharArray();\n    final List<String> list = new ArrayList<>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        final int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new String[0];\n    }\n    char[] c = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return new String[0];\n    }\n    char[] c = str.toCharArray();\n    List<String> list = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(c[tokenStart]);\n    for (int pos = tokenStart + 1; pos < c.length; pos++) {\n        int type = Character.getType(c[pos]);\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(new String(c, tokenStart, newTokenStart - tokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(new String(c, tokenStart, pos - tokenStart));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(new String(c, tokenStart, c.length - tokenStart));\n    return list.toArray(new String[list.size()]);\n}"
    ],
    [
      "public long parseMillis(String text)  {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                return millis;\n            }\n        } else {\n            newPos = ~newPos;\n            throw new IllegalArgumentException(\"Invalid format: \\\"\" + text.substring(0, newPos) + \"\\\"\");\n        }\n    }",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(\n            \"Invalid format: \\\"\" + text + \"\\\" is malformed at \" + newPos);\n    }\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(\"Invalid format: \\\"\" + text.substring(0, newPos) + \"\\\"\");\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(\"Invalid format: \\\"\" + text.substring(newPos) + \"\\\"\");\n    }\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(\"Invalid format: \\\"\" + text.substring(newPos) + \"\\\"\");\n    }\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(\"Invalid format: \" + text.substring(newPos));\n    }\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(\"Invalid format: \\\"\" + text + \"\\\"\");\n    }\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(\"Invalid format: \\\"\" + text.substring(newPos) + \"\\\"\");\n    }\n}",
      "public long parseMillis(String text)  {\n    return parseDateTime(text).getMillis();\n}",
      "public long parseMillis(String text)  {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                return millis;\n            }\n        } else {\n            newPos = ~newPos;\n            throw new IllegalArgumentException(\"Invalid format: \\\"\" + text + \"\\\"\" +\n                    \" at position \" + newPos);\n        }\n    }"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    return new MinimizedCondition(\n        MeasuredNode.addNode(n.cloneTree(), MeasuredNode.SCRIPT_PLACEHOLDER),\n        MeasuredNode.addNode(n.cloneTree(), MeasuredNode.SCRIPT_PLACEHOLDER));\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Node placeholder = swapWithPlaceholderNode(n);\n    return new MinimizedCondition(\n        MeasuredNode.addNode(n.cloneTree(), placeholder),\n        MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n), placeholder));\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    return new MinimizedCondition(\n        MeasuredNode.addNode(n.cloneTree(), MeasuredNode.ZERO),\n        MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n            MeasuredNode.INFINITY));\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    return new MinimizedCondition(\n        MeasuredNode.addNode(n.cloneTree(),\n            MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                    MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                        MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                            MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                    MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                        MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                            MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                    MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                        MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                            MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                                MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                                    MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                                        MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                                            MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                                                MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Node placeholder = swapWithPlaceholderNode(n);\n    return new MinimizedCondition(\n        MeasuredNode.addNode(n.cloneTree(), placeholder),\n        MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n), placeholder));\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Node placeholder = swapWithPlaceholderNode(n);\n    return new MinimizedCondition(\n        MeasuredNode.addNode(n.cloneTree(), placeholder),\n        MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n), placeholder));\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Node placeholder = swapWithPlaceholderNode(n);\n    return new MinimizedCondition(\n        MeasuredNode.addNode(n.cloneTree(), placeholder),\n        MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n), placeholder));\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    return new MinimizedCondition(\n        MeasuredNode.addNode(n.cloneTree(), MeasuredNode.addNode(\n            new Node(Token.SCRIPT).srcref(n),\n            MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                    MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                        MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                            MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                    MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                        MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                            MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                    MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                        MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                            MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                                MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                                    MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                                        MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                                            MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    return new MinimizedCondition(\n        MeasuredNode.addNode(n.cloneTree(),\n            MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                    MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                        MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                            MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                    MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                        MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                            MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                    MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                        MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                            MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                                MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                                    MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                                        MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                                            MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n                                                                                MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    Node placeholder = swapWithPlaceholderNode(n);\n    return new MinimizedCondition(\n        MeasuredNode.addNode(n.cloneTree(), placeholder),\n        MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n), placeholder));\n  }"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n        asEnum(enumClass);\n        Validate.notNull(values);\n        final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n        for (final E value : values) {\n            Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n            condensed.add(value);\n        }\n        final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n        for (final E value : condensed) {\n            result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n        }\n        ArrayUtils.reverse(result);\n        return result;\n    }",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) \n    {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    Converter[] removed = new Converter[1];\n    ConverterSet set = iPartialConverters.add(converter, removed);\n    if (set != iPartialConverters) {\n        iPartialConverters = set;\n        if (removed[0] != null) {\n            return (PartialConverter) removed[0];\n        }\n    }\n    return null;\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    Converter[] removed = new Converter[1];\n    ConverterSet set = iPartialConverters.add(converter, removed);\n    if (set != iPartialConverters) {\n        iPartialConverters = set;\n        if (removed[0] != null) {\n            return (PartialConverter) removed[0];\n        }\n    }\n    return null;\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    Converter[] removed = new Converter[1];\n    ConverterSet set = iPartialConverters.add(converter, removed);\n    if (set != iPartialConverters) {\n        iPartialConverters = set;\n        return (PartialConverter) removed[0];\n    }\n    return null;\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    Converter[] removed = new Converter[1];\n    ConverterSet set = iPartialConverters.add(converter, removed);\n    if (set != iPartialConverters) {\n        iPartialConverters = set;\n        if (removed[0] != null) {\n            return (PartialConverter) removed[0];\n        }\n    }\n    return null;\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    Converter[] removed = new Converter[1];\n    ConverterSet set = iPartialConverters.add(converter, removed);\n    if (set != iPartialConverters) {\n        iPartialConverters = set;\n        return (PartialConverter) removed[0];\n    }\n    return null;\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    return (PartialConverter) iPartialConverters.add(converter, null);\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    return (PartialConverter) iPartialConverters.add(converter, null);\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        return (PartialConverter)iPartialConverters.add(converter, null);\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    return (PartialConverter) iPartialConverters.add(converter, null);\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    Converter[] removed = new Converter[1];\n    ConverterSet set = iPartialConverters.add(converter, removed);\n    if (set != iPartialConverters) {\n        iPartialConverters = set;\n        if (removed[0] != null) {\n            return (PartialConverter) removed[0];\n        }\n    }\n    return null;\n}"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return lexicalScopeOrdering.compare(scope, globalScope);\n  } else if (scope.isPropertyScope()) {\n    SymbolScope lexicalScope = scope.getPropertyScope();\n    return lexicalScopeOrdering.compare(lexicalScope, globalScope) +\n        lexicalScope.getScopeDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isGlobalScope()) {\n    return 0;\n  } else if (scope.isDocScope()) {\n    return 0;\n  } else {\n    return 1 + getLexicalScopeDepth(scope.getParentScope());\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isGlobalScope()) {\n    return 0;\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return getLexicalScopeDepth(scope.getParentScope());\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return lexicalScopeOrdering.indexOf(scope);\n  } else if (scope.isPropertyScope()) {\n    SymbolScope parent = scope.getParentScope();\n    return getLexicalScopeDepth(parent) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return lexicalScopeOrdering.compare(scope, globalScope);\n  } else if (scope.isPropertyScope()) {\n    SymbolScope parent = scope.getParentScope();\n    return getLexicalScopeDepth(parent) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isGlobalScope()) {\n    return 0;\n  } else if (scope.isDocScope()) {\n    return 0;\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return getLexicalScopeDepth(scope.getParentScope());\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isGlobalScope()) {\n    return 0;\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return scope.getScopeDepth();\n  }\n}"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blocks = new double[blockRows][];\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int startRow    = iBlock * BLOCK_SIZE;\n            final int endRow      = FastMath.min(startRow + BLOCK_SIZE, rows);\n            final int blockHeight = endRow - startRow;\n            final int blockLength = blockHeight * blockColumns;\n            blocks[iBlock] = new double[blockLength];\n            int k = 0;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int startColumn = jBlock * BLOCK_SIZE;\n                final int endColumn   = FastMath.min(startColumn + BLOCK_SIZE, columns);\n                for (int i = startRow; i < endRow; ++i) {\n                    for (int j = startColumn; j < endColumn; ++j) {\n                        blocks[iBlock][k++] = rawData[i][j];\n                    }\n                }\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n            final int startRow = blockRow * BLOCK_SIZE;\n            final int endRow = FastMath.min(startRow + BLOCK_SIZE, rows);\n            final int blockHeight = endRow - startRow;\n            for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n                final int startColumn = blockColumn * BLOCK_SIZE;\n                final int endColumn = FastMath.min(startColumn + BLOCK_SIZE, columns);\n                final int blockWidth = endColumn - startColumn;\n                final double[] block = new double[blockHeight * blockWidth];\n                blocks[blockRow * blockColumns + blockColumn] = block;\n                int k = 0;\n                for (int i = startRow; i < endRow; ++i) {\n                    for (int j = startColumn; j < endColumn; ++j) {\n                        block[k++] = rawData[i][j];\n                    }\n                }\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // convert to blocks layout\n    final double[][] blockData = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int blockJ = 0; blockJ < blockColumns; ++blockJ) {\n        final int startJ = blockJ * BLOCK_SIZE;\n        final int endJ   = FastMath.min(startJ + BLOCK_SIZE, columns);\n        for (int blockI = 0; blockI < blockRows; ++blockI) {\n            final int startI = blockI * BLOCK_SIZE;\n            final int endI   = FastMath.min(startI + BLOCK_SIZE, rows);\n            blockData[blockIndex] = new double[endI - startI][endJ - startJ];\n            for (int i = startI; i < endI; ++i) {\n                System.arraycopy(rawData[i], startJ, blockData[blockIndex][i - startI], 0, endJ - startJ);\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocksData = new double[blockRows][];\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        final int startRow = blockRow * BLOCK_SIZE;\n        final int endRow = Math.min(startRow + BLOCK_SIZE, rows);\n        final int blockHeight = endRow - startRow;\n        final double[] block = new double[blockHeight * blockColumns];\n        blocksData[blockRow] = block;\n        for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n            final int startColumn = blockColumn * BLOCK_SIZE;\n            final int endColumn = Math.min(startColumn + BLOCK_SIZE, columns);\n            final int blockWidth = endColumn - startColumn;\n            int k = 0;\n            for (int i = startRow; i < endRow; ++i) {\n                for (int j = startColumn; j < endColumn; ++j) {\n                    block[k++] = rawData[i][j];\n                }\n            }\n        }\n    }\n\n    return blocksData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // create the output array\n    final double[][] blocksData = new double[blockRows * blockColumns][];\n\n    // fill the output array\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        final int startRow    = blockRow * BLOCK_SIZE;\n        final int endRow      = FastMath.min(startRow + BLOCK_SIZE, rows);\n        final int blockHeight = endRow - startRow;\n        for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n            final int startColumn = blockColumn * BLOCK_SIZE;\n            final int endColumn   = FastMath.min(startColumn + BLOCK_SIZE, columns);\n            final int blockWidth  = endColumn - startColumn;\n            final int blockIndex  = blockRow * blockColumns + blockColumn;\n            blocksData[blockIndex] = new double[blockHeight * blockWidth];\n            int blockRowIndex = 0;\n            for (int i = startRow; i < endRow; ++i) {\n                int blockColumnIndex = 0;\n                for (int j = startColumn; j < endColumn; ++j) {\n                    blocksData[blockIndex][blockRowIndex * blockWidth + blockColumnIndex] = rawData[i][j];\n                    ++blockColumnIndex;\n                }\n                ++blockRowIndex;\n            }\n        }\n    }\n\n    return blocksData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // convert the raw data array into a block data array\n    final double[][] blockData = new double[blockRows][blockColumns * BLOCK_SIZE];\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iStart = iBlock * BLOCK_SIZE;\n        final int iEnd = FastMath.min(iStart + BLOCK_SIZE, rows);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int jStart = jBlock * BLOCK_SIZE;\n            final int jEnd = FastMath.min(jStart + BLOCK_SIZE, columns);\n            int k = 0;\n            for (int i = iStart; i < iEnd; ++i) {\n                for (int j = jStart; j < jEnd; ++j) {\n                    blockData[iBlock][k] = rawData[i][j];\n                    ++k;\n                }\n            }\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows][];\n    for (int i = 0; i < blockRows; ++i) {\n        blocks[i] = new double[blockColumns * BLOCK_SIZE * BLOCK_SIZE];\n    }\n\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int i0 = iBlock * BLOCK_SIZE;\n            final int j0 = jBlock * BLOCK_SIZE;\n            final int i1 = FastMath.min(i0 + BLOCK_SIZE, rows);\n            final int j1 = FastMath.min(j0 + BLOCK_SIZE, columns);\n            for (int i = i0; i < i1; ++i) {\n                for (int j = j0; j < j1; ++j) {\n                    blocks[iBlock][jBlock * BLOCK_SIZE * BLOCK_SIZE + (i - i0) * BLOCK_SIZE + (j - j0)] = rawData[i][j];\n                }\n            }\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows][];\n    for (int i = 0; i < blockRows; ++i) {\n        blocks[i] = new double[blockColumns * BLOCK_SIZE];\n    }\n\n    for (int i = 0; i < rows; ++i) {\n        final int blockI = i / BLOCK_SIZE;\n        final int indexI = i % BLOCK_SIZE;\n        for (int j = 0; j < columns; ++j) {\n            final int blockJ = j / BLOCK_SIZE;\n            final int indexJ = j % BLOCK_SIZE;\n            blocks[blockI][blockJ * BLOCK_SIZE + indexJ] = rawData[i][j];\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows][];\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        final int startRow = blockRow * BLOCK_SIZE;\n        final int endRow   = FastMath.min(startRow + BLOCK_SIZE, rows);\n        final int rowLength = endRow - startRow;\n        final double[] block = new double[rowLength * blockColumns];\n        blocks[blockRow] = block;\n        int blockIndex = 0;\n        for (int row = startRow; row < endRow; ++row) {\n            final double[] rawRow = rawData[row];\n            System.arraycopy(rawRow, 0, block, blockIndex, rowLength);\n            blockIndex += rowLength;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        final double[][] blockData = new double[blockRows][blockColumns * BLOCK_SIZE];\n\n        // copy the data\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iStart = iBlock * BLOCK_SIZE;\n            final int iEnd = iStart + BLOCK_SIZE;\n            final int iMax = FastMath.min(iEnd, rows);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int jStart = jBlock * BLOCK_SIZE;\n                final int jEnd = jStart + BLOCK_SIZE;\n                final int jMax = FastMath.min(jEnd, columns);\n                int k = 0;\n                for (int i = iStart; i < iMax; ++i) {\n                    for (int j = jStart; j < jMax; ++j) {\n                        blockData[iBlock][k++] = rawData[i][j];\n                    }\n                }\n            }\n        }\n\n        return blockData;\n    }"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n    final Dfp two = a.getTwo();\n\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a.add(a);\n    c = c.multiply(c);\n\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i-1)*i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n    final Dfp two = one.add(one);\n\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a.add(a);\n\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i - 1) * i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n    final Dfp two = one.add(one);\n\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a.add(a);\n    c = c.multiply(c);\n\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i - 1) * i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\n        final Dfp one = a.getOne();\n        final Dfp two = a.getTwo();\n        final Dfp zero = a.getZero();\n\n        Dfp x = a;\n        Dfp y = one;\n        Dfp c = a.add(a);\n        c = c.multiply(c);\n\n        Dfp fact = one;\n        Dfp py = new Dfp(y);\n\n        for (int i = 3; i < 90; i += 2) {\n            x = x.multiply(c);\n            x = x.negate();\n\n            fact = fact.divide((i - 1) * i);  // 1 over fact\n            y = y.add(x.multiply(fact));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a.add(a);\n    c = c.multiply(c);\n\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 3; i < 90; i += 2) \n    {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i-1)*i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) \n        {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n        final Dfp one = a.getOne();\n        final Dfp two = a.getTwo();\n        final Dfp half = one.divide(two);\n\n        Dfp x = a;\n        Dfp y = one;\n        Dfp c = x.multiply(x);\n\n        Dfp fact = one;\n        Dfp py = new Dfp(y);\n\n        for (int i = 2; i < 90; i += 2) {\n            x = x.multiply(c);\n            x = x.divide(fact);\n\n            y = y.add(x);\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n\n            fact = fact.add(one);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n    final Dfp two = a.getTwo();\n\n    Dfp x = a;\n    Dfp y = one;\n    Dfp c = a.add(a);\n    c = c.multiply(c);\n\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i-1)*i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a.add(a);\n    c = c.multiply(c);\n\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i-1)*i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n    final Dfp two = one.add(one);\n\n    Dfp x = a;\n    Dfp y = one;\n    Dfp c = a.add(a);\n    c = c.multiply(c);\n\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 3; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i-1)*i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a.add(a);\n    c = c.multiply(c);\n\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i - 1) * i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        if (FastMath.abs(x) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n            return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n        } else if (FastMath.abs(y) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n            return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n        }\n        double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n        return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    T threshold = getNorm().multiply(0.6);\n    if (threshold.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    if (x.getReal() <= threshold.getReal()) {\n        T inverse = x.getField().getOne().divide(x.multiply(x).add(y.multiply(y)).add(z.multiply(z)));\n        return new FieldVector3D<T>(x.getField().getZero(), z.multiply(inverse), y.multiply(inverse).negate());\n    } else if (y.getReal() <= threshold.getReal()) {\n        T inverse = x.getField().getOne().divide(x.multiply(x).add(y.multiply(y)).add(z.multiply(z)));\n        return new FieldVector3D<T>(y.getField().getZero(), x.multiply(inverse).negate(), z.multiply(inverse));\n    }\n    T inverse = x.getField().getOne().divide(x.multiply(x).add(y.multiply(y)).add(z.multiply(z)));\n    return new FieldVector3D<T>(y.getField().getZero(), y.multiply(inverse).negate(), x.multiply(inverse));\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        if (FastMath.abs(x) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n            return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n        } else if (FastMath.abs(y) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n            return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n        }\n        double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n        return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        if (FastMath.abs(x) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n            return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n        } else if (FastMath.abs(y) <= threshold) {\n            double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n            return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n        }\n        double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n        return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n    }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    // compute the norm of the instance\n    final T norm = getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    // compute the orthogonal vector\n    final T inverseNorm = norm.reciprocal();\n    return new FieldVector3D<T>(inverseNorm.multiply(z), inverseNorm.multiply(x.negate()), inverseNorm.multiply(y));\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    T threshold = getNorm().multiply(0.6);\n    if (threshold.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    T dot = dotProduct(this);\n\n    if (dot.getReal() < ((2.0e-15 - 1.0) * threshold.getReal())) {\n      // special case u = -v: we select a PI angle rotation around\n      // an arbitrary vector orthogonal to u\n      FieldVector3D<T> w = orthogonal();\n      q0 = 0.0;\n      q1 = -w.getX();\n      q2 = -w.getY();\n      q3 = -w.getZ();\n    } else {\n      // general case: (u, v) defines a plane, we select\n      // the shortest possible rotation: axis orthogonal to this plane\n      q0 = FastMath.sqrt(0.5 * (1.0 + dot.getReal() / threshold.getReal()));\n      double coeff = 1.0 / (2.0 * q0 * threshold.getReal());\n      FieldVector3D<T> q = v.crossProduct(u);\n      q1 = coeff * q.getX();\n      q2 = coeff * q.getY();\n      q3 = coeff * q.getZ();\n    }\n\n  }",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    T threshold = getNorm().multiply(0.6);\n    if (threshold.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    T dot = x.multiply(x).add(y.multiply(y)).add(z.multiply(z));\n    if (dot.getReal() <= threshold.getReal()) {\n        T inverse  = x.multiply(x).add(y.multiply(y)).add(z.multiply(z)).sqrt();\n        return new FieldVector3D<T>(x.multiply(0).add(z.multiply(inverse)),\n                                    x.multiply(0).add(y.multiply(inverse)),\n                                    x.multiply(0).add(z.multiply(0).subtract(inverse)));\n    } else if (x.getReal() <= threshold.getReal()) {\n        T inverse  = x.multiply(x).add(y.multiply(y)).add(z.multiply(z)).sqrt();\n        return new FieldVector3D<T>(x.multiply(0).add(z.multiply(inverse)),\n                                    x.multiply(0).add(y.multiply(inverse)),\n                                    x.multiply(0).add(z.multiply(0).subtract(inverse)));\n    }\n    T inverse  = x.multiply(x).add(y.multiply(y)).add(z.multiply(z)).sqrt();\n    return new FieldVector3D<T>(x.multiply(0).add(y.multiply(inverse)),\n                                x.multiply(0).add(z.multiply(0).subtract(inverse)),\n                                x.multiply(0).add(y.multiply(0).subtract(inverse)));\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    // compute the square of the norm\n    final T normSq = getNormSq();\n    if (normSq.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    // compute the threshold for what is considered null\n    final double threshold = 0.6 * normSq.getReal();\n\n    // select the vector component which is not null\n    if (x.getReal() <= threshold) {\n        final T inverse  = x.divide(normSq);\n        return new FieldVector3D<T>(x.getField().getZero(),\n                                    y.subtract(z.multiply(inverse)),\n                                    z.add(y.multiply(inverse)));\n    } else if (y.getReal() <= threshold) {\n        final T inverse  = y.divide(normSq);\n        return new FieldVector3D<T>(x.add(z.multiply(inverse)),\n                                    y.getField().getZero(),\n                                    z.subtract(x.multiply(inverse)));\n    }\n    final T inverse  = z.divide(normSq);\n    return new FieldVector3D<T>(x.subtract(y.multiply(inverse)),\n                                y.add(x.multiply(inverse)),\n                                z.getField().getZero());\n}"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return null;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    final T min = (comparator().compare(minimum, other.minimum) <= 0) ? minimum : other.minimum;\n    final T max = (comparator().compare(maximum, other.maximum) >= 0) ? maximum : other.maximum;\n    return between(min, max, comparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    return between(\n        (minimum.compareTo(other.minimum) <= 0) ? minimum : other.minimum,\n        (maximum.compareTo(other.maximum) >= 0) ? maximum : other.maximum,\n        comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    return between(\n        (minimum.compareTo(other.minimum) < 0) ? other.minimum : minimum,\n        (maximum.compareTo(other.maximum) > 0) ? other.maximum : maximum,\n        comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    final T min = (isBefore(other.minimum)) ? other.minimum : minimum;\n    final T max = (isAfter(other.maximum)) ? other.maximum : maximum;\n    return between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return null;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    return between(\n        getMinimum().compareTo(other.getMinimum()) < 0 ? getMinimum() : other.getMinimum(),\n        getMaximum().compareTo(other.getMaximum()) > 0 ? getMaximum() : other.getMaximum(),\n        getComparator()\n    );\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    final T newMin = (elementCompareTo(other.minimum) <= 0) ? minimum : other.minimum;\n    final T newMax = (elementCompareTo(other.maximum) >= 0) ? maximum : other.maximum;\n    return between(newMin, newMax, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    final T newMin = (comparator.compare(minimum, other.minimum) <= 0) ? minimum : other.minimum;\n    final T newMax = (comparator.compare(maximum, other.maximum) >= 0) ? maximum : other.maximum;\n    return between(newMin, newMax, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return null;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    final T min = (isBefore(other.minimum)) ? other.minimum : minimum;\n    final T max = (isAfter(other.maximum)) ? other.maximum : maximum;\n    return between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    return between(\n        (comparator.compare(minimum, other.minimum) <= 0) ? minimum : other.minimum,\n        (comparator.compare(maximum, other.maximum) >= 0) ? maximum : other.maximum,\n        comparator\n    );\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return null;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap to calculate intersection\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    final T min = getMinimum().compareTo(other.getMinimum()) < 0 ? getMinimum() : other.getMinimum();\n    final T max = getMaximum().compareTo(other.getMaximum()) > 0 ? getMaximum() : other.getMaximum();\n    return between(min, max, getComparator());\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, new OutputStreamWriter(out, \"UTF-8\"));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8Generator gen = new UTF8Generator(ctxt, _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return Objects.equals(o1, o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return ((Byte) o1).equals(o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return ((Short) o1).equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return ((Integer) o1).equals(o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return ((Character) o1).equals(o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return ((Long) o1).equals(o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return ((Float) o1).equals(o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return ((Double) o1).equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return ((Boolean) o1).equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) \n    {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return Objects.equals(o1, o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return ((Byte) o1).byteValue() == ((Byte) o2).byteValue();\n    }\n    if (type.equals(Short.TYPE)) {\n        return ((Short) o1).shortValue() == ((Short) o2).shortValue();\n    }\n    if (type.equals(Integer.TYPE)) {\n        return ((Integer) o1).intValue() == ((Integer) o2).intValue();\n    }\n    if (type.equals(Character.TYPE)) {\n        return ((Character) o1).charValue() == ((Character) o2).charValue();\n    }\n    if (type.equals(Long.TYPE)) {\n        return ((Long) o1).longValue() == ((Long) o2).longValue();\n    }\n    if (type.equals(Float.TYPE)) {\n        return ((Float) o1).floatValue() == ((Float) o2).floatValue();\n    }\n    if (type.equals(Double.TYPE)) {\n        return ((Double) o1).doubleValue() == ((Double) o2).doubleValue();\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return ((Boolean) o1).booleanValue() == ((Boolean) o2).booleanValue();\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) \n    {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return ObjectUtils.equals(o1, o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return Objects.equals(o1, o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) \n    {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return Objects.equals(o1, o2);\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n    if (type.isUnionType()) {\n      UnionType union = type.toMaybeUnionType();\n      if (union.isUnknownType()) {\n        return type;\n      }\n      if (union.isEquivalent(type)) {\n        return type;\n      }\n      if (union.isLiteralObject()) {\n        return type;\n      }\n      return filterNoResolvedType(union.getRestrictedUnion(type));\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    } else if (type.isUnionType()) {\n      UnionType unionType = type.toMaybeUnionType();\n      if (unionType.isUnknownType()) {\n        return type;\n      } else {\n        ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n        for (JSType alternate : unionType.getAlternates()) {\n          builder.add(filterNoResolvedType(alternate));\n        }\n        return JSType.join(builder.build());\n      }\n    } else {\n      return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    } else if (type.isUnionType()) {\n      UnionType union = type.toMaybeUnionType();\n      ImmutableList.Builder<JSType> filteredBuilder = ImmutableList.builder();\n      for (JSType alternate : union.getAlternates()) {\n        if (alternate.isNoResolvedType()) {\n          filteredBuilder.add(alternate);\n        }\n      }\n      if (filteredBuilder.build().size() == union.getAlternatesCount()) {\n        return type;\n      }\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type == null) {\n      return null;\n    }\n\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n\n    if (type.isUnionType()) {\n      UnionType unionType = type.toMaybeUnionType();\n      ImmutableList.Builder<JSType> filteredBuilder = ImmutableList.builder();\n      for (JSType alt : unionType.getAlternates()) {\n        JSType filteredAlt = filterNoResolvedType(alt);\n        if (filteredAlt != null) {\n          filteredBuilder.add(filteredAlt);\n        }\n      }\n      return JSType.join(filteredBuilder.build());\n    }\n\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    } else if (type.isUnionType()) {\n      UnionType union = type.toMaybeUnionType();\n      boolean changed = false;\n      ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n      for (JSType alt : union.getAlternates()) {\n        JSType filtered = filterNoResolvedType(alt);\n        if (filtered != null) {\n          builder.add(filtered);\n        } else {\n          changed = true;\n        }\n      }\n      if (changed) {\n        return JSType.join(builder.build());\n      }\n    }\n    return null;\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type == null) {\n      return null;\n    }\n\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n\n    if (type.isUnionType()) {\n      UnionType union = type.toMaybeUnionType();\n      ImmutableList.Builder<JSType> filteredAlternates = ImmutableList.builder();\n      for (JSType alternate : union.getAlternates()) {\n        if (alternate.isNoResolvedType()) {\n          return alternate;\n        }\n        filteredAlternates.add(filterNoResolvedType(alternate));\n      }\n      return JSType.join(filteredAlternates.build());\n    }\n\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    } else if (type.isUnionType()) {\n      UnionType union = type.toMaybeUnionType();\n      ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n      for (JSType alternate : union.getAlternates()) {\n        if (!alternate.isNoResolvedType()) {\n          builder.add(alternate);\n        }\n      }\n      return builder.build().isEmpty() ?\n          JSType.getNativeType(JSTypeNative.NO_RESOLVED_TYPE) :\n          JSType.join(builder.build());\n    } else {\n      return type;\n    }\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type == null) {\n      return null;\n    }\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n    if (type.isUnionType()) {\n      UnionType union = type.toMaybeUnionType();\n      ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n      for (JSType alt : union.getAlternates()) {\n        if (alt.isNoResolvedType()) {\n          builder.add(alt);\n        }\n      }\n      if (builder.build().size() == union.getAlternatesCount()) {\n        return type;\n      }\n      return JSType.join(builder.build());\n    }\n    return type;\n  }\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type == null) {\n      return null;\n    }\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n    if (type.isUnionType()) {\n      UnionType union = type.toMaybeUnionType();\n      ImmutableList<JSType> alternates = union.getAlternates();\n      if (alternates.size() == 2) {\n        JSType first = alternates.get(0);\n        JSType second = alternates.get(1);\n        if (first.isNoResolvedType() && second.isNoResolvedType()) {\n          return type;\n        }\n      }\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    } else if (type.isUnionType()) {\n      UnionType unionType = type.toMaybeUnionType();\n      if (unionType.isUnknownType()) {\n        return type;\n      }\n      return JSType.join(\n          unionType.getAlternates(JSType.filterNoResolvedType));\n    } else {\n      return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n  }\n}"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      return maybeRestrictTwoNames(\n          blindScope, node, originalType, restrictedType,\n          null, null, null);\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      return maybeRestrictTwoNames(\n          blindScope, node, originalType, restrictedType, null, null, null);\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      return maybeRestrictTwoNames(\n          blindScope, node, originalType, restrictedType,\n          null, null, null);\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      return maybeRestrictTwoNames(\n          blindScope, node, originalType, restrictedType, null, null, null);\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      return maybeRestrictTwoNames(\n          blindScope, node, originalType, restrictedType, null, null, null);\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      return maybeRestrictTwoNames(\n          blindScope, node, originalType, restrictedType, null, null, null);\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      return maybeRestrictTwoNames(\n          blindScope, node, originalType, restrictedType,\n          null, null, null);\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      return maybeRestrictTwoNames(\n          blindScope, node, originalType, restrictedType, null, null, null);\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParameters = null;\n    Node thisType = null;\n    Node parametersType = null;\n    Node resultType = null;\n\n    // Parse type parameters.\n    if (match(JsDocToken.LT)) {\n      typeParameters = parseTypeParameters(next());\n    }\n\n    // Parse 'this' type.\n    if (match(JsDocToken.THIS)) {\n      thisType = parseTypeName(next());\n    }\n\n    // Parse parameters type.\n    if (match(JsDocToken.LP)) {\n      parametersType = parseParametersType(next());\n    }\n\n    // Parse result type.\n    if (match(JsDocToken.RP)) {\n      resultType = parseResultType(next());\n    }\n\n    if (typeParameters != null) {\n      functionType.addChildToBack(typeParameters);\n    }\n\n    if (thisType != null) {\n      functionType.addChildToBack(thisType);\n    }\n\n    if (parametersType != null) {\n      functionType.addChildToBack(parametersType);\n    }\n\n    if (resultType != null) {\n      functionType.addChildToBack(resultType);\n    }\n\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node typeParameters = null;\n  Node parametersType = null;\n  Node resultType = null;\n\n  // Parse the type parameters.\n  if (match(JsDocToken.LT)) {\n    typeParameters = parseTypeParameters(next());\n    if (typeParameters == null) {\n      return reportGenericTypeSyntaxWarning();\n    }\n  }\n\n  // Parse the parameters.\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n\n  next();\n  skipEOLs();\n  token = next();\n\n  if (token == JsDocToken.THIS) {\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n\n    next();\n    skipEOLs();\n    token = next();\n  }\n\n  parametersType = parseParametersType(token);\n  if (parametersType == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n\n  next();\n  skipEOLs();\n  token = next();\n\n  // Parse the result type.\n  if (token == JsDocToken.COLON) {\n    next();\n    skipEOLs();\n    token = next();\n\n    resultType = parseTypeExpression(token);\n    if (resultType == null) {\n      return reportGenericTypeSyntaxWarning();\n    }\n  }\n\n  // Create the function type.\n  functionType.addChildToBack(typeParameters);\n  functionType.addChildToBack(parametersType);\n  functionType.addChildToBack(resultType);\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParameters = null;\n    Node parametersType = null;\n    Node resultType = null;\n\n    if (match(JsDocToken.LT)) {\n      typeParameters = parseTypeParameters(next());\n    }\n\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    if (match(JsDocToken.THIS)) {\n      next();\n      skipEOLs();\n      if (!match(JsDocToken.COLON)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n      }\n      next();\n      skipEOLs();\n      Node typeName = parseTypeName(next());\n      if (typeName == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n      }\n      functionType.addChildToBack(typeName);\n    }\n\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    next();\n\n    if (match(JsDocToken.LP)) {\n      parametersType = parseParametersType(next());\n    }\n\n    if (match(JsDocToken.ARROW)) {\n      next();\n      skipEOLs();\n      resultType = parseTypeExpression(next());\n    }\n\n    if (typeParameters != null) {\n      functionType.addChildToBack(typeParameters);\n    }\n\n    if (parametersType != null) {\n      functionType.addChildToBack(parametersType);\n    }\n\n    if (resultType != null) {\n      functionType.addChildToBack(resultType);\n    }\n\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  if (match(JsDocToken.LT)) {\n    next();\n    skipEOLs();\n    Node typeParameters = parseTypeExpressionList(next());\n    if (typeParameters != null) {\n      functionType.addChildToFront(typeParameters);\n\n      skipEOLs();\n      if (!match(JsDocToken.GT)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n      }\n\n      next();\n    }\n  }\n\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.THIS)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.COLON)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n\n  next();\n  skipEOLs();\n  Node thisType = parseTypeExpression(next());\n  if (thisType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n  }\n\n  functionType.addChildToBack(thisType);\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n\n  next();\n  skipEOLs();\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n  }\n\n  functionType.addChildToBack(parametersType);\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n  }\n\n  functionType.addChildToBack(resultType);\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node parametersType = parseParametersType(token);\n    if (parametersType == null) {\n      return reportGenericTypeSyntaxWarning();\n    }\n    functionType.addChildToBack(parametersType);\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node parametersType = parseParametersType(token);\n  if (parametersType == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  functionType.addChildToBack(parametersType);\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node typeParameters = parseTypeParameters(token);\n  if (typeParameters != null) {\n    functionType.addChildToBack(typeParameters);\n  }\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  skipEOLs();\n  if (match(JsDocToken.THIS)) {\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    Node thisType = parseTypeName(next());\n    if (thisType == null) {\n      return reportGenericTypeSyntaxWarning();\n    }\n    functionType.addChildToBack(thisType);\n  }\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  skipEOLs();\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n  functionType.addChildToBack(parametersType);\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n  functionType.addChildToBack(resultType);\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node typeParameters = null;\n  Node parametersType = null;\n  Node resultType = null;\n\n  // Parse type parameters.\n  if (match(JsDocToken.LT)) {\n    typeParameters = parseTypeParameters(next());\n  }\n\n  // Parse parameters.\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  skipEOLs();\n  if (match(JsDocToken.THIS)) {\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    Node thisType = parseTypeExpression(next());\n    if (thisType == null) {\n      return reportGenericTypeSyntaxWarning();\n    }\n    functionType.addChildToBack(thisType);\n  }\n  parametersType = parseParametersType(next());\n  if (parametersType == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n  functionType.addChildToBack(parametersType);\n\n  // Parse result type.\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  skipEOLs();\n  if (match(JsDocToken.COLON)) {\n    next();\n    skipEOLs();\n    resultType = parseTypeExpression(next());\n    if (resultType == null) {\n      return reportGenericTypeSyntaxWarning();\n    }\n  }\n\n  // Create the function type node.\n  functionType.addChildToBack(typeParameters);\n  functionType.addChildToBack(parametersType);\n  functionType.addChildToBack(resultType);\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node parametersType = parseParametersType(token);\n  if (parametersType == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n\n  next();\n  functionType.addChildToBack(parametersType);\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node typeParameters = parseTypeParameters(token);\n  if (typeParameters != null) {\n    functionType.addChildToBack(typeParameters);\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.THIS)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.COLON)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n\n  next();\n  skipEOLs();\n  Node typeName = parseTypeName(next());\n  if (typeName == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n\n  next();\n  skipEOLs();\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  functionType.addChildToBack(typeName);\n  functionType.addChildToBack(parametersType);\n  functionType.addChildToBack(resultType);\n  return functionType;\n}"
    ],
    [
      "public static String deleteWhitespace(final String str)  ",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) \n    {\n        return str;\n    }\n    int sz = str.length();\n    char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) \n    {\n        if (!Character.isWhitespace(str.charAt(i))) \n        {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) \n    {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  ",
      "public static String deleteWhitespace(final String str)  ",
      "public static String deleteWhitespace(final String str)  {\n    if (isEmpty(str)) {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  ",
      "public static String deleteWhitespace(final String str)  ",
      "public static String deleteWhitespace(final String str)  ",
      "public static String deleteWhitespace(final String str)  ",
      "public static String deleteWhitespace(final String str)  "
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n        double sum = 0;\n        double sumsq = 0;\n        long n = 0;\n        double max = Double.NEGATIVE_INFINITY;\n        double min = Double.POSITIVE_INFINITY;\n        double sumLog = 0;\n        double geoMean = 1;\n        for (SummaryStatistics stat : statistics) {\n            sum += stat.getSum();\n            sumsq += stat.getSumsq();\n            n += stat.getN();\n            max = Math.max(max, stat.getMax());\n            min = Math.min(min, stat.getMin());\n            sumLog += stat.getSumOfLogs();\n            geoMean *= stat.getGeometricMean();\n        }\n        return new StatisticalSummaryValues(sum / n,\n                                            sumsq / n,\n                                            n,\n                                            max,\n                                            min,\n                                            sumLog);\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n        double sum = 0;\n        double sumsq = 0;\n        long n = 0;\n        double max = Double.NEGATIVE_INFINITY;\n        double min = Double.POSITIVE_INFINITY;\n        double sumLog = 0;\n        double geoMean = 1;\n        for (SummaryStatistics stat : statistics) {\n            sum += stat.getSum();\n            sumsq += stat.getSumsq();\n            n += stat.getN();\n            max = Math.max(max, stat.getMax());\n            min = Math.min(min, stat.getMin());\n            sumLog += stat.getSumOfLogs();\n            geoMean *= stat.getGeometricMean();\n        }\n        return new StatisticalSummaryValues(sum / n,\n                sumsq / n - (sum / n) * (sum / n), n, max, min, sum);\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n        double sum = 0;\n        double sumsq = 0;\n        long n = 0;\n        double max = Double.NEGATIVE_INFINITY;\n        double min = Double.POSITIVE_INFINITY;\n        double sumLog = 0;\n        double geoMean = 1;\n        for (SummaryStatistics stat : statistics) {\n            n += stat.getN();\n            sum += stat.getSum();\n            sumsq += stat.getSumsq();\n            max = Math.max(max, stat.getMax());\n            min = Math.min(min, stat.getMin());\n            sumLog += stat.getSumOfLogs();\n            geoMean *= stat.getGeometricMean();\n        }\n        return new StatisticalSummaryValues(sum / n,\n                sumsq / n - (sum / n) * (sum / n), n, max, min, sum);\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    // Validate input\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    // Initialize values\n    double sum = 0;\n    double sumsq = 0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    double sumLog = 0;\n    double geoMean = 1;\n    long n = 0;\n\n    // Iterate over the input statistics\n    for (SummaryStatistics stat : statistics) {\n        // Update the values\n        n += stat.getN();\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n        sumLog += stat.getSumOfLogs();\n        geoMean *= stat.getGeometricMean();\n    }\n\n    // Compute the mean and variance\n    double mean = sum / n;\n    double variance = sumsq / n - mean * mean;\n\n    // Return the summary statistics\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n        double sum = 0;\n        double sumsq = 0;\n        double min = Double.POSITIVE_INFINITY;\n        double max = Double.NEGATIVE_INFINITY;\n        long n = 0;\n        double sumLog = 0;\n        double geoMean = 1;\n        for (SummaryStatistics stat : statistics) {\n            if (stat == null) {\n                continue;\n            }\n            sum += stat.getSum();\n            sumsq += stat.getSumsq();\n            min = Math.min(min, stat.getMin());\n            max = Math.max(max, stat.getMax());\n            n += stat.getN();\n            sumLog += stat.getSumOfLogs();\n            geoMean *= stat.getGeometricMean();\n        }\n        return new StatisticalSummaryValues(sum / n,\n                                            sumsq / n - (sum / n) * (sum / n),\n                                            n,\n                                            max,\n                                            min,\n                                            sum);\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n        double sum = 0;\n        double sumsq = 0;\n        double min = Double.POSITIVE_INFINITY;\n        double max = Double.NEGATIVE_INFINITY;\n        double sumLog = 0;\n        double geoMean = 1;\n        long n = 0;\n        for (SummaryStatistics stat : statistics) {\n            n += stat.getN();\n            sum += stat.getSum();\n            sumsq += stat.getSumsq();\n            min = Math.min(min, stat.getMin());\n            max = Math.max(max, stat.getMax());\n            sumLog += stat.getSumOfLogs();\n            geoMean *= stat.getGeometricMean();\n        }\n        return new StatisticalSummaryValues(sum / n,\n                (n * sumsq - sum * sum) / (n * (n - 1)),\n                n, max, min, sum);\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n        double sum = 0;\n        double sumsq = 0;\n        double min = Double.POSITIVE_INFINITY;\n        double max = Double.NEGATIVE_INFINITY;\n        double sumLog = 0;\n        double geoMean = 1;\n        long n = 0;\n        for (SummaryStatistics stat : statistics) {\n            n += stat.getN();\n            sum += stat.getSum();\n            sumsq += stat.getSumsq();\n            min = Math.min(min, stat.getMin());\n            max = Math.max(max, stat.getMax());\n            sumLog += stat.getSumOfLogs();\n            geoMean *= stat.getGeometricMean();\n        }\n        return new StatisticalSummaryValues(sum / n,\n                                            sumsq / n,\n                                            n,\n                                            max,\n                                            min,\n                                            sum);\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        // Handle empty statistics collection\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n\n        // Compute aggregate statistics\n        SummaryStatistics aggregate = new SummaryStatistics();\n        for (SummaryStatistics stat : statistics) {\n            aggregate.addValue(stat.getMean());\n        }\n\n        return new StatisticalSummaryValues(aggregate.getMean(),\n                                            aggregate.getVariance(),\n                                            aggregate.getN(),\n                                            aggregate.getMax(),\n                                            aggregate.getMin(),\n                                            aggregate.getSum());\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n        // Create a SummaryStatistics to hold the aggregate values\n        SummaryStatistics aggregate = new SummaryStatistics();\n        // Iterate over the input statistics and add their values to the aggregate\n        for (SummaryStatistics stat : statistics) {\n            aggregate.addValue(stat.getSum());\n            aggregate.addValue(stat.getSumsq());\n            aggregate.addValue(stat.getMin());\n            aggregate.addValue(stat.getMax());\n            aggregate.addValue(stat.getGeometricMean());\n            aggregate.addValue(stat.getMean());\n            aggregate.addValue(stat.getVariance());\n            aggregate.addValue(stat.getStandardDeviation());\n            aggregate.addValue(stat.getSecondMoment());\n            aggregate.addValue(stat.getSumOfLogs());\n        }\n        return new StatisticalSummaryValues(\n                aggregate.getMean(),\n                aggregate.getVariance(),\n                aggregate.getN(),\n                aggregate.getMax(),\n                aggregate.getMin(),\n                aggregate.getSum()\n        );\n    }",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n        if (statistics == null || statistics.isEmpty()) {\n            return null;\n        }\n\n        // Compute the aggregate statistics\n        double sum = 0;\n        double sumsq = 0;\n        double min = Double.POSITIVE_INFINITY;\n        double max = Double.NEGATIVE_INFINITY;\n        double sumLog = 0;\n        double geoMean = 1;\n        long n = 0;\n        for (SummaryStatistics stat : statistics) {\n            n += stat.getN();\n            sum += stat.getSum();\n            sumsq += stat.getSumsq();\n            min = Math.min(min, stat.getMin());\n            max = Math.max(max, stat.getMax());\n            sumLog += stat.getSumOfLogs();\n            geoMean *= stat.getGeometricMean();\n        }\n        geoMean = Math.pow(geoMean, 1.0 / n);\n\n        // Compute the mean and variance\n        double mean = sum / n;\n        double variance = sumsq / n - mean * mean;\n\n        return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n    }"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            double d = sample1[i] - sample2[i] - meanDifference;\n            result += d * d;\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        return varianceDifference(sample1, sample2, meanDifference, 0, sample1.length);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        return varianceDifference(sample1, sample2, meanDifference, 0, sample1.length);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        return varianceDifference(sample1, sample2, meanDifference, 0, sample1.length);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            double d = sample1[i] - sample2[i] - meanDifference;\n            result += d * d;\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i] - meanDifference) * (sample1[i] - sample2[i] - meanDifference);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    sample1.length, 2, true);\n        }\n        double sumSq = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sumSq += (sample1[i] - sample2[i] - meanDifference) *\n                    (sample1[i] - sample2[i] - meanDifference);\n        }\n        return sumSq / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    sample1.length, 2, true);\n        }\n        double sumSqDifferences = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sumSqDifferences += (sample1[i] - sample2[i] - meanDifference) *\n                    (sample1[i] - sample2[i] - meanDifference);\n        }\n        return sumSqDifferences / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    sample1.length, 2, true);\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            double dev = sample1[i] - sample2[i] - meanDifference;\n            sum += dev * dev;\n        }\n        return sum / (sample1.length - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    sample1.length, 2, true);\n        }\n        double variance = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            variance += (sample1[i] - sample2[i] - meanDifference) *\n                    (sample1[i] - sample2[i] - meanDifference);\n        }\n        return variance / (sample1.length - 1);\n    }"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() > 0) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED_NAME) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED_NAME) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED_NAME) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED_NAME) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED_NAME) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else if (p == PEEKED_LONG) {\n      result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n      result = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED_NAME) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n        result = peekedString;\n        peekedString = null;\n    } else if (p == PEEKED_LONG) {\n        result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n        result = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    pathIndices[stackSize - 1] = 0;\n    return result;\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED_NAME) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n  }"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            final int avail = Math.min(uncompressedBytesRemaining,\n                                       in.available());\n            final int read = in.read(b, off, Math.min(len, avail));\n            if (read != -1) {\n                count(read);\n                uncompressedBytesRemaining -= read;\n            }\n            if (uncompressedBytesRemaining == 0) {\n                inUncompressedChunk = false;\n                skipBlock();\n            }\n            return read;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            final int readable = Math.min(len, uncompressedBytesRemaining);\n            if (readable > 0) {\n                final int read = in.read(b, off, readable);\n                if (read == -1) {\n                    throw new IOException(\"Premature end of stream reading uncompressed chunk\");\n                }\n                uncompressedBytesRemaining -= read;\n                if (uncompressedBytesRemaining == 0) {\n                    inUncompressedChunk = false;\n                }\n                return read;\n            }\n            return 0;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            final int readable = Math.min(len, uncompressedBytesRemaining);\n            final int read = in.read(b, off, readable);\n            if (read == -1) {\n                endReached = true;\n                return -1;\n            }\n            uncompressedBytesRemaining -= read;\n            return read;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            final int avail = Math.min(uncompressedBytesRemaining, len);\n            if (avail > 0) {\n                final int read = in.read(b, off, avail);\n                if (read == -1) {\n                    throw new IOException(\"Premature end of stream reading uncompressed chunk\");\n                }\n                uncompressedBytesRemaining -= read;\n                return read;\n            }\n            return 0;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            final int readable = Math.min(len, uncompressedBytesRemaining);\n            if (readable > 0) {\n                final int read = in.read(b, off, readable);\n                if (read == -1) {\n                    throw new IOException(\"Premature end of stream reading uncompressed chunk\");\n                }\n                count(read);\n                uncompressedBytesRemaining -= read;\n                size += read;\n                return read;\n            }\n            return -1;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            final int avail = Math.min(uncompressedBytesRemaining, len);\n            final int read = in.read(b, off, avail);\n            if (read != -1) {\n                uncompressedBytesRemaining -= read;\n                expectedChecksum = Crc32C.update(expectedChecksum, b, off, read);\n            }\n            return read;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            return readFromBuffer(b, off, len);\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            return readFromBuffer(b, off, len);\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            return readFromBuffer(b, off, len);\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            return readFromBuffer(b, off, len);\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node arg = null;\n      Node callOrNew = site.node;\n      if (callOrNew.isCall()) {\n        arg = getArgumentForCallOrNew(callOrNew, argIndex);\n      } else if (isFunctionObjectCall(callOrNew)) {\n        arg = getArgumentForCallOrNew(callOrNew, argIndex);\n      } else if (isFunctionObjectApply(callOrNew)) {\n        arg = getArgumentForCallOrNew(callOrNew, argIndex);\n      } else if (callOrNew.isGetProp()) {\n        Node firstChild = callOrNew.getFirstChild();\n        if (firstChild.isName() && \"call\".equals(callOrNew.getString())) {\n          arg = getArgumentForCallOrNew(callOrNew, argIndex);\n        }\n      }\n      return arg;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node node = site.node;\n      if (NodeUtil.isCallOrNew(node)) {\n        return getArgumentForCallOrNew(node, argIndex);\n      } else if (NodeUtil.isGet(node)) {\n        Node parent = node.getParent();\n        if (NodeUtil.isCall(parent)) {\n          return getArgumentForCallOrNew(parent, argIndex);\n        }\n      }\n      return null;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node arg = null;\n      Node node = site.node;\n      switch (node.getType()) {\n        case Token.CALL:\n          arg = getArgumentForCallOrNew(node, argIndex);\n          break;\n        case Token.NEW:\n          arg = getArgumentForCallOrNew(node, argIndex);\n          break;\n        case Token.GETPROP:\n          arg = getArgumentForCallOrNew(node, argIndex);\n          break;\n        default:\n          throw new IllegalStateException(\"Unexpected node type: \" +\n              Token.name(node.getType()));\n      }\n      return arg;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node arg = null;\n      if (site.node.isCall()) {\n        arg = getArgumentForCallOrNew(site.node, argIndex);\n      } else if (site.node.isGetProp()) {\n        if (isToStringMethodCall(site.node)) {\n          arg = getArgumentForCallOrNew(site.node, argIndex);\n        }\n      }\n      return arg;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node node = site.node;\n      Node parent = node.getParent();\n      if (NodeUtil.isCallOrNew(parent)) {\n        return NodeUtil.getArgumentForCallOrNew(parent, argIndex);\n      } else if (NodeUtil.isGet(node)) {\n        Node grandParent = parent.getParent();\n        if (NodeUtil.isCall(grandParent)) {\n          return NodeUtil.getArgumentForCallOrNew(grandParent, argIndex);\n        }\n      }\n      return null;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node node = site.node;\n      if (NodeUtil.isCallOrNew(node)) {\n        return getArgumentForCallOrNew(node, argIndex);\n      } else if (NodeUtil.isGet(node)) {\n        return getArgumentForCallOrNew(node.getFirstChild(), argIndex);\n      } else {\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + node +\n            \"\\n parent:\" + node.getParent());\n      }\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node node = site.node;\n      if (NodeUtil.isCallOrNew(node)) {\n        return NodeUtil.getArgumentForCallOrNew(node, argIndex);\n      } else if (NodeUtil.isGet(node)) {\n        Node grandParent = node.getParent();\n        if (NodeUtil.isCall(grandParent)) {\n          return NodeUtil.getArgumentForCallOrNew(grandParent, argIndex);\n        }\n      }\n      return null;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node node = site.node;\n      if (node.isCall()) {\n        return getArgumentForCallOrNew(node, argIndex);\n      } else if (isObjectCallMethod(node, \"call\")) {\n        return getArgumentForCallOrNew(node, argIndex + 1);\n      } else if (node.isGetProp()) {\n        return getArgumentForCallOrNew(node.getLastChild(), argIndex);\n      } else {\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + node +\n            \"\\n parent:\" + node.getParent());\n      }\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node arg = null;\n      Node node = site.node;\n      if (NodeUtil.isCallOrNew(node)) {\n        arg = NodeUtil.getArgumentForCallOrNew(node, argIndex);\n      } else if (NodeUtil.isGet(node)) {\n        Node call = node.getFirstChild();\n        if (NodeUtil.isCall(call)) {\n          arg = NodeUtil.getArgumentForCallOrNew(call, argIndex);\n        }\n      }\n      return arg;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node node = site.node;\n      if (node.isCall()) {\n        return getArgumentForCallOrNew(node, argIndex);\n      } else if (isObjectCallMethod(node, \"call\")) {\n        return getArgumentForCallOrNew(node.getFirstChild(), argIndex);\n      } else if (isObjectCallMethod(node, \"apply\")) {\n        return getArgumentForCallOrNew(node.getFirstChild(), argIndex + 1);\n      } else if (node.isGetProp()) {\n        return getArgumentForCallOrNew(node.getFirstChild(), argIndex);\n      } else {\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + node +\n            \"\\n parent:\" + node.getParent());\n      }\n    }"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type.isNoType()) {\n    return null;\n  }\n\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n\n    return \"\";\n  }\n\n  if (type.isUnionType()) {\n    for (JSType alt : type.toMaybeUnionType().getAlternates()) {\n      String reason = getTypeDeprecationInfo(alt);\n      if (reason != null) {\n        return reason;\n      }\n    }\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    // TODO: Implement this method\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isFunctionType()) \n    {\n        FunctionType functionType = type.toMaybeFunctionType();\n        JSDocInfo info = functionType.getJSDocInfo();\n        if (info != null && info.isDeprecated()) \n        {\n            if (info.getDeprecationReason() != null) \n            {\n                return info.getDeprecationReason();\n            }\n\n            return \"\";\n        }\n    }\n    else if (type.isObjectType()) \n    {\n        ObjectType objectType = type.toMaybeObjectType();\n        JSDocInfo info = objectType.getJSDocInfo();\n        if (info != null && info.isDeprecated()) \n        {\n            if (info.getDeprecationReason() != null) \n            {\n                return info.getDeprecationReason();\n            }\n\n            return \"\";\n        }\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type.isObject()) {\n    ObjectType objectType = type.toObjectType();\n    JSDocInfo docInfo = objectType.getOwnPropertyJSDocInfo(\"constructor\");\n    if (docInfo != null && docInfo.isDeprecated()) {\n      if (docInfo.getDeprecationReason() != null) {\n        return docInfo.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) {\n    return null;\n  }\n\n  if (type.isDeprecated()) {\n    if (type.getDeprecationReason() != null) {\n      return type.getDeprecationReason();\n    }\n\n    return \"\";\n  }\n\n  return getTypeDeprecationInfo(type.getImplicitPrototype());\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return null;\n  }\n  if (type.isObject()) {\n    JSDocInfo info = type.toObjectType().getOwnPropertyJSDocInfo(\"constructor\");\n    if (info != null && info.isDeprecated()) {\n      return info.getDeprecationReason();\n    }\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isFunctionType()) {\n      return getTypeDeprecationInfo(type.toMaybeFunctionType());\n    } else if (type.isObjectType()) {\n      return getTypeDeprecationInfo(type.toMaybeObjectType());\n    } else {\n      return null;\n    }\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type.isFunctionType()) {\n      JSDocInfo info = type.toMaybeFunctionType().getJSDocInfo();\n      if (info != null && info.isDeprecated()) {\n        if (info.getDeprecationReason() != null) {\n          return info.getDeprecationReason();\n        }\n\n        return \"\";\n      }\n    } else if (type.isObjectType()) {\n      ObjectType objectType = type.toMaybeObjectType();\n      if (objectType.isConstructor()) {\n        JSDocInfo info = objectType.getConstructor().getJSDocInfo();\n        if (info != null && info.isDeprecated()) {\n          if (info.getDeprecationReason() != null) {\n            return info.getDeprecationReason();\n          }\n\n          return \"\";\n        }\n      }\n    }\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n        return null;\n    }\n    if (type.isDeprecated()) {\n        if (type.getDeprecationReason() != null) {\n            return type.getDeprecationReason();\n        }\n        return \"\";\n    }\n    if (type.isNoResolvedType()) {\n        return null;\n    }\n    if (type.isUnionType()) {\n        for (JSType altType : type.toMaybeUnionType().getAlternates()) {\n            String deprecationReason = getTypeDeprecationInfo(altType);\n            if (deprecationReason != null) {\n                return deprecationReason;\n            }\n        }\n    }\n    return null;\n}"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        // This is a very slow call, so cache the results.\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) \n    {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) \n        {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) \n    {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) \n        {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) \n    {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) \n        {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        // This is a very slow call, so cache the results.\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) \n    {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) \n        {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) \n    {\n        // This is a very slow call, so cache the results.\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) \n        {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        // This is a very slow call, so cache the results.\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) {\n            value = previous;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        // This is a very slow call, so cache the results.\n        value = tz.getDisplayName(daylight, style, locale);\n        final String previous = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (previous != null) {\n            value = previous;\n        }\n    }\n    return value;\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    int index = -1;\n    if (key != null) {\n        index = this.underlying.getColumnIndex(key);\n        if (index >= 0) {\n            index = (index + this.firstCategoryIndex) % this.maximumCategoryCount;\n        }\n    }\n    return index;\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = -1;\n    if (key != null) \n    {\n        index = this.underlying.getColumnIndex(key);\n        if (index >= 0) \n        {\n            index = index - this.firstCategoryIndex;\n            if (index < 0) \n            {\n                index = -1;\n            }\n            else if (index >= this.maximumCategoryCount) \n            {\n                index = -1;\n            }\n        }\n    }\n    return index;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = -1;\n    if (this.underlying.getColumnKeys().contains(key))\n    {\n        index = this.underlying.getColumnIndex(key);\n    }\n    return index;\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    int columnCount = getColumnCount();\n    for (int i = 0; i < columnCount; i++) \n    {\n        Comparable currentKey = getColumnKey(i);\n        if (currentKey.equals(key)) \n        {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = -1;\n    if (key != null) {\n        index = this.underlying.getColumnIndex(key);\n        if (index >= this.firstCategoryIndex && index < this.lastCategoryIndex()) {\n            index = index - this.firstCategoryIndex;\n        }\n    }\n    return index;\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point < lower - tolerance || point > upper + tolerance) {\n            return Location.OUTSIDE;\n        }\n        if (point <= lower + tolerance && point >= lower - tolerance) {\n            return Location.BOUNDARY;\n        }\n        if (point <= upper + tolerance && point >= upper - tolerance) {\n            return Location.BOUNDARY;\n        }\n        return Location.INSIDE;\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point < lower - tolerance || point > upper + tolerance) {\n            return Location.OUTSIDE;\n        } else if (point < lower + tolerance || point > upper - tolerance) {\n            return Location.BOUNDARY;\n        } else {\n            return Location.INSIDE;\n        }\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lower + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance || point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point <= lower + tolerance && point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lower + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point < lower - tolerance || point > upper + tolerance) {\n            return Location.OUTSIDE;\n        } else if (point <= lower + tolerance && point >= upper - tolerance) {\n            return Location.BOUNDARY;\n        } else {\n            return Location.INSIDE;\n        }\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point - lower < tolerance) {\n        return Location.BOUNDARY;\n    } else if (upper - point < tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point - lower <= tolerance) {\n        return Location.BOUNDARY;\n    } else if (upper - point <= tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance || point > upper + tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point < lower + tolerance && point > upper - tolerance) {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n        if (point < lower - tolerance) {\n            return Location.OUTSIDE;\n        }\n        if (point > upper + tolerance) {\n            return Location.OUTSIDE;\n        }\n        if (point < lower + tolerance) {\n            return Location.BOUNDARY;\n        }\n        if (point > upper - tolerance) {\n            return Location.BOUNDARY;\n        }\n        return Location.INSIDE;\n    }"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer minCoefficientCol = null;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) {\n        double coefficient = tableau.getEntry(0, i);\n        if (coefficient < minCoefficient) {\n            minCoefficient = coefficient;\n            minCoefficientCol = i;\n        }\n    }\n    return minCoefficientCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoeff = Double.MAX_VALUE;\n    Integer pivotCol = null;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) \n    {\n        double coeff = tableau.getEntry(0, i);\n        if (coeff < minCoeff) \n        {\n            minCoeff = coeff;\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer minCoefficientColumn = null;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) \n    {\n        double coefficient = tableau.getEntry(0, i);\n        if (coefficient < minCoefficient) \n        {\n            minCoefficient = coefficient;\n            minCoefficientColumn = i;\n        }\n    }\n    return minCoefficientColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) {\n            final double ratio = entry / getInvertedCoefficientSum(tableau.getRow(0));\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) {\n                minRatioPositions.add(i);\n            } else if (cmp < 0) {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) {\n        return null;\n    } else if (minRatioPositions.size() > 1) {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // select the first one\n        return minRatioPositions.get(0);\n    } else {\n        return minRatioPositions.get(0);\n    }\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // find the column with the most negative coefficient in the objective function row\n    Integer pivotCol = null;\n    double minCoeff = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) {\n        final double coeff = tableau.getEntry(0, i);\n        if (coeff < minCoeff) {\n            minCoeff = coeff;\n            pivotCol = i;\n        }\n    }\n\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // find the column with the most negative coefficient in the objective function row\n    double minCoefficient = Double.MAX_VALUE;\n    Integer pivotCol = null;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (entry < minCoefficient) {\n            minCoefficient = entry;\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer pivotCol = null;\n    for (int i = 0; i < tableau.getWidth(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) {\n            if (entry < minCoefficient) {\n                minCoefficient = entry;\n                pivotCol = i;\n            }\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) {\n            final double ratio = entry / getInvertedCoefficientSum(tableau.getEntry(0, i));\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) {\n                minRatioPositions.add(i);\n            } else if (cmp < 0) {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) {\n        return null;\n    } else if (minRatioPositions.size() > 1) {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // choose the first one\n        return minRatioPositions.get(0);\n    } else {\n        return minRatioPositions.get(0);\n    }\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n        double minCoeff = Double.MAX_VALUE;\n        Integer minCoeffCol = null;\n        for (int i = 0; i < tableau.getWidth() - 1; i++) {\n            final double coeff = tableau.getEntry(0, i);\n            if (coeff < minCoeff) {\n                minCoeff = coeff;\n                minCoeffCol = i;\n            }\n        }\n        return minCoeffCol;\n    }",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer pivotColumn = null;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) \n    {\n        double coefficient = tableau.getEntry(0, i);\n        if (coefficient < minCoefficient) \n        {\n            minCoefficient = coefficient;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}"
    ]
  ]
}