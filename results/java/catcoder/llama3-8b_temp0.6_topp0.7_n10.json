{
  "benchmark": "javaeval_xc",
  "lastest_eval": {
    "compile@1": 0.6512562814070353,
    "pass@1": 0.34522613065326635,
    "compile@3": 0.7588358458961475,
    "pass@3": 0.4273869346733667,
    "compile@5": 0.7946279014118208,
    "pass@5": 0.4567280848687883
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }"
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    int column = getColumnIndex(columnKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            double percentComplete = duration.getPercentComplete();\n            return new Double(percentComplete);\n        }\n    }\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    int column = getColumnIndex(columnKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(task.getProgress() * 100);\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            double percentComplete = duration.getPercentComplete();\n            result = new Double(percentComplete);\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    int column = getColumnIndex(columnKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            double percentComplete = (double) duration.getPercentComplete() / 100;\n            return new Double(percentComplete);\n        }\n    }\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    int column = getColumnIndex(columnKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Long(duration.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    int column = getColumnIndex(columnKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(task.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(task.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    int column = getColumnIndex(columnKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(task.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    int column = getColumnIndex(columnKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            return new Double(task.getPercentComplete());\n        }\n    }\n    return null;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    int column = getColumnIndex(columnKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Long(duration.getEnd().getTime());\n        }\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new FluentIterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new FluentIterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        int n = m.getRowDimension();\n        double[] d = new double[n];\n        for (int i = 0; i < n; i++) {\n            d[i] = m.getEntry(i, 0);\n        }\n        return new DiagonalMatrix(d);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        int n = m.getRowDimension();\n        double[] d = new double[n];\n        for (int i = 0; i < n; i++) {\n            d[i] = m.getEntry(i, i);\n        }\n        return new DiagonalMatrix(d);\n    } else {\n        throw new MatrixDimensionMismatchException();\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    int n = m.getColumnDimension();\n    double[][] d = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        d[i][i] = m.getEntry(i, i);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return new DiagonalMatrix(m.getColumnDimension(), m.getColumn(0));\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        return new DiagonalMatrix(m.getRowDimension(), m.getData());\n    } else {\n        throw new MatrixDimensionMismatchException();\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    int n = m.getColumnDimension();\n    double[][] d = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        d[i][i] = m.getEntry(i, i);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return new DiagonalMatrix(m.getColumnDimension(), m.getColumn(0));\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        return new DiagonalMatrix(m.getRowDimension(), m.getData());\n    } else {\n        throw new MatrixDimensionMismatchException();\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    int n = m.getColumnDimension();\n    double[][] d = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        d[i][i] = m.getEntry(i, i);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    int n = m.getColumnDimension();\n    double[][] d = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        d[i][i] = m.getEntry(i, 0);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        int n = m.getRowDimension();\n        double[] d = new double[n];\n        for (int i = 0; i < n; i++) {\n            d[i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        int n = m.getRowDimension();\n        double[][] d = new double[n][1];\n        for (int i = 0; i < n; i++) {\n            d[i][0] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        throw new MatrixDimensionMismatchException();\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        int n = m.getRowDimension();\n        double[] data = new double[n];\n        for (int i = 0; i < n; i++) {\n            data[i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(data, false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        int n = m.getRowDimension();\n        double[][] data = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            data[i][i] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(data, false);\n    } else {\n        throw new MatrixDimensionMismatchException();\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        int n = m.getRowDimension();\n        double[] data = new double[n];\n        for (int i = 0; i < n; i++) {\n            data[i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(data, false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        int n = m.getRowDimension();\n        double[][] data = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            data[i][i] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(data, false);\n    } else {\n        throw new MatrixDimensionMismatchException(\"Input matrix must be a column matrix or a square matrix.\");\n    }\n}"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) {\n            return dtz;\n        }\n        int offset = parseOffset(id);\n        if (offset == 0) {\n            return DateTimeZone.UTC;\n        }\n        return fixedOffsetZone(id, offset);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) {\n            return dtz;\n        }\n        // Convert from old alias before consulting provider since they may differ.\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = forOffsetMillis(parseOffset(id));\n        }\n        return dtz;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) {\n            return dtz;\n        }\n        int offset = parseOffset(id);\n        return fixedOffsetZone(id, offset);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.length() == 6 && id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return fixedOffsetZone(id, parseOffset(id));\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.length() == 5 && id.charAt(0) == '+' || id.charAt(0) == '-') {\n            int offset = parseOffset(id);\n            return fixedOffsetZone(id, offset);\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) {\n            return dtz;\n        }\n        // Convert from old alias before consulting provider since they may differ.\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            throw new IllegalArgumentException(\"The datetime zone id is not recognised: \" + id);\n        }\n        return dtz;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) {\n            return dtz;\n        }\n        // Convert from old alias before consulting provider since they may differ.\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        // Try to parse as a fixed offset\n        int offset = parseOffset(id);\n        if (offset != 0) {\n            return fixedOffsetZone(id, offset);\n        }\n        // Try to parse as a JDK TimeZone\n        try {\n            return forTimeZone(TimeZone.getTimeZone(id));\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Invalid time zone ID: \" + id);\n        }\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz == null) {\n            dtz = fixedOffsetZone(id, parseOffset(id));\n        }\n        return dtz;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.length() == 6) {\n            int offset = parseOffset(id);\n            return fixedOffsetZone(id, offset);\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz == null) {\n            dtz = cProvider.getZone(getConvertedId(id));\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) {\n            return dtz;\n        }\n        dtz = fixedOffsetZone(id, parseOffset(id));\n        return dtz;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) {\n            return dtz;\n        }\n        int offset = parseOffset(id);\n        if (offset != 0) {\n            return fixedOffsetZone(id, offset);\n        }\n        return null;\n    }"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(getZero());\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / x;\n            rl = r - rh * x;\n            result.mant[i] = rh;\n        }\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(getZero());\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / x;\n            rl = r - rh * x;\n            result.mant[i] = rh;\n        }\n        if (rl > 0) {\n            result.mant[0] = rl;\n        }\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(getZero());\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / x;\n            rl = r - rh * x;\n            result.mant[i] = rh;\n        }\n        if (rl > 0) {\n            result.mant[0] += rl;\n        }\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(getZero());\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / x;\n            rl = r - rh * x;\n            result.mant[i] = rh;\n        }\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(getZero());\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / x;\n            rl = r - rh * x;\n            result.mant[i] = rh;\n        }\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(getZero());\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / x;\n            rl = r - rh * x;\n            result.mant[i] = rh;\n        }\n        if (rl > 0) {\n            result.mant[0] += rl;\n        }\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(getZero());\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / x;\n            rl = r - rh * x;\n            result.mant[i] = rh;\n        }\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(getZero());\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / x;\n            rl = r - rh * x;\n            result.mant[i] = rh;\n        }\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(getZero());\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / x;\n            rl = r - rh * x;\n            result.mant[i] = rh;\n        }\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(getZero());\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / x;\n            rl = r - rh * x;\n            result.mant[i] = rh;\n        }\n        if (rl > 0) {\n            result.mant[0] = rl;\n        }\n        return result;\n    }"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedHashMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedHashMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedHashMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedHashMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function();\n    externFunction.setJSType(exportedFunction.getJSType());\n    externFunction.setName(exportedFunction.getName());\n    externFunction.setType(exportedFunction.getType());\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function(name, null);\n    externFunction.setJSType(exportedFunction.getJSType());\n    externFunction.setJSDocInfo(new JSDocInfo());\n\n    // Check if the function has a return type\n    if (exportedFunction.getReturnType() != null) {\n        externFunction.setReturnType(exportedFunction.getReturnType());\n    } else {\n        // If not, create a warning\n        compiler.getWarnings().addWarning(\n            \"Function \" + name + \" has no return type\");\n    }\n\n    // Check if the function has parameters\n    if (exportedFunction.getParameters() != null) {\n        for (Node parameter : exportedFunction.getParameters()) {\n            Node externParameter = IR.param(parameter.getName(), null);\n            externFunction.addChildToFront(externParameter);\n        }\n    } else {\n        // If not, create a warning\n        compiler.getWarnings().addWarning(\n            \"Function \" + name + \" has no parameters\");\n    }\n\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function(exportedFunction.getType(), exportedFunction.getName());\n    externFunction.setJSType(exportedFunction.getJSType());\n    externFunction.setJSDocInfo(new JSDocInfo());\n\n    // Check if the function has parameters\n    if (exportedFunction.hasChildren()) {\n        Node paramList = IR.paramlist();\n        for (Node child = exportedFunction.getFirstChild();\n             child != null;\n             child = child.getNext()) {\n            paramList.addChildToBack(IR.param(child.getString()));\n        }\n        externFunction.addChildToBack(paramList);\n    }\n\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function();\n    externFunction.setJSType(exportedFunction.getJSType());\n    externFunction.setJSDocInfo(new JSDocInfo());\n\n    // Add parameters\n    Node parameters = IR.parameters();\n    for (Node child = exportedFunction.getFirstChild();\n         child != null;\n         child = child.getNext()) {\n        if (child.isParamList()) {\n            parameters.addChildToBack(child);\n        }\n    }\n    externFunction.addChildToBack(parameters);\n\n    // Add return type\n    Node returnType = IR.returnType();\n    if (exportedFunction.hasChildren()) {\n        returnType.addChildToBack(exportedFunction.getLastChild());\n    }\n    externFunction.addChildToBack(returnType);\n\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function();\n    externFunction.setJSType(exportedFunction.getJSType());\n    externFunction.setJSDocInfo(new JSDocInfo());\n\n    // Add parameters\n    Node params = IR.params();\n    for (Node child = exportedFunction.getFirstChild();\n         child != null;\n         child = child.getNext()) {\n        if (child.isFunctionParam()) {\n            Node param = IR.param(child.getString());\n            params.addChildToBack(param);\n        }\n    }\n    externFunction.addChildToBack(params);\n\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function(exportedFunction.getType(), exportedFunction.getName());\n    externFunction.setJSType(exportedFunction.getJSType());\n    externFunction.setJSDocInfo(exportedFunction.getJSDocInfo());\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function();\n    externFunction.setJSType(exportedFunction.getJSType());\n    externFunction.setJSDocInfo(new JSDocInfo());\n    externFunction.setType(exportedFunction.getType());\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function(exportedFunction.getType(), exportedFunction.getName());\n    externFunction.setJSType(exportedFunction.getJSType());\n    externFunction.setJSDocInfo(new JSDocInfo());\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function(exportedFunction.getType(), exportedFunction.getName());\n    externFunction.setJSType(exportedFunction.getJSType());\n    externFunction.setJSDocInfo(new JSDocInfo());\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function(name, null);\n    externFunction.setJSType(exportedFunction.getJSType());\n    externFunction.setJSDocInfo(new JSDocInfo());\n    return externFunction;\n}"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n    double[] errors = new double[params.length];\n    for (int i = 0; i < errors.length; ++i) {\n        errors[i] = Math.sqrt(covar[i][i]);\n    }\n    return errors;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n    double[] errors = new double[params.length];\n    for (int i = 0; i < errors.length; ++i) {\n        errors[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return errors;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n    double[] errors = new double[params.length];\n    for (int i = 0; i < errors.length; ++i) {\n        errors[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return errors;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n    double[] errors = new double[params.length];\n    for (int i = 0; i < errors.length; ++i) {\n        errors[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return errors;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n    double[] errors = new double[params.length];\n    for (int i = 0; i < errors.length; ++i) {\n        errors[i] = Math.sqrt(covar[i][i]);\n    }\n    return errors;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n    double[] errors = new double[params.length];\n    for (int i = 0; i < errors.length; ++i) {\n        errors[i] = Math.sqrt(covar[i][i]);\n    }\n    return errors;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n    double[] errors = new double[params.length];\n    for (int i = 0; i < errors.length; ++i) {\n        errors[i] = Math.sqrt(covar[i][i]);\n    }\n    return errors;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n    double[] errors = new double[params.length];\n    for (int i = 0; i < errors.length; ++i) {\n        errors[i] = Math.sqrt(covar[i][i]);\n    }\n    return errors;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n    double[] errors = new double[params.length];\n    for (int i = 0; i < errors.length; ++i) {\n        errors[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return errors;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n    double[] errors = new double[params.length];\n    for (int i = 0; i < errors.length; ++i) {\n        errors[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return errors;\n}"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        for (String priorVar : priorVariables) {\n            if (priorVar.equals(varName)) {\n                throw new StrSubstitutorException(\"Cyclic variable reference: \" + varName);\n            }\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new StrSubstitutorException(\"Cyclic variable reference: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new StrSubstitutorException(\"Cyclic variable substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        for (String priorVar : priorVariables) {\n            if (priorVar.equals(varName)) {\n                throw new StrSubstitutorException(\"Cyclic variable reference: \" + varName);\n            }\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new SubstitutionException(\"Cyclic substitution detected for variable '\" + varName + \"'\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new StrSubstitutorException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        for (String priorVar : priorVariables) {\n            if (priorVar.equals(varName)) {\n                throw new StrSubstitutorException(\"Cyclic variable reference: \" + varName);\n            }\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new StrSubstitutorException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new StrSubstitutorException(\"Cyclic variable reference detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new SubstitutionException(\"Cyclic variable reference: \" + varName);\n    }\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    if (sorted) {\n      return topologicalStableSort(roots, deps);\n    } else {\n      return roots;\n    }\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    if (sorted) {\n      return topologicalStableSort(roots, deps);\n    } else {\n      return roots;\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    if (sorted) {\n        return topologicalStableSort(roots, provideMap);\n    } else {\n        return roots;\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> dependencies = new ArrayList<INPUT>();\n    Set<INPUT> visited = new HashSet<INPUT>();\n    for (INPUT root : roots) {\n      dependencies.addAll(getDependencies(root, visited, sorted));\n    }\n    return dependencies;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    if (sorted) {\n        return topologicalStableSort(roots, deps);\n    } else {\n        return roots;\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    if (sorted) {\n      return topologicalStableSort(roots, provideMap);\n    } else {\n      return roots;\n    }\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<INPUT>();\n    Set<INPUT> visited = new HashSet<INPUT>();\n    for (INPUT root : roots) {\n      if (!visited.contains(root)) {\n        List<INPUT> dependencies = getDependencies(root, visited);\n        if (sorted) {\n          result.addAll(topologicalStableSort(dependencies, provideMap));\n        } else {\n          result.addAll(dependencies);\n        }\n      }\n    }\n    return result;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<INPUT>();\n    Set<INPUT> visited = new HashSet<INPUT>();\n    for (INPUT root : roots) {\n      if (!visited.contains(root)) {\n        getDependenciesOf(root, result, visited, sorted);\n      }\n    }\n    return result;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> dependencies = new ArrayList<INPUT>();\n    Set<INPUT> visited = new HashSet<INPUT>();\n    for (INPUT root : roots) {\n        if (!visited.contains(root)) {\n            dependencies.addAll(getDependencies(root, visited, sorted));\n        }\n    }\n    return dependencies;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    if (sorted) {\n        return topologicalStableSort(roots, deps);\n    } else {\n        return roots;\n    }\n}"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n    DfpField field = a.getField();\n    return split(field, a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    DfpField field = a.getField();\n    return split(field, a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    DfpField field = a.getField();\n    String str = a.toString();\n    result = split(field, str);\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    DfpField field = a.getField();\n    Dfp[] result = new Dfp[2];\n    result[0] = new Dfp(field, a.getReal());\n    result[1] = new Dfp(field, 0);\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    DfpField field = a.getField();\n    return split(field, a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    DfpField field = a.getField();\n    String s = a.toString();\n    result = split(field, s);\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    DfpField field = a.getField();\n    Dfp[] result = new Dfp[2];\n    String str = a.toString();\n    result[0] = split(field, str)[0];\n    result[1] = split(field, str)[1];\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}"
    ],
    [
      "public String cssSelector()  {\n    if (id() != null) {\n        return \"#\" + id();\n    } else {\n        StringBuilder selector = new StringBuilder();\n        if (parentNode != null) {\n            selector.append(parentNode.cssSelector());\n            if (!parentNode.tagName().equals(\"#root\")) {\n                selector.append(\" > \");\n            }\n        }\n        selector.append(tagName());\n        if (!classNames().isEmpty()) {\n            selector.append(\":\");\n            for (String className : classNames()) {\n                selector.append(\".\" + className);\n            }\n        }\n        if (index() != -1) {\n            selector.append(\":nth-child(\" + index() + \")\");\n        }\n        return selector.toString();\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null) {\n        return \"#\" + id();\n    } else {\n        StringBuilder css = new StringBuilder();\n        if (parentNode != null) {\n            css.append(parentNode.cssSelector());\n            css.append(\" > \");\n        }\n        css.append(tagName());\n        if (!classNames().isEmpty()) {\n            css.append(\":\");\n            for (String className : classNames()) {\n                css.append(\".\" + className);\n            }\n        }\n        if (hasChildNodes()) {\n            css.append(\":nth-child(\" + childNodeSize() + \")\");\n        }\n        return css.toString();\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null) {\n        return \"#\" + id();\n    } else {\n        String parentSelector = parent() != null ? parent().cssSelector() : \"\";\n        String childSelector = \"\";\n        if (tagName() != null) {\n            childSelector += tagName();\n            if (classNames().size() > 0) {\n                childSelector += \".\" + classNames().toString().replace(\",\", \".\");\n            }\n            if (hasAttr(\"class\")) {\n                childSelector += \"[\" + attr(\"class\") + \"]\";\n            }\n            if (hasAttr(\"style\")) {\n                childSelector += \"[\" + attr(\"style\") + \"]\";\n            }\n        }\n        if (childSelector.isEmpty()) {\n            return parentSelector;\n        } else {\n            return parentSelector + \" > \" + childSelector;\n        }\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null) {\n        return \"#\" + id();\n    } else {\n        String parentSelector = parent().cssSelector();\n        if (parentSelector == null) {\n            return \"\";\n        }\n        return parentSelector + \" > \" + tagName() + (classNames().size() > 0 ? \".\" + classNames().toString() : \"\") + (hasAttr(\"nth-child\") ? \":nth-child(\" + attr(\"nth-child\") + \")\" : \"\");\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null) {\n        return \"#\" + id();\n    } else {\n        String parentSelector = parent().cssSelector();\n        if (parentSelector == null) {\n            return \"\";\n        } else {\n            return parentSelector + \" > \" + tagName() + (classNames().size() > 0 ? \".\" + classNames().toString() : \"\") + (index() > 0 ? \":nth-child(\" + index() + \")\" : \"\");\n        }\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null) {\n        return \"#\" + id();\n    } else {\n        String parentSelector = parent().cssSelector();\n        if (parentSelector == null) {\n            return \"\";\n        }\n        return parentSelector + \" > \" + tagName() + (classNames().size() > 0 ? \".\" + classNames().get(0) : \"\") + (index() > 0 ? \":nth-child(\" + index() + \")\" : \"\");\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null) {\n        return \"#\" + id();\n    } else {\n        StringBuilder selector = new StringBuilder();\n        if (parentNode != null) {\n            selector.append(parentNode.cssSelector());\n            if (parentNode.childNodeSize() > 0) {\n                selector.append(\" > \");\n            }\n        }\n        if (tagName() != null) {\n            selector.append(tagName());\n        }\n        if (classNames().size() > 0) {\n            selector.append(\".\" + classNames().get(0));\n        }\n        if (childNodeSize() > 0) {\n            selector.append(\":nth-child(\" + childNodeSize() + \")\");\n        }\n        return selector.toString();\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null) {\n        return \"#\" + id();\n    } else {\n        String parentSelector = parent() == null ? \"\" : parent().cssSelector();\n        if (parentSelector.isEmpty()) {\n            return \"\";\n        }\n        return parentSelector + \" > \" + tagName() + (classNames().size() > 0 ? \".\" + classNames().toString() : \"\") + (hasAttr(\"nth-child\") ? \":nth-child(\" + attr(\"nth-child\") + \")\" : \"\");\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null) {\n        return \"#\" + id();\n    } else {\n        String parentSelector = parent().cssSelector();\n        if (parentSelector == null) {\n            return \"\";\n        }\n        return parentSelector + \" > \" + tagName() + (classNames().size() > 0 ? \".\" + classNames().toString() : \"\") + (index() > 0 ? \":nth-child(\" + index() + \")\" : \"\");\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null) {\n        return \"#\" + id();\n    } else {\n        StringBuilder sb = new StringBuilder();\n        if (parentNode != null) {\n            sb.append(parentNode.cssSelector());\n            sb.append(\" > \");\n        }\n        sb.append(tagName());\n        if (!classNames().isEmpty()) {\n            sb.append(\":\");\n            for (String className : classNames()) {\n                sb.append(\".\" + className);\n            }\n        }\n        if (hasChildNodes()) {\n            sb.append(\":nth-child(\" + childNodeSize() + \")\");\n        }\n        return sb.toString();\n    }\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 1;\n    }\n    if (n.getType() == Token.EQ || n.getType() == Token.NE || n.getType() == Token.SHEQ || n.getType() == Token.SHNE) {\n        return 2;\n    }\n    return 0;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 1;\n    }\n    if (n.getType() == Token.PAREN) {\n        return 2;\n    }\n    if (n.getType() == Token.EQ || n.getType() == Token.NE) {\n        return 1;\n    }\n    if (n.getType() == Token.SHEQ || n.getType() == Token.SHNE) {\n        return 1;\n    }\n    return 0;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 1;\n    }\n    if (n.getType() == Token.EQ || n.getType() == Token.NE || n.getType() == Token.SHEQ || n.getType() == Token.SHNE) {\n        return 2;\n    }\n    return 0;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 1;\n    }\n    if (n.getType() == Token.PAREN) {\n        return 1;\n    }\n    return 0;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 1;\n    } else if (n.getType() == Token.PAREN_OPEN || n.getType() == Token.PAREN_CLOSE) {\n        return 1;\n    } else {\n        return 0;\n    }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 1;\n    }\n    if (n.getType() == Token.PAREN_OPEN || n.getType() == Token.PAREN_CLOSE) {\n        return 1;\n    }\n    return 0;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 1;\n    }\n    if (n.getType() == Token.EQ || n.getType() == Token.NE || n.getType() == Token.SHEQ || n.getType() == Token.SHNE) {\n        return 2;\n    }\n    return 0;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 1;\n    } else if (n.getType() == Token.PAREN) {\n        return 2;\n    } else {\n        return 0;\n    }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 1;\n    } else if (n.getType() == Token.EQ || n.getType() == Token.NE) {\n        return 2;\n    } else if (n.getType() == Token.SHEQ || n.getType() == Token.SHNE) {\n        return 3;\n    } else {\n        return 0;\n    }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 1;\n    }\n    if (n.getType() == Token.EQ || n.getType() == Token.NE) {\n        return 2;\n    }\n    if (n.getType() == Token.SHEQ || n.getType() == Token.SHNE) {\n        return 2;\n    }\n    return 0;\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    char[] buffer = this.buffer;\n    int start = 0;\n    int end = size - 1;\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    char[] buffer = this.buffer;\n    int start = 0;\n    int end = size - 1;\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n        char[] buffer = this.buffer;\n        int start = 0;\n        int end = size - 1;\n        while (start < end) {\n            char temp = buffer[start];\n            buffer[start] = buffer[end];\n            buffer[end] = temp;\n            start++;\n            end--;\n        }\n        return this;\n    }",
      "public StrBuilder reverse()  {\n        char[] buffer = this.buffer;\n        int start = 0;\n        int end = size - 1;\n        while (start < end) {\n            char temp = buffer[start];\n            buffer[start] = buffer[end];\n            buffer[end] = temp;\n            start++;\n            end--;\n        }\n        return this;\n    }",
      "public StrBuilder reverse()  {\n        int start = 0;\n        int end = size - 1;\n        while (start < end) {\n            char temp = buffer[start];\n            buffer[start] = buffer[end];\n            buffer[end] = temp;\n            start++;\n            end--;\n        }\n        return this;\n    }",
      "public StrBuilder reverse()  {\n    char[] buffer = this.buffer;\n    int start = 0;\n    int end = size - 1;\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n        char[] buffer = this.buffer;\n        int start = 0;\n        int end = size - 1;\n        while (start < end) {\n            char temp = buffer[start];\n            buffer[start] = buffer[end];\n            buffer[end] = temp;\n            start++;\n            end--;\n        }\n        return this;\n    }",
      "public StrBuilder reverse()  {\n    char[] buffer = this.buffer;\n    int start = 0;\n    int end = size - 1;\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    char[] buffer = this.buffer;\n    int start = 0;\n    int end = size - 1;\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    char[] buffer = this.buffer;\n    int start = 0;\n    int end = size - 1;\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    if (offset > text.length()) {\n        throw new IndexOutOfBoundsException(\"Offset \" + offset + \" is greater than the text length \" + text.length());\n    }\n    String before = text.substring(0, offset);\n    String after = text.substring(offset);\n    TextNode beforeNode = new TextNode(before);\n    TextNode afterNode = new TextNode(after);\n    this.parentNode().appendChild(beforeNode);\n    this.parentNode().appendChild(afterNode);\n    return afterNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String before = text.substring(0, offset);\n    String after = text.substring(offset);\n    TextNode beforeNode = new TextNode(before);\n    TextNode afterNode = new TextNode(after);\n    this.siblingNodes().add(afterNode);\n    return afterNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = this.text();\n    String before = text.substring(0, offset);\n    String after = text.substring(offset);\n    TextNode newNode = new TextNode(after);\n    this.text(before);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String before = text.substring(0, offset);\n    String after = text.substring(offset);\n    TextNode node = new TextNode(after);\n    nextSibling(node);\n    coreValue(before);\n    return node;\n}",
      "public TextNode splitText(int offset)  {\n    String text = this.text();\n    String before = text.substring(0, offset);\n    String after = text.substring(offset);\n    TextNode beforeNode = new TextNode(before);\n    TextNode afterNode = new TextNode(after);\n    this.replaceWith(beforeNode);\n    this.nextSibling().insertBefore(afterNode);\n    return afterNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    if (offset < 0 || offset > text.length()) {\n        throw new IndexOutOfBoundsException(\"offset is out of range\");\n    }\n    String before = text.substring(0, offset);\n    String after = text.substring(offset);\n    TextNode newNode = new TextNode(after);\n    insertAfter(this, newNode);\n    coreValue(before);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    if (offset > text.length()) {\n        throw new IndexOutOfBoundsException(\"offset is out of bounds\");\n    }\n    String firstPart = text.substring(0, offset);\n    String secondPart = text.substring(offset);\n    TextNode first = new TextNode(firstPart);\n    TextNode second = new TextNode(secondPart);\n    appendChild(second);\n    return second;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String leftText = text.substring(0, offset);\n    String rightText = text.substring(offset);\n    TextNode leftNode = new TextNode(leftText);\n    TextNode rightNode = new TextNode(rightText);\n    insertAfter(leftNode);\n    return rightNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String leftText = text.substring(0, offset);\n    String rightText = text.substring(offset);\n    TextNode leftNode = new TextNode(leftText);\n    TextNode rightNode = new TextNode(rightText);\n    appendChild(rightNode);\n    return rightNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String before = text.substring(0, offset);\n    String after = text.substring(offset);\n    TextNode node = new TextNode(after);\n    appendChild(node);\n    text(before);\n    return node;\n}"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(subtract(union(a, b), intersection(a, b)), subtract(union(a, b), intersection(a, b)));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(subtract(union(a, b), intersection(a, b)), subtract(union(a, b), intersection(a, b)));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(subtract(union(a, b), intersection(a, b)), subtract(union(a, b), intersection(a, b)));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(subtract(union(a, b), intersection(a, b)), subtract(union(a, b), intersection(a, b)));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(subtract(union(a, b), intersection(a, b)), subtract(union(a, b), intersection(a, b)));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(subtract(union(a, b), intersection(a, b)), subtract(union(a, b), intersection(a, b)));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(subtract(union(a, b), intersection(a, b)), subtract(union(a, b), intersection(a, b)));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(subtract(union(a, b), intersection(a, b)), subtract(union(a, b), intersection(a, b)));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(subtract(union(a, b), intersection(a, b)), subtract(union(a, b), intersection(a, b)));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(subtract(union(a, b), intersection(a, b)), subtract(union(a, b), intersection(a, b)));\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] bytes = value.toByteArray();\n    if (bytes.length > 8) {\n        bytes = new byte[8];\n        System.arraycopy(bytes, bytes.length - 8, bytes, 0, 8);\n    }\n    System.arraycopy(bytes, 0, result, 0, 8);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    putLong(value.longValue(), result, 0);\n    putLong(value.longValue() >> 32, result, 4);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = value.toByteArray();\n    if (bytes.length > 8) {\n        bytes = new byte[8];\n        System.arraycopy(bytes, 0, bytes, 8 - bytes.length, bytes.length);\n    } else if (bytes.length < 8) {\n        bytes = new byte[8];\n        System.arraycopy(bytes, 0, bytes, 0, bytes.length);\n        for (int i = bytes.length; i < 8; i++) {\n            bytes[i] = 0;\n        }\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] bytes = value.toByteArray();\n    if (bytes.length > 8) {\n        bytes = new byte[8];\n        System.arraycopy(bytes, bytes.length - 8, bytes, 0, 8);\n    }\n    System.arraycopy(bytes, 0, result, 8 - bytes.length, bytes.length);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = value.toByteArray();\n    if (bytes.length > 8) {\n        bytes = new byte[8];\n        System.arraycopy(bytes, 0, bytes, 0, 8);\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = value.toByteArray();\n    if (bytes.length > 8) {\n        bytes = Arrays.copyOfRange(bytes, bytes.length - 8, bytes.length);\n    } else if (bytes.length < 8) {\n        bytes = new byte[8];\n        System.arraycopy(bytes, 0, bytes, bytes.length - bytes.length, bytes.length);\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    ByteUtils.toLittleEndian(result, value.longValue(), 0, 8);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] bytes = value.toByteArray();\n    if (bytes.length > 8) {\n        bytes = new byte[8];\n        System.arraycopy(bytes, 0, result, 0, 8);\n    } else {\n        System.arraycopy(bytes, 0, result, 8 - bytes.length, bytes.length);\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = value.toByteArray();\n    if (bytes.length > 8) {\n        bytes = new byte[8];\n        System.arraycopy(bytes, 0, bytes, 0, 8);\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    byte[] temp = value.toByteArray();\n    if (temp.length > 8) {\n        temp = new byte[8];\n        System.arraycopy(temp, 0, bytes, 0, 8);\n    } else {\n        System.arraycopy(temp, 0, bytes, 8 - temp.length, temp.length);\n    }\n    return bytes;\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}"
    ],
    [
      "public RealMatrix getSquareRoot()  {\n    if (isSymmetric()) {\n        return squareRoot(realEigenvalues);\n    } else {\n        throw new MathUnsupportedOperationException();\n    }\n}",
      "public RealMatrix getSquareRoot()  {\n    if (isSymmetric()) {\n        if (hasComplexEigenvalues()) {\n            throw new MathUnsupportedOperationException();\n        }\n        return new Solver(realEigenvalues, imagEigenvalues, eigenvectors);\n    } else {\n        return squareRoot(transformToTridiagonal(matrix));\n    }\n}",
      "public RealMatrix getSquareRoot()  {\n    if (isSymmetric()) {\n        return new RectangularCholeskyDecomposition(new EigenDecomposition(getMatrix()));\n    } else {\n        throw new MathUnsupportedOperationException();\n    }\n}",
      "public RealMatrix getSquareRoot()  {\n    if (isSymmetric()) {\n        if (hasComplexEigenvalues()) {\n            throw new MathUnsupportedOperationException();\n        }\n        return new SchurTransformer(transformToSchur(getMatrix())).getSquareRoot();\n    } else {\n        return squareRoot(getMatrix());\n    }\n}",
      "public RealMatrix getSquareRoot()  {\n    if (isSymmetric()) {\n        return squareRoot(realEigenvalues);\n    } else {\n        throw new MathUnsupportedOperationException();\n    }\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException();\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    return squareRoot(cachedD);\n}",
      "public RealMatrix getSquareRoot()  {\n    if (isSymmetric()) {\n        return new RectangularCholeskyDecomposition(new EigenDecomposition(getMatrix()).getD());\n    } else {\n        throw new MathUnsupportedOperationException();\n    }\n}",
      "public RealMatrix getSquareRoot()  {\n    if (isSymmetric()) {\n        if (hasComplexEigenvalues()) {\n            throw new MathUnsupportedOperationException();\n        }\n        return new TriDiagonalTransformer(transformToTridiagonal(getMatrix())).getT();\n    } else {\n        throw new MathUnsupportedOperationException();\n    }\n}",
      "public RealMatrix getSquareRoot()  {\n    if (isSymmetric()) {\n        if (hasComplexEigenvalues()) {\n            throw new MathUnsupportedOperationException();\n        }\n        return new SchurTransformer(transformToSchur(matrix)).getSquareRoot();\n    } else {\n        return squareRoot(matrix);\n    }\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException();\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    return new RectangularCholeskyDecomposition(this).getRoot();\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.END_OBJECT) {\n            return ctxt.handleUnexpectedToken(getMapClass(), p);\n        }\n        // 21-Apr-2017, tatu: Need separate methods to do proper merging\n        if (_standardStringKey) {\n            _readAndUpdateStringKeyMap(p, ctxt, result);\n            return result;\n        }\n        _readAndUpdate(p, ctxt, result);\n        return result;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_NULL) {\n            return _deserializeNull(p, ctxt);\n        }\n        if (t == JsonToken.END_OBJECT) {\n            return _deserializeEndObject(p, ctxt);\n        }\n        if (t == JsonToken.END_ARRAY) {\n            return _deserializeEndArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return _deserializeNumber(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return _deserializeFloat(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_STRING) {\n            return _deserializeString(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return Boolean.TRUE;\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return Boolean.FALSE;\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return _deserializeNull(p, ctxt);\n        }\n        return ctxt.handleUnexpectedToken(getMapClass(), p);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \tif (t == JsonToken.VALUE_NULL) {\n    \t\treturn _deserializeNull(p, ctxt);\n    \t}\n    \tif (t == JsonToken.END_OBJECT) {\n    \t\treturn _deserializeEndObject(p, ctxt);\n    \t}\n    \tif (t == JsonToken.END_ARRAY) {\n    \t\treturn _deserializeEndArray(p, ctxt);\n    \t}\n    \tif (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n    \t\treturn _deserializeEmbeddedObject(p, ctxt);\n    \t}\n    \tif (t == JsonToken.VALUE_STRING) {\n    \t\treturn _deserializeString(p, ctxt);\n    \t}\n    \tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\treturn _deserializeNumberInt(p, ctxt);\n    \t}\n    \tif (t == JsonToken.VALUE_NUMBER_FLOAT) {\n    \t\treturn _deserializeNumberFloat(p, ctxt);\n    \t}\n    \tif (t == JsonToken.VALUE_TRUE) {\n    \t\treturn _deserializeBooleanTrue(p, ctxt);\n    \t}\n    \tif (t == JsonToken.VALUE_FALSE) {\n    \t\treturn _deserializeBooleanFalse(p, ctxt);\n    \t}\n    \tif (t == JsonToken.VALUE_NULL) {\n    \t\treturn _deserializeNull(p, ctxt);\n    \t}\n    \tif (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n    \t\treturn _deserializeEmbeddedObject(p, ctxt);\n    \t}\n    \treturn _deserializeOther(p, ctxt, t);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.END_OBJECT) {\n            return ctxt.handleUnexpectedToken(getMapClass(), p);\n        }\n        // 21-Apr-2017, tatu: Need separate methods to do proper merging\n        if (_standardStringKey) {\n            _readAndUpdateStringKeyMap(p, ctxt, result);\n            return result;\n        }\n        _readAndUpdate(p, ctxt, result);\n        return result;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \treturn deserializeIfNatural(p, ctxt, getMapClass());\n     }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.END_OBJECT) {\n            return ctxt.handleEndOfInput(DeserializationContext.ErrorTarget.BEAN, p);\n        }\n        if (t == JsonToken.END_ARRAY) {\n            return ctxt.handleEndOfInput(DeserializationContext.ErrorTarget.BEAN, p);\n        }\n        return deserialize(p, ctxt);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.END_OBJECT) {\n            return ctxt.handleUnexpectedToken(getMapClass(), p);\n        }\n        if (t == JsonToken.END_ARRAY) {\n            return ctxt.handleUnexpectedToken(getMapClass(), p);\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return null;\n        }\n        if (t == JsonToken.VALUE_STRING) {\n            return p.getText();\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return p.getIntValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return p.getDoubleValue();\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return Boolean.TRUE;\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return Boolean.FALSE;\n        }\n        return ctxt.handleUnexpectedToken(getMapClass(), p);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_NULL) {\n            return _deserializeNull(p, ctxt);\n        }\n        return ctxt.handleUnexpectedToken(getMapClass(), p);\n     }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // [databind#631]: Assign current value, to be accessible by custom deserializers\n        p.setCurrentValue(result);\n        \n        // Ok: must point to START_OBJECT or FIELD_NAME\n        JsonToken token = p.getCurrentToken();\n        if (token != JsonToken.START_OBJECT && token != JsonToken.FIELD_NAME) {\n            return (Map<Object,Object>) ctxt.handleUnexpectedToken(getMapClass(), p);\n        }\n        // 21-Apr-2017, tatu: Need separate methods to do proper merging\n        if (_standardStringKey) {\n            _readAndUpdateStringKeyMap(p, ctxt, result);\n            return result;\n        }\n        _readAndUpdate(p, ctxt, result);\n        return result;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_NULL) {\n            return _deserializeNull(p, ctxt);\n        }\n        if (t == JsonToken.END_OBJECT) {\n            return _deserializeEndObject(p, ctxt);\n        }\n        if (t == JsonToken.END_ARRAY) {\n            return _deserializeEndArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_STRING) {\n            return _deserializeString(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return _deserializeNumber(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return _deserializeFloat(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return _deserializeBooleanTrue(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return _deserializeBooleanFalse(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return _deserializeNull(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return _deserializeEmbeddedObject(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_STRING) {\n            return _deserializeString(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return _deserializeEmbeddedObject(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return _deserializeBooleanTrue(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return _deserializeBooleanFalse(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return _deserializeNull(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return _deserializeEmbeddedObject(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return _deserializeBooleanTrue(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return _deserializeBooleanFalse(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return _deserializeNull(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            return _deserializeEmbeddedObject(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return _deserializeBooleanTrue(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return _deserializeBooleanFalse(p, ctxt);\n}\n}"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_head == null) {\n             _head = new LinkedNode<Object[]>(fullChunk);\n             _tail = _head;\n         } else {\n             _tail._next = new LinkedNode<Object[]>(fullChunk);\n             _tail = _tail._next;\n         }\n         _size += fullChunk.length;\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        _size += fullChunk.length;\n        Object[] result = new Object[_size];\n        System.arraycopy(_freeBuffer, 0, result, 0, _freeBuffer.length);\n        System.arraycopy(fullChunk, 0, result, _freeBuffer.length, fullChunk.length);\n        _freeBuffer = result;\n        return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (_freeBuffer == null) {\n            _freeBuffer = new Object[12];\n        }\n        if (_freeBuffer.length < _size + fullChunk.length) {\n            Object[] newBuffer = new Object[Math.max(12, _size + fullChunk.length)];\n            System.arraycopy(_freeBuffer, 0, newBuffer, 0, _size);\n            _freeBuffer = newBuffer;\n        }\n        System.arraycopy(fullChunk, 0, _freeBuffer, _size, fullChunk.length);\n        _size += fullChunk.length;\n        return _freeBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (_freeBuffer == null) {\n            _freeBuffer = new Object[12];\n        }\n        if (_freeBuffer.length < _size + fullChunk.length) {\n            Object[] newBuffer = new Object[Math.max(12, _size + fullChunk.length)];\n            System.arraycopy(_freeBuffer, 0, newBuffer, 0, _size);\n            _freeBuffer = newBuffer;\n        }\n        System.arraycopy(fullChunk, 0, _freeBuffer, _size, fullChunk.length);\n        _size += fullChunk.length;\n        return _freeBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (_freeBuffer == null) {\n            _freeBuffer = new Object[12];\n        }\n        if (_freeBuffer.length < _size + fullChunk.length) {\n            Object[] newBuffer = new Object[Math.max(12, _size + fullChunk.length)];\n            System.arraycopy(_freeBuffer, 0, newBuffer, 0, _size);\n            _freeBuffer = newBuffer;\n        }\n        System.arraycopy(fullChunk, 0, _freeBuffer, _size, fullChunk.length);\n        _size += fullChunk.length;\n        return _freeBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        _add(fullChunk);\n        return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_freeBuffer == null) {\n             _freeBuffer = new Object[fullChunk.length];\n         }\n         System.arraycopy(fullChunk, 0, _freeBuffer, _size, fullChunk.length);\n         _size += fullChunk.length;\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         _tail.setNext(fullChunk);\n         _tail = fullChunk;\n         _size += fullChunk.length;\n         return _head;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         _add(fullChunk);\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (_head == null) {\n            _head = new LinkedNode<Object[]>(fullChunk);\n            _tail = _head;\n            _size = fullChunk.length;\n        } else {\n            _tail.setNext(new LinkedNode<Object[]>(fullChunk));\n            _tail = _tail.getNext();\n            _size += fullChunk.length;\n        }\n        return _freeBuffer;\n    }"
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        appendPatternTo(builder, pattern);\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        appendPatternTo(builder, pattern);\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        appendPatternTo(builder, pattern);\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        appendPatternTo(builder, pattern);\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.STRING && stream.getString().equals(\"null\")) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.STRING && stream.getString().equals(\"undefined\")) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else if (match(JsDocToken.FUNCTION)) {\n    return parseFunctionType(token);\n  } else if (match(JsDocToken.UNION)) {\n    return parseUnionType(token);\n  } else if (match(JsDocToken.RECORD)) {\n    return parseRecordType(token);\n  } else if (match(JsDocToken.ARRAY)) {\n    return parseArrayType(token);\n  }\n  return null;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.STRING && stream.getString().equals(\"null\")) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.STRING && stream.getString().equals(\"undefined\")) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else if (match(JsDocToken.FUNCTION)) {\n    return parseFunctionType(token);\n  } else if (match(JsDocToken.UNION)) {\n    return parseUnionType(token);\n  } else if (match(JsDocToken.RECORD)) {\n    return parseRecordType(token);\n  } else if (match(JsDocToken.ARRAY)) {\n    return parseArrayType(token);\n  }\n  return null;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.STRING && stream.getString().equals(\"null\")) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.STRING && stream.getString().equals(\"undefined\")) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.FUNCTION) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.PIPE) {\n    return parseUnionType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.STRING && stream.getString().equals(\"null\")) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.STRING && stream.getString().equals(\"undefined\")) {\n      return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.STRING) {\n      return parseTypeName(token);\n    } else {\n      return parseFunctionType(token);\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.STRING && stream.getString().equals(\"null\")) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.STRING && stream.getString().equals(\"undefined\")) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else {\n    return parseFunctionType(token);\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.STRING && stream.getString().equals(\"null\")) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.STRING && stream.getString().equals(\"undefined\")) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else if (match(JsDocToken.LP)) {\n    return parseFunctionType(token);\n  } else if (match(JsDocToken.LB)) {\n    return parseArrayType(token);\n  } else if (match(JsDocToken.LC)) {\n    return parseRecordType(token);\n  } else if (match(JsDocToken.PIPE)) {\n    return parseUnionType(token);\n  }\n  return null;\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.STRING && stream.getString().equals(\"null\")) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.STRING && stream.getString().equals(\"undefined\")) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.FUNCTION) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.PIPE) {\n    return parseUnionType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.basic.type\");\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.STRING && stream.getString().equals(\"null\")) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.STRING && stream.getString().equals(\"undefined\")) {\n      return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.STRING) {\n      return parseTypeName(token);\n    } else if (match(JsDocToken.LP)) {\n      return parseFunctionType(token);\n    } else if (match(JsDocToken.LB)) {\n      return parseArrayType(token);\n    } else if (match(JsDocToken.LC)) {\n      return parseRecordType(token);\n    } else if (match(JsDocToken.PIPE)) {\n      return parseUnionType(token);\n    } else {\n      return null;\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.STRING && stream.getString().equals(\"null\")) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.STRING && stream.getString().equals(\"undefined\")) {\n      return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.STRING) {\n      return parseTypeName(token);\n    } else if (match(JsDocToken.FUNCTION)) {\n      return parseFunctionType(token);\n    } else if (match(JsDocToken.UNION)) {\n      return parseUnionType(token);\n    } else if (match(JsDocToken.RECORD)) {\n      return parseRecordType(token);\n    } else if (match(JsDocToken.ARRAY)) {\n      return parseArrayType(token);\n    } else {\n      return null;\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.STRING && stream.getString().equals(\"null\")) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.STRING && stream.getString().equals(\"undefined\")) {\n      return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.STRING) {\n      return parseTypeName(token);\n    } else if (token == JsDocToken.LP) {\n      return parseFunctionType(token);\n    } else if (token == JsDocToken.LB) {\n      return parseArrayType(token);\n    } else if (token == JsDocToken.LC) {\n      return parseRecordType(token);\n    } else {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.basetype\");\n    }\n  }"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n  writeDeferredName();\n  beforeName();\n  out.append('\"');\n  string(name);\n  out.append('\"');\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    beforeName();\n    out.append('\"');\n    string(name);\n    out.append('\"');\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n  writeDeferredName();\n  beforeName();\n  out.append('\"');\n  string(name);\n  out.append('\"');\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  writeDeferredName();\n  beforeName();\n  out.append('\"');\n  string(name);\n  out.append('\"');\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  writeDeferredName();\n  beforeName();\n  out.append('\"');\n  string(name);\n  out.append('\"');\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  writeDeferredName();\n  beforeName();\n  out.append('\"');\n  string(name);\n  out.append('\"');\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    beforeName();\n    out.append('\"');\n    string(name);\n    out.append('\"');\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n  writeDeferredName();\n  beforeName();\n  out.append('\"');\n  string(name);\n  out.append('\"');\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  writeDeferredName();\n  beforeName();\n  out.append('\"');\n  string(name);\n  out.append('\"');\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  writeDeferredName();\n  beforeName();\n  out.append('\"');\n  string(name);\n  out.append('\"');\n  return this;\n}"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // work out the minimum value...\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        return new Double(info.getRangeLowerBound(true));\n    }\n\n    // hasn't implemented RangeInfo, so we'll have to iterate...\n    else {\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum[g] = Math.min(minimum[g], negative[g]);\n                maximum[g] = Math.max(maximum[g], positive[g]);\n            }\n        }\n        if (hasValidData) {\n            for (int j = 0; j < groupCount; j++) {\n                result = Range.combine(result, new Range(minimum[j],\n                        maximum[j]));\n            }\n        }\n        return result;\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // work out the minimum value...\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        return new Double(info.getRangeLowerBound(true));\n    }\n\n    // hasn't implemented RangeInfo, so we'll have to iterate...\n    else {\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum[g] = Math.min(minimum[g], negative[g]);\n                maximum[g] = Math.max(maximum[g], positive[g]);\n            }\n        }\n        if (hasValidData) {\n            for (int j = 0; j < groupCount; j++) {\n                result = Range.combine(result, new Range(minimum[j],\n                        maximum[j]));\n            }\n        }\n        return result;\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    // work out the minimum value...\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        return new Double(info.getRangeLowerBound(true));\n    }\n    else {\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum[g] = Math.min(minimum[g], negative[g]);\n                maximum[g] = Math.max(maximum[g], positive[g]);\n            }\n        }\n        if (hasValidData) {\n            for (int j = 0; j < groupCount; j++) {\n                result = Range.combine(result, new Range(minimum[j],\n                        maximum[j]));\n            }\n        }\n        return result;\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // work out the minimum value...\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        return new Double(info.getRangeLowerBound(true));\n    }\n\n    // hasn't implemented RangeInfo, so we'll have to iterate...\n    else {\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum[g] = Math.min(minimum[g], negative[g]);\n                maximum[g] = Math.max(maximum[g], positive[g]);\n            }\n        }\n        if (hasValidData) {\n            for (int j = 0; j < groupCount; j++) {\n                result = Range.combine(result, new Range(minimum[j],\n                        maximum[j]));\n            }\n        }\n        return result;\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // work out the minimum value...\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        return new Double(info.getRangeLowerBound(true));\n    }\n\n    // hasn't implemented RangeInfo, so we'll have to iterate...\n    else {\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum[g] = Math.min(minimum[g], negative[g]);\n                maximum[g] = Math.max(maximum[g], positive[g]);\n            }\n        }\n        if (hasValidData) {\n            for (int j = 0; j < groupCount; j++) {\n                result = Range.combine(result, new Range(minimum[j],\n                        maximum[j]));\n            }\n        }\n        return result;\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    // work out the minimum value...\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        return new Double(info.getRangeLowerBound(true));\n    }\n\n    // hasn't implemented RangeInfo, so we'll have to iterate...\n    else {\n        int categoryCount = dataset.getColumnCount();\n        double minimum = Double.MAX_VALUE;\n        int groupCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    double value = number.doubleValue();\n                    if (value < minimum) {\n                        minimum = value;\n                    }\n                }\n            }\n        }\n        return new Double(minimum);\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // work out the minimum value...\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        return new Double(info.getRangeLowerBound(true));\n    }\n\n    // hasn't implemented RangeInfo, so we'll have to iterate...\n    else {\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                                 // '+', remember value is negative\n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum[g] = Math.min(minimum[g], negative[g]);\n                maximum[g] = Math.max(maximum[g], positive[g]);\n            }\n        }\n        if (hasValidData) {\n            for (int j = 0; j < groupCount; j++) {\n                result = Range.combine(result, new Range(minimum[j],\n                        maximum[j]));\n            }\n        }\n        return result;\n    }\n}"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element != null && !element.booleanValue()) {\n            return Boolean.FALSE;\n        }\n    }\n    return Boolean.TRUE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element != null && !element.booleanValue()) {\n            return Boolean.FALSE;\n        }\n    }\n    return Boolean.TRUE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element != null && !element.booleanValue()) {\n            return Boolean.FALSE;\n        }\n    }\n    return Boolean.TRUE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element != null && !element.booleanValue()) {\n            return Boolean.FALSE;\n        }\n    }\n    return Boolean.TRUE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element != null && element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element != null && element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        for (final boolean element : primitive) {\n            if (!element) {\n                return Boolean.FALSE;\n            }\n        }\n        return Boolean.TRUE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element != null && !element.booleanValue()) {\n            return Boolean.FALSE;\n        }\n    }\n    return Boolean.TRUE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element != null && element.booleanValue()) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        for (final boolean element : primitive) {\n            if (!element) {\n                return Boolean.FALSE;\n            }\n        }\n        return Boolean.TRUE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return str;\n    }\n    final StringBuilder result = new StringBuilder();\n    boolean word = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            word = true;\n        } else if (word) {\n            result.append(Character.toUpperCase(ch));\n            word = false;\n        } else {\n            result.append(ch);\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (delimiters == null) {\n        delimiters = new char[]{' '};\n    }\n    StringBuilder result = new StringBuilder();\n    boolean inWord = false;\n    for (char ch : str.toCharArray()) {\n        if (isDelimiter(ch, delimiters)) {\n            inWord = false;\n        } else if (!inWord) {\n            result.append(Character.toUpperCase(ch));\n            inWord = true;\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder result = new StringBuilder();\n    boolean inWord = false;\n    for (char ch : str.toCharArray()) {\n        if (isDelimiter(ch, delimiters)) {\n            inWord = false;\n        } else if (!inWord) {\n            result.append(Character.toUpperCase(ch));\n            inWord = true;\n        } else {\n            result.append(ch);\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder result = new StringBuilder();\n    boolean wordStarted = false;\n    for (char ch : str.toCharArray()) {\n        if (isDelimiter(ch, delimiters)) {\n            wordStarted = false;\n        } else if (!wordStarted) {\n            result.append(Character.toUpperCase(ch));\n            wordStarted = true;\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (delimiters == null) {\n        delimiters = new char[] {' '};\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean wordStarted = false;\n    for (char ch : str.toCharArray()) {\n        if (isDelimiter(ch, delimiters)) {\n            wordStarted = false;\n        } else if (!wordStarted) {\n            sb.append(Character.toUpperCase(ch));\n            wordStarted = true;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder result = new StringBuilder();\n    boolean inWord = false;\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            inWord = false;\n        } else if (!inWord) {\n            result.append(Character.toUpperCase(ch));\n            inWord = true;\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder result = new StringBuilder();\n    boolean inWord = false;\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            inWord = false;\n        } else if (!inWord) {\n            inWord = true;\n            result.append(Character.toUpperCase(ch));\n        } else {\n            result.append(ch);\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    StringBuilder initials = new StringBuilder();\n    boolean word = false;\n    for (char ch : str.toCharArray()) {\n        if (isDelimiter(ch, delimiters)) {\n            word = false;\n        } else if (!word) {\n            word = true;\n            initials.append(Character.toUpperCase(ch));\n        } else {\n            initials.append(ch);\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return str;\n    }\n    final StringBuilder result = new StringBuilder();\n    boolean inWord = false;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            inWord = false;\n        } else if (!inWord) {\n            result.append(Character.toUpperCase(ch));\n            inWord = true;\n        } else {\n            result.append(ch);\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return str;\n    }\n    StringBuilder result = new StringBuilder();\n    boolean isWord = false;\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            isWord = false;\n        } else if (!isWord) {\n            result.append(Character.toUpperCase(ch));\n            isWord = true;\n        }\n    }\n    return result.toString();\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    return new Point2D.Double(screenPoint.x - getInsets().left, screenPoint.y - getInsets().top);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / getScaleX();\n    double y = (screenPoint.y - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    return translateJava2DToScreen(screenPoint);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / getScaleX();\n    double y = (screenPoint.y - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / getScaleX();\n    double y = (screenPoint.y - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    return new Point2D.Double(screenPoint.x, screenPoint.y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / getScaleX();\n    double y = (screenPoint.y - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    return translateJava2DToScreen(new Point2D.Double(screenPoint.x, screenPoint.y));\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    return new Point2D.Double(screenPoint.x / getScaleX(), screenPoint.y / getScaleY());\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / getScaleX();\n    double y = (screenPoint.y - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition pos = new ParsePosition(0);\n        return parse(source, pos);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition pos = new ParsePosition(0);\n        return parse(source, pos);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition pos = new ParsePosition(0);\n        final BigFraction result = parse(source, pos);\n        if (pos.getIndex() == 0) {\n            throw new MathParseException(source, pos.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition pos = new ParsePosition(0);\n        final BigFraction result = parse(source, pos);\n        if (pos.getIndex() == 0) {\n            throw new MathParseException(source, pos.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition pos = new ParsePosition(0);\n        final BigFraction result = parse(source, pos);\n        if (pos.getIndex() == 0) {\n            throw new MathParseException(source, pos.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition pos = new ParsePosition(0);\n        final BigFraction result = parse(source, pos);\n        if (pos.getIndex() == 0) {\n            throw new MathParseException(source, pos.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition pos = new ParsePosition(0);\n        final BigFraction result = parse(source, pos);\n        if (pos.getIndex() == 0) {\n            throw new MathParseException(source, pos.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition pos = new ParsePosition(0);\n        final BigFraction result = parse(source, pos);\n        if (pos.getIndex() == 0) {\n            throw new MathParseException(source, pos.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    ListOrderedSet<E> orderedSet = new ListOrderedSet<E>(new HashSet<E>());\n    orderedSet.setOrder = new ArrayList<E>(list);\n    return orderedSet;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(new HashSet<E>(), temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>();\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return new ListOrderedSet<E>(sl);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(), list);\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range range = plot.getDataRange(axis);\n            if (result == null) {\n                result = range;\n            } else {\n                result = Range.combine(result, range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis instanceof NumberAxis) {\n        NumberAxis na = (NumberAxis) axis;\n        na.configure();\n        return na.getRange();\n    } else {\n        return null;\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis instanceof NumberAxis) {\n        NumberAxis na = (NumberAxis) axis;\n        Range result = new Range();\n        if (na.isAutoRange()) {\n            na.configure();\n        }\n        result.setLowerBound(na.getLowerBound());\n        result.setUpperBound(na.getUpperBound());\n        return result;\n    } else {\n        return null;\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis instanceof NumberAxis) {\n        NumberAxis na = (NumberAxis) axis;\n        na.configure();\n        return na.getRange();\n    }\n    return null;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis instanceof NumberAxis) {\n        NumberAxis na = (NumberAxis) axis;\n        na.configure();\n        return na.getRange();\n    }\n    return null;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (axis instanceof NumberAxis) {\n        NumberAxis na = (NumberAxis) axis;\n        na.configure();\n        result = na.getRange();\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range r = plot.getDataRange(axis);\n            if (result == null) {\n                result = r;\n            } else {\n                result = Range.combine(result, r);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis instanceof NumberAxis) {\n        NumberAxis na = (NumberAxis) axis;\n        na.configure();\n        return na.getRange();\n    } else {\n        return null;\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range r = plot.getDataRange(axis);\n            if (result == null) {\n                result = r;\n            } else {\n                result = Range.combine(result, r);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (axis instanceof NumberAxis) {\n        NumberAxis na = (NumberAxis) axis;\n        na.configure();\n        result = na.getRange();\n    }\n    else {\n        // handle other types of axes\n    }\n    return result;\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) + Math.log(10.0)) / Math.log(10.0);\n        res += (1.0 - res) * (Math.log(10.0) / (Math.log(10.0) - 1.0));\n    }\n    else {\n        res = Math.log(val) / Math.log(10.0);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = Math.log(val) / Math.log(10.0) + (1.0 - val / 10.0);\n    }\n    else {\n        res = Math.log(val) / Math.log(10.0);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = (Math.log(val) + Math.log(10.0)) / Math.log(10.0); //adjustLog10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) + Math.log(10.0)) / Math.log(10.0);\n        res += (1.0 - res) * (1.0 - Math.log(val) / Math.log(10.0));\n    }\n    else {\n        res = Math.log(val) / Math.log(10.0);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = (Math.log(val) + Math.log(10.0)) / Math.log(10.0); //adjust for values less than 1\n    }\n    else {\n        res = Math.log(val) / Math.log(10.0);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = Math.log(val) / Math.log(10.0) + (1.0 - val / 10.0);\n    }\n    else {\n        res = Math.log(val) / Math.log(10.0);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = Math.log(val) / Math.log(10.0) + (1.0 - val / 10.0);\n    }\n    else {\n        res = Math.log(val) / Math.log(10.0);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = (Math.log(val) + Math.log(10.0)) / Math.log(10.0); //adjust for 0\n    }\n    else {\n        res = Math.log(val) / Math.log(10.0);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = (Math.log(val) + Math.log(10.0)) / Math.log(10.0);\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) + Math.log(10.0)) / Math.log(10.0); //adjustLog10\n    }\n    else {\n        res = Math.log(val) / Math.log(10.0);\n    }\n    return negFlag ? (-res) : res;\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    if (cfg.isImplicitReturn(cfg.getEntry())) {\n      return true;\n    }\n    for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getNodes()) {\n      if (node.isConditional()) {\n        if (node.getTrueTarget().isImplicitReturn()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    if (cfg.isImplicitReturn()) {\n      return true;\n    }\n    return false;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    return CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>.allPathsSatisfyPredicate(\n        cfg, cfg.getEntry(), cfg.getImplicitReturn(), IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE);\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    if (cfg.getEntry().isConditional()) {\n      return true;\n    }\n    if (cfg.getImplicitReturn().isConditional()) {\n      return true;\n    }\n    return false;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    if (cfg.isImplicitReturn()) {\n      return true;\n    }\n    if (cfg.getEntry().isReturn()) {\n      return true;\n    }\n    for (ControlFlowGraph.Branch edge : cfg.getEdges()) {\n      if (edge.isConditional()) {\n        if (edge.getTarget().isReturn()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node entry = cfg.getEntry();\n    Node implicitReturn = cfg.getImplicitReturn();\n    if (isReturnBlock(entry)) {\n      return true;\n    }\n    if (isReturnExpressBlock(entry)) {\n      return getBlockReturnExpression(entry).hasOneChild();\n    }\n    if (isReturnExpression(entry)) {\n      return true;\n    }\n    if (isVarBlock(entry)) {\n      return true;\n    }\n    // Traverse the control flow graph to check if all paths return.\n    CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> test =\n        new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n            cfg,\n            entry,\n            implicitReturn,\n            IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE);\n\n    return test.allPathsSatisfyPredicate();\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    if (cfg.isImplicitReturn()) {\n      return true;\n    }\n    for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getNodes()) {\n      if (node.isConditional()) {\n        if (!node.getEdge().isTrueCondition()) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    if (cfg.isImplicitReturn(cfg.getEntry())) {\n      return true;\n    }\n    for (ControlFlowGraph.Branch edge : cfg.getEdges()) {\n      if (edge.isConditional()) {\n        if (edge.getTarget().isReturn()) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    if (cfg.getEntry().isImplicitReturn()) {\n      return true;\n    }\n    for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getNodes()) {\n      if (node.isConditional()) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    Node entry = cfg.getEntry();\n    Node implicitReturn = cfg.getImplicitReturn();\n    if (!cfg.isEnteringNewCfgNode(entry)) {\n      return true;\n    }\n    if (cfg.isImplicitReturn(entry)) {\n      return true;\n    }\n    if (cfg.isEnteringNewCfgNode(implicitReturn)) {\n      return true;\n    }\n    return false;\n  }"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] y = new Dfp[2];\n    Dfp[] x = new Dfp[2];\n    Dfp[] a1 = new Dfp[2];\n    Dfp[] a2 = new Dfp[2];\n    Dfp[] a3 = new Dfp[2];\n    Dfp[] a4 = new Dfp[2];\n    Dfp[] a5 = new Dfp[2];\n    Dfp[] a6 = new Dfp[2];\n    Dfp[] a7 = new Dfp[2];\n    Dfp[] a8 = new Dfp[2];\n    Dfp[] a9 = new Dfp[2];\n    Dfp[] a10 = new Dfp[2];\n    Dfp[] a11 = new Dfp[2];\n    Dfp[] a12 = new Dfp[2];\n    Dfp[] a13 = new Dfp[2];\n    Dfp[] a14 = new Dfp[2];\n    Dfp[] a15 = new Dfp[2];\n    Dfp[] a16 = new Dfp[2];\n    Dfp[] a17 = new Dfp[2];\n    Dfp[] a18 = new Dfp[2];\n    Dfp[] a19 = new Dfp[2];\n    Dfp[] a20 = new Dfp[2];\n    Dfp[] a21 = new Dfp[2];\n    Dfp[] a22 = new Dfp[2];\n    Dfp[] a23 = new Dfp[2];\n    Dfp[] a24 = new Dfp[2];\n    Dfp[] a25 = new Dfp[2];\n    Dfp[] a26 = new Dfp[2];\n    Dfp[] a27 = new Dfp[2];\n    Dfp[] a28 = new Dfp[2];\n    Dfp[] a29 = new Dfp[2];\n    Dfp[] a30 = new Dfp[2];\n    Dfp[] a31 = new Dfp[2];\n    Dfp[] a32 = new Dfp[2];\n    Dfp[] a33 = new Dfp[2];\n    Dfp[] a34 = new Dfp[2];\n    Dfp[] a35 = new Dfp[2];\n    Dfp[] a36 = new Dfp[2];\n    Dfp[] a37 = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    double x[] = new double[2];\n    double x2[] = new double[2];\n    double y[] = new double[2];\n    double a[] = new double[2];\n\n    split(a, x);\n\n    /* Set X = (x-1)/(x+1) */\n    x[0] += 1.0;\n    resplit(x);\n    splitReciprocal(x, a);\n    x[0] -= 2.0;\n    resplit(x);\n    splitMult(x, a, y);\n    x[0] = y[0];\n    x[1] = y[1];\n\n    /* Square X -> X2*/\n    splitMult(x, x, x2);\n\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n    for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n        splitMult(y, x2, a);\n        y[0] = a[0];\n        y[1] = a[1];\n        splitAdd(y, LN_SPLIT_COEF[i], a);\n        y[0] = a[0];\n        y[1] = a[1];\n    }\n\n    splitMult(y, x, a);\n    y[0] = a[0];\n    y[1] = a[1];\n\n    return new Dfp[]{new Dfp(a[0]), new Dfp(a[1])};\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] y = new Dfp[2];\n    double x[] = new double[2];\n    double x2[] = new double[2];\n    double a1[] = new double[2];\n    double a2[] = new double[2];\n    double a3[] = new double[2];\n    double a4[] = new double[2];\n    double a5[] = new double[2];\n    double a6[] = new double[2];\n    double a7[] = new double[2];\n    double a8[] = new double[2];\n    double a9[] = new double[2];\n    double a10[] = new double[2];\n    double a11[] = new double[2];\n    double a12[] = new double[2];\n    double a13[] = new double[2];\n    double a14[] = new double[2];\n    double a15[] = new double[2];\n    double a16[] = new double[2];\n    double a17[] = new double[2];\n    double a18[] = new double[2];\n    double a19[] = new double[2];\n    double a20[] = new double[2];\n    double a21[] = new double[2];\n    double a22[] = new double[2];\n    double a23[] = new double[2];\n    double a24[] = new double[2];\n    double a25[] = new double[2];\n    double a26[] = new double[2];\n    double a27[] = new double[2];\n    double a28[] = new double[2];\n    double a29[] = new double[2];\n    double a30[] = new double[2];\n    double a31[] = new double[2];\n    double a32[] = new double[2];\n    double a33[] = new double[2];\n    double a34[] = new double[2];\n    double a35[] = new double[2];\n    double a36[] = new double[2];\n    double a37[] = new double[2];\n    double a38[] = new double[2];\n    double a39[] = new double[2];\n    double a40[] = new double[2];\n    double a41[] = new double[2];\n    double a42[] = new double[2];\n    double a43[] = new double[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] result = new Dfp[2];\n    double x[] = new double[2];\n    double x2[] = new double[2];\n    double y[] = new double[2];\n    double a[] = new double[2];\n\n    split(a, x);\n\n    /* Set X = (x-1)/(x+1) */\n    x[0] += 1.0;\n    resplit(x);\n    splitReciprocal(x, a);\n    x[0] -= 2.0;\n    resplit(x);\n    splitMult(x, a, y);\n    x[0] = y[0];\n    x[1] = y[1];\n\n    /* Square X -> X2*/\n    splitMult(x, x, x2);\n\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n    for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n        splitMult(y, x2, a);\n        y[0] = a[0];\n        y[1] = a[1];\n        splitAdd(y, LN_SPLIT_COEF[i], a);\n        y[0] = a[0];\n        y[1] = a[1];\n    }\n\n    splitMult(y, x, a);\n    y[0] = a[0];\n    y[1] = a[1];\n\n    result[0] = new Dfp(y[0]);\n    result[1] = new Dfp(y[1]);\n\n    return result;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    double[] y = new double[2];\n    double x[] = new double[2];\n    double x2[] = new double[2];\n    double a[] = new double[2];\n\n    split(a, x);\n\n    /* Set X = (x-1)/(x+1) */\n    x[0] += 1.0;\n    resplit(x);\n    splitReciprocal(x, a);\n    x[0] -= 2.0;\n    resplit(x);\n    splitMult(x, a, y);\n    x[0] = y[0];\n    x[1] = y[1];\n\n    /* Square X -> X2*/\n    splitMult(x, x, x2);\n\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n    for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n        splitMult(y, x2, a);\n        y[0] = a[0];\n        y[1] = a[1];\n        splitAdd(y, LN_SPLIT_COEF[i], a);\n        y[0] = a[0];\n        y[1] = a[1];\n    }\n\n    splitMult(y, x, a);\n    y[0] = a[0];\n    y[1] = a[1];\n\n    return new Dfp[]{new Dfp(y[0]), new Dfp(y[1])};\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] result = new Dfp[2];\n    Dfp[] x = new Dfp[2];\n    Dfp[] y = new Dfp[2];\n    Dfp[] a1 = new Dfp[2];\n    Dfp[] a2 = new Dfp[2];\n    Dfp[] a3 = new Dfp[2];\n    Dfp[] a4 = new Dfp[2];\n    Dfp[] a5 = new Dfp[2];\n    Dfp[] a6 = new Dfp[2];\n    Dfp[] a7 = new Dfp[2];\n    Dfp[] a8 = new Dfp[2];\n    Dfp[] a9 = new Dfp[2];\n    Dfp[] a10 = new Dfp[2];\n    Dfp[] a11 = new Dfp[2];\n    Dfp[] a12 = new Dfp[2];\n    Dfp[] a13 = new Dfp[2];\n    Dfp[] a14 = new Dfp[2];\n    Dfp[] a15 = new Dfp[2];\n    Dfp[] a16 = new Dfp[2];\n    Dfp[] a17 = new Dfp[2];\n    Dfp[] a18 = new Dfp[2];\n    Dfp[] a19 = new Dfp[2];\n    Dfp[] a20 = new Dfp[2];\n    Dfp[] a21 = new Dfp[2];\n    Dfp[] a22 = new Dfp[2];\n    Dfp[] a23 = new Dfp[2];\n    Dfp[] a24 = new Dfp[2];\n    Dfp[] a25 = new Dfp[2];\n    Dfp[] a26 = new Dfp[2];\n    Dfp[] a27 = new Dfp[2];\n    Dfp[] a28 = new Dfp[2];\n    Dfp[] a29 = new Dfp[2];\n    Dfp[] a30 = new Dfp[2];\n    Dfp[] a31 = new Dfp[2];\n    Dfp[] a32 = new Dfp[2];\n    Dfp[] a33 = new Dfp[2];\n    Dfp[] a34 = new Dfp[2];\n    Dfp[] a35 = new Dfp[2];\n    Dfp[] a36 = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] result = new Dfp[2];\n    Dfp[] x = new Dfp[2];\n    Dfp[] y = new Dfp[2];\n    Dfp[] a1 = new Dfp[2];\n    Dfp[] a2 = new Dfp[2];\n    Dfp[] a3 = new Dfp[2];\n    Dfp[] a4 = new Dfp[2];\n    Dfp[] a5 = new Dfp[2];\n    Dfp[] a6 = new Dfp[2];\n    Dfp[] a7 = new Dfp[2];\n    Dfp[] a8 = new Dfp[2];\n    Dfp[] a9 = new Dfp[2];\n    Dfp[] a10 = new Dfp[2];\n    Dfp[] a11 = new Dfp[2];\n    Dfp[] a12 = new Dfp[2];\n    Dfp[] a13 = new Dfp[2];\n    Dfp[] a14 = new Dfp[2];\n    Dfp[] a15 = new Dfp[2];\n    Dfp[] a16 = new Dfp[2];\n    Dfp[] a17 = new Dfp[2];\n    Dfp[] a18 = new Dfp[2];\n    Dfp[] a19 = new Dfp[2];\n    Dfp[] a20 = new Dfp[2];\n    Dfp[] a21 = new Dfp[2];\n    Dfp[] a22 = new Dfp[2];\n    Dfp[] a23 = new Dfp[2];\n    Dfp[] a24 = new Dfp[2];\n    Dfp[] a25 = new Dfp[2];\n    Dfp[] a26 = new Dfp[2];\n    Dfp[] a27 = new Dfp[2];\n    Dfp[] a28 = new Dfp[2];\n    Dfp[] a29 = new Dfp[2];\n    Dfp[] a30 = new Dfp[2];\n    Dfp[] a31 = new Dfp[2];\n    Dfp[] a32 = new Dfp[2];\n    Dfp[] a33 = new Dfp[2];\n    Dfp[] a34 = new Dfp[2];\n    Dfp[] a35 = new Dfp[2];\n    Dfp[] a36 = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] y = new Dfp[2];\n    Dfp[] x = new Dfp[2];\n    Dfp[] a1 = new Dfp[2];\n    Dfp[] a2 = new Dfp[2];\n    Dfp[] a3 = new Dfp[2];\n    Dfp[] a4 = new Dfp[2];\n\n    split(a[0], x);\n\n    /* Set X = (x-1)/(x+1) */\n    x[0] += 1.0;\n    resplit(x);\n    splitReciprocal(x, a1);\n    x[0] -= 2.0;\n    resplit(x);\n    splitMult(x, a1, y);\n    x[0] = y[0];\n    x[1] = y[1];\n\n    /* Square X -> X2*/\n    splitMult(x, x, a2);\n\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n    for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n        splitMult(y, a2, a3);\n        y[0] = a3[0];\n        y[1] = a3[1];\n        splitAdd(y, LN_SPLIT_COEF[i], a4);\n        y[0] = a4[0];\n        y[1] = a4[1];\n    }\n\n    splitMult(y, x, a);\n    y[0] = a[0];\n    y[1] = a[1];\n\n    return y;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] result = new Dfp[2];\n    Dfp[] x = new Dfp[2];\n    Dfp[] y = new Dfp[2];\n    Dfp[] a1 = new Dfp[2];\n    Dfp[] a2 = new Dfp[2];\n    Dfp[] a3 = new Dfp[2];\n    Dfp[] a4 = new Dfp[2];\n\n    split(a[0], x);\n\n    /* Set X = (x-1)/(x+1) */\n    x[0] += 1.0;\n    resplit(x);\n    splitReciprocal(x, a1);\n    x[0] -= 2.0;\n    resplit(x);\n    splitMult(x, a1, y);\n\n    x[0] = y[0];\n    x[1] = y[1];\n\n    /* Square X -> X2*/\n    splitMult(x, x, a2);\n\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n    for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n        splitMult(y, a2, a3);\n        y[0] = a3[0];\n        y[1] = a3[1];\n        splitAdd(y, LN_SPLIT_COEF[i], a4);\n        y[0] = a4[0];\n        y[1] = a4[1];\n    }\n\n    splitMult(y, a, result);\n\n    return result;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] y = new Dfp[2];\n    Dfp[] x = new Dfp[2];\n    Dfp[] a1 = new Dfp[2];\n    Dfp[] a2 = new Dfp[2];\n    Dfp[] a3 = new Dfp[2];\n    Dfp[] a4 = new Dfp[2];\n\n    split(a[0], x);\n\n    // Set X = (x-1)/(x+1)\n    x[0] += 1.0;\n    resplit(x);\n    splitReciprocal(x, a1);\n    x[0] -= 2.0;\n    resplit(x);\n    splitMult(x, a1, y);\n\n    // Square X -> X2\n    splitMult(x, x, a2);\n\n    // Compute ln(x+1) - ln(x-1)\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n    for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n        splitMult(y, a2, a3);\n        y[0] = a3[0];\n        y[1] = a3[1];\n        splitAdd(y, LN_SPLIT_COEF[i], a4);\n        y[0] = a4[0];\n        y[1] = a4[1];\n    }\n\n    splitMult(y, x, a);\n    y[0] = a[0];\n    y[1] = a[1];\n\n    return y;\n}"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"Key is null\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"Value is null\");\n        }\n        Collection<V> collection = getCollection(key);\n        if (collection == null) {\n            return false;\n        }\n        collection.remove(value);\n        return collection.size() == 0;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"Key or value is null\");\n        }\n        Collection<V> collection = getCollection(key);\n        if (collection != null) {\n            collection.remove(value);\n            if (collection.isEmpty()) {\n                decorated().remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"key\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"value\");\n        }\n        Collection<V> collection = getCollection(key);\n        if (collection == null) {\n            return false;\n        }\n        return collection.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"Key or value is null\");\n        }\n        if (!containsKey(key)) {\n            return false;\n        }\n        Collection<V> collection = getCollection(key);\n        if (collection.remove(value)) {\n            if (collection.isEmpty()) {\n                decorated().remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"Key or value is null\");\n        }\n        Map<K, Collection<V>> map = getMap();\n        if (!map.containsKey(key)) {\n            return false;\n        }\n        Collection<V> collection = map.get(key);\n        if (!collection.remove(value)) {\n            return false;\n        }\n        if (collection.isEmpty()) {\n            map.remove(key);\n        }\n        return true;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"Key is null\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"Value is null\");\n        }\n        Map<K, Collection<V>> map = getMap();\n        if (!map.containsKey(key)) {\n            return false;\n        }\n        Collection<V> collection = map.get(key);\n        if (!collection.remove(value)) {\n            return false;\n        }\n        if (collection.isEmpty()) {\n            map.remove(key);\n        }\n        return true;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"Key is null\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"Value is null\");\n        }\n        Map<K, Collection<V>> map = getMap();\n        if (!map.containsKey(key)) {\n            return false;\n        }\n        Collection<V> collection = map.get(key);\n        if (!collection.remove(value)) {\n            return false;\n        }\n        if (collection.isEmpty()) {\n            map.remove(key);\n        }\n        return true;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"Key is null\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"Value is null\");\n        }\n        Map<K, Collection<V>> map = getMap();\n        if (!map.containsKey(key)) {\n            return false;\n        }\n        Collection<V> collection = map.get(key);\n        collection.remove(value);\n        if (collection.isEmpty()) {\n            map.remove(key);\n        }\n        return true;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"Key is null\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"Value is null\");\n        }\n        final Collection<V> collection = getCollection(key);\n        if (collection == null) {\n            return false;\n        }\n        collection.remove(value);\n        if (collection.isEmpty()) {\n            decorated().remove(key);\n        }\n        return true;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"Key or value is null\");\n        }\n        if (!containsKey(key)) {\n            return false;\n        }\n        Collection<V> collection = getCollection(key);\n        collection.remove(value);\n        if (collection.isEmpty()) {\n            decorated().remove(key);\n        }\n        return true;\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Node.JSDOC_INFO_PROP) {\n        return n;\n    }\n    if (n.getType() == Node.VAR_ARGS_NAME) {\n        return n;\n    }\n    if (n.getType() == Node.INCRDECR_PROP) {\n        return n;\n    }\n    if (n.getType() == Node.QUOTED_PROP) {\n        return n;\n    }\n    if (n.getType() == Node.OPT_ARG_NAME) {\n        return n;\n    }\n    if (n.getType() == Node.SYNTHETIC_BLOCK_PROP) {\n        return n;\n    }\n    if (n.getType() == Node.EMPTY_BLOCK) {\n        return n;\n    }\n    if (n.getType() == Node.ORIGINALNAME_PROP) {\n        return n;\n    }\n    if (n.getType() == Node.SIDE_EFFECT_FLAGS) {\n        return n;\n    }\n    if (n.getType() == Node.IS_CONSTANT_NAME) {\n        return n;\n    }\n    if (n.getType() == Node.IS_NAMESPACE) {\n        return n;\n    }\n    if (n.getType() == Node.IS_DISPATCHER) {\n        return n;\n    }\n    if (n.getType() == Node.DIRECTIVES) {\n        return n;\n    }\n    if (n.getType() == Node.DIRECT_EVAL) {\n        return n;\n    }\n    if (n.getType() == Node.FREE_CALL) {\n        return n;\n    }\n    if (n.getType() == Node.STATIC_SOURCE_FILE) {\n        return n;\n    }\n    if (n.getType() == Node.LENGTH) {\n        return n;\n    }\n    if (n.getType() == Node.INPUT_ID) {\n        return n;\n    }\n    if (n.getType() == Node.SLASH_V) {\n        return n;\n    }\n    if (n.getType() == Node.INFERRED_FUNCTION) {\n        return n;\n    }\n    if (n.getType() == Node.CHANGE_TIME) {\n        return n;\n    }\n    if (n.getType() == Node.REFLECTED_OBJECT) {\n        return n;\n    }\n    if (n.getType() == Node.LAST_PROP) {\n        return n;\n    }\n    if (n.getType() == Node.COLUMN_BITS) {\n        return n;\n    }\n    if (n.getType() == Node.MAX_COLUMN_NUMBER) {\n        return n;\n    }\n    if (n.getType() == Node.COLUMN_MASK) {\n        return n;\n    }\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.type == Node.Type.NAME) {\n        return new StringNode(Node.Type.STRING, n.toString());\n    } else if (n.type == Node.Type.STRING) {\n        return new StringNode(Node.Type.STRING, n.toString());\n    } else {\n        return n;\n    }\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Node.JSDOC_INFO_PROP) {\n        return new StringNode(Node.STRING, n.getString(), n.getLineno(), n.getCharno());\n    }\n    if (n.getType() == Node.VAR_ARGS_NAME) {\n        return new StringNode(Node.STRING, n.getString(), n.getLineno(), n.getCharno());\n    }\n    if (n.getType() == Node.INCRDECR_PROP) {\n        return new StringNode(Node.STRING, n.getString(), n.getLineno(), n.getCharno());\n    }\n    if (n.getType() == Node.QUOTED_PROP) {\n        return new StringNode(Node.STRING, n.getString(), n.getLineno(), n.getCharno());\n    }\n    if (n.getType() == Node.OPT_ARG_NAME) {\n        return new StringNode(Node.STRING, n.getString(), n.getLineno(), n.getCharno());\n    }\n    if (n.getType() == Node.SYNTHETIC_BLOCK_PROP) {\n        return new StringNode(Node.STRING, n.getString(), n.getLineno(), n.getCharno());\n    }\n    if (n.getType() == Node.EMPTY_BLOCK) {\n        return new StringNode(Node.STRING, n.getString(), n.getLineno(), n.getCharno());\n    }\n    if (n.getType() == Node.ORIGINALNAME_PROP) {\n        return new StringNode(Node.STRING, n.getString(), n.getLineno(), n.getCharno());\n    }\n    if (n.getType() == Node.SIDE_EFFECT_FLAGS) {\n        return new StringNode(Node.STRING, n.getString(), n.getLineno(), n.getCharno());\n    }\n    if (n.getType() == Node.IS_CONSTANT_NAME) {\n        return new StringNode(Node.STRING, n.getString(), n.getLineno(), n.getCharno());\n    }\n    if (n.getType() == Node.IS_NAMESPACE) {\n        return new StringNode(Node.STRING, n.getString(), n.getLineno(), n.getCharno());\n    }\n    if (n.getType() == Node.IS_DISPATCHER) {\n        return new StringNode(Node.STRING, n.getString(), n.getLineno(), n.getCharno());\n    }\n    if (n.getType() == Node.DIRECTIVES) {\n        return new StringNode(Node.STRING, n.getString(), n.getLineno(), n.getCharno());\n    }\n    if (n.getType() == Node.DIRECT_EVAL) {\n}\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = new Node(n.getType());\n    for (Node child : n.getChildren()) {\n        node.addChildToBack(transform(child));\n    }\n    if (n.getType() == Node.JS_NAME) {\n        node.setType(Node.JS_STRING);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Node.Type.NAME) {\n        return new StringNode(Node.Type.STRING, n.getString(), n.getLineno(), n.getCharno());\n    } else if (n.getType() == Node.Type.STRING) {\n        return new StringNode(Node.Type.STRING, n.getString(), n.getLineno(), n.getCharno());\n    } else {\n        return n;\n    }\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Node.Type.NAME) {\n        Node node = newNode(Token.STRING);\n        node.setString(n.getName());\n        return node;\n    } else if (n.getType() == Node.Type.STRING) {\n        Node node = newNode(Token.STRING);\n        node.setString(n.getString());\n        return node;\n    } else {\n        return n;\n    }\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = new Node(n.getType());\n    if (n.getType() == Node.Type.NAME) {\n        node.setType(Node.Type.STRING);\n    } else if (n.getType() == Node.Type.STRING) {\n        node.setString(n.getString());\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = newNode(Token.STRING);\n    if (n.getType() == Node.Type.NAME) {\n        node.setType(Token.STRING);\n    } else if (n.getType() == Node.Type.STRING) {\n        node.setQuotedString();\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Node.Type.NAME) {\n        return new StringNode(Node.Type.STRING, n.getString(), n.getLineno(), n.getCharno());\n    } else if (n.getType() == Node.Type.STRING) {\n        return new StringNode(Node.Type.STRING, n.getString(), n.getLineno(), n.getCharno());\n    } else {\n        return n;\n    }\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Node.Type.NAME) {\n        Node node = newNode(Token.STRING);\n        node.setString(n.getName());\n        return node;\n    } else if (n.getType() == Node.Type.STRING) {\n        Node node = newNode(Token.STRING);\n        node.setString(n.getString());\n        return node;\n    }\n    return n;\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    int seriesCount = dataset.getColumnCount();\n    for (int series = 0; series < seriesCount; series++) {\n        double sum = 0.0;\n        for (int row : includedRows) {\n            Number n = dataset.getValue(series, row);\n            if (n != null) {\n                double value = n.doubleValue();\n                sum += value;\n            }\n        }\n        if (asPercentages) {\n            sum /= DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        values.add(sum);\n    }\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        Number n = dataset.getValue(includedRows[i], category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            values.add(v);\n            total += v;\n        }\n    }\n    values.add(base);\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    int seriesCount = dataset.getColumnCount();\n    for (int series = 0; series < seriesCount; series++) {\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        for (int row : includedRows) {\n            Number n = dataset.getValue(series, row);\n            if (n != null) {\n                double value = n.doubleValue();\n                if (asPercentages) {\n                    value = value / total;\n                }\n                values.add(value);\n                total += value;\n            }\n        }\n        if (asPercentages) {\n            values.add(base);\n        }\n    }\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    double total = 0.0;\n    for (int i = 0; i < dataset.getColumnCount(); i++) {\n        Number n = dataset.getValue(i, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                total += v;\n            }\n            values.add(v);\n        }\n    }\n    if (asPercentages) {\n        for (int i = 0; i < values.size(); i++) {\n            double v = (double) values.get(i);\n            v /= total;\n            values.set(i, v);\n        }\n    }\n    values.add(base);\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    int seriesCount = dataset.getColumnCount();\n    for (int series = 0; series < seriesCount; series++) {\n        double sum = 0.0;\n        for (int i = 0; i < includedRows.length; i++) {\n            Number n = dataset.getValue(series, includedRows[i]);\n            if (n != null) {\n                double value = n.doubleValue();\n                sum += value;\n            }\n        }\n        if (asPercentages) {\n            sum /= DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        values.add(sum);\n    }\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    int seriesCount = dataset.getColumnCount();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int series = 0; series < seriesCount; series++) {\n        Number n = dataset.getValue(series, category);\n        if (n != null) {\n            double value = n.doubleValue();\n            if (asPercentages) {\n                value = value / total;\n            }\n            values.add(value);\n            total += value;\n        }\n    }\n    values.add(base);\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    int seriesCount = dataset.getColumnCount();\n    double total = 0.0;\n    for (int series = 0; series < seriesCount; series++) {\n        Number n = dataset.getValue(series, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                total = DataUtilities.calculateColumnTotal(dataset, category);\n                v = v / total;\n            }\n            values.add(v);\n            total += v;\n        }\n    }\n    if (asPercentages) {\n        values.add(1.0 - total);\n    }\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int i = 0; i < dataset.getColumnCount(); i++) {\n        Number n = dataset.getValue(i, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            values.add(v);\n        }\n    }\n    values.add(base);\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    int seriesCount = dataset.getColumnCount();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int series = 0; series < seriesCount; series++) {\n        Number n = dataset.getValue(series, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            values.add(v);\n        }\n    }\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    double total = 0.0;\n    for (int i = 0; i < dataset.getColumnCount(); i++) {\n        Number n = dataset.getValue(i, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                total += v;\n            }\n            values.add(v);\n        }\n    }\n    if (asPercentages) {\n        for (int i = 0; i < values.size(); i++) {\n            double v = (double) values.get(i);\n            v /= total;\n            values.set(i, v);\n        }\n    }\n    values.add(base);\n    return values;\n}"
    ],
    [
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        List<Node> childNodes = ensureChildNodes();\n        List<Element> childElements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                childElements.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(childElements);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        List<Node> childNodes = ensureChildNodes();\n        List<Element> childElements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                childElements.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(childElements);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n        if (shadowChildrenRef == null) {\n            shadowChildrenRef = new WeakReference<>(new Elements(childNodes()));\n        }\n        return shadowChildrenRef.get();\n    }",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        List<Node> childNodes = ensureChildNodes();\n        List<Element> childElements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                childElements.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(childElements);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        List<Node> childNodes = ensureChildNodes();\n        List<Element> childElements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                childElements.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(childElements);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n        if (shadowChildrenRef == null) {\n            List<Node> childNodes = ensureChildNodes();\n            List<Element> childElements = new ArrayList<>();\n            for (Node node : childNodes) {\n                if (node instanceof Element)\n                    childElements.add((Element) node);\n            }\n            shadowChildrenRef = new WeakReference<>(childElements);\n        }\n        return shadowChildrenRef.get();\n    }",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        shadowChildrenRef = new WeakReference<>(new Elements(childNodes()));\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n        if (shadowChildrenRef == null) {\n            shadowChildrenRef = new WeakReference<>(new Elements(childNodes()));\n        }\n        return shadowChildrenRef.get();\n    }",
      "private List<Element> childElementsList()  {\n        if (shadowChildrenRef == null) {\n            List<Node> childNodes = ensureChildNodes();\n            List<Element> childElements = new ArrayList<>();\n            for (Node node : childNodes) {\n                if (node instanceof Element)\n                    childElements.add((Element) node);\n            }\n            shadowChildrenRef = new WeakReference<>(childElements);\n        }\n        return shadowChildrenRef.get();\n    }",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        List<Node> childNodes = ensureChildNodes();\n        List<Element> childElements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element) {\n                childElements.add((Element) node);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(childElements);\n    }\n    return shadowChildrenRef.get();\n}"
    ],
    [
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n        return (key == null) ? 0 : key.hashCode() % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n        return (key == null) ? 0 : key.hashCode() % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n        return (key == null) ? 0 : key.hashCode() % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }",
      "private int getHash(final Object key)  {\n        return Math.abs(key.hashCode()) % buckets.length;\n    }"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int rows = m.getRowDimension();\n    final int cols = m.getColumnDimension();\n    final double[][] d = new double[rows - k][cols - k];\n    for (int i = 0; i < rows - k; i++) {\n        for (int j = 0; j < cols - k; j++) {\n            d[i][j] = m.getEntry(i + k, j + k);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int rows = m.getRowDimension();\n    final int cols = m.getColumnDimension();\n    final double[][] d = new double[rows-k][cols];\n    for (int i = k; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (j >= i-k) {\n                d[i-k][j] = m.getEntry(i, j);\n            } else {\n                d[i-k][j] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int n = m.getColumnDimension();\n    final double[][] d = new double[m.getRowDimension()][n];\n    for (int i = 0; i < m.getRowDimension(); i++) {\n        for (int j = 0; j < n; j++) {\n            if (j >= i + k) {\n                d[i][j] = m.getEntry(i, j);\n            } else {\n                d[i][j] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    double[][] data = new double[rows][cols];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (i >= j - k) {\n                data[i][j] = m.getEntry(i, j);\n            } else {\n                data[i][j] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int rows = m.getRowDimension();\n    final int cols = m.getColumnDimension();\n    final double[][] d = new double[rows - k][cols - k];\n    for (int i = 0; i < rows - k; i++) {\n        for (int j = 0; j < cols - k; j++) {\n            d[i][j] = m.getEntry(i + k, j + k);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int rows = m.getRowDimension();\n    final int cols = m.getColumnDimension();\n    final double[][] d = new double[rows-k][cols-k];\n    for (int i = k; i < rows; i++) {\n        for (int j = k; j < cols; j++) {\n            d[i-k][j-k] = m.getEntry(i, j);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int rows = m.getRowDimension();\n    final int cols = m.getColumnDimension();\n    final double[][] d = new double[rows - k][cols - k];\n    for (int i = k; i < rows; i++) {\n        for (int j = k; j < cols; j++) {\n            d[i - k][j - k] = m.getEntry(i, j);\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    double[][] d = new double[rows-k][cols];\n    for (int i = 0; i < rows-k; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (j >= i+k) {\n                d[i][j] = m.getEntry(i+k, j);\n            } else {\n                d[i][j] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int n = m.getColumnDimension();\n    final double[][] d = new double[m.getRowDimension()][n];\n    for (int i = 0; i < m.getRowDimension(); i++) {\n        for (int j = 0; j < n; j++) {\n            if (j >= i + k) {\n                d[i][j] = m.getEntry(i, j);\n            } else {\n                d[i][j] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int rows = m.getRowDimension();\n    final int cols = m.getColumnDimension();\n    final double[][] d = new double[rows-k][cols];\n    for (int i = k; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (j >= i-k) {\n                d[i-k][j] = m.getEntry(i, j);\n            } else {\n                d[i-k][j] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.left.skew;\n                right.rotateCCW();\n                rotateCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) {\n            rotateCW();\n            skew      = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n            return true;\n        } else if (right.skew == Skew.BALANCED) {\n            rotateCW();\n            skew      = Skew.LEFT_HIGH;\n            left.skew = Skew.RIGHT_HIGH;\n            return false;\n        } else {\n            final Skew s = right.left.skew;\n            right.rotateCCW();\n            rotateCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        }\n    default:\n        skew = Skew.RIGHT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.left.skew;\n                right.rotateCCW();\n                rotateCW();\n                switch (s) {\n                case LEFT_HIGH:\n                    left.skew  = Skew.BALANCED;\n                    right.skew = Skew.RIGHT_HIGH;\n                    break;\n                case RIGHT_HIGH:\n                    left.skew  = Skew.LEFT_HIGH;\n                    right.skew = Skew.BALANCED;\n                    break;\n                default:\n                    left.skew  = Skew.BALANCED;\n                    right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) {\n            rotateCW();\n            skew      = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n            return true;\n        } else if (right.skew == Skew.BALANCED) {\n            rotateCW();\n            skew      = Skew.LEFT_HIGH;\n            left.skew = Skew.RIGHT_HIGH;\n            return false;\n        } else {\n            final Skew s = right.left.skew;\n            right.rotateCCW();\n            rotateCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        }\n    default:\n        skew = Skew.RIGHT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) {\n            rotateCCW();\n            skew      = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n            return true;\n        } else if (right.skew == Skew.BALANCED) {\n            rotateCCW();\n            skew      = Skew.LEFT_HIGH;\n            left.skew = Skew.RIGHT_HIGH;\n            return false;\n        } else {\n            final Skew s = right.left.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        }\n    default:\n        skew = Skew.RIGHT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    while (im >= 0) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) +\n                FastMath.abs(z) +\n                FastMath.abs(matrixT[im + 1][im + 1]));\n\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im--;\n    }\n\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    while (im > 0) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) + FastMath.abs(shift.x) + FastMath.abs(matrixT[im + 1][im + 1]));\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im--;\n    }\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    while (im >= 0) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) +\n                FastMath.abs(z) +\n                FastMath.abs(matrixT[im + 1][im + 1]));\n\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im--;\n    }\n\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    while (im > startIdx) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) +\n                FastMath.abs(z) +\n                FastMath.abs(matrixT[im + 1][im + 1]));\n\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im--;\n    }\n\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    while (im >= 0) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) + FastMath.abs(z) + FastMath.abs(matrixT[im + 1][im + 1]));\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im--;\n    }\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    while (im >= 0) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) +\n                FastMath.abs(z) +\n                FastMath.abs(matrixT[im + 1][im + 1]));\n\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im--;\n    }\n\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    while (im > startIdx) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) +\n                FastMath.abs(z) +\n                FastMath.abs(matrixT[im + 1][im + 1]));\n\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im--;\n    }\n\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    while (im >= 0) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) + FastMath.abs(z) + FastMath.abs(matrixT[im + 1][im + 1]));\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im--;\n    }\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    while (im > 0) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) + FastMath.abs(z) + FastMath.abs(matrixT[im + 1][im + 1]));\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im--;\n    }\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    while (im >= 0) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) + FastMath.abs(z) + FastMath.abs(matrixT[im + 1][im + 1]));\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im--;\n    }\n    return im;\n}"
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; node = node.getNext()) {\n        if (node.element.compareTo(reference) >= 0) {\n            return node;\n        }\n        candidate = node;\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node node = top;\n    while (node != null) {\n        if (node.element.compareTo(reference) >= 0) {\n            return node;\n        }\n        node = node.left;\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node node = top;\n    while (node != null) {\n        if (node.element.compareTo(reference) >= 0) {\n            return node;\n        }\n        node = node.left;\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node node = top;\n    while (node != null) {\n        if (node.element.compareTo(reference) >= 0) {\n            return node;\n        }\n        node = node.left;\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node node = top;\n    while (node != null) {\n        if (node.element.compareTo(reference) >= 0) {\n            return node;\n        }\n        node = node.left;\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node node = top;\n    while (node != null) {\n        if (node.element.compareTo(reference) >= 0) {\n            return node;\n        }\n        node = node.left;\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node node = top;\n    while (node != null) {\n        if (node.element.compareTo(reference) >= 0) {\n            return node;\n        }\n        node = node.left;\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; node = node.getNext()) {\n        if (node.element.compareTo(reference) >= 0) {\n            return node;\n        }\n        candidate = node;\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node node = top;\n    while (node != null) {\n        if (node.element.compareTo(reference) >= 0) {\n            return node;\n        }\n        node = node.left;\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; node = node.getNext()) {\n        if (node.element.compareTo(reference) >= 0) {\n            return node;\n        }\n        candidate = node;\n    }\n    return null;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = 0;\n    while ((index = indexOf(str, index)) != -1) {\n        deleteImpl(index, index + str.length(), str.length());\n        index += str.length();\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = 0;\n    while ((index = indexOf(str, index)) != -1) {\n        deleteImpl(index, index + str.length(), str.length());\n        index += str.length();\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    int index = 0;\n    while ((index = indexOf(str, index)) >= 0) {\n        deleteImpl(index, index + len, len);\n        index += len;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    int index = indexOf(str, 0);\n    while (index >= 0) {\n        deleteImpl(index, index + len, len);\n        index = indexOf(str, index + len);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        int index = indexOf(str, 0);\n        while (index >= 0) {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index + len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = 0;\n    while ((index = indexOf(str, index)) != -1) {\n        deleteImpl(index, index + str.length(), str.length());\n        index += str.length();\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    while (index >= 0) {\n        deleteImpl(index, index + len, len);\n        index = indexOf(str, index + len);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    int index = indexOf(str, 0);\n    while (index >= 0) {\n        deleteImpl(index, index + len, len);\n        index = indexOf(str, index + len);\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str);\n    while (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n        index = indexOf(str, index + str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    int index = indexOf(str);\n    while (index >= 0) {\n        deleteImpl(index, index + len, len);\n        index = indexOf(str, index + len);\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = parseInlineTypeDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = parseInlineTypeDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = parseInlineTypeDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = parseInlineTypeDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = parseInlineTypeDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = parseInlineTypeDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    return irNode;\n  }"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    if (elementTypeList == null) {\n      return null;\n    }\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    if (elementTypeList == null) {\n      return null;\n    }\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    if (elementTypeList == null) {\n      return null;\n    }\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n  Node elementTypeList = parseElementTypeList(token);\n  if (elementTypeList == null) {\n    return null;\n  }\n  arrayType.addChildToBack(elementTypeList);\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n  Node elementTypeList = parseElementTypeList(token);\n  arrayType.addChildToBack(elementTypeList);\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    if (elementTypeList == null) {\n      return null;\n    }\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n}"
    ],
    [
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3);\n}"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte c : bytes) {\n        int b = c;\n        if (b < 0) {\n            b = 256 + b;\n        }\n        if (b == ESCAPE_CHAR) {\n            buffer.write(0);\n            buffer.write(0);\n            buffer.write(0);\n            buffer.write(0);\n        } else if (b == '+') {\n            buffer.write(' ');\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        if (bytes[i] == ESCAPE_CHAR) {\n            i++;\n            int hex1 = Character.digit((char) bytes[i], RADIX);\n            int hex2 = Character.digit((char) bytes[i + 1], RADIX);\n            buffer.write((byte) ((hex1 << 4) + hex2));\n            i++;\n        } else {\n            buffer.write(bytes[i]);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    boolean inEscape = false;\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            inEscape = true;\n        } else if (inEscape) {\n            buffer.write((byte) ((c - '0') * 16 + (bytes[buffer.size() - 1] - '0')));\n            inEscape = false;\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        if (bytes[i] == ESCAPE_CHAR) {\n            if (i + 2 >= bytes.length) {\n                throw new DecoderException(\"Invalid quoted-printable encoding\");\n            }\n            final byte hex1 = (byte)Character.toLowerCase(Character.forDigit((bytes[i + 1] >> 4) & 0xF, RADIX));\n            final byte hex2 = (byte)Character.toLowerCase(Character.forDigit(bytes[i + 1] & 0xF, RADIX));\n            buffer.write((byte)Integer.parseInt(new String(new byte[]{hex1, hex2}), RADIX));\n            i += 2;\n        } else {\n            buffer.write(bytes[i]);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    boolean inEscape = false;\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            inEscape = true;\n        } else if (inEscape) {\n            buffer.write(c);\n            inEscape = false;\n        } else if (c == '+') {\n            buffer.write(' ');\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        if (bytes[i] == ESCAPE_CHAR) {\n            if (i + 2 < bytes.length) {\n                final int hex = Character.digit((char) bytes[i + 1], RADIX) << 4 | Character.digit((char) bytes[i + 2], RADIX);\n                buffer.write((byte) hex);\n                i += 2;\n            } else {\n                throw new DecoderException(\"Invalid URL decoding\");\n            }\n        } else {\n            buffer.write(bytes[i]);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    boolean inEscape = false;\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            inEscape = true;\n        } else if (inEscape) {\n            buffer.write(c);\n            inEscape = false;\n        } else if (c == '+') {\n            buffer.write(' ');\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    boolean inEscape = false;\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            inEscape = true;\n        } else if (inEscape) {\n            buffer.write(c);\n            inEscape = false;\n        } else {\n            if (c == '+') {\n                buffer.write(' ');\n            } else {\n                buffer.write(c);\n            }\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    boolean inEscape = false;\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            inEscape = true;\n        } else if (inEscape) {\n            buffer.write(c);\n            inEscape = false;\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    boolean inEscape = false;\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            inEscape = true;\n        } else if (inEscape) {\n            buffer.write((byte) ((c - '0') * 16 + (bytes[buffer.size() - 1] - '0')));\n            inEscape = false;\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    // Get the fields of the partial\n    DateTimeFieldType[] fields = partial.getFieldTypes();\n    // Check if the fields are contiguous\n    for (int i = 0; i < fields.length - 1; i++) {\n        DateTimeFieldType field1 = fields[i];\n        DateTimeFieldType field2 = fields[i + 1];\n        // Check if the range of the first field is equal to the unit of the second field\n        if (!field1.getRange().equals(field2.getUnit())) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size; i++) {\n        DateTimeFieldType fieldType = partial.getFieldType(i);\n        DateTimeField field = partial.getField(i);\n        if (i < size - 1) {\n            DateTimeFieldType nextFieldType = partial.getFieldType(i + 1);\n            DateTimeField nextField = partial.getField(i + 1);\n            if (!fieldType.range().equals(nextField.range())) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    // implement the logic here\n    // check if the partial is contiguous\n    // return true if it is, false otherwise\n    // you can use the getFieldType, getField, getValue, getChronology methods of the ReadablePartial interface\n    // you can also use the getDurationField and getRangeDurationField methods of the DateTimeField interface\n    // you can use the isSupported method of the DateTimeField interface\n    // you can use the getMillis method of the MillisProvider interface\n    // you can use the toDateTime method of the ReadablePartial interface\n    // you can use the equals method of the ReadablePartial interface\n    // you can use the hashCode method of the ReadablePartial interface\n    // you can use the toString method of the ReadablePartial interface\n    // you can use the compareTo method of the ReadablePartial interface\n    // you can use the isAfter method of the ReadablePartial interface\n    // you can use the isBefore method of the ReadablePartial interface\n    // you can use the getInstantChronology method of the DateTimeUtils class\n    // you can use the getIntervalChronology method of the DateTimeUtils class\n    // you can use the getReadableInterval method of the DateTimeUtils class\n    // you can use the getChronology method of the DateTimeUtils class\n    // you can use the getZone method of the DateTimeUtils class\n    // you can use the getPeriodType method of the DateTimeUtils class\n    // you can use the getDurationMillis method of the DateTimeUtils class\n    // you can use the toJulianDay method of the DateTimeUtils class\n    // you can use the toJulianDayNumber method of the DateTimeUtils class\n    // you can use the fromJulianDay method of the DateTimeUtils class\n    // you can use the getMillis method of the MillisProvider interface\n    // you can use the getInstantMillis method of the DateTimeUtils class\n    // you can use the getIntervalChronology method of the DateTimeUtils class\n    // you can use the getIntervalChronology method of the DateTimeUtils class\n    // you can use the getIntervalChronology method of the DateTimeUtils class\n    // you can use the getIntervalChronology method of the DateTimeUtils class\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    // Your code here\n    return false;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    DateTimeFieldType[] fields = partial.getFieldTypes();\n    for (int i = 0; i < fields.length - 1; i++) {\n        DateTimeFieldType field = fields[i];\n        DateTimeFieldType nextField = fields[i + 1];\n        if (!field.getRangeDurationField().equals(nextField.getRangeDurationField())) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    DateTimeField[] fields = partial.getFieldTypes();\n    for (int i = 0; i < fields.length - 1; i++) {\n        DateTimeField field = fields[i];\n        DateTimeField nextField = fields[i + 1];\n        if (!field.getRangeDurationField().equals(nextField.getRangeDurationField())) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) {\n        DateTimeFieldType fieldType = partial.getFieldType(i);\n        DateTimeField field = partial.getField(i);\n        int fieldValue = partial.getValue(i);\n        DateTimeFieldType nextFieldType = partial.getFieldType(i + 1);\n        DateTimeField nextField = partial.getField(i + 1);\n        int nextFieldValue = partial.getValue(i + 1);\n        if (!fieldType.range().equals(nextField.range())) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    // TO DO: implement the logic to check if the partial is contiguous\n    return false; // TO DO: implement the logic to check if the partial is contiguous\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    // Get the fields of the partial\n    DateTimeFieldType[] fields = partial.getFieldTypes();\n    // Check if the partial is contiguous\n    for (int i = 0; i < fields.length - 1; i++) {\n        DateTimeFieldType field = fields[i];\n        DateTimeFieldType nextField = fields[i + 1];\n        // Check if the range of the current field is equal to the unit of the next field\n        if (!field.getRange().equals(nextField.getUnit())) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size; i++) {\n        DateTimeFieldType fieldType = partial.getFieldType(i);\n        DateTimeField field = partial.getField(i);\n        int value = partial.getValue(i);\n        DateTimeFieldType nextFieldType = i < size - 1 ? partial.getFieldType(i + 1) : null;\n        DateTimeField nextField = i < size - 1 ? partial.getField(i + 1) : null;\n        int nextValue = i < size - 1 ? partial.getValue(i + 1) : 0;\n        if (fieldType.getRange() != nextFieldType.getRange()) {\n            return false;\n        }\n        if (field.getDurationField().getUnitMillis() != nextField.getDurationField().getUnitMillis()) {\n            return false;\n        }\n        if (value + field.getDurationField().getUnitMillis() > nextValue) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Set<O> set = new HashSet<O>();\n    for (final O obj : a) {\n        set.add(obj);\n    }\n    for (final O obj : b) {\n        set.add(obj);\n    }\n    return new ArrayList<O>(set);\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Set<O> set = new HashSet<O>();\n    for (final O obj : a) {\n        set.add(obj);\n    }\n    for (final O obj : b) {\n        set.add(obj);\n    }\n    return new ArrayList<O>(set);\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Set<O> set = new HashSet<O>();\n    for (final O obj : a) {\n        set.add(obj);\n    }\n    for (final O obj : b) {\n        set.add(obj);\n    }\n    return new ArrayList<O>(set);\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Set<O> set = new HashSet<O>();\n    for (final O obj : a) {\n        set.add(obj);\n    }\n    for (final O obj : b) {\n        set.add(obj);\n    }\n    return new ArrayList<O>(set);\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Set<O> set = new HashSet<O>();\n    for (final O obj : a) {\n        set.add(obj);\n    }\n    for (final O obj : b) {\n        set.add(obj);\n    }\n    return new ArrayList<O>(set);\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Set<O> set = new HashSet<O>();\n    for (final O obj : a) {\n        set.add(obj);\n    }\n    for (final O obj : b) {\n        set.add(obj);\n    }\n    return new ArrayList<O>(set);\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Set<O> set = new HashSet<O>();\n    for (final O obj : a) {\n        set.add(obj);\n    }\n    for (final O obj : b) {\n        set.add(obj);\n    }\n    return new ArrayList<O>(set);\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Set<O> set = new HashSet<O>();\n    for (final O obj : a) {\n        set.add(obj);\n    }\n    for (final O obj : b) {\n        set.add(obj);\n    }\n    return new ArrayList<O>(set);\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Set<O> set = new HashSet<O>();\n    for (final O obj : a) {\n        set.add(obj);\n    }\n    for (final O obj : b) {\n        set.add(obj);\n    }\n    return new ArrayList<O>(set);\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final Set<O> set = new HashSet<O>();\n    for (final O obj : a) {\n        set.add(obj);\n    }\n    for (final O obj : b) {\n        set.add(obj);\n    }\n    return new ArrayList<O>(set);\n}"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    for (Node param : params.getChildren()) {\n        result.add(Node.newString(param.getStringValue()));\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    for (Node param : params.getChildren()) {\n        result.add(Node.newString(param.getString()));\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n        result.add(new StringNode(Node.STRING, param.getString()));\n        param = param.getNext();\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node child = params.getFirstChild();\n    while (child != null) {\n        if (child.getType() == Node.TYPE_STRING) {\n            result.add(child);\n        }\n        child = child.getNext();\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    for (Node param : params.getChildren()) {\n        if (param.getType() == Node.TYPE_STRING) {\n            result.add(param);\n        }\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n        result.add(new StringNode(Node.STRING, param.getString(), param.getLineno(), param.getCharno()));\n        param = param.getNext();\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n        result.add(Node.newString(param.getString()));\n        param = param.getNext();\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    for (Node param : params.getChildren()) {\n        if (param.getType() == Node.TYPE_STRING) {\n            result.add(param);\n        }\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    for (Node param : params.getChildren()) {\n        if (param.getType() == Node.TYPE_STRING) {\n            result.add((Node) param.clone());\n        }\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n        result.add(Node.newString(param.getString()));\n        param = param.getNext();\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return capitalize(str);\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return capitalize(str);\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    if (id.equals(\"UTC\")) {\n        return \"UTC\";\n    }\n    if (id.equals(\"GMT\")) {\n        return \"UTC\";\n    }\n    if (id.equals(\"Z\")) {\n        return \"UTC\";\n    }\n    if (id.equals(\"GMT-0\")) {\n        return \"UTC\";\n    }\n    if (id.equals(\"GMT+0\")) {\n        return \"UTC\";\n    }\n    if (id.equals(\"GMT-1\")) {\n        return \"GMT-1\";\n    }\n    if (id.equals(\"GMT+1\")) {\n        return \"GMT+1\";\n    }\n    if (id.equals(\"GMT-2\")) {\n        return \"GMT-2\";\n    }\n    if (id.equals(\"GMT+2\")) {\n        return \"GMT+2\";\n    }\n    if (id.equals(\"GMT-3\")) {\n        return \"GMT-3\";\n    }\n    if (id.equals(\"GMT+3\")) {\n        return \"GMT+3\";\n    }\n    if (id.equals(\"GMT-4\")) {\n        return \"GMT-4\";\n    }\n    if (id.equals(\"GMT+4\")) {\n        return \"GMT+4\";\n    }\n    if (id.equals(\"GMT-5\")) {\n        return \"GMT-5\";\n    }\n    if (id.equals(\"GMT+5\")) {\n        return \"GMT+5\";\n    }\n    if (id.equals(\"GMT-6\")) {\n        return \"GMT-6\";\n    }\n    if (id.equals(\"GMT+6\")) {\n        return \"GMT+6\";\n    }\n    if (id.equals(\"GMT-7\")) {\n        return \"GMT-7\";\n    }\n    if (id.equals(\"GMT+7\")) {\n        return \"GMT+7\";\n    }\n    if (id.equals(\"GMT-8\")) {\n        return \"GMT-8\";\n    }\n    if (id.equals(\"GMT+8\")) {\n        return \"GMT+8\";\n    }\n    if (id.equals(\"GMT-9\")) {\n        return \"GMT-9\";\n    }\n    if (id.equals(\"GMT+9\")) {\n        return \"GMT+9\";\n    }\n    if (id.equals(\"GMT-10\")) {\n        return \"GMT-10\";\n    }\n    if (id.equals(\"GMT+10\")) {\n        return \"GMT+10\";\n    }\n    if (id.equals(\"GMT-11\")) {\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n        if (id == null) {\n            return null;\n        }\n        if (id.equals(\"UTC\")) {\n            return \"UTC\";\n        }\n        if (id.equals(\"GMT\")) {\n            return \"UTC\";\n        }\n        if (id.equals(\"GMT+0\")) {\n            return \"UTC\";\n        }\n        if (id.equals(\"GMT-0\")) {\n            return \"UTC\";\n        }\n        if (id.startsWith(\"GMT+\")) {\n            return \"UTC\" + id.substring(4);\n        }\n        if (id.startsWith(\"GMT-\")) {\n            return \"UTC\" + id.substring(4);\n        }\n        if (id.equals(\"EST\")) {\n            return \"America/New_York\";\n        }\n        if (id.equals(\"EDT\")) {\n            return \"America/New_York\";\n        }\n        if (id.equals(\"CST\")) {\n            return \"America/Chicago\";\n        }\n        if (id.equals(\"CDT\")) {\n            return \"America/Chicago\";\n        }\n        if (id.equals(\"MST\")) {\n            return \"America/Denver\";\n        }\n        if (id.equals(\"MDT\")) {\n            return \"America/Denver\";\n        }\n        if (id.equals(\"PST\")) {\n            return \"America/Los_Angeles\";\n        }\n        if (id.equals(\"PDT\")) {\n            return \"America/Los_Angeles\";\n        }\n        return null;\n    }",
      "private static synchronized String getConvertedId(String id)  {\n        if (id == null) {\n            return null;\n        }\n        // Check if the id is a fixed offset zone\n        if (id.startsWith(\"GMT\")) {\n            int offset = parseOffset(id.substring(3));\n            return DateTimeZone.forOffsetHoursMinutes(offset / 60, offset % 60).getID();\n        }\n        // Check if the id is a UTC offset zone\n        if (id.startsWith(\"UTC\")) {\n            int offset = parseOffset(id.substring(3));\n            return DateTimeZone.forOffsetHoursMinutes(offset / 60, offset % 60).getID();\n        }\n        // Check if the id is a time zone\n        try {\n            DateTimeZone zone = DateTimeZone.forID(id);\n            return zone.getID();\n        } catch (DateTimeException e) {\n            // Try to convert to a fixed offset zone\n            int offset = parseOffset(id);\n            return DateTimeZone.forOffsetHoursMinutes(offset / 60, offset % 60).getID();\n        }\n    }",
      "private static synchronized String getConvertedId(String id)  {\n        if (id == null) {\n            return null;\n        }\n        if (id.length() == 5) {\n            // Fixed offset zone\n            return fixedOffsetZone(id, parseOffset(id)).getID();\n        } else {\n            // Other zones\n            return forID(id).getID();\n        }\n    }",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    // Try to convert the id using the default name provider\n    NameProvider nameProvider = getDefaultNameProvider();\n    String convertedId = nameProvider.getShortName(Locale.getDefault(), id, \"GMT\");\n    if (convertedId != null) {\n        return convertedId;\n    }\n    // If the default name provider didn't work, try the fixed offset cache\n    DateTimeZone zone = DateTimeZone.forID(id);\n    if (zone.isFixed()) {\n        return zone.getID();\n    }\n    // If the fixed offset cache didn't work, try the available IDs\n    Set<String> availableIDs = getAvailableIDs();\n    for (String availableID : availableIDs) {\n        if (availableID.equals(id)) {\n            return availableID;\n        }\n    }\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n        if (id == null) {\n            return null;\n        }\n        if (id.equals(\"GMT\")) {\n            return \"UTC\";\n        }\n        if (id.equals(\"UTC\")) {\n            return id;\n        }\n        if (id.equals(\"EST\")) {\n            return \"America/New_York\";\n        }\n        if (id.equals(\"EDT\")) {\n            return \"America/New_York\";\n        }\n        if (id.equals(\"CST\")) {\n            return \"America/Chicago\";\n        }\n        if (id.equals(\"CDT\")) {\n            return \"America/Chicago\";\n        }\n        if (id.equals(\"MST\")) {\n            return \"America/Denver\";\n        }\n        if (id.equals(\"MDT\")) {\n            return \"America/Denver\";\n        }\n        if (id.equals(\"PST\")) {\n            return \"America/Los_Angeles\";\n        }\n        if (id.equals(\"PDT\")) {\n            return \"America/Los_Angeles\";\n        }\n        return null;\n    }",
      "private static synchronized String getConvertedId(String id)  {\n        if (id == null) {\n            return null;\n        }\n        // Check for fixed offset zones\n        if (id.length() > 3 && id.startsWith(\"GMT\")) {\n            int offset = parseOffset(id.substring(3));\n            return \"GMT\" + printOffset(offset);\n        }\n        // Check for timezones with a colon\n        int colon = id.indexOf(':');\n        if (colon != -1) {\n            String zoneId = id.substring(0, colon);\n            int offset = parseOffset(id.substring(colon + 1));\n            return zoneId + printOffset(offset);\n        }\n        // Check for timezones without a colon\n        int offset = parseOffset(id);\n        return id + printOffset(offset);\n    }",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    if (id.equals(\"GMT\")) {\n        return \"UTC\";\n    }\n    if (id.equals(\"UTC\")) {\n        return \"UTC\";\n    }\n    if (id.equals(\"GMT-0\")) {\n        return \"UTC\";\n    }\n    if (id.equals(\"GMT+0\")) {\n        return \"UTC\";\n    }\n    if (id.equals(\"GMT-1\")) {\n        return \"GMT-01:00\";\n    }\n    if (id.equals(\"GMT+1\")) {\n        return \"GMT+01:00\";\n    }\n    if (id.equals(\"GMT-2\")) {\n        return \"GMT-02:00\";\n    }\n    if (id.equals(\"GMT+2\")) {\n        return \"GMT+02:00\";\n    }\n    if (id.equals(\"GMT-3\")) {\n        return \"GMT-03:00\";\n    }\n    if (id.equals(\"GMT+3\")) {\n        return \"GMT+03:00\";\n    }\n    if (id.equals(\"GMT-4\")) {\n        return \"GMT-04:00\";\n    }\n    if (id.equals(\"GMT+4\")) {\n        return \"GMT+04:00\";\n    }\n    if (id.equals(\"GMT-5\")) {\n        return \"GMT-05:00\";\n    }\n    if (id.equals(\"GMT+5\")) {\n        return \"GMT+05:00\";\n    }\n    if (id.equals(\"GMT-6\")) {\n        return \"GMT-06:00\";\n    }\n    if (id.equals(\"GMT+6\")) {\n        return \"GMT+06:00\";\n    }\n    if (id.equals(\"GMT-7\")) {\n        return \"GMT-07:00\";\n    }\n    if (id.equals(\"GMT+7\")) {\n        return \"GMT+07:00\";\n    }\n    if (id.equals(\"GMT-8\")) {\n        return \"GMT-08:00\";\n    }\n    if (id.equals(\"GMT+8\")) {\n        return \"GMT+08:00\";\n    }\n    if (id.equals(\"GMT-9\")) {\n        return \"GMT-09:00\";\n    }\n    if (id.equals(\"GMT+9\")) {\n        return \"GMT+09:00\";\n    }\n    if (id.equals(\"GMT-10\")) {\n        return \"GMT-10:00\";\n    }\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    if (id.equals(\"UTC\")) {\n        return \"UTC\";\n    }\n    if (id.equals(\"GMT\")) {\n        return \"UTC\";\n    }\n    if (id.equals(\"GMT+0\")) {\n        return \"UTC\";\n    }\n    if (id.equals(\"GMT-0\")) {\n        return \"UTC\";\n    }\n    // Add more conversions here...\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n        if (id == null) {\n            return null;\n        }\n        if (id.equals(\"UTC\")) {\n            return \"UTC\";\n        }\n        if (id.equals(\"GMT\")) {\n            return \"UTC\";\n        }\n        if (id.equals(\"Z\")) {\n            return \"UTC\";\n        }\n        if (id.equals(\"GMT-0\")) {\n            return \"UTC\";\n        }\n        if (id.equals(\"GMT+0\")) {\n            return \"UTC\";\n        }\n        if (id.equals(\"GMT-1\")) {\n            return \"UTC-01:00\";\n        }\n        if (id.equals(\"GMT+1\")) {\n            return \"UTC+01:00\";\n        }\n        if (id.equals(\"GMT-2\")) {\n            return \"UTC-02:00\";\n        }\n        if (id.equals(\"GMT+2\")) {\n            return \"UTC+02:00\";\n        }\n        if (id.equals(\"GMT-3\")) {\n            return \"UTC-03:00\";\n        }\n        if (id.equals(\"GMT+3\")) {\n            return \"UTC+03:00\";\n        }\n        if (id.equals(\"GMT-4\")) {\n            return \"UTC-04:00\";\n        }\n        if (id.equals(\"GMT+4\")) {\n            return \"UTC+04:00\";\n        }\n        if (id.equals(\"GMT-5\")) {\n            return \"UTC-05:00\";\n        }\n        if (id.equals(\"GMT+5\")) {\n            return \"UTC+05:00\";\n        }\n        if (id.equals(\"GMT-6\")) {\n            return \"UTC-06:00\";\n        }\n        if (id.equals(\"GMT+6\")) {\n            return \"UTC+06:00\";\n        }\n        if (id.equals(\"GMT-7\")) {\n            return \"UTC-07:00\";\n        }\n        if (id.equals(\"GMT+7\")) {\n            return \"UTC+07:00\";\n        }\n        if (id.equals(\"GMT-8\")) {\n            return \"UTC-08:00\";\n        }\n        if (id.equals(\"GMT+8\")) {\n            return \"UTC+08:00\";\n        }\n        if (id.equals(\"GMT-9\")) {\n            return \"UTC-09:00\";\n        }\n        if (id.equals(\"GMT+9\")) {\n            return \"UTC+09:00\";\n        }\n        if (id.equals(\"GMT-10\")) {\n}\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix jacobian = jF.value(params);\n    final RealMatrix weightMatrix = getWeightSquareRoot();\n    return weightMatrix.multiply(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final MultivariateMatrixFunction jacobian = this.jacobian;\n    final int nR = this.rows;\n    final int nC = this.cols;\n\n    final RealMatrix weightMatrix = getWeightSquareRoot();\n    if (weightMatrix.getRowDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n    }\n    if (weightMatrix.getColumnDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n    }\n\n    final double[][] weightedJacobian = new double[nR][nC];\n    for (int i = 0; i < nR; i++) {\n        final double[] residualsWeights = new double[nC];\n        for (int j = 0; j < nC; j++) {\n            residualsWeights[j] = weightMatrix.getEntry(i, j);\n        }\n        final double[] grad = jacobian.value(params);\n        for (int j = 0; j < nC; j++) {\n            weightedJacobian[i][j] = residualsWeights[j] * grad[j];\n        }\n    }\n    return RealMatrix.createMatrix(nR, nC, weightedJacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    double[][] weightedJacobian = new double[rows][cols];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            weightedJacobian[i][j] = weightedResidualJacobian[i][j] * weightMatrixSqrt.getEntry(i, j);\n        }\n    }\n    return RealMatrix.createMatrix(rows, cols, weightedJacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    RealMatrix weightedJacobian = jF.value(params);\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix jacobian = jF.value(params);\n    final RealMatrix weightMatrix = getWeightSquareRoot();\n    final RealMatrix weightedJacobian = weightMatrix.multiply(jacobian);\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    RealMatrix weightedJacobian = jF.value(params);\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    double[][] jacobian = jF.value(params);\n    RealMatrix weightedJacobian = RealMatrixFactory.createRealMatrix(rows, cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            weightedJacobian.setEntry(i, j, jacobian[i][j] * weightMatrixSqrt.getEntry(i, i));\n        }\n    }\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final MultivariateMatrixFunction jacobian = this.jacobian;\n    final RealMatrix weightedJacobian = jacobian.value(params);\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix jacobian = jF.value(params);\n    final RealMatrix weightMatrix = getWeightSquareRoot();\n    final RealMatrix weightedJacobian = weightMatrix.multiply(jacobian);\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final MultivariateMatrixFunction jacobian = this.jacobian;\n    final int nR = this.rows;\n    final int nC = this.cols;\n    final RealMatrix weightMatrix = getWeightSquareRoot();\n    if (weightMatrix.getRowDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n    }\n    if (weightMatrix.getColumnDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n    }\n    final RealMatrix jacobianMatrix = jacobian.value(params);\n    final RealMatrix weightedJacobian = weightMatrix.multiply(jacobianMatrix);\n    return weightedJacobian;\n}"
    ],
    [
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (leastIndex == -1 || comparator.compare(values.get(leastIndex), values.get(i)) > 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator not set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (leastIndex == -1 || comparator.compare(values.get(leastIndex), values.get(i)) > 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator not set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (leastIndex == -1 || comparator.compare(values.get(leastIndex), values.get(i)) > 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator not set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (leastIndex == -1 || comparator.compare(values.get(leastIndex), values.get(i)) > 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (leastIndex == -1 || comparator.compare(values.get(leastIndex), values.get(i)) > 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (leastIndex == -1 || comparator.compare(values.get(leastIndex), values.get(i)) > 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator not set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (leastIndex == -1 || comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator not set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (leastIndex == -1 || comparator.compare(values.get(leastIndex), values.get(i)) > 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator not set\");\n    }\n    int leastIndex = -1;\n    int leastValue = Integer.MAX_VALUE;\n    for (int i = 0; i < values.size(); i++) {\n        if (values.get(i) != null && comparator.compare(values.get(i), leastValue) < 0) {\n            leastIndex = i;\n            leastValue = values.get(i);\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    int leastValue = Integer.MAX_VALUE;\n    for (int i = 0; i < values.size(); i++) {\n        if (values.get(i) != null && comparator.compare(values.get(i), leastValue) < 0) {\n            leastIndex = i;\n            leastValue = values.get(i);\n        }\n    }\n    return leastIndex;\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    Object value = parentPointer.getImmediateNode();\n    return NodePointer.newChildNodePointer(parentPointer, name, value);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    Object value = parentPointer.getImmediateNode();\n    return NodePointer.newChildNodePointer(parentPointer, name, value);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n        Object value = parentPointer.getImmediateNode();\n        return NodePointer.newChildNodePointer(parentPointer, name, value);\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    int index = ((NodeIndexTest) step.getNodeTest()).getIndex();\n    if (index != -1) {\n        return new CollectionElementPointer(parentPointer, name, index);\n    } else {\n        return new PropertyOwnerPointer(parentPointer, name);\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    int index = ((NodeIndexTest) step.getNodeTest()).getIndex();\n    if (index == -1) {\n        return parentPointer.getPropertyPointer().getChildPointer(name);\n    } else {\n        return parentPointer.getPropertyPointer().getChildPointer(name, index);\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    Object value = parentPointer.getImmediateNode();\n    return NodePointer.newChildNodePointer(parentPointer, name, value);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n        Object value = parentPointer.getImmediateNode();\n        return NodePointer.newChildNodePointer(parentPointer, name, value);\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    return new PropertyOwnerPointer(parentPointer, name);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    return new PropertyOwnerPointer(parentPointer, name);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n        int index = step.getIndex();\n        return new PropertyOwnerPointer(parentPointer, name, index);\n    }"
    ],
    [
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = Math.min(inf, op.getLocation().getX());\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = Math.min(inf, op.getLocation().getX());\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = Math.min(inf, op.getLocation().getX());\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = Math.min(inf, op.getLocation().getX());\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = Math.min(inf, op.getLocation().getX());\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = Math.min(inf, op.getLocation().getX());\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = Math.min(inf, op.getLocation().getX());\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = Math.min(inf, op.getLocation().getX());\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = Math.min(inf, op.getLocation().getX());\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = Math.min(inf, op.getLocation().getX());\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}"
    ],
    [
      "private boolean setNextObject()  {\n        if (!hasNext()) {\n            return false;\n        }\n        while (iterator.hasNext()) {\n            E next = iterator.next();\n            if (predicate.evaluate(next)) {\n                nextObject = next;\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        return false;\n    }",
      "private boolean setNextObject()  {\n        if (!hasNext()) {\n            return false;\n        }\n        nextObject = iterator.next();\n        while (!predicate.evaluate(nextObject)) {\n            nextObject = iterator.next();\n            if (!iterator.hasNext()) {\n                return false;\n            }\n        }\n        nextObjectSet = true;\n        return true;\n    }",
      "private boolean setNextObject()  {\n        if (!iterator.hasNext()) {\n            nextObject = null;\n            nextObjectSet = false;\n            return false;\n        }\n        E next = iterator.next();\n        if (predicate.evaluate(next)) {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n        return setNextObject();\n    }",
      "private boolean setNextObject()  {\n    if (!iterator.hasNext()) {\n        nextObjectSet = false;\n        return false;\n    }\n    E next = iterator.next();\n    if (!predicate.evaluate(next)) {\n        nextObjectSet = false;\n        return setNextObject();\n    }\n    nextObject = next;\n    nextObjectSet = true;\n    return true;\n}",
      "private boolean setNextObject()  {\n        if (!hasNext()) {\n            return false;\n        }\n        while (iterator.hasNext()) {\n            E obj = iterator.next();\n            if (predicate.evaluate(obj)) {\n                nextObject = obj;\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        return false;\n    }",
      "private boolean setNextObject()  {\n        if (!nextObjectSet) {\n            while (iterator.hasNext()) {\n                E next = iterator.next();\n                if (predicate.evaluate(next)) {\n                    nextObject = next;\n                    nextObjectSet = true;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }",
      "private boolean setNextObject()  {\n        if (!iterator.hasNext()) {\n            return false;\n        }\n        E next = iterator.next();\n        if (!predicate.evaluate(next)) {\n            setNextObject();\n        } else {\n            nextObject = next;\n            nextObjectSet = true;\n        }\n        return true;\n    }",
      "private boolean setNextObject()  {\n    if (!hasNext()) {\n        return false;\n    }\n    nextObject = iterator.next();\n    while (!predicate.evaluate(nextObject)) {\n        nextObject = iterator.next();\n        if (!iterator.hasNext()) {\n            nextObject = null;\n            nextObjectSet = false;\n            return false;\n        }\n    }\n    nextObjectSet = true;\n    return true;\n}",
      "private boolean setNextObject()  {\n    if (!iterator.hasNext()) {\n        return false;\n    }\n    E next = iterator.next();\n    if (predicate.evaluate(next)) {\n        nextObject = next;\n        nextObjectSet = true;\n    } else {\n        setNextObject();\n    }\n    return true;\n}",
      "private boolean setNextObject()  {\n        if (!iterator.hasNext()) {\n            return false;\n        }\n        E next = iterator.next();\n        if (!predicate.evaluate(next)) {\n            return setNextObject();\n        }\n        nextObject = next;\n        nextObjectSet = true;\n        return true;\n    }"
    ],
    [
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < CMAESOptimizer.this.getLowerBound()[i]) {\n            repaired[i] = CMAESOptimizer.this.getLowerBound()[i];\n        } else if (x[i] > CMAESOptimizer.this.getUpperBound()[i]) {\n            repaired[i] = CMAESOptimizer.this.getUpperBound()[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < CMAESOptimizer.this.getLowerBound()[i]) {\n            repaired[i] = CMAESOptimizer.this.getLowerBound()[i];\n        } else if (x[i] > CMAESOptimizer.this.getUpperBound()[i]) {\n            repaired[i] = CMAESOptimizer.this.getUpperBound()[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < CMAESOptimizer.this.getLowerBound()[i]) {\n            repaired[i] = CMAESOptimizer.this.getLowerBound()[i];\n        } else if (x[i] > CMAESOptimizer.this.getUpperBound()[i]) {\n            repaired[i] = CMAESOptimizer.this.getUpperBound()[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < CMAESOptimizer.this.getLowerBound()[i]) {\n            repaired[i] = CMAESOptimizer.this.getLowerBound()[i];\n        } else if (x[i] > CMAESOptimizer.this.getUpperBound()[i]) {\n            repaired[i] = CMAESOptimizer.this.getUpperBound()[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < CMAESOptimizer.this.getLowerBound()[i]) {\n            repaired[i] = CMAESOptimizer.this.getLowerBound()[i];\n        } else if (x[i] > CMAESOptimizer.this.getUpperBound()[i]) {\n            repaired[i] = CMAESOptimizer.this.getUpperBound()[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    return schurTransformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    return schurTransformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    return schurTransformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    return schurTransformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    return schurTransformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    return schurTransformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    return schurTransformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    return schurTransformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    return schurTransformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    return schurTransformer;\n}"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (E constant : enumClass.getEnumConstants()) {\n            if ((value & (1 << (constant.ordinal() % Long.SIZE))) != 0) {\n                result.add(constant);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    if (values.length == 0) {\n        return EnumSet.noneOf(enumClass);\n    }\n    if (values.length == 1) {\n        return EnumSet.of(enumClass.getEnumConstants()[Long.bitCount(values[0])]);\n    }\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (E e : enumClass.getEnumConstants()) {\n            if ((value & (1L << e.ordinal())) != 0) {\n                result.add(e);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    Validate.notNull(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (E value : enumClass.getEnumConstants()) {\n            if ((values[i] & (1 << (value.ordinal() % Long.SIZE))) != 0) {\n                result.add(value);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (E constant : enumClass.getEnumConstants()) {\n            if ((value & (1 << (constant.ordinal() % Long.SIZE))) != 0) {\n                result.add(constant);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    if (values.length == 0) {\n        return EnumSet.noneOf(enumClass);\n    }\n    long value = 0;\n    for (long v : values) {\n        value |= v;\n    }\n    return processBitVector(enumClass, value);\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (E e : enumClass.getEnumConstants()) {\n            if ((value & (1 << (e.ordinal() % Long.SIZE))) != 0) {\n                result.add(e);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (E e : enumClass.getEnumConstants()) {\n            if ((values[i] & (1 << (e.ordinal() % Long.SIZE))) != 0) {\n                result.add(e);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    if (values.length == 0) {\n        return EnumSet.noneOf(enumClass);\n    }\n    long value = 0;\n    for (long v : values) {\n        value |= v;\n    }\n    return processBitVector(enumClass, value);\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    Validate.notNull(enumClass);\n    Validate.noNullElements(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (E e : enumClass.getEnumConstants()) {\n            if ((value & (1 << (e.ordinal() % Long.SIZE))) != 0) {\n                result.add(e);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    if (values.length == 0) {\n        return EnumSet.noneOf(enumClass);\n    }\n    Validate.notNull(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if (((value >> j) & 1) == 1) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long instantLocal = oldInstant + getOffset(oldInstant);\n    long instantUTC = instantLocal;\n    if (newZone != this) {\n        instantUTC = newZone.convertLocalToUTC(instantLocal, true);\n    }\n    return instantUTC;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long localInstant = oldInstant - offset;\n    long newInstant = localInstant;\n    if (newZone != this) {\n        newInstant = newZone.convertLocalToUTC(localInstant, true);\n    }\n    return newInstant + offset;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long instantLocal = oldInstant + offset;\n    long instantUTC = instantLocal;\n    if (newZone != this) {\n        int newOffset = newZone.getOffset(instantLocal);\n        instantUTC = instantLocal - newOffset + offset;\n    }\n    return instantUTC;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long instantLocal = oldInstant - getOffset(oldInstant);\n    long instantUTC = instantLocal;\n    if (newZone != this) {\n        int offsetNew = newZone.getOffset(instantLocal);\n        instantUTC += offsetNew - getOffset(instantLocal);\n    }\n    return instantUTC;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long instantLocal = oldInstant - getOffset(oldInstant);\n    long instantUTC = instantLocal;\n    if (newZone != this) {\n        instantUTC = instantLocal + newZone.getOffset(instantLocal);\n    }\n    return instantUTC;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long localInstant = oldInstant - offset;\n    long newInstant = localInstant;\n    while (true) {\n        int newOffset = newZone.getOffset(newInstant);\n        if (newOffset == offset) {\n            return newInstant;\n        }\n        newInstant = newInstant + (newOffset - offset);\n    }\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long instantLocal = oldInstant + getOffset(oldInstant);\n    long instantUTC = instantLocal;\n    if (newZone != this) {\n        instantUTC = newZone.convertLocalToUTC(instantLocal, true);\n    }\n    return instantUTC;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long instantLocal = oldInstant - getOffset(oldInstant);\n    long instantUTC = instantLocal;\n    if (newZone != this) {\n        instantUTC = instantLocal + newZone.getOffset(instantLocal);\n    }\n    return instantUTC;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long instantLocal = oldInstant - getOffset(oldInstant);\n    long instantUTC = instantLocal;\n    if (newZone != this) {\n        int offsetNew = newZone.getOffset(instantUTC);\n        instantUTC = instantLocal + offsetNew;\n    }\n    return instantUTC;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long localInstant = oldInstant - offset;\n    long newInstant = localInstant;\n    if (newZone != this) {\n        newInstant = newZone.convertLocalToUTC(localInstant, true);\n    }\n    return newInstant + offset;\n}"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count + 1);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    milliseconds = calendar.get(Calendar.MILLISECOND);\n    seconds = calendar.get(Calendar.SECOND);\n    minutes = calendar.get(Calendar.MINUTE);\n    hours = calendar.get(Calendar.HOUR_OF_DAY);\n    days = calendar.get(Calendar.DAY_OF_MONTH);\n    months = calendar.get(Calendar.MONTH);\n    years = calendar.get(Calendar.YEAR);\n\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n\n    if (unit.getCalendarField() == Calendar.MILLISECOND) {\n        value = (value + count - 1) % count;\n    } else {\n        value = (value + count - 1) / count;\n    }\n\n    calendar.set(Calendar.MILLISECOND, value % 1000);\n    calendar.set(Calendar.SECOND, value / 1000 % 60);\n    calendar.set(Calendar.MINUTE, value / 60000 % 60);\n    calendar.set(Calendar.HOUR_OF_DAY, value / 3600000 % 24);\n    calendar.set(Calendar.DAY_OF_MONTH, value / 86400000 % 31);\n    calendar.set(Calendar.MONTH, value / 2592000000 % 12);\n    calendar.set(Calendar.YEAR, value / 31536000000);\n\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count + 1);\n\n    calendar.set(Calendar.MILLISECOND, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.DAY_OF_MONTH, 1);\n    calendar.set(Calendar.MONTH, 0);\n    calendar.set(Calendar.YEAR, 1970);\n\n    calendar.add(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n\n    calendar.set(Calendar.MILLISECOND, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.DAY_OF_MONTH, 1);\n    calendar.set(Calendar.MONTH, 0);\n    calendar.set(Calendar.YEAR, 1970);\n\n    calendar.add(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    calendar.add(unit.getCalendarField(), count);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n\n    calendar.set(Calendar.MILLISECOND, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.DAY_OF_MONTH, 1);\n    calendar.set(Calendar.MONTH, 0);\n    calendar.set(Calendar.YEAR, 1970);\n\n    calendar.add(unit.getCalendarField(), value);\n\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count + 1);\n\n    calendar.set(Calendar.MILLISECOND, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.DAY_OF_MONTH, 1);\n    calendar.set(Calendar.MONTH, 0);\n    calendar.set(Calendar.YEAR, 1970);\n\n    calendar.add(unit.getCalendarField(), value);\n\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n\n    calendar.add(unit.getCalendarField(), count);\n    return calendar.getTime();\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String value = this.variableResolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    buf.replace(startPos, endPos - startPos, value);\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String value = getVariableResolver().lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    buf.replace(startPos, endPos - startPos, value);\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String value = getVariableResolver().lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    buf.replace(startPos, endPos - startPos, value);\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String value = getVariableResolver().lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String value = null;\n    if (variableName != null) {\n        value = getVariableResolver().lookup(variableName);\n    }\n    if (value == null) {\n        value = \"\";\n    }\n    return value;\n}"
    ],
    [
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    char[] chars = str.toUpperCase().toCharArray();\n    StringBuilder sb = new StringBuilder();\n    sb.append(chars[0]);\n    for (int i = 1; i < chars.length; i++) {\n        char ch = chars[i];\n        if (ch == ' ') {\n            continue;\n        }\n        if (ch == 'H' || ch == 'K' || ch == 'W' || ch == 'X' || ch == 'Y') {\n            continue;\n        }\n        if (ch >= 'A' && ch <= 'Z') {\n            sb.append(map(ch));\n        } else {\n            sb.append('0');\n        }\n    }\n    while (sb.length() < 4) {\n        sb.append('0');\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase();\n    char[] soundexCode = new char[4];\n    int index = 0;\n    for (int i = 0; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (Character.isLetter(ch)) {\n            if (index < 4) {\n                soundexCode[index++] = map(ch);\n            }\n        }\n    }\n    while (index < 4) {\n        soundexCode[index++] = '0';\n    }\n    return new String(soundexCode).substring(0, Math.min(index, 4));\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    char[] chars = str.toUpperCase().toCharArray();\n    StringBuilder sb = new StringBuilder();\n    sb.append(chars[0]);\n    for (int i = 1; i < chars.length; i++) {\n        char ch = chars[i];\n        if (ch == ' ') {\n            continue;\n        }\n        if (ch >= 'A' && ch <= 'Z') {\n            sb.append(map(ch));\n        } else if (ch == 'H' || ch == 'W' || ch == 'X' || ch == 'Y') {\n            sb.append('0');\n        } else if (ch == 'B' || ch == 'F' || ch == 'P' || ch == 'V') {\n            sb.append('1');\n        } else if (ch == 'C' || ch == 'G' || ch == 'J' || ch == 'K' || ch == 'Q' || ch == 'S' || ch == 'X' || ch == 'Z') {\n            sb.append('2');\n        } else if (ch == 'D' || ch == 'T') {\n            sb.append('3');\n        } else if (ch == 'L') {\n            sb.append('4');\n        } else if (ch == 'M' || ch == 'N') {\n            sb.append('5');\n        } else if (ch == 'R') {\n            sb.append('6');\n        }\n    }\n    while (sb.length() < 4) {\n        sb.append('0');\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase();\n    char[] chars = str.toCharArray();\n    StringBuilder sb = new StringBuilder();\n    sb.append(chars[0]);\n    for (int i = 1; i < chars.length; i++) {\n        char ch = chars[i];\n        if (ch == ' ') {\n            continue;\n        }\n        if (ch >= 'A' && ch <= 'Z') {\n            sb.append(map(ch));\n        } else if (ch == 'H' || ch == 'K' || ch == 'W' || ch == 'X' || ch == 'Y') {\n            sb.append('0');\n        } else if (ch == 'B' || ch == 'F' || ch == 'P' || ch == 'V') {\n            sb.append('1');\n        } else if (ch == 'C' || ch == 'G' || ch == 'J' || ch == 'S' || ch == 'Z') {\n            sb.append('2');\n        } else if (ch == 'D' || ch == 'T') {\n            sb.append('3');\n        } else if (ch == 'L') {\n            sb.append('4');\n        } else {\n            sb.append('0');\n        }\n    }\n    while (sb.length() < 4) {\n        sb.append('0');\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    char[] chars = str.toUpperCase().toCharArray();\n    StringBuilder sb = new StringBuilder();\n    sb.append(chars[0]);\n    for (int i = 1; i < chars.length; i++) {\n        char ch = chars[i];\n        if (ch == ' ') {\n            continue;\n        }\n        if (ch >= 'A' && ch <= 'Z') {\n            sb.append(map(ch));\n        } else if (ch == 'H' || ch == 'W' || ch == 'X' || ch == 'Y') {\n            sb.append('0');\n        } else if (ch == 'B' || ch == 'F' || ch == 'P' || ch == 'V') {\n            sb.append('1');\n        } else if (ch == 'C' || ch == 'G' || ch == 'J' || ch == 'K' || ch == 'Q' || ch == 'S' || ch == 'X' || ch == 'Z') {\n            sb.append('2');\n        } else if (ch == 'D' || ch == 'T') {\n            sb.append('3');\n        } else if (ch == 'L') {\n            sb.append('4');\n        } else {\n            sb.append('0');\n        }\n    }\n    while (sb.length() < 4) {\n        sb.append('0');\n    }\n    return sb.toString().substring(0, 4);\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    char[] chars = str.toUpperCase().toCharArray();\n    StringBuilder sb = new StringBuilder();\n    sb.append(chars[0]);\n    for (int i = 1; i < chars.length; i++) {\n        char ch = chars[i];\n        if (ch == ' ') {\n            continue;\n        }\n        if (ch == 'X' || ch == 'K') {\n            sb.append('0');\n        } else if (ch == 'S' || ch == 'C' || ch == 'Z') {\n            sb.append('2');\n        } else if (ch == 'T' || ch == 'D' || ch == 'N') {\n            sb.append('3');\n        } else if (ch == 'M' || ch == 'B' || ch == 'P') {\n            sb.append('4');\n        } else if (ch == 'R' || ch == 'L') {\n            sb.append('4');\n        } else if (ch == 'H' || ch == 'G') {\n            sb.append('5');\n        } else if (ch == 'F' || ch == 'V') {\n            sb.append('6');\n        } else {\n            throw new IllegalArgumentException(\"The character is not mapped: \" + ch);\n        }\n    }\n    while (sb.length() < 4) {\n        sb.append('0');\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase();\n    StringBuilder sb = new StringBuilder();\n    sb.append(str.charAt(0));\n    for (int i = 1; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (ch == 'H' || ch == 'W' || ch == 'X' || ch == 'Y') {\n            continue;\n        }\n        if (ch >= 'A' && ch <= 'Z') {\n            sb.append(map(ch));\n        } else if (ch == ' ') {\n            continue;\n        } else {\n            sb.append('#');\n        }\n    }\n    while (sb.length() < 4) {\n        sb.append('0');\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase();\n    StringBuilder sb = new StringBuilder();\n    sb.append(str.charAt(0));\n    for (int i = 1; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (ch == 'H' || ch == 'W' || ch == 'X' || ch == 'Y') {\n            continue;\n        }\n        if (ch >= 'A' && ch <= 'Z') {\n            sb.append(map(ch));\n        } else {\n            sb.append('0');\n        }\n    }\n    while (sb.length() < 4) {\n        sb.append('0');\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase();\n    StringBuilder sb = new StringBuilder();\n    sb.append(str.charAt(0));\n    for (int i = 1; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        if (Character.isLetter(ch)) {\n            char mapped = map(ch);\n            if (sb.length() < 4) {\n                sb.append(mapped);\n            }\n        }\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase();\n    char[] chars = str.toCharArray();\n    StringBuilder sb = new StringBuilder();\n    sb.append(chars[0]);\n    for (int i = 1; i < chars.length; i++) {\n        char ch = chars[i];\n        if (ch == ' ') {\n            continue;\n        }\n        if (ch >= 'A' && ch <= 'Z') {\n            sb.append(map(ch));\n        } else if (ch == 'H' || ch == 'K' || ch == 'W' || ch == 'X') {\n            sb.append('0');\n        } else if (ch == 'M' || ch == 'N') {\n            sb.append('50');\n        } else if (ch == 'R' || ch == 'L') {\n            sb.append('40');\n        } else if (ch == 'S' || ch == 'T') {\n            sb.append('30');\n        } else if (ch == 'D' || ch == 'C') {\n            sb.append('20');\n        } else if (ch == 'B' || ch == 'P') {\n            sb.append('80');\n        } else {\n            sb.append('0');\n        }\n    }\n    while (sb.length() < 4) {\n        sb.append('0');\n    }\n    return sb.toString();\n}"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    } else if (clz == Comparable.class) {\n        return CORE_TYPE_COMPARABLE;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOL;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Enum.class) {\n        return CORE_TYPE_ENUM;\n    } else if (clz == Class.class) {\n        return CORE_TYPE_CLASS;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // Object (\"untyped\"), String equivalents:\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Comparable.class) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == Boolean.class) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Class.class) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == Enum.class) {\n        return CORE_TYPE_ENUM;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    } else if (clz == Comparable.class) {\n        return CORE_TYPE_COMPARABLE;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOL;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Enum.class) {\n        return CORE_TYPE_ENUM;\n    } else if (clz == Class.class) {\n        return CORE_TYPE_CLASS;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // Check for common, \"well-known\" types\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOL;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    } else if (clz == Comparable.class) {\n        return CORE_TYPE_COMPARABLE;\n    } else if (clz == Enum.class) {\n        return CORE_TYPE_ENUM;\n    } else if (clz == Class.class) {\n        return CORE_TYPE_CLASS;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // Object (\"untyped\"), String equivalents:\n    if (clz == Class.class) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == Enum.class) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == Comparable.class) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == Boolean.class) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    } else if (clz == Comparable.class) {\n        return CORE_TYPE_COMPARABLE;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOL;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Enum.class) {\n        return CORE_TYPE_ENUM;\n    } else if (clz == Class.class) {\n        return CORE_TYPE_CLASS;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    } else if (clz == Comparable.class) {\n        return CORE_TYPE_COMPARABLE;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOL;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Enum.class) {\n        return CORE_TYPE_ENUM;\n    } else if (clz == Class.class) {\n        return CORE_TYPE_CLASS;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // Object (\"untyped\"), String equivalents:\n    if (clz == Class.class) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == Enum.class) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == Comparable.class) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == Boolean.class) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    } else if (clz == Comparable.class) {\n        return CORE_TYPE_COMPARABLE;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOL;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Enum.class) {\n        return CORE_TYPE_ENUM;\n    } else if (clz == Class.class) {\n        return CORE_TYPE_CLASS;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    } else if (clz == Boolean.class) {\n        return CORE_TYPE_BOOL;\n    } else if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    } else if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    } else if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    } else if (clz == Comparable.class) {\n        return CORE_TYPE_COMPARABLE;\n    } else if (clz == Enum.class) {\n        return CORE_TYPE_ENUM;\n    } else if (clz == Class.class) {\n        return CORE_TYPE_CLASS;\n    }\n    return null;\n}"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isPrototypeMemberDeclaration()) {\n        return new PrototypeMemberDeclaration(n.getFirstChild(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isPrototypeMemberDeclaration()) {\n        return new PrototypeMemberDeclaration(n.getLhs(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isPrototypeMemberDeclaration()) {\n        return new PrototypeMemberDeclaration(n.getFirstChild(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isFunction()) {\n        return null;\n    }\n    PrototypeMemberDeclaration prototypeMember = new PrototypeMemberDeclaration(n.getFirstChild(), n);\n    return prototypeMember;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isPrototypeMemberDeclaration()) {\n        return new PrototypeMemberDeclaration(n.getFirstChild(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isFunction()) {\n        return null;\n    }\n    if (n.isPrototypeMemberDeclaration()) {\n        return new PrototypeMemberDeclaration(n.getLhs(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isFunction()) {\n        return null;\n    }\n    PrototypeMemberDeclaration prototypeMember = new PrototypeMemberDeclaration(\n        n.getFirstChild().getFirstChild(), n);\n    return prototypeMember;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isFunction()) {\n        return null;\n    }\n    PrototypeMemberDeclaration declaration = new PrototypeMemberDeclaration(n.getFirstChild(), n);\n    return declaration;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isFunction()) {\n        return null;\n    }\n    if (n.isPrototypeMemberDeclaration()) {\n        return new PrototypeMemberDeclaration(n.getLHS(), n);\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isFunction()) {\n        return null;\n    }\n    PrototypeMemberDeclaration prototypeMember = new PrototypeMemberDeclaration(\n            n.getFirstChild(), n);\n    return prototypeMember;\n}"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension() * n;\n    int cols = mat.getColumnDimension() * m;\n    double[][] data = new double[rows][cols];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            int row = i / n;\n            int col = j / m;\n            data[i][j] = mat.getEntry(row, col);\n        }\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension() * n;\n    int cols = mat.getColumnDimension() * m;\n    double[][] data = new double[rows][cols];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            int row = i / n;\n            int col = j / m;\n            data[i][j] = mat.getEntry(row, col);\n        }\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rows = mat.getRowDimension();\n    final int cols = mat.getColumnDimension();\n    final double[][] data = new double[rows * n][cols * m];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    data[i * n + k][j * m + l] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    double[][] data = new double[rows * n][cols * m];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    data[i * n + k][j * m + l] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    double[][] data = new double[rows * n][cols * m];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    data[i * n + k][j * m + l] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension() * n;\n    int cols = mat.getColumnDimension() * m;\n    double[][] data = new double[rows][cols];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            data[i][j] = mat.getEntry(i % mat.getRowDimension(), j % mat.getColumnDimension());\n        }\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension() * n;\n    int cols = mat.getColumnDimension() * m;\n    double[][] data = new double[rows][cols];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            data[i][j] = mat.getEntry(i % mat.getRowDimension(), j % mat.getColumnDimension());\n        }\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension() * n;\n    int cols = mat.getColumnDimension() * m;\n    double[][] data = new double[rows][cols];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            int row = i / n;\n            int col = j / m;\n            data[i][j] = mat.getEntry(row, col);\n        }\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    double[][] data = new double[rows * n][cols * m];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    data[i * n + k][j * m + l] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rows = mat.getRowDimension() * n;\n    final int cols = mat.getColumnDimension() * m;\n    final double[][] d = new double[rows][cols];\n    for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols; c++) {\n            d[r][c] = mat.getEntry(r % mat.getRowDimension(), c % mat.getColumnDimension());\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) > 0) {\n            return candidate;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) > 0) {\n            return candidate;\n        }\n        candidate = node;\n        if (node.right == null) {\n            return candidate;\n        }\n        node = node.right;\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) > 0) {\n            return candidate;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) <= 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) <= 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    return inf.getBytesRead();\n}",
      "private long getBytesInflated()  {\n    return inf.getBytesRead();\n}",
      "private long getBytesInflated()  {\n    return inf.getBytesRead();\n}",
      "private long getBytesInflated()  {\n    return getBytesReadFromStream() - getBytesRead();\n}",
      "private long getBytesInflated()  {\n    return getBytesReadFromStream();\n}",
      "private long getBytesInflated()  {\n    return getBytesRead() - getBytesReadFromStream();\n}",
      "private long getBytesInflated()  {\n    if (inf != null) {\n        return inf.getBytesConsumed();\n    }\n    return getBytesRead();\n}",
      "private long getBytesInflated()  {\n    return Math.min(getBytesRead(), TWO_EXP_32);\n}",
      "private long getBytesInflated()  {\n    return Math.min(current.entry.getCompressedSize(), current.bytesReadFromStream);\n}",
      "private long getBytesInflated()  {\n    return getBytesReadFromStream();\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name);\n}\n\n// NodeUtil.java\nstatic boolean isLatin(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c > LARGEST_BASIC_LATIN) {\n      return false;\n    }\n  }\n  return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name) && !isSimpleName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name) && !name.contains(\".\");\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name);\n}\n\n  // This is a helper method to check if a name is a valid property name.\n  // It's used in the check for side effects.\n  static boolean isValidPropertyName(Node n) {\n    return isValidPropertyName(getPropertyName(n));\n  }\n\n  // This is a helper method to check if a name is a valid property name.\n  // It's used in the check for side effects.\n  static boolean isValidPropertyName(String name) {\n    return isValidPropertyName(name);\n  }\n\n  // This is a helper method to check if a name is a valid property name.\n  // It's used in the check for side effects.\n  static boolean isValidPropertyName(Node n, Set<String> defines) {\n    return isValidPropertyName(getPropertyName(n), defines);\n  }\n\n  // This is a helper method to check if a name is a valid property name.\n  // It's used in the check for side effects.\n  static boolean isValidPropertyName(String name, Set<String> defines) {\n    return isValidSimpleName(name) && !defines.contains(name);\n  }\n\n  // This is a helper method to check if a name is a valid property name.\n  // It's used in the check for side effects.\n  static boolean isValidPropertyName(Node n, Set<String> defines, boolean checkForNewObjects) {\n    return isValidPropertyName(getPropertyName(n), defines, checkForNewObjects);\n  }\n\n  // This is a helper method to check if a name is a valid property name.\n  // It's used in the check for side effects.\n  static boolean isValidPropertyName(String name, Set<String> defines, boolean checkForNewObjects) {\n    return isValidSimpleName(name) && !defines.contains(name) && !checkForNewObjects;\n  }\n\n  // This is a helper method to check if a name is a valid property name.\n  // It's used in the check for side effects.\n  static boolean isValidPropertyName(Node n, Set<String> defines, boolean checkForNewObjects, AbstractCompiler compiler) {\n    return isValidPropertyName(getPropertyName(n), defines, checkForNewObjects, compiler);\n  }\n\n  // This is a helper method to check if a name is a valid property name.\n  // It's used in the check for side effects.\n  static boolean isValidPropertyName(String name, Set<String> defines, boolean checkForNewObjects, AbstractCompiler compiler) {\n    return isValidSimpleName(name) && !defines.contains(name) && !checkForNewObjects && compiler.isAllowedProperty(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name) && !isValidPropertyName(name);\n  }\n\n  // NodeUtil.java\n  static boolean isLatin(String s) {\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c > LARGEST_BASIC_LATIN) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // NodeUtil.java\n  static boolean isValidSimpleName(String name) {\n    return TokenStream.isJSIdentifier(name) &&\n        !TokenStream.isKeyword(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, Unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        isLatin(name);\n  }\n\n  // NodeUtil.java\n  static boolean isValidPropertyName(String name) {\n    return isValidSimpleName(name);\n  }\n\n  // NodeUtil.java\n  static boolean isImmutableValue(Node n) {\n    return !mayEffectMutableState(n);\n  }\n\n  // NodeUtil.java\n  static boolean mayEffectMutableState(Node n) {\n    return mayEffectMutableState(n, compiler);\n  }\n\n  // NodeUtil.java\n  static boolean mayEffectMutableState(Node n, AbstractCompiler compiler) {\n    return !mayEffectMutableStateHelper(n, compiler);\n  }\n\n  // NodeUtil.java\n  static boolean mayEffectMutableStateHelper(Node n, AbstractCompiler compiler) {\n    // Check if the node is a function or a constructor.\n    if (n.getType() == Node.Type.FUNCTION || n.getType() == Node.Type.CONSTRUCTOR) {\n      // Check if the function or constructor has side effects.\n      if (compiler.hasSideEffects(n)) {\n        return true;\n      }\n    }\n    // Check if the node is an assignment or a call.\n    if (n.getType() == Node.Type.ASSIGN || n.getType() == Node.Type.CALL) {\n      // Check if the assignment or call has side effects.\n      if (compiler.hasSideEffects(n)) {\n        return true;\n      }\n    }\n    // Check if the node is a loop or a conditional statement.\n    if (n.getType() == Node.Type.LOOP || n.getType() == Node.Type.CONDITIONAL) {\n}\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name) && !isValidSimpleName(name.substring(0, name.lastIndexOf('.')));\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name);\n}\n\n// NodeUtil.java\nstatic boolean isLatin(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c > LARGEST_BASIC_LATIN) {\n      return false;\n    }\n  }\n  return true;\n}\n\nstatic boolean isValidSimpleName(String name) {\n  return TokenStream.isJSIdentifier(name) &&\n      !TokenStream.isKeyword(name) &&\n      // no Unicode escaped characters - some browsers are less tolerant\n      // of Unicode characters that might be valid according to the\n      // language spec.\n      // Note that by this point, Unicode escapes have been converted\n      // to UTF-16 characters, so we're only searching for character\n      // values, not escapes.\n      isLatin(name);\n}\n\nstatic boolean isValidPropertyName(String name) {\n  return isValidSimpleName(name);\n}\n\n// GlobalNamespace.java\nboolean isNamespace() {\n  return hasDeclaredTypeDescendant && type == Type.OBJECTLIT;\n}\n\nboolean isSimpleName() {\n  return parent == null;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  if (name == null || name.isEmpty()) {\n    return false;\n  }\n  int i = 0;\n  while (i < name.length() && Character.isLetter(name.charAt(i))) {\n    i++;\n  }\n  if (i == 0) {\n    return false;\n  }\n  return isValidSimpleName(name.substring(0, i)) && isValidSimpleName(name.substring(i));\n}"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = il;\n    double p = matrixT[il][il - 1];\n    double q = matrixT[il + 1][il - 1];\n    double r = (iu > il + 1) ? matrixT[il + 2][il - 1] : 0.0;\n    shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n    if (!Precision.equals(shift.x, 0.0, epsilon)) {\n        p = p / shift.x;\n        q = q / shift.x;\n        r = r / shift.x;\n    }\n    double s = FastMath.sqrt(p * p + q * q + r * r);\n    if (p < 0.0) {\n        s = -s;\n    }\n    if (s != 0.0) {\n        if (il != im) {\n            matrixT[il][il - 1] = -s * shift.x;\n        }\n        p = p + s;\n        shift.x = p / s;\n        shift.y = q / s;\n        double z = r / s;\n        q = q / p;\n        r = r / p;\n        hVec[0] = p;\n        hVec[1] = q;\n        hVec[2] = r;\n        im++;\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    double p = 0.0;\n    double q = 0.0;\n    double r = 0.0;\n    for (int k = il; k <= iu; k++) {\n        p = matrixT[k][k - 1];\n        q = matrixT[k + 1][k - 1];\n        r = k == iu ? 0.0 : matrixT[k + 2][k - 1];\n        shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n        if (!Precision.equals(shift.x, 0.0, epsilon)) {\n            p = p / shift.x;\n            q = q / shift.x;\n            r = r / shift.x;\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n            hVec[0] = shift.x;\n            hVec[1] = shift.y;\n            hVec[2] = z;\n        }\n    }\n    return il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = matrixT[il][il - 1];\n    double q = matrixT[il + 1][il - 1];\n    double r = iu > il + 1 ? matrixT[il + 2][il - 1] : 0.0;\n    shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n    if (!Precision.equals(shift.x, 0.0, epsilon)) {\n        p = p / shift.x;\n        q = q / shift.x;\n        r = r / shift.x;\n    }\n    if (shift.x == 0.0) {\n        return il;\n    }\n    double s = FastMath.sqrt(p * p + q * q + r * r);\n    if (p < 0.0) {\n        s = -s;\n    }\n    if (s != 0.0) {\n        if (il > 0) {\n            matrixT[il][il - 1] = -s * shift.x;\n        }\n        p = p + s;\n        shift.x = p / s;\n        shift.y = q / s;\n        double z = r / s;\n        q = q / p;\n        r = r / p;\n        hVec[0] = shift.x;\n        hVec[1] = shift.y;\n        hVec[2] = z;\n    }\n    return il + 1;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = il;\n    double p = 0.0;\n    double q = 0.0;\n    double r = 0.0;\n    if (il > 0) {\n        p = matrixT[il][il - 1];\n        q = matrixT[il + 1][il - 1];\n        r = matrixT[il + 2][il - 1];\n        shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n        if (!Precision.equals(shift.x, 0.0, epsilon)) {\n            p = p / shift.x;\n            q = q / shift.x;\n            r = r / shift.x;\n        }\n    }\n    if (shift.x == 0.0) {\n        im = il;\n    } else {\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (il > 0) {\n                matrixT[il][il - 1] = -s * shift.x;\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n            hVec[0] = p;\n            hVec[1] = q;\n            hVec[2] = r;\n            im = il + 1;\n        }\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = il;\n    double p = matrixT[il][il - 1];\n    double q = matrixT[il + 1][il - 1];\n    double r = (iu > il + 1) ? matrixT[il + 2][il - 1] : 0.0;\n    shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n    if (!Precision.equals(shift.x, 0.0, epsilon)) {\n        p = p / shift.x;\n        q = q / shift.x;\n        r = r / shift.x;\n    }\n    if (shift.x == 0.0) {\n        return il;\n    }\n    double s = FastMath.sqrt(p * p + q * q + r * r);\n    if (p < 0.0) {\n        s = -s;\n    }\n    if (s != 0.0) {\n        if (il != im) {\n            matrixT[il][il - 1] = -s * shift.x;\n        }\n        p = p + s;\n        shift.x = p / s;\n        shift.y = q / s;\n        double z = r / s;\n        q = q / p;\n        r = r / p;\n        im++;\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = il;\n    double p = 0.0;\n    double q = 0.0;\n    double r = 0.0;\n    if (il > 0) {\n        p = matrixT[il - 1][il - 1];\n        q = matrixT[il][il - 1];\n        r = matrixT[il + 1][il - 1];\n        shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n        if (!Precision.equals(shift.x, 0.0, epsilon)) {\n            p = p / shift.x;\n            q = q / shift.x;\n            r = r / shift.x;\n        }\n    }\n    if (shift.x == 0.0) {\n        im = il;\n    } else {\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (il > 0) {\n                matrixT[il][il - 1] = -s * shift.x;\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n            hVec[0] = p;\n            hVec[1] = q;\n            hVec[2] = r;\n            im = il + 1;\n        }\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = il;\n    while (im < iu) {\n        double p = matrixT[im][im - 1];\n        double q = matrixT[im + 1][im - 1];\n        double r = im < iu - 1 ? matrixT[im + 2][im - 1] : 0.0;\n        shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n        if (!Precision.equals(shift.x, 0.0, epsilon)) {\n            p = p / shift.x;\n            q = q / shift.x;\n            r = r / shift.x;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (im < iu - 1) {\n                matrixT[im][im - 1] = -s * shift.x;\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n            hVec[0] = p;\n            hVec[1] = q;\n            hVec[2] = r;\n            im++;\n        } else {\n            break;\n        }\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    double p = matrixT[il][il - 1];\n    double q = matrixT[il + 1][il - 1];\n    double r = iu > il + 1 ? matrixT[il + 2][il - 1] : 0.0;\n    shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n    if (!Precision.equals(shift.x, 0.0, epsilon)) {\n        p = p / shift.x;\n        q = q / shift.x;\n        r = r / shift.x;\n    }\n    double s = FastMath.sqrt(p * p + q * q + r * r);\n    if (p < 0.0) {\n        s = -s;\n    }\n    if (s != 0.0) {\n        if (il != 0) {\n            matrixT[il][il - 1] = -s * shift.x;\n        }\n        p = p + s;\n        shift.x = p / s;\n        shift.y = q / s;\n        double z = r / s;\n        q = q / p;\n        r = r / p;\n        hVec[0] = shift.x;\n        hVec[1] = shift.y;\n        hVec[2] = z;\n        return il + 1;\n    } else {\n        return il;\n    }\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    double p = matrixT[il][il - 1];\n    double q = matrixT[il + 1][il - 1];\n    double r = iu > il + 1 ? matrixT[il + 2][il - 1] : 0.0;\n    shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n    if (!Precision.equals(shift.x, 0.0, epsilon)) {\n        p = p / shift.x;\n        q = q / shift.x;\n        r = r / shift.x;\n    }\n    double s = FastMath.sqrt(p * p + q * q + r * r);\n    if (p < 0.0) {\n        s = -s;\n    }\n    hVec[0] = p / s;\n    hVec[1] = q / s;\n    hVec[2] = r / s;\n    return il + 1;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = 0.0;\n    double q = 0.0;\n    double r = 0.0;\n    if (il > 0) {\n        p = matrixT[il - 1][il - 1];\n        q = matrixT[il][il - 1];\n        r = matrixT[il + 1][il - 1];\n    }\n    shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n    if (!Precision.equals(shift.x, 0.0, epsilon)) {\n        p = p / shift.x;\n        q = q / shift.x;\n        r = r / shift.x;\n    }\n    if (shift.x == 0.0) {\n        return il;\n    }\n    double s = FastMath.sqrt(p * p + q * q + r * r);\n    if (p < 0.0) {\n        s = -s;\n    }\n    if (s != 0.0) {\n        p = p + s;\n        shift.x = p / s;\n        shift.y = q / s;\n        double z = r / s;\n        q = q / p;\n        r = r / p;\n        hVec[0] = shift.x;\n        hVec[1] = shift.y;\n        hVec[2] = z;\n    }\n    return il;\n}"
    ],
    [
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) {\n        if (segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) {\n        if (segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int amount = chrono.getPeriod(zeroInstance).getDifference(end.getMillis(), start.getMillis());\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.getChronology() != end.getChronology()) {\n            throw new IllegalArgumentException(\"Chronology mismatch\");\n        }\n        int amount = zeroInstance.getValue();\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start instanceof LocalDate && end instanceof LocalDate)   {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int amount = chrono.getPeriod(zeroInstance).getDifference(\n                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n            return amount;\n        }\n        int amount = zeroInstance.getValue();\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int amount = chrono.getDurationField(zeroInstance.getFieldType()).getDifference(end.getMillis(), start.getMillis());\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start instanceof LocalDate && end instanceof LocalDate) {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int amount = chrono.getDurationField(chrono.months()).getDifference(\n                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n            return amount;\n        }\n        int amount = zeroInstance.getValue();\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getPartialChronology(start);\n        int amount = zeroInstance.getValue();\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start instanceof LocalDate && end instanceof LocalDate) {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int amount = chrono.getPeriod(zeroInstance).getDifference(end, start);\n            return amount;\n        } else {\n            int amount = zeroInstance.getValue();\n            return amount;\n        }\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (!start.getChronology().equals(end.getChronology())) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same chronology\");\n        }\n        int amount = zeroInstance.getValue();\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int amount = zeroInstance.getValue();\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null || zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (!(start instanceof LocalDate) || !(end instanceof LocalDate)) {\n            int amount = zeroInstance.getValue();\n            return amount;\n        }\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int amount = chrono.years().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return amount;\n    }"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    if (index < 0) {\n        return null;\n    }\n    List subtitles = getSubtitles();\n    if (subtitles == null) {\n        return null;\n    }\n    if (index >= subtitles.size()) {\n        return null;\n    }\n    return (LegendTitle) subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    return (LegendTitle) getSubtitle(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0) {\n        return null;\n    }\n    if (index >= subtitles.size()) {\n        return null;\n    }\n    return (LegendTitle) subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0) {\n        return null;\n    }\n    if (index >= this.subtitles.size()) {\n        return null;\n    }\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0) {\n        return null;\n    }\n    if (index >= this.subtitles.size()) {\n        return null;\n    }\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0) {\n        return null;\n    }\n    List subtitles = getSubtitles();\n    if (subtitles == null) {\n        return null;\n    }\n    if (index >= subtitles.size()) {\n        return null;\n    }\n    return (LegendTitle) subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    return (LegendTitle) getSubtitle(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    return (LegendTitle) getSubtitle(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= subtitles.size()) {\n        return null;\n    }\n    return (LegendTitle) subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    return (LegendTitle) getSubtitle(index);\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseOptionalParameterType(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseOptionalParameterType(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseOptionalParameterType(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseOptionalParameterType(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseOptionalParameterType(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseOptionalParameterType(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    if (t == null) {\n        return new ArrayList<String>();\n    }\n    final String[] stackFrames = getStackFrames(getStackTrace(t));\n    final List<String> list = new ArrayList<String>();\n    for (final String frame : stackFrames) {\n        if (!frame.startsWith(\"at \")) {\n            list.add(frame);\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    String[] frames = getStackFrames(getStackTrace(t));\n    for (String frame : frames) {\n        if (!frame.startsWith(\"at \")) {\n            list.add(frame);\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> stackFrames = new ArrayList<String>();\n    Throwable cause = t;\n    while (cause != null) {\n        String[] frames = getRootCauseStackTrace(cause);\n        for (int i = frames.length - 1; i >= 0; i--) {\n            if (!frames[i].startsWith(\"at \")) {\n                stackFrames.add(frames[i]);\n            } else {\n                break;\n            }\n        }\n        cause = getCause(cause);\n    }\n    return stackFrames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    if (t == null) {\n        return new ArrayList<String>();\n    }\n    final String[] stackFrames = getRootCauseStackTrace(t);\n    final List<String> list = new ArrayList<String>();\n    for (final String element : stackFrames) {\n        if (!element.startsWith(\"at \")) {\n            list.add(element);\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    String[] frames = getStackFrames(t.toString());\n    for (String frame : frames) {\n        if (!frame.startsWith(\"at \")) {\n            list.add(frame);\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> stackFrames = new ArrayList<String>();\n    Throwable current = t;\n    while (current != null) {\n        final String[] frames = getStackFrames(current.toString());\n        for (final String frame : frames) {\n            if (!frame.startsWith(\"at \")) {\n                stackFrames.add(frame);\n            }\n        }\n        current = getCause(current);\n    }\n    return stackFrames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    Throwable current = t;\n    while (current != null) {\n        final String[] frames = getStackFrames(current.getStackTrace()[0].getMethodName());\n        for (final String frame : frames) {\n            list.add(frame);\n        }\n        current = getCause(current);\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    String[] frames = getRootCauseStackTrace(t);\n    for (String frame : frames) {\n        if (!frame.startsWith(\"Caused by:\")) {\n            list.add(frame);\n        } else {\n            break;\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    if (t == null) {\n        return new ArrayList<String>();\n    }\n    final String[] stackFrames = getStackFrames(t.toString());\n    final List<String> list = new ArrayList<String>();\n    for (int i = 0; i < stackFrames.length; i++) {\n        if (stackFrames[i].startsWith(\"at\")) {\n            list.add(stackFrames[i]);\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    Throwable current = t;\n    while (current != null) {\n        String[] frames = getRootCauseStackTrace(current);\n        for (int i = frames.length - 1; i >= 0; i--) {\n            if (!frames[i].startsWith(\"Caused by:\")) {\n                list.add(frames[i]);\n            } else {\n                break;\n            }\n        }\n        current = getCause(current);\n    }\n    return list;\n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  } else {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  } else {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  } else {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  } else {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  } else {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node fn = call.getFirstChild();\n    if (fn.getType() == Token.GETPROP) {\n        Node obj = fn.getFirstChild();\n        if (obj.getType() == Token.STRING) {\n            // Check if the object has side effects\n            if (compiler.hasSideEffects(obj.getString())) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    // Check if the method call has side effects\n    if (compiler.hasSideEffects(call)) {\n      return true;\n    }\n    // Check if the method call's arguments have side effects\n    Node[] args = call.getArgs();\n    for (Node arg : args) {\n      if (compiler.hasSideEffects(arg)) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    if (call.isCall()) {\n        Node function = call.getFirstChild();\n        if (function.isGetProp()) {\n            Node nameNode = function.getFirstChild().getNext();\n            if (nameNode.isString()) {\n                String functionName = nameNode.getString();\n                if (this.disposeCalls.containsKey(functionName)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    if (call.isCall()) {\n        Node function = call.getFirstChild();\n        if (function.isGetProp()) {\n            Node nameNode = function.getFirstChild().getNext();\n            if (nameNode.isString()) {\n                String functionName = nameNode.getString();\n                if (this.disposeCalls.containsKey(functionName)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node fn = call.getFirstChild();\n    if (fn.getType() == Token.GETPROP) {\n        Node obj = fn.getFirstChild();\n        if (obj.getType() == Token.NAME) {\n            String objName = obj.getString();\n            if (objName.equals(\"window\") || objName.equals(\"document\")) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    // Check if the method call's arguments have side effects\n    // by checking if any of the arguments are objects that\n    // have side effects.\n    Node[] args = call.getArguments();\n    for (Node arg : args) {\n      if (arg.isObject()) {\n        // Check if the object has side effects\n        if (accumulator.hasSideEffects(arg)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node function = call.getFirstChild();\n    if (!function.isGetProp()) {\n      return false;\n    }\n    Node nameNode = function.getFirstChild().getNext();\n    if (!nameNode.isString()) {\n      return false;\n    }\n    String functionName = nameNode.getString();\n    if (FORBIDDEN_TYPES.contains(function.getType())) {\n      return false;\n    }\n    // Check if the function call has side effects\n    if (isClassDefiningCall(function)) {\n      return true;\n    }\n    // Check if the function call disposes an object\n    if (disposeCalls.containsKey(compiler.getTypeRegistry().getType(functionName))) {\n      return true;\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node function = call.getFirstChild();\n    if (!function.isGetProp()) {\n        return false;\n    }\n    Node nameNode = function.getFirstChild().getNext();\n    if (!nameNode.isString()) {\n        return false;\n    }\n    String functionName = nameNode.getString();\n    if (disposeCalls.containsKey(functionName)) {\n        return true;\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    // Check if the method call's arguments have side effects.\n    // For now, we just check if any of the arguments are not constants.\n    for (Node arg : call.getArguments()) {\n        if (!NodeUtil.isConstant(arg)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    // Check if the call is a function call\n    if (!call.isCall()) {\n      return false;\n    }\n    // Get the function node\n    Node function = call.getFirstChild();\n    // Check if the function is a property access\n    if (!function.isGetProp()) {\n      return false;\n    }\n    // Get the property name\n    Node propertyName = function.getFirstChild().getNext();\n    // Check if the property name is a string\n    if (!propertyName.isString()) {\n      return false;\n    }\n    // Get the property value\n    Node propertyValue = propertyName.getNext();\n    // Check if the property value is a function\n    if (propertyValue.isFunction()) {\n      // Check if the function has side effects\n      return compiler.hasSideEffects(propertyValue);\n    }\n    return false;\n  }"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, field.getZero());\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, field.getZero());\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, field.getZero());\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, field.getZero());\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, field.getZero());\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, field.getZero());\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, field.getZero());\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, field.getZero());\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, field.getZero());\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, field.getZero());\n                }\n            }\n        }\n    }\n    return cachedP;\n}"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int sum = WORD;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (final ZipExtraField element : data) {\n        System.arraycopy(element.getHeaderId().getBytes(), 0, result, start, 2);\n        start += WORD;\n        final byte[] local = element.getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount = lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final int sum = WORD;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (final ZipExtraField element : data) {\n        System.arraycopy(element.getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(element.getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = element.getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int sum = WORD;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (final ZipExtraField element : data) {\n        System.arraycopy(element.getHeaderId().getBytes(), 0, result, start, 2);\n        start += WORD;\n        final byte[] local = element.getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int sum = WORD;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (final ZipExtraField element : data) {\n        System.arraycopy(element.getHeaderId().getBytes(), 0, result, start, 2);\n        start += WORD;\n        final byte[] local = element.getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int sum = WORD;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (final ZipExtraField element : data) {\n        System.arraycopy(element.getHeaderId().getBytes(), 0, result, start, 2);\n        start += WORD;\n        final byte[] local = element.getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int sum = WORD;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (final ZipExtraField element : data) {\n        System.arraycopy(element.getHeaderId().getBytes(), 0, result, start, 2);\n        start += WORD;\n        final byte[] local = element.getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int sum = WORD;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (final ZipExtraField element : data) {\n        System.arraycopy(element.getHeaderId().getBytes(), 0, result, start, 2);\n        start += WORD;\n        final byte[] local = element.getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(true);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(true);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(true);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(true);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(true);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(true);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(true);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(true);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(true);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(true);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n    if (isEndOfFile(ch)) {\n        token.type = EOF;\n    } else if (isEndOfLine(ch)) {\n        token.type = EORECORD;\n    } else if (isDelimiter(ch)) {\n        token.type = TOKEN;\n    } else {\n        token.content.append((char) ch);\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n    if (isDelimiter(ch)) {\n        token.type = TOKEN;\n    } else if (eol) {\n        token.type = EORECORD;\n    } else if (isEndOfFile(ch)) {\n        token.type = EOF;\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    if (token.type == INVALID) {\n        token.content.setLength(0);\n    }\n    if (isStartOfLine(ch)) {\n        token.type = EORECORD;\n    } else if (isEndOfFile(ch)) {\n        token.type = EOF;\n    } else if (isDelimiter(ch)) {\n        token.type = TOKEN;\n    } else {\n        token.content.append((char) ch);\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n    if (isEndOfFile(ch)) {\n        token.type = EOF;\n    } else if (isDelimiter(ch)) {\n        token.type = TOKEN;\n    } else if (isEndOfLine(ch)) {\n        token.type = EORECORD;\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    if (token.type == INVALID) {\n        token.content.setLength(0);\n    }\n    if (isWhitespace(ch)) {\n        while (isWhitespace(ch)) {\n            ch = reader.read();\n        }\n    }\n    if (isDelimiter(ch)) {\n        token.type = TOKEN;\n        token.isReady = true;\n    } else if (isEndOfFile(ch)) {\n        token.type = EOF;\n        token.isReady = true;\n    } else if (eol) {\n        token.type = EORECORD;\n        token.isReady = true;\n    } else {\n        token.content.append((char) ch);\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    if (isStartOfLine(ch)) {\n        token.type = EORECORD;\n    } else if (isEndOfFile(ch)) {\n        token.type = EOF;\n    } else if (isDelimiter(ch)) {\n        token.type = TOKEN;\n    } else {\n        token.content.append((char) ch);\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    if (token.type == INVALID) {\n        token.content.setLength(0);\n    }\n    if (isStartOfLine(ch)) {\n        token.type = EORECORD;\n    } else if (isEndOfFile(ch)) {\n        token.type = EOF;\n    } else if (isDelimiter(ch)) {\n        token.type = TOKEN;\n    } else {\n        token.content.append((char) ch);\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    token.content.append((char) ch);\n    if (isEndOfFile(ch)) {\n        token.type = EOF;\n        token.isReady = true; // there is data at EOF\n    } else if (isDelimiter(ch)) {\n        token.type = TOKEN;\n    } else if (isEndOfFile(ch)) {\n        token.type = EORECORD;\n    } else {\n        token.content.append((char) ch);\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    if (isEndOfFile(ch)) {\n        token.type = EOF;\n        token.isReady = true; // there is data at EOF\n    } else if (isDelimiter(ch)) {\n        token.type = TOKEN;\n    } else if (isQuoteChar(ch)) {\n        // consume encapsulated token\n        parseEncapsulatedToken(token);\n    } else if (isCommentStart(ch)) {\n        // consume comment\n        parseComment(token);\n    } else if (isWhitespace(ch)) {\n        // ignore whitespace\n        if (ignoreSurroundingSpaces) {\n            while (isWhitespace(ch) && !readEndOfLine(ch)) {\n                ch = reader.read();\n            }\n        }\n    } else {\n        // add character to token content\n        token.content.append((char) ch);\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    if (isEndOfFile(ch)) {\n        token.type = EOF;\n        token.isReady = true;\n    } else if (isDelimiter(ch)) {\n        token.type = TOKEN;\n    } else if (isEndOfFile(ch)) {\n        token.type = EORECORD;\n    } else {\n        token.content.append((char) ch);\n    }\n    return token;\n}"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int temp = index;\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = temp % size[i];\n        temp /= size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int temp = index;\n    for (int i = dimension - 1; i >= 0; i--) {\n        counts[i] = temp % size[i];\n        temp /= size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int tempIndex = index;\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = tempIndex % size[i];\n        tempIndex /= size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int i = index;\n    for (int j = 0; j < dimension; j++) {\n        counts[j] = i % size[j];\n        i /= size[j];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int i = index;\n    for (int j = 0; j < dimension; j++) {\n        counts[j] = i % size[j];\n        i /= size[j];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int temp = index;\n    for (int i = dimension - 1; i >= 0; i--) {\n        counts[i] = temp % size[i];\n        temp /= size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int temp = index;\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = temp % size[i];\n        temp /= size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int temp = index;\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = temp % size[i];\n        temp /= size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int tempIndex = index;\n    for (int i = dimension - 1; i >= 0; i--) {\n        counts[i] = tempIndex % size[i];\n        tempIndex /= size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int i = index;\n    for (int j = 0; j < dimension; j++) {\n        counts[j] = i % size[j];\n        i /= size[j];\n    }\n    return counts;\n}"
    ],
    [
      "public JsonPointer last()  {\n    JsonPointer prev = this;\n    while (prev._nextSegment != null) {\n        prev = prev._nextSegment;\n    }\n    return prev;\n}",
      "public JsonPointer last()  {\n    JsonPointer current = this;\n    while (current._nextSegment != null) {\n        current = current._nextSegment;\n    }\n    return current;\n}",
      "public JsonPointer last()  {\n    JsonPointer current = this;\n    while (current._nextSegment != null) {\n        current = current._nextSegment;\n    }\n    return current;\n}",
      "public JsonPointer last()  {\n    JsonPointer current = this;\n    while (current._nextSegment != null) {\n        current = current._nextSegment;\n    }\n    return current;\n}",
      "public JsonPointer last()  {\n    JsonPointer current = this;\n    while (current._nextSegment != null) {\n        current = current._nextSegment;\n    }\n    return current;\n}",
      "public JsonPointer last()  {\n    JsonPointer current = this;\n    while (current._nextSegment != null) {\n        current = current._nextSegment;\n    }\n    return current;\n}",
      "public JsonPointer last()  {\n    JsonPointer prev = this;\n    while (prev._nextSegment != null) {\n        prev = prev._nextSegment;\n    }\n    return prev;\n}",
      "public JsonPointer last()  {\n    JsonPointer current = this;\n    while (current._nextSegment != null) {\n        current = current._nextSegment;\n    }\n    return current;\n}",
      "public JsonPointer last()  {\n    JsonPointer current = this;\n    while (current._nextSegment != null) {\n        current = current._nextSegment;\n    }\n    return current;\n}",
      "public JsonPointer last()  {\n    JsonPointer current = this;\n    while (current._nextSegment != null) {\n        current = current._nextSegment;\n    }\n    return current;\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) SerializationUtils.clone(obj);\n        } catch (SerializationException e) {\n            throw new CloneFailedException(e);\n        }\n    }\n    return obj;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) SerializationUtils.clone(obj);\n        } catch (SerializationException e) {\n            throw new CloneFailedException(\"Failed to clone object\", e);\n        }\n    }\n    return obj;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) SerializationUtils.clone(obj);\n        } catch (SerializationException e) {\n            throw new CloneFailedException(\"Failed to clone object: \" + obj, e);\n        }\n    }\n    return obj;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) SerializationUtils.clone(obj);\n        } catch (SerializationException e) {\n            throw new CloneFailedException(\"Failed to clone object\", e);\n        }\n    }\n    return obj;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) SerializationUtils.clone(obj);\n        } catch (SerializationException e) {\n            throw new CloneFailedException(\"Failed to clone object: \" + obj, e);\n        }\n    }\n    return obj;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n        } catch (Exception e) {\n            throw new CloneFailedException(\"Failed to clone object\", e);\n        }\n    }\n    return obj;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) SerializationUtils.clone(obj);\n        } catch (SerializationException e) {\n            throw new CloneFailedException(\"Failed to clone object\", e);\n        }\n    }\n    return obj;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n        } catch (Exception e) {\n            throw new CloneFailedException(\"Failed to clone object\", e);\n        }\n    }\n    return obj;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) SerializationUtils.clone(obj);\n        } catch (SerializationException e) {\n            throw new CloneFailedException(e);\n        }\n    }\n    return obj;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            return (T) SerializationUtils.clone(obj);\n        } catch (SerializationException e) {\n            throw new CloneFailedException(\"Failed to clone object: \" + obj, e);\n        }\n    }\n    return obj;\n}"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (!sym.getFunctionType().isConstructor() && !sym.getFunctionType().isInterface()) {\n    return null;\n  }\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  Node functionNode = type.getSource();\n  if (functionNode == null) {\n    return null;\n  }\n  SymbolScope scope = getScopeInFunction(sym);\n  if (scope == null) {\n    return null;\n  }\n  return scope.getQualifiedSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n      return null;\n    }\n    Node functionNode = type.getSource();\n    if (functionNode == null) {\n      return null;\n    }\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n      return null;\n    }\n    return scope.getQualifiedSlot(paramName);\n  }",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.getFunctionType() == null) {\n    return null;\n  }\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  Node functionNode = type.getSource();\n  if (functionNode == null) {\n    return null;\n  }\n  SymbolScope scope = getScopeInFunction(sym);\n  if (scope == null) {\n    return null;\n  }\n  return scope.getQualifiedSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  Node functionNode = type.getSource();\n  if (functionNode == null) {\n    return null;\n  }\n  SymbolScope scope = getScopeInFunction(sym);\n  if (scope == null) {\n    return null;\n  }\n  return scope.getQualifiedSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (sym.getFunctionType() == null) {\n    return null;\n  }\n  FunctionType type = sym.getFunctionType();\n  for (Parameter param : type.getParameters()) {\n    if (param.getName().equals(paramName)) {\n      return param.getSymbol();\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  Node functionNode = type.getSource();\n  if (functionNode == null) {\n    return null;\n  }\n  SymbolScope scope = getScopeInFunction(sym);\n  if (scope == null) {\n    return null;\n  }\n  return scope.getQualifiedSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  Node functionNode = type.getSource();\n  if (functionNode == null) {\n    return null;\n  }\n  SymbolScope scope = getScopeInFunction(sym);\n  if (scope == null) {\n    return null;\n  }\n  return scope.getQualifiedSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (!sym.isFunction()) {\n      return null;\n    }\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n      return null;\n    }\n    Node functionNode = type.getSource();\n    if (functionNode == null) {\n      return null;\n    }\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n      return null;\n    }\n    return scope.getQualifiedSlot(paramName);\n  }",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (!sym.getFunctionType().isConstructor()) {\n      return null;\n    }\n    FunctionType type = sym.getFunctionType();\n    for (Parameter param : type.getParameters()) {\n      if (param.getName().equals(paramName)) {\n        return param.getSymbol();\n      }\n    }\n    return null;\n  }",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (!sym.isFunction()) {\n    return null;\n  }\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  Node functionNode = type.getSource();\n  if (functionNode == null) {\n    return null;\n  }\n  SymbolScope scope = getScopeInFunction(sym);\n  if (scope == null) {\n    return null;\n  }\n  return scope.getQualifiedSlot(paramName);\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int rows = matrix.getRowDimension();\n    int cols = matrix.getColumnDimension();\n    if (rows < 2 || cols < 1) {\n        throw new MathIllegalArgumentException(\"Matrix must have at least one column and two rows\");\n    }\n    double[] means = new double[cols];\n    for (int i = 0; i < cols; i++) {\n        double sum = 0;\n        for (int j = 0; j < rows; j++) {\n            sum += matrix.getEntry(j, i);\n        }\n        means[i] = sum / rows;\n    }\n    RealMatrix result = RealMatrixFactory1D.createRealMatrix(rows, cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            double sum = 0;\n            for (int k = 0; k < rows; k++) {\n                sum += (matrix.getEntry(k, i) - means[i]) * (matrix.getEntry(k, j) - means[j]);\n            }\n            if (biasCorrected) {\n                sum /= rows - 1;\n            } else {\n                sum /= rows;\n            }\n            result.setEntry(i, j, sum);\n        }\n    }\n    return result;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int rows = matrix.getRowDimension();\n    int cols = matrix.getColumnDimension();\n    RealMatrix result = RealMatrixFactory1D.createRealMatrix(rows, cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            double sum = 0;\n            for (int k = 0; k < n; k++) {\n                sum += (matrix.getEntry(i, k) - matrix.getEntry(i, 0)) * (matrix.getEntry(j, k) - matrix.getEntry(j, 0));\n            }\n            result.setEntry(i, j, sum / (n - 1));\n        }\n    }\n    return result;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int n = matrix.getRowDimension();\n    RealMatrix result = RealMatrixFactory1D.createRealMatrix(n, n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            double sum = 0;\n            for (int k = 0; k < n; k++) {\n                sum += (matrix.getEntry(k, i) - matrix.getEntry(k, n - 1)) * (matrix.getEntry(k, j) - matrix.getEntry(k, n - 1));\n            }\n            if (biasCorrected) {\n                sum /= n - 1;\n            } else {\n                sum /= n;\n            }\n            result.setEntry(i, j, sum);\n        }\n    }\n    return result;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int n = matrix.getRowDimension();\n    int p = matrix.getColumnDimension();\n    double[] sumX = new double[p];\n    double[] sumY = new double[p];\n    double[] sumXY = new double[p];\n    double[] sumX2 = new double[p];\n    double[] sumY2 = new double[p];\n\n    for (int i = 0; i < n; i++) {\n        double[] row = matrix.getRow(i);\n        for (int j = 0; j < p; j++) {\n            sumX[j] += row[j];\n            sumY[j] += row[j];\n            sumXY[j] += row[j] * row[j];\n            sumX2[j] += row[j] * row[j];\n            sumY2[j] += row[j] * row[j];\n        }\n    }\n\n    RealMatrix covarianceMatrix = new Array2DRowRealMatrix(p, p);\n\n    for (int i = 0; i < p; i++) {\n        for (int j = 0; j < p; j++) {\n            double numerator = 0;\n            double denominator = 0;\n            for (int k = 0; k < n; k++) {\n                numerator += (matrix.getRow(k)[i] - sumX[i] / n) * (matrix.getRow(k)[j] - sumY[j] / n);\n                denominator += (matrix.getRow(k)[i] - sumX[i] / n) * (matrix.getRow(k)[i] - sumX[i] / n);\n            }\n            if (biasCorrected) {\n                covarianceMatrix.setEntry(i, j, numerator / (n - 1));\n            } else {\n                covarianceMatrix.setEntry(i, j, numerator / n);\n            }\n        }\n    }\n\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int rows = matrix.getRowDimension();\n    int cols = matrix.getColumnDimension();\n    RealMatrix result = RealMatrixFactory1D.createRealMatrix(rows, cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            double sum = 0;\n            for (int k = 0; k < n; k++) {\n                sum += (matrix.getEntry(i, k) - mean[i]) * (matrix.getEntry(j, k) - mean[j]);\n            }\n            if (biasCorrected) {\n                sum /= n - 1;\n            } else {\n                sum /= n;\n            }\n            result.setEntry(i, j, sum);\n        }\n    }\n    return result;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int rows = matrix.getRowDimension();\n    int cols = matrix.getColumnDimension();\n    if(rows < 2 || cols < 1) {\n        throw new MathIllegalArgumentException(\"Matrix must have at least one column and two rows\");\n    }\n    RealMatrix result = RealMatrixFactory1D.createRealMatrix(cols);\n    for(int i = 0; i < cols; i++) {\n        for(int j = 0; j < cols; j++) {\n            double sum = 0;\n            for(int k = 0; k < rows; k++) {\n                sum += (matrix.getEntry(k, i) - matrix.getEntry(0, i)) * (matrix.getEntry(k, j) - matrix.getEntry(0, j));\n            }\n            if(biasCorrected) {\n                sum /= rows - 1;\n            } else {\n                sum /= rows;\n            }\n            result.setEntry(i, j, sum);\n        }\n    }\n    return result;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int n = matrix.getRowDimension();\n    int p = matrix.getColumnDimension();\n    double[] means = new double[p];\n    for (int j = 0; j < p; j++) {\n        double sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += matrix.getEntry(i, j);\n        }\n        means[j] = sum / n;\n    }\n    RealMatrix result = RealMatrixFactory1D.createRealMatrix(p, p);\n    for (int i = 0; i < p; i++) {\n        for (int j = 0; j < p; j++) {\n            double sum = 0;\n            for (int k = 0; k < n; k++) {\n                double x = matrix.getEntry(k, i) - means[i];\n                double y = matrix.getEntry(k, j) - means[j];\n                sum += x * y;\n            }\n            if (biasCorrected) {\n                sum /= n - 1;\n            } else {\n                sum /= n;\n            }\n            result.setEntry(i, j, sum);\n        }\n    }\n    return result;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int rows = matrix.getRowDimension();\n    int cols = matrix.getColumnDimension();\n    RealMatrix result = MatrixFactory.createRealMatrix(rows, cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            double sum = 0;\n            for (int k = 0; k < n; k++) {\n                sum += (matrix.getEntry(i, k) - mean[i]) * (matrix.getEntry(j, k) - mean[j]);\n            }\n            if (biasCorrected) {\n                sum /= (n - 1);\n            } else {\n                sum /= n;\n            }\n            result.setEntry(i, j, sum);\n        }\n    }\n    return result;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int rows = matrix.getRowDimension();\n    int cols = matrix.getColumnDimension();\n    RealMatrix result = RealMatrixFactory1D.createRealMatrix(rows, cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            double sum = 0;\n            for (int k = 0; k < n; k++) {\n                sum += (matrix.getEntry(i, k) - mean[i]) * (matrix.getEntry(j, k) - mean[j]);\n            }\n            if (biasCorrected) {\n                sum /= (n - 1);\n            } else {\n                sum /= n;\n            }\n            result.setEntry(i, j, sum);\n        }\n    }\n    return result;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    int rows = matrix.getRowDimension();\n    int cols = matrix.getColumnDimension();\n    RealMatrix result = RealMatrixFactory1D.createRealMatrix(cols, cols);\n    for (int i = 0; i < cols; i++) {\n        for (int j = 0; j < cols; j++) {\n            double sum = 0;\n            for (int k = 0; k < rows; k++) {\n                sum += (matrix.getEntry(k, i) - matrix.getEntry(k, 0)) * (matrix.getEntry(k, j) - matrix.getEntry(k, 0));\n            }\n            if (biasCorrected) {\n                sum /= (rows - 1);\n            } else {\n                sum /= rows;\n            }\n            result.setEntry(i, j, sum);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        return processBitsGreater57(count);\n    }\n    long bitsOut = 0;\n    int overflowBits = 0;\n    long overflow = 0l;\n    while (count > 0) {\n        int toRead = Math.min(count, 64 - bitsCachedSize);\n        long bits = fromLittleEndian(in, toRead);\n        bitsOut |= (bits >> (bitsCachedSize - toRead));\n        bitsCachedSize += toRead;\n        if (bitsCachedSize >= 64) {\n            bitsCached = bits;\n            bitsCachedSize = 0;\n        }\n        count -= toRead;\n        if (bitsCachedSize == 8) {\n            bitsCachedSize = 0;\n            bitsCached = 0;\n        }\n    }\n    if (count > 0) {\n        return -1;\n    }\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        throw new IOException(\"Cannot read more than 63 bits at once\");\n    }\n    if (bitsCachedSize >= count) {\n        bitsCachedSize -= count;\n        bitsCached >>= count;\n        return bitsCached;\n    }\n    long bitsOut = 0;\n    int overflowBits = 0;\n    long overflow = 0l;\n    while (bitsCachedSize < count) {\n        int toRead = Math.min(count - bitsCachedSize, 8);\n        long bytesRead = fromLittleEndian(in, toRead);\n        bitsCachedSize += toRead;\n        bitsCached |= (bytesRead & MASKS[toRead]) << (bitsCachedSize - toRead);\n        overflowBits += toRead;\n        overflow |= (bytesRead >>> (32 - toRead));\n    }\n    bitsCachedSize -= count;\n    bitsCached >>= count;\n    bitsOut |= bitsCached;\n    bitsCached = overflow;\n    bitsCachedSize = overflowBits;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        throw new IOException(\"count is too large\");\n    }\n    long bitsOut = 0;\n    int overflowBits = 0;\n    long overflow = 0l;\n    while (count > 0) {\n        int toRead = Math.min(count, 8);\n        long bits = fromLittleEndian(in, toRead);\n        bitsOut |= (bits & MASKS[toRead]) << (overflowBits * 8);\n        overflowBits += toRead;\n        count -= toRead;\n        if (count > 0) {\n            if (bits < 0) {\n                throw new IOException(\"premature end of data\");\n            }\n            bitsOut |= (bits >> (8 - toRead)) << (overflowBits * 8);\n            overflowBits += 8 - toRead;\n            overflowBits -= toRead;\n        }\n    }\n    if (overflowBits > 0) {\n        bitsOut |= overflow << (overflowBits - 1) * 8;\n    }\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        throw new IOException(\"Too many bits requested\");\n    }\n    if (bitsCachedSize >= count) {\n        long bits = bitsCached;\n        bitsCached = 0;\n        bitsCachedSize = 0;\n        return bits >>> (64 - count);\n    }\n    int toRead = count - bitsCachedSize;\n    if (toRead > 0) {\n        bitsCachedSize += toRead;\n        bitsCached |= in.read() << (bitsCachedSize - toRead);\n    }\n    return bitsCached;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        return processBitsGreater57(count);\n    }\n\n    long bitsOut = 0;\n    int overflowBits = 0;\n    long overflow = 0l;\n\n    while (count > 0) {\n        int toRead = Math.min(count, 8);\n        long bits = fromLittleEndian(in, toRead);\n        bitsOut |= (bits >> (8 - toRead));\n        overflowBits = (int) (bits & ((1L << (8 - toRead)) - 1));\n        overflow |= (bits & ((1L << (8 - toRead)) - 1)) << toRead;\n        count -= toRead;\n    }\n\n    bitsCached = overflow;\n    bitsCachedSize = overflowBits;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        throw new IOException(\"Requested bit count exceeds maximum cache size\");\n    }\n    long bitsOut = 0;\n    int overflowBits = 0;\n    long overflow = 0l;\n    while (count > 0) {\n        if (bitsCachedSize == 0) {\n            if (bitsCachedSize == 0) {\n                bitsCachedSize = (int) in.read();\n                if (bitsCachedSize == -1) {\n                    return -1;\n                }\n                bitsCached = (long) (bitsCached & MASKS[bitsCachedSize]);\n            }\n        }\n        if (count <= bitsCachedSize) {\n            bitsOut |= (bitsCached & MASKS[count]);\n            bitsCached &= ~MASKS[count];\n            bitsCachedSize -= count;\n            count = 0;\n        } else {\n            bitsOut |= (bitsCached & MASKS[bitsCachedSize]);\n            bitsCached = (long) (bitsCached >> bitsCachedSize);\n            bitsCachedSize = 0;\n            count -= bitsCachedSize;\n            overflowBits = bitsCachedSize;\n            overflow = bitsCached;\n        }\n    }\n    if (overflowBits > 0) {\n        bitsOut |= (overflow << (count - overflowBits));\n        bitsCached = overflow >> (8 - overflowBits);\n        bitsCachedSize = 8 - overflowBits;\n    }\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        return processBitsGreater57(count);\n    }\n    long bitsOut = 0;\n    int overflowBits = 0;\n    long overflow = 0l;\n    for (int i = 0; i < count; i++) {\n        if (bitsCachedSize == 0) {\n            int bytesRead = in.read();\n            if (bytesRead == -1) {\n                return -1;\n            }\n            bitsCached = (long) (bytesRead & MASKS[bitsCachedSize]);\n            bitsCachedSize += 8;\n        }\n        bitsOut |= (bitsCached & MASKS[i % 8]);\n        bitsCached >>= 1;\n        overflowBits++;\n        if (overflowBits == 8) {\n            overflow = bitsCached;\n            bitsCached = 0;\n            bitsCachedSize = 0;\n            overflowBits = 0;\n        }\n    }\n    if (overflowBits > 0) {\n        bitsOut |= overflow << (8 - overflowBits);\n    }\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        return processBitsGreater57(count);\n    }\n\n    long bitsOut = 0;\n    int overflowBits = 0;\n    long overflow = 0l;\n\n    while (count > 0) {\n        if (bitsCachedSize == 0) {\n            if (in.available() == 0) {\n                return -1;\n            }\n            bitsCached = fromLittleEndian(in, 1);\n            bitsCachedSize = 8;\n        }\n\n        if (bitsCachedSize <= count) {\n            bitsOut |= (bitsCached & MASKS[count]) >>> (bitsCachedSize - count);\n            bitsCached &= ~MASKS[count];\n            bitsCachedSize -= count;\n            count = 0;\n        } else {\n            bitsOut |= (bitsCached & MASKS[count]) >>> (bitsCachedSize - count);\n            bitsCachedSize -= count;\n            count = 0;\n        }\n    }\n\n    if (bitsCachedSize > 0) {\n        overflowBits = bitsCachedSize;\n        overflow = bitsCached;\n    }\n\n    if (overflowBits > 0) {\n        bitsCached = overflow;\n        bitsCachedSize = overflowBits;\n    }\n\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        throw new IOException(\"Cannot read more than 63 bits at once\");\n    }\n    long bitsOut = 0;\n    int overflowBits = 0;\n    long overflow = 0l;\n    while (count > 0) {\n        if (bitsCachedSize == 0) {\n            if (bitsCached == 0) {\n                if (in.available() == 0) {\n                    return -1;\n                }\n                bitsCached = fromLittleEndian(in, 1);\n                bitsCachedSize = 8;\n            }\n            bitsCachedSize -= 8;\n        }\n        bitsOut |= (bitsCached & MASKS[count]) >>> (bitsCachedSize - count);\n        overflowBits = (int) ((bitsCached & MASKS[count]) >>> (bitsCachedSize - count));\n        overflow |= (long) overflowBits << (count);\n        bitsCached &= ~MASKS[count];\n        bitsCachedSize -= count;\n        count = 0;\n    }\n    if (bitsCachedSize > 0) {\n        alignWithByteBoundary();\n    }\n    return overflow | bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        throw new IOException(\"Requested bits exceed maximum cache size\");\n    }\n    long bitsOut = 0;\n    int overflowBits = 0;\n    long overflow = 0l;\n    while (count > 0) {\n        if (bitsCachedSize == 0) {\n            int toRead = Math.min(count, 8);\n            bitsCached = fromLittleEndian(in, toRead);\n            bitsCachedSize = toRead;\n        }\n        bitsOut |= (bitsCached & MASKS[count]) >>> (bitsCachedSize - count);\n        bitsCached &= ~MASKS[count];\n        bitsCachedSize -= count;\n        count = 0;\n        if (bitsCachedSize == 0) {\n            bitsCachedSize = in.available();\n            if (bitsCachedSize == 0) {\n                return -1;\n            }\n        }\n    }\n    return bitsOut;\n}"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    int m = getDimension();\n    int n = v.getDimension();\n    FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    int m = getDimension();\n    int n = v.getDimension();\n    FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    try {\n        return outerProduct((ArrayFieldVector<T>) v);\n    } catch (ClassCastException cce) {\n        final int m = data.length;\n        final int n = v.getDimension();\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n            }\n        }\n        return out;\n    }\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    int m = data.length;\n    int n = v.getDimension();\n    FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    int m = getDimension();\n    int n = v.getDimension();\n    FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    try {\n        return outerProduct((FieldVector<T>) v);\n    } catch (ClassCastException cce) {\n        final int m = data.length;\n        final int n = v.getDimension();\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n            }\n        }\n        return out;\n    }\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    try {\n        return outerProduct((ArrayFieldVector<T>) v);\n    } catch (ClassCastException cce) {\n        final int m = data.length;\n        final int n = v.getDimension();\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n            }\n        }\n        return out;\n    }\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = getDimension();\n    final int n = v.getDimension();\n    FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, getEntry(i).multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    return target.getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.getType() == Token.LABEL) {\n        return target.getString().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.isLabel()) {\n      return target.getString().equals(label);\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.isLabelName()) {\n        return target.getString().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.getType() == Token.LABEL) {\n        return target.getString().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.isLabel()) {\n        return target.getString().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.getType() == Token.LABEL) {\n      return target.getString().equals(label);\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.isLabel()) {\n        return target.getString().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    return target.getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.isLabel()) {\n      return target.getString().equals(label);\n    }\n    return false;\n  }"
    ],
    [
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null) {\n        return generator.generateURL(null, series, item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null && !urls.isEmpty()) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    XYDataset dataset = null;\n    // Get the dataset\n    // ...\n\n    // Get the series key\n    Comparable seriesKey = dataset.getSeriesKey(series);\n\n    // Get the x value\n    long x = (long) dataset.getXValue(series, item);\n\n    // Format the x value\n    String xValue = this.dateFormat.format(new Date(x));\n\n    // Generate the URL\n    String result = this.prefix;\n    boolean firstParameter = result.indexOf(\"?\") == -1;\n    if (seriesKey != null) {\n        result += firstParameter ? \"?\" : \"&amp;\";\n        String s = null;\n        try {\n            s = URLEncoder.encode(seriesKey.toString(), \"UTF-8\");\n        }\n        catch (UnsupportedEncodingException e) {\n            s = seriesKey.toString();\n        }\n        result += this.seriesParameterName + \"=\" + s;\n        firstParameter = false;\n    }\n\n    result += firstParameter ? \"?\" : \"&amp;\";\n    String s = null;\n    try {\n        s = URLEncoder.encode(xValue, \"UTF-8\");\n    }\n    catch (UnsupportedEncodingException e) {\n        s = xValue;\n    }\n    result += this.itemParameterName + \"=\" + s;\n\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator urlGenerator = getURLGenerator(series, item, false);\n    if (urlGenerator != null) {\n        return urlGenerator.generateURL(null, series, item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null && urls.size() > item) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    XYDataset dataset = null;\n    // TO DO: implement this method\n    // TO DO: implement this method\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    XYDataset dataset = null;\n    // Assuming the XYDataset is available in the context\n    // You can use it to get the series key, x value, and item value\n    Comparable seriesKey = dataset.getSeriesKey(series);\n    long x = (long) dataset.getXValue(series, item);\n    String xValue = this.dateFormat.format(new Date(x));\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        String url = null;\n        for (int i = 0; i < urls.size(); i++) {\n            String s = (String) urls.get(i);\n            if (s.contains(seriesKey.toString())) {\n                url = s;\n                break;\n            }\n        }\n        if (url == null) {\n            url = this.prefix + \"?series=\" + seriesKey.toString()\n                    + \"&x=\" + xValue;\n        }\n        return url;\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    XYDataset dataset = null;\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null) {\n        dataset = getDataset();\n        return generator.generateURL(dataset, series, item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null) {\n        XYDataset dataset = getDataset();\n        return generator.generateURL(dataset, series, item);\n    }\n    return null;\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    int i = 0;\n    while (i < str.length()) {\n        char c = str.charAt(i);\n        if (c == '[') {\n            return i;\n        }\n        i++;\n    }\n    return -1;\n}\nprotected static JsonPointer _parseTail(String input) {\n    int index = _parseIndex(input);\n    if (index == -1) {\n        return EMPTY;\n    }\n    String tail = input.substring(index + 1);\n    return new JsonPointer(tail);\n}\nprotected static JsonPointer _parseQuotedTail(String input, int i) {\n    int index = _parseIndex(input);\n    if (index == -1) {\n        return EMPTY;\n    }\n    String tail = input.substring(index + 1);\n    return new JsonPointer(tail);\n}\nprotected JsonPointer _constructHead() {\n    return new JsonPointer(\"\", \"\", 0, null);\n}\nprotected JsonPointer _constructHead(int suffixLength, JsonPointer last) {\n    return new JsonPointer(\"\", \"\", suffixLength, last);\n}",
      "private final static int _parseIndex(String str)  {\n    int i = 0;\n    int length = str.length();\n    while (i < length) {\n        char c = str.charAt(i);\n        if (c == '/') {\n            return i;\n        }\n        i++;\n    }\n    return -1;\n}\n\nprotected static JsonPointer _parseTail(String input) {\n    int index = _parseIndex(input);\n    if (index == -1) {\n        return new JsonPointer(input, \"\", 0, null);\n    }\n    String segment = input.substring(0, index);\n    String rest = input.substring(index + 1);\n    if (rest.isEmpty()) {\n        return new JsonPointer(input, segment, 0, null);\n    }\n    int matchIndex = _parseIndex(rest);\n    if (matchIndex == -1) {\n        return new JsonPointer(input, segment, 0, null);\n    }\n    String nextSegment = rest.substring(0, matchIndex);\n    String nextRest = rest.substring(matchIndex + 1);\n    return new JsonPointer(input, segment, matchIndex, _parseTail(nextRest));\n}\n\nprotected static JsonPointer _parseQuotedTail(String input, int i) {\n    int index = _parseIndex(input);\n    if (index == -1) {\n        return new JsonPointer(input, \"\", 0, null);\n    }\n    String segment = input.substring(0, index);\n    String rest = input.substring(index + 1);\n    if (rest.isEmpty()) {\n        return new JsonPointer(input, segment, 0, null);\n    }\n    int matchIndex = _parseIndex(rest);\n    if (matchIndex == -1) {\n        return new JsonPointer(input, segment, 0, null);\n    }\n    String nextSegment = rest.substring(0, matchIndex);\n    String nextRest = rest.substring(matchIndex + 1);\n    return new JsonPointer(input, segment, matchIndex, _parseQuotedTail(nextRest, i + 1));\n}\n\nprotected JsonPointer _constructHead() {\n    return new JsonPointer(\"\", \"\", 0, null);\n}\n\nprotected JsonPointer _constructHead(int suffixLength, JsonPointer last) {\n    return new JsonPointer(\"\", \"\", suffixLength, last);\n}",
      "private final static int _parseIndex(String str)  {\n    int i = 0;\n    int len = str.length();\n    while (i < len) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return i;\n        }\n        i++;\n    }\n    return i;\n}\nprotected static JsonPointer _parseTail(String input) {\n    int i = _parseIndex(input);\n    if (i == input.length()) {\n        return JsonPointer.EMPTY;\n    }\n    String segment = input.substring(0, i);\n    JsonPointer next = _parseTail(input.substring(i));\n    if (next == JsonPointer.EMPTY) {\n        return JsonPointer.valueOf(segment);\n    }\n    return new JsonPointer(segment, next);\n}\nprotected static JsonPointer _parseQuotedTail(String input, int i) {\n    int j = i + 1;\n    while (j < input.length() && input.charAt(j) != '\"') {\n        j++;\n    }\n    String segment = input.substring(i + 1, j);\n    JsonPointer next = _parseQuotedTail(input.substring(j + 1), 0);\n    if (next == JsonPointer.EMPTY) {\n        return JsonPointer.valueOf(segment);\n    }\n    return new JsonPointer(segment, next);\n}\nprotected JsonPointer _constructHead() {\n    return JsonPointer.EMPTY;\n}\nprotected JsonPointer _constructHead(int suffixLength, JsonPointer last) {\n    return last;\n}",
      "private final static int _parseIndex(String str)  {\n    int i = 0;\n    while (i < str.length()) {\n        char c = str.charAt(i);\n        if (c == '.') {\n            return i;\n        }\n        i++;\n    }\n    return -1;\n}\n\nprotected static JsonPointer _parseTail(String input) {\n    JsonPointer result = null;\n    int index = _parseIndex(input);\n    if (index != -1) {\n        String segment = input.substring(0, index);\n        String tail = input.substring(index + 1);\n        result = new JsonPointer(segment, segment, 0, _parseTail(tail));\n    } else {\n        result = new JsonPointer(input, input, 0, null);\n    }\n    return result;\n}\n\nprotected static JsonPointer _parseQuotedTail(String input, int i) {\n    int start = i;\n    while (i < input.length()) {\n        char c = input.charAt(i);\n        if (c == '\"') {\n            return new JsonPointer(input.substring(start, i), input.substring(start, i), 0, null);\n        }\n        i++;\n    }\n    return null;\n}\n\nprotected JsonPointer _constructHead() {\n    return new JsonPointer(\"\", \"\", 0, null);\n}\n\nprotected JsonPointer _constructHead(int suffixLength, JsonPointer last) {\n    return new JsonPointer(\"\", \"\", suffixLength, last);\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int index = 0;\n    for (int i = 0; i < len; i++) {\n        char c = str.charAt(i);\n        if (c == '/') {\n            index++;\n        }\n    }\n    return index;\n}\n\nprotected static JsonPointer _parseTail(String input) {\n    int index = _parseIndex(input);\n    if (index == 0) {\n        return JsonPointer.valueOf(input);\n    }\n    String[] segments = input.split(\"/\");\n    JsonPointer head = JsonPointer.valueOf(segments[0]);\n    for (int i = 1; i < segments.length; i++) {\n        head = head.append(JsonPointer.valueOf(segments[i]));\n    }\n    return head;\n}\n\nprotected static JsonPointer _parseQuotedTail(String input, int i) {\n    int index = _parseIndex(input);\n    if (index == 0) {\n        return JsonPointer.valueOf(input);\n    }\n    String[] segments = input.substring(i).split(\"/\");\n    JsonPointer head = JsonPointer.valueOf(input.substring(0, i));\n    for (int j = 0; j < segments.length; j++) {\n        head = head.append(JsonPointer.valueOf(segments[j]));\n    }\n    return head;\n}\n\nprotected JsonPointer _constructHead() {\n    return JsonPointer.valueOf(\"\");\n}\n\nprotected JsonPointer _constructHead(int suffixLength, JsonPointer last) {\n    return last;\n}",
      "private final static int _parseIndex(String str)  {\n    int i = 0;\n    while (i < str.length()) {\n        char c = str.charAt(i);\n        if (c == '[') {\n            return i;\n        }\n        i++;\n    }\n    return -1;\n}\n\nprotected static JsonPointer _parseTail(String input) {\n    int i = _parseIndex(input);\n    if (i == -1) {\n        return EMPTY;\n    }\n    return new JsonPointer(input.substring(i));\n}\n\nprotected static JsonPointer _parseQuotedTail(String input, int i) {\n    int j = i + 1;\n    while (j < input.length()) {\n        char c = input.charAt(j);\n        if (c == ']') {\n            return new JsonPointer(input.substring(i + 1, j));\n        }\n        j++;\n    }\n    return EMPTY;\n}\n\nprotected JsonPointer _constructHead() {\n    return new JsonPointer(\"\", \"\", 0, null);\n}\n\nprotected JsonPointer _constructHead(int suffixLength, JsonPointer last) {\n    return new JsonPointer(\"\", \"\", suffixLength, last);\n}",
      "private final static int _parseIndex(String str)  {\n    int i = 0;\n    while (i < str.length() && Character.isWhitespace(str.charAt(i))) {\n        i++;\n    }\n    return i;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    for (int i = 0; i < len; i++) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return i;\n        }\n    }\n    return len;\n}\n\nprotected static JsonPointer _parseTail(String input) {\n    int len = input.length();\n    JsonPointer head = null;\n    for (int i = 0; i < len; i++) {\n        char c = input.charAt(i);\n        if (c == '/') {\n            if (head == null) {\n                head = new JsonPointer();\n            }\n            head = head.append(new JsonPointer(input.substring(i + 1)));\n            i = len - 1;\n        }\n    }\n    return head;\n}\n\nprotected static JsonPointer _parseQuotedTail(String input, int i) {\n    int len = input.length();\n    JsonPointer head = null;\n    for (int j = i; j < len; j++) {\n        char c = input.charAt(j);\n        if (c == '\"') {\n            if (head == null) {\n                head = new JsonPointer(input.substring(i, j + 1));\n            }\n            return head;\n        }\n    }\n    return null;\n}\n\nprotected JsonPointer _constructHead() {\n    return new JsonPointer();\n}\n\nprotected JsonPointer _constructHead(int suffixLength, JsonPointer last) {\n    return new JsonPointer(last._asString + \"/\" + suffixLength);\n}",
      "private final static int _parseIndex(String str)  {\n    int i = 0;\n    while (i < str.length()) {\n        char c = str.charAt(i);\n        if (c <= INT_SPACE) {\n            i++;\n            continue;\n        }\n        if (c == '/') {\n            return i;\n        }\n        i++;\n    }\n    return -1;\n}\n\nprotected static JsonPointer _parseTail(String input) {\n    int index = _parseIndex(input);\n    if (index == -1) {\n        return EMPTY;\n    }\n    String segment = input.substring(index + 1);\n    return new JsonPointer(input, segment, 0, null);\n}\n\nprotected static JsonPointer _parseQuotedTail(String input, int i) {\n    int index = _parseIndex(input);\n    if (index == -1) {\n        return EMPTY;\n    }\n    String segment = input.substring(index + 1);\n    return new JsonPointer(input, segment, i, null);\n}\n\nprotected JsonPointer _constructHead() {\n    return new JsonPointer(\"\", \"\", 0, null);\n}\n\nprotected JsonPointer _constructHead(int suffixLength, JsonPointer last) {\n    return new JsonPointer(\"\", \"\", suffixLength, last);\n}",
      "private final static int _parseIndex(String str)  {\n    int i = 0;\n    int len = str.length();\n    while (i < len) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            break;\n        }\n        i++;\n    }\n    return i;\n}\n\nprotected static JsonPointer _parseTail(String input) {\n    int i = _parseIndex(input);\n    if (i == 0) {\n        return EMPTY;\n    }\n    return _parseQuotedTail(input, i);\n}\n\nprotected static JsonPointer _parseQuotedTail(String input, int i) {\n    JsonPointer tail = new JsonPointer();\n    tail._asString = input.substring(i);\n    return tail;\n}\n\nprotected JsonPointer _constructHead() {\n    return new JsonPointer();\n}\n\nprotected JsonPointer _constructHead(int suffixLength, JsonPointer last) {\n    JsonPointer head = _constructHead();\n    head._nextSegment = last;\n    return head;\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n    return new ArrayList<>(c).subList(0, k).toArray();\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE, k);\n    }\n\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (Object obj : c) {\n        sample[i++] = obj;\n    }\n    // Shuffle the sample\n    MathArrays.shuffle(sample, getRandomGenerator());\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n    return new ArrayList<>(c).subList(0, k).toArray();\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    int[] index = new int[c.size()];\n    for (int i = 0; i < c.size(); i++) {\n        index[i] = i;\n    }\n    MathArrays.shuffle(index, getRandomGenerator());\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = c.toArray()[index[i]];\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.COLLECTION_SAMPLE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.COLLECTION_SAMPLE_SIZE,\n                                               k);\n    }\n\n    Object[] sample = new Object[k];\n    int[] index = getNatural(c.size());\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    for (int i = 0; i < k; i++) {\n        sample[i] = c.toArray()[index[i]];\n    }\n\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE, k);\n    }\n\n    List<?> list = new ArrayList<>(c);\n    Collections.shuffle(list, getRandomGenerator());\n    return list.subList(0, k).toArray();\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_EXCEEDS_COLLECTION_SIZE, k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE, k);\n    }\n\n    return MathArrays.copyOf(c.toArray(), k);\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Call(methodName);\n    callNode.setSourcePosition(srcref.getSourcePosition());\n    callNode.setSourceOffset(srcref.getSourceOffset());\n    callNode.addChildToFront(argumentNode);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new CallNode(methodName, argumentNode, srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Call(methodName);\n    callNode.setSourcePosition(srcref.getSourcePosition());\n    callNode.setSourceFile(srcref.getSourceFile());\n    callNode.setLineno(srcref.getLineno());\n    callNode.setCharno(srcref.getCharno());\n    callNode.addChildToFront(argumentNode);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new CallNode(methodName);\n    callNode.addChildToFront(argumentNode);\n    callNode.setSourcePosition(srcref.getSourcePosition());\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new CallNode(methodName);\n    callNode.addChildToFront(argumentNode);\n    callNode.setSrcref(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new CallNode(methodName);\n    callNode.setArgument(argumentNode);\n    callNode.setSrcref(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Node(Node.CALL, methodName);\n    callNode.addChildToFront(argumentNode);\n    callNode.setSourcePosition(srcref.getSourcePosition());\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Node(Node.Call, argumentNode);\n    callNode.setSourcePosition(srcref.getSourcePosition());\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Node(Node.Call, null, null);\n    Node functionIdentifyingExpression = new Node(Node.GetProp, methodName, null);\n    callNode.addChildToFront(functionIdentifyingExpression);\n    callNode.addChildToFront(argumentNode);\n    callNode.setSourcePosition(srcref.getSourcePosition());\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Node(Node.Call, srcref);\n    Node methodIdentifyingExpression = new Node(Node.GetProp, methodName);\n    callNode.addChildToFront(methodIdentifyingExpression);\n    callNode.addChildToFront(argumentNode);\n    return callNode;\n}"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    int[] sortedIndices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        sortedIndices[i] = indices[i].index;\n    }\n    return sortedIndices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    int[] sortedIndices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        sortedIndices[i] = indices[i].index;\n    }\n    return sortedIndices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    int[] sortedIndices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        sortedIndices[i] = indices[i].index;\n    }\n    return sortedIndices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    int[] sortedIndices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        sortedIndices[i] = indices[i].index;\n    }\n    return sortedIndices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    int[] sortedIndices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        sortedIndices[i] = indices[i].index;\n    }\n    return sortedIndices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    int[] sortedIndices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        sortedIndices[i] = indices[i].index;\n    }\n    return sortedIndices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] doubleIndex = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        doubleIndex[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(doubleIndex);\n    int[] sortedIndices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        sortedIndices[i] = doubleIndex[i].index;\n    }\n    return sortedIndices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] doubleIndexArray = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        doubleIndexArray[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(doubleIndexArray);\n    int[] sortedIndices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        sortedIndices[i] = doubleIndexArray[i].index;\n    }\n    return sortedIndices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] doubleIndex = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        doubleIndex[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(doubleIndex);\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = doubleIndex[i].index;\n    }\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    int[] sortedIndices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        sortedIndices[i] = indices[i].index;\n    }\n    return sortedIndices;\n}"
    ],
    [
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getP().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getP().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) {\n        return this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = this.defaultGroup;\n    if (this.keyToGroupMap.containsKey(key)) {\n        result = (Comparable) this.keyToGroupMap.get(key);\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) {\n        return this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        return this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) {\n        return this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = this.defaultGroup;\n    if (this.keyToGroupMap.containsKey(key)) {\n        result = this.keyToGroupMap.get(key);\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) {\n        return this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        return this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        return this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) {\n        return this.defaultGroup;\n    }\n    return result;\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<>(set, transformer);\n}"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        buffer = new char[capacity];\n        System.arraycopy(buffer, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) {\n        buffer = new char[capacity];\n        System.arraycopy(buffer, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) {\n        buffer = new char[capacity];\n        System.arraycopy(buffer, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) {\n        buffer = new char[capacity];\n        System.arraycopy(buffer, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) {\n        buffer = new char[capacity];\n        System.arraycopy(buffer, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) {\n        buffer = new char[capacity];\n        System.arraycopy(buffer, 0, buffer, 0, size);\n    }\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    Range result = null;\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) {\n        double cumulativeTotal = 0.0;\n        double cumulativeMinimum = Double.POSITIVE_INFINITY;\n        double cumulativeMaximum = Double.NEGATIVE_INFINITY;\n        int itemCount = dataset.getColumnCount();\n        for (int i = 0; i < itemCount; i++) {\n            double value = dataset.getValue(s, i);\n            if (!Double.isNaN(value)) {\n                cumulativeTotal += value;\n                cumulativeMinimum = Math.min(cumulativeMinimum, value);\n                cumulativeMaximum = Math.max(cumulativeMaximum, value);\n            }\n        }\n        if (cumulativeMinimum < minimum) {\n            minimum = cumulativeMinimum;\n        }\n        if (cumulativeMaximum > maximum) {\n            maximum = cumulativeMaximum;\n        }\n    }\n    result = new Range(minimum, maximum);\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    } else {\n        result = iterateCumulativeRangeBounds(dataset, true);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    } else {\n        result = iterateCumulativeRangeBounds(dataset, true);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    Range result = null;\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    } else {\n        result = iterateCumulativeRangeBounds(dataset, true);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    } else {\n        result = iterateCumulativeRangeBounds(dataset, true);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset, true);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    Range result = null;\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    } else {\n        result = iterateCumulativeRangeBounds(dataset, true);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    Range result = null;\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) {\n        double cumulativeTotal = 0.0;\n        double[] values = dataset.getColumnKeys(s).toArray(new Comparable[0]);\n        for (int i = 0; i < values.length; i++) {\n            double value = dataset.getValue(values[i], s);\n            cumulativeTotal += value;\n            if (cumulativeTotal < minimum) {\n                minimum = cumulativeTotal;\n            }\n            if (cumulativeTotal > maximum) {\n                maximum = cumulativeTotal;\n            }\n        }\n    }\n    if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) {\n        return null;\n    }\n    return new Range(minimum, maximum);\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    int offset = hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000;\n    if (offset > 23 * 60 * 60 * 1000 * 1000 + 59 * 60 * 1000) {\n        throw new IllegalArgumentException(\"Resulting offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(\"UTC\" + hoursOffset + \":\" + minutesOffset, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    int offset = hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000;\n    if (offset > 23 * 60 * 60 * 1000 * 1000 + 59 * 60 * 1000) {\n        throw new IllegalArgumentException(\"Resulting offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(\"UTC\" + hoursOffset + \":\" + minutesOffset, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    int offset = hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000;\n    if (offset > 23 * 60 * 60 * 1000 * 1000 + 59 * 60 * 1000) {\n        throw new IllegalArgumentException(\"Offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(\"GMT\" + hoursOffset + \":\" + minutesOffset, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours offset out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes offset out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    int offset = hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000;\n    if (offset < -23 * 60 * 60 * 1000 || offset > 23 * 60 * 60 * 1000) {\n        throw new IllegalArgumentException(\"Offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(String.valueOf(hoursOffset) + \":\" + String.valueOf(minutesOffset), offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours offset out of range\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes offset out of range\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    int offset = hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000;\n    if (offset < -23 * 60 * 60 * 1000 || offset > 23 * 60 * 60 * 1000) {\n        throw new IllegalArgumentException(\"Offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(\"GMT\" + hoursOffset + \":\" + minutesOffset, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours offset out of range\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes offset out of range\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    long offset = hoursOffset * DateTimeConstants.MILLIS_PER_HOUR + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n    if (offset > DateTimeConstants.MILLIS_PER_DAY * 23 + DateTimeConstants.MILLIS_PER_MINUTE * 59) {\n        throw new IllegalArgumentException(\"Offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(\"UTC\" + hoursOffset + \":\" + minutesOffset, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    int offset = hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000;\n    if (offset < -23 * 60 * 60 * 1000 - 59 * 60 * 1000 || offset > 23 * 60 * 60 * 1000 + 59 * 60 * 1000) {\n        throw new IllegalArgumentException(\"Offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(\"GMT\" + hoursOffset + \":\" + minutesOffset, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours offset out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes offset out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    int offset = hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000;\n    if (offset < -23 * 60 * 60 * 1000 - 59 * 60 * 1000 || offset > 23 * 60 * 60 * 1000 + 59 * 60 * 1000) {\n        throw new IllegalArgumentException(\"Offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(\"UTC\" + hoursOffset + \":\" + minutesOffset, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes offset must be in the range -59 to +59\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    int offset = hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000;\n    if (offset < -23 * 60 * 60 * 1000 - 59 * 60 * 1000 || offset > 23 * 60 * 60 * 1000 + 59 * 60 * 1000) {\n        throw new IllegalArgumentException(\"Offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(\"GMT\" + hoursOffset + \":\" + minutesOffset, offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours offset out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes offset out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    long offset = hoursOffset * DateTimeConstants.MILLIS_PER_HOUR + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n    if (offset > DateTimeConstants.MILLIS_PER_DAY * 23 + DateTimeConstants.MILLIS_PER_MINUTE * 59) {\n        throw new IllegalArgumentException(\"Offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(\"GMT\" + hoursOffset + \":\" + minutesOffset, offset);\n}"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = StringUtil.borrowBuilder();\n    int depth = 1;\n    while (!isEmpty()) {\n        char c = peek();\n        if (c == open) {\n            depth++;\n        } else if (c == close) {\n            depth--;\n            if (depth == 0) {\n                break;\n            }\n        }\n        if (depth > 0) {\n            consume();\n            out.append(c);\n        }\n    }\n    return StringUtil.releaseBuilder(out);\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = new StringBuilder();\n    int depth = 0;\n    while (!isEmpty()) {\n        char c = peek();\n        if (c == open) {\n            depth++;\n        } else if (c == close) {\n            if (depth > 0) {\n                depth--;\n                out.append(c);\n            } else {\n                break;\n            }\n        } else {\n            out.append(c);\n        }\n        advance();\n    }\n    return out.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = new StringBuilder();\n    int depth = 1;\n    while (!isEmpty()) {\n        char c = consume();\n        if (c == open) {\n            depth++;\n        } else if (c == close) {\n            depth--;\n            if (depth == 0) {\n                break;\n            }\n        }\n        out.append(c);\n    }\n    return out.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    int count = 0;\n    StringBuilder out = StringUtil.borrowBuilder();\n    while (!isEmpty()) {\n        char c = peek();\n        if (c == open) {\n            count++;\n        } else if (c == close) {\n            count--;\n            if (count == 0) {\n                String data = consumeTo(String.valueOf(open) + String.valueOf(close));\n                return out.toString() + data;\n            }\n        } else {\n            out.append(consume());\n        }\n    }\n    return out.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = new StringBuilder();\n    int depth = 1;\n    while (!isEmpty()) {\n        char c = peek();\n        if (c == open) {\n            depth++;\n        } else if (c == close) {\n            depth--;\n            if (depth == 0) {\n                break;\n            }\n        }\n        consume();\n        out.append(c);\n    }\n    return out.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = new StringBuilder();\n    int count = 0;\n    while (!isEmpty()) {\n        char c = peek();\n        if (c == open) {\n            count++;\n        } else if (c == close) {\n            if (count > 0) {\n                count--;\n                out.append(c);\n            } else {\n                break;\n            }\n        } else {\n            out.append(consume());\n        }\n    }\n    return out.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    int depth = 1;\n    StringBuilder out = StringUtil.borrowBuilder();\n    while (!isEmpty()) {\n        char c = consume();\n        if (c == open) {\n            depth++;\n        } else if (c == close) {\n            depth--;\n            if (depth == 0) {\n                break;\n            }\n        }\n        out.append(c);\n    }\n    return StringUtil.releaseBuilder(out);\n}",
      "public String chompBalanced(char open, char close)  {\n    int depth = 1;\n    StringBuilder out = StringUtil.borrowBuilder();\n    while (!isEmpty()) {\n        char c = consume();\n        if (c == open) {\n            depth++;\n        } else if (c == close) {\n            depth--;\n            if (depth == 0) {\n                break;\n            }\n        }\n        out.append(c);\n    }\n    return StringUtil.releaseBuilder(out);\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = StringUtil.borrowBuilder();\n    int level = 1;\n    while (!isEmpty()) {\n        char c = peek();\n        if (c == open) {\n            level++;\n        } else if (c == close) {\n            level--;\n            if (level == 0) {\n                break;\n            }\n        }\n        if (level > 0) {\n            consume();\n            out.append(c);\n        }\n    }\n    return StringUtil.releaseBuilder(out);\n}",
      "public String chompBalanced(char open, char close)  {\n    int depth = 1;\n    StringBuilder out = StringUtil.borrowBuilder();\n    while (!isEmpty()) {\n        char c = peek();\n        if (c == open) {\n            depth++;\n        } else if (c == close) {\n            depth--;\n            if (depth == 0) {\n                break;\n            }\n        }\n        if (depth > 0) {\n            consume();\n            out.append(c);\n        } else {\n            consume();\n        }\n    }\n    return StringUtil.releaseBuilder(out);\n}"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix R = qr.getR();\n        int p = R.getColumnDimension();\n        RealMatrix RTR = R.transpose().multiply(R);\n        RealMatrix RTRInv = RTR.getSubMatrix(0, p-1, 0, p-1).inverse();\n        return RTRInv;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix R = qr.getR();\n        int p = R.getColumnDimension();\n        RealMatrix RTrans = R.transpose();\n        RealMatrix RTransR = RTrans.multiply(R);\n        RealMatrix RTransRInv = RTransR.getSubMatrix(0, p-1, 0, p-1).inverse();\n        return RTransRInv;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix qrR = qr.getR();\n        int p = qrR.getColumnDimension();\n        RealMatrix qrRt = qrR.transpose();\n        RealMatrix qrRtR = qrRt.multiply(qrR);\n        return qrRtR.getSubMatrix(0, p - 1, 0, p - 1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix R = qr.getR();\n        int p = R.getColumnDimension();\n        RealMatrix RTR = R.transpose().multiply(R);\n        RealMatrix invRTR = RTR.inverse();\n        RealMatrix result = invRTR.getSubMatrix(0, p-1, 0, p-1);\n        return result;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix R = qr.getR();\n        int p = R.getColumnDimension();\n        RealMatrix RTrans = R.transpose();\n        RealMatrix RTransR = RTrans.multiply(R);\n        RealMatrix inverseRTransR = RTransR.inverse();\n        return inverseRTransR.getSubMatrix(0, p-1, 0, p-1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix XTX = xMatrix.transpose().multiply(xMatrix);\n        RealMatrix XTXi = qr.getR().transpose().multiply(qr.getR());\n        RealMatrix betaVariance = XTXi.copy();\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix R = qr.getR();\n        int p = R.getColumnDimension();\n        RealMatrix RTR = R.transpose().multiply(R);\n        RealMatrix RTRinv = RTR.inverse();\n        RealMatrix result = RTRinv.getSubMatrix(0, p-1, 0, p-1);\n        return result;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix R = qr.getR();\n        int p = R.getColumnDimension();\n        RealMatrix RTR = R.transpose().multiply(R);\n        RealMatrix inverseRTR = RTR.inverse();\n        RealMatrix betaVariance = inverseRTR.getSubMatrix(0, p - 1, 0, p - 1);\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix qrR = qr.getR();\n        int p = qrR.getColumnDimension();\n        RealMatrix rT = qrR.transpose();\n        RealMatrix rTR = rT.multiply(qrR);\n        RealMatrix inverseRTR = rTR.getInverse();\n        return inverseRTR.getSubMatrix(0, p-1, 0, p-1);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix XTransposeXT = xMatrix.transpose().multiply(xMatrix);\n        RealMatrix XTransposeXTInverse = XTransposeXT.inverse();\n        RealMatrix RTransposeR = qr.getR().transpose().multiply(qr.getR());\n        int p = calculateBeta().getDimension();\n        RealMatrix RTransposeRInverse = RTransposeR.copy().getSubMatrix(0, p-1, 0, p-1).inverse();\n        return RTransposeRInverse;\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    int sign = offset < 0 ? -1 : 1;\n    offset = Math.abs(offset) / 3600000;\n    return sign == -1 ? \"-\" : \"+\";\n    + String.format(\"%02d:%02d\", offset / 60, offset % 60);\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().withChronology(new BaseChronology()).parseMillis(String.valueOf(offset));\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().withChronology(new BaseChronology()).parseMillis(String.valueOf(offset));\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"+00:00\";\n    }\n    return ((offset > 0) ? \"+\" : \"-\") + String.format(\"%02d:%02d\", Math.abs(offset) / 3600000, (Math.abs(offset) % 3600000) / 60000);\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"UTC\";\n    }\n    return offsetFormatter().withChronology(new BaseChronology()).print(offset);\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    int hours = offset / 3600000;\n    int minutes = (offset % 3600000) / 60000;\n    return String.format(\"%+d:%02d\", hours, minutes);\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().withChronology(new BaseChronology()).parseMillis(String.valueOf(offset));\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().withChronology(new BaseChronology()).print(offset);\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().withChronology(new BaseChronology()).parseMillis(String.valueOf(offset));\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().withChronology(new BaseChronology()).parseMillis(String.valueOf(offset));\n}"
    ],
    [
      "public int getIndex(Comparable key)  {\n    return this.keys.indexOf(key);\n}",
      "public int getIndex(Comparable key)  {\n    for (int i = 0; i < keys.size(); i++) {\n        if (keys.get(i).equals(key)) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    for (int i = 0; i < keys.size(); i++) {\n        if (keys.get(i).equals(key)) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    for (int i = 0; i < keys.size(); i++) {\n        if (keys.get(i).equals(key)) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    for (int i = 0; i < keys.size(); i++) {\n        if (keys.get(i).equals(key)) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    for (int i = 0; i < keys.size(); i++) {\n        if (keys.get(i).equals(key)) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    for (int i = 0; i < keys.size(); i++) {\n        if (keys.get(i).equals(key)) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    for (int i = 0; i < keys.size(); i++) {\n        if (keys.get(i).equals(key)) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    for (int i = 0; i < keys.size(); i++) {\n        if (keys.get(i).equals(key)) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    for (int i = 0; i < keys.size(); i++) {\n        if (keys.get(i).equals(key)) {\n            return i;\n        }\n    }\n    return -1;\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    return symbols;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> result = new HashMap<>();\n    for (Map.Entry<String, StaticSlot<JSType>> entry : cache.symbols.entrySet()) {\n        if (!slots.containsKey(entry.getKey())) {\n            slots.put(entry.getKey(), entry.getValue());\n        }\n        result.put(entry.getKey(), entry.getValue());\n    }\n    return result;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    return myFlowSlots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> result = new HashMap<>();\n    for (Map.Entry<String, StaticSlot<JSType>> entry : cache.symbols.entrySet()) {\n        if (!slots.containsKey(entry.getKey())) {\n            slots.put(entry.getKey(), entry.getValue());\n        }\n    }\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    return myFlowSlots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    return allFlowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    return symbols;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> myFlowSlots = new HashMap<>();\n    // implement your logic here\n    return myFlowSlots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    return symbols;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    return myFlowSlots;\n  }"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
    ],
    [
      "public static double atanh(double a)  {\n    if (a > 1 || a < -1) {\n        throw new ArithmeticException(\"Argument out of range: -1 <= a <= 1\");\n    }\n    if (a == 0) {\n        return 0;\n    }\n    double hiPrec[] = new double[2];\n    expm1(a * 2.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double na = ya;\n    double nb = yb;\n    double da = 2.0 + ya;\n    double db = -(da - 2.0 - ya);\n    double ratio = na / da;\n    double ratiob = (na - da * ratio - da * ratiob - db * ratio - db * ratiob) / da;\n    ratiob += nb / da;\n    ratiob += -db * na / da / da;\n    return ratio + ratiob;\n}",
      "public static double atanh(double a)  {\n    if (a > 1 || a < -1) {\n        throw new ArithmeticException(\"Argument out of range\");\n    }\n    if (a == 1) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (a == -1) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (a == 0) {\n        return 0;\n    }\n    if (a < 0) {\n        a = -a;\n    }\n    double hiPrec[] = new double[2];\n    expm1(Math.log(a) * 2, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double na = ya;\n    double nb = yb;\n    double da = 2.0 + ya;\n    double db = -(da - 2.0 - ya);\n    double temp = da + yb;\n    db += -(temp - da - yb);\n    da = temp;\n    temp = da * HEX_40000000;\n    double daa = da + temp - temp;\n    double dab = da - daa;\n    double ratio = na / da;\n    temp = ratio * HEX_40000000;\n    double ratioa = ratio + temp - temp;\n    double ratiob = ratio - ratioa;\n    ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;\n    ratiob += nb / da;\n    ratiob += -db * na / da / da;\n    return ratioa + ratiob;\n}",
      "public static double atanh(double a)  {\n    if (a > 1.0 || a < -1.0) {\n        throw new ArithmeticException(\"Argument out of range: |a| > 1\");\n    }\n    if (a == 0.0) {\n        return 0.0;\n    }\n    if (a == 1.0) {\n        return Math.log(1.0 + 1.0);\n    }\n    if (a == -1.0) {\n        return -Math.log(1.0 + 1.0);\n    }\n    double hiPrec[] = new double[2];\n    expm1(a*2.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double na = ya;\n    double nb = yb;\n    double da = 2.0 + ya;\n    double db = -(da - 2.0 - ya);\n    double temp = da + yb;\n    db += -(temp - da - yb);\n    da = temp;\n    double ratio = na / da;\n    temp = ratio * HEX_40000000;\n    double ratioa = ratio + temp - temp;\n    double ratiob = ratio - ratioa;\n    ratiob += (na - da * ratioa - da * ratiob - db * ratioa - db * ratiob) / da;\n    ratiob += nb / da;\n    ratiob += -db * na / da / da;\n    return ratioa + ratiob;\n}",
      "public static double atanh(double a)  {\n    if (a > 1.0 || a < -1.0) {\n        throw new ArithmeticException(\"Argument out of range\");\n    }\n    if (a == 1.0) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (a == -1.0) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (a == 0.0) {\n        return 0.0;\n    }\n    if (a > 0.0) {\n        return FastMath.log((1.0 + a) / (1.0 - a));\n    }\n    return -FastMath.log((1.0 + a) / (1.0 - a));\n}",
      "public static double atanh(double a)  {\n    if (a > 1.0 || a < -1.0) {\n        throw new ArithmeticException(\"Argument out of range: |a| > 1\");\n    }\n    double hiPrec[] = new double[2];\n    if (a < 0.0) {\n        a = -a;\n    }\n    expm1(a*2.0, hiPrec);\n\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n    /* Numerator */\n    double na = ya;\n    double nb = yb;\n\n    /* Denominator */\n    double da = 2.0 + ya;\n    double db = -(da - 2.0 - ya);\n    double temp = da + yb;\n    db += -(temp - da - yb);\n    da = temp;\n\n    temp = da * HEX_40000000;\n    double daa = da + temp - temp;\n    double dab = da - daa;\n\n    // ratio = na/da\n    double ratio = na/da;\n    temp = ratio * HEX_40000000;\n    double ratioa = ratio + temp - temp;\n    double ratiob = ratio - ratioa;\n\n    // Correct for rounding in division\n    ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n    // Account for nb\n    ratiob += nb / da;\n    // Account for db\n    ratiob += -db * na / da / da;\n\n    return ratioa + ratiob;\n}",
      "public static double atanh(double a)  {\n    if (a > 1.0 || a < -1.0) {\n        throw new ArithmeticException(\"Argument out of range\");\n    }\n    if (a == 0.0) {\n        return 0.0;\n    }\n    if (a == 1.0) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (a == -1.0) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (a > 0.0) {\n        return Math.log((1.0 + a) / (1.0 - a));\n    }\n    return -Math.log((1.0 + a) / (1.0 - a));\n}",
      "public static double atanh(double a)  {\n    if (a > 1.0 || a < -1.0) {\n        throw new ArithmeticException(\"Argument out of range\");\n    }\n    if (a == 1.0) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (a == -1.0) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    double hiPrec[] = new double[2];\n    expm1(a * 2.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double na = ya;\n    double nb = yb;\n    double da = 2.0 + ya;\n    double db = -(da - 2.0 - ya);\n    double ratio = na / da;\n    double ratioa = ratio;\n    double ratiob = 0.0;\n    ratiob += nb / da;\n    ratiob += -db * na / da / da;\n    return ratioa + ratiob;\n}",
      "public static double atanh(double a)  {\n    if (a > 1.0 || a < -1.0) {\n        throw new ArithmeticException(\"Argument out of range\");\n    }\n    double hiPrec[] = new double[2];\n    expm1(a * 2.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double na = ya;\n    double nb = yb;\n    double da = 2.0 + ya;\n    double db = -(da - 2.0 - ya);\n    double ratio = na / da;\n    double ratioa = ratio + (na - da * ratio) / da;\n    double ratiob = ratio - ratioa;\n    return ratioa + ratiob;\n}",
      "public static double atanh(double a)  {\n    if (a > 1 || a < -1) {\n        throw new ArithmeticException(\"Argument out of range\");\n    }\n    if (a == 1) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (a == -1) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (a == 0) {\n        return 0;\n    }\n    if (a < 0) {\n        a = -a;\n    }\n    double hiPrec[] = new double[2];\n    expm1(a * 2.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double na = ya;\n    double nb = yb;\n    double da = 2.0 + ya;\n    double db = -(da - 2.0 - ya);\n    double ratio = na / da;\n    double ratiob = (na - da * ratio - da * ratio) / da;\n    ratiob += nb / da;\n    ratiob += -db * na / da / da;\n    return ratio + ratiob;\n}",
      "public static double atanh(double a)  {\n    if (a > 1 || a < -1) {\n        throw new ArithmeticException(\"Argument out of range\");\n    }\n    if (a == 1) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (a == -1) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    double hiPrec[] = new double[2];\n    expm1(a * 2.0, hiPrec);\n    double ya = hiPrec[0] + hiPrec[1];\n    double yb = -(ya - hiPrec[0] - hiPrec[1]);\n    double na = ya;\n    double nb = yb;\n    double da = 2.0 + ya;\n    double db = -(da - 2.0 - ya);\n    double temp = da + yb;\n    db += -(temp - da - yb);\n    da = temp;\n    temp = da * HEX_40000000;\n    double daa = da + temp - temp;\n    double dab = da - daa;\n    double ratio = na / da;\n    temp = ratio * HEX_40000000;\n    double ratioa = ratio + temp - temp;\n    double ratiob = ratio - ratioa;\n    ratiob += (na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;\n    ratiob += nb / da;\n    ratiob += -db * na / da / da;\n    return ratioa + ratiob;\n}"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (normalizedSum == Double.POSITIVE_INFINITY || normalizedSum == Double.NEGATIVE_INFINITY) {\n        throw new MathIllegalArgumentException(\"Target sum is infinite\");\n    }\n    double sum = SUM.sum(values);\n    if (Double.isNaN(sum) || sum == 0) {\n        throw new MathArithmeticException(\"Input array contains infinite elements or sums to zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = sum(values);\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"normalizedSum is infinite or NaN\");\n    }\n    if (Double.isInfinite(sum) || sum == 0) {\n        throw new MathArithmeticException(\"sum is infinite or zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = sum(values);\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum is infinite or NaN\");\n    }\n    if (Double.isInfinite(sum) || sum == 0) {\n        throw new MathArithmeticException(\"Input array contains infinite elements or sums to zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = SUM.sum(values);\n    if (Double.isInfinite(sum) || Double.isNaN(sum)) {\n        throw new MathArithmeticException(\"Input array contains infinite elements or sums to zero.\");\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum is infinite or NaN.\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = 0;\n    for (double val : values) {\n        if (!Double.isNaN(val)) {\n            sum += val;\n        }\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"normalizedSum is infinite or NaN\");\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"sum is zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = 0.0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum is infinite or NaN\");\n    }\n    if (sum == 0.0) {\n        throw new MathArithmeticException(\"Input array sums to zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum is infinite or NaN\");\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Input array sums to zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = sum(values);\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"normalizedSum is infinite or NaN\");\n    }\n    if (Double.isInfinite(sum) || sum == 0) {\n        throw new MathArithmeticException(\"sum is infinite or zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            result[i] = Double.NaN;\n        } else {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = sum(values);\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum is infinite or NaN\");\n    }\n    if (Double.isInfinite(sum) || sum == 0) {\n        throw new MathArithmeticException(\"Input array contains infinite elements or sums to zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = SUM.sum(values);\n    if (Double.isInfinite(sum) || Double.isNaN(sum)) {\n        throw new MathArithmeticException(\"Array contains infinite or NaN values\");\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum is infinite or NaN\");\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Array sums to zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toUpperCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toUpperCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toUpperCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toUpperCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toUpperCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toUpperCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toUpperCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    StringBuilder result = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < len; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            result.append(ch);\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            result.append(Character.toUpperCase(ch));\n            capitalizeNext = false;\n        } else {\n            result.append(ch);\n        }\n    }\n    return result.toString();\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = X.transpose().multiply(OI).multiply(X);\n        RealMatrix XTOIY = X.transpose().multiply(OI).multiply(getY());\n        return XTOIX.solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = X.transpose().multiply(OI).multiply(X);\n        RealMatrix XTOIY = X.transpose().multiply(OI).multiply(getY());\n        return XTOIX.solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return XTOIX.solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XTOIX = getX().transpose().multiply(getOmegaInverse()).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(getOmegaInverse()).multiply(getY());\n        return XTOIX.solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XTOIX = getX().transpose().multiply(getOmegaInverse()).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(getOmegaInverse()).multiply(getY());\n        return XTOIX.solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return XTOIX.solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XTOIX = getX().transpose().multiply(getOmegaInverse()).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(getOmegaInverse()).multiply(getY());\n        return XTOIX.solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = X.transpose().multiply(OI).multiply(X);\n        RealMatrix XTOIY = X.transpose().multiply(OI).multiply(getY());\n        return XTOIX.solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(newYSampleData());\n        return XTOIX.solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(new Array2DRowRealMatrix(yVector.toArray()));\n        return XTOIX.solve(XTOIY);\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    return Collector.collect(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    return Collector.collect(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = normalize(id);\n    return Collector.collect(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = normalize(id);\n    return Collector.collect(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    return getElementsByTag(\"[\" + id + \"]\").first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = normalize(id);\n\n    return Collector.collect(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = normalize(id);\n    return Collector.collect(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    return getElementsByTag(\"[\" + id + \"]\").first();\n}",
      "public Element getElementById(String id)  {\n    return Collector.collect(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    return Collector.collect(new Evaluator.Id(id), this);\n}"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    int start = 0;\n    for (int i = 0; i < pattern.length(); i++) {\n        if (pattern.charAt(i) == START_FE) {\n            start = i;\n            while (i < pattern.length() && pattern.charAt(i) != END_FE) {\n                i++;\n            }\n            final String formatDesc = parseFormatDescription(pattern.substring(start, i), new ParsePosition(0));\n            if (registry != null) {\n                final FormatFactory factory = registry.get(formatDesc);\n                if (factory != null) {\n                    final Format format = factory.getFormat();\n                    result.append(pattern.substring(start, i));\n                    result.append(format.format(new Date()));\n                    i = i - 1;\n                } else {\n                    result.append(pattern.substring(start, i));\n                }\n            } else {\n                result.append(pattern.substring(start, i));\n            }\n        } else {\n            result.append(pattern.charAt(i));\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int start = 0;\n    for (int i = 0; i < pattern.length(); i++) {\n        char c = pattern.charAt(i);\n        if (c == START_FE) {\n            result.append(pattern.substring(start, i));\n            start = i + 1;\n            int depth = 1;\n            for (; i < pattern.length(); i++) {\n                c = pattern.charAt(i);\n                if (c == START_FE) {\n                    depth++;\n                } else if (c == END_FE) {\n                    depth--;\n                    if (depth == 0) {\n                        result.append(pattern.substring(start, i + 1));\n                        start = i + 1;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    result.append(pattern.substring(start));\n    if (!customPatterns.isEmpty()) {\n        for (String customPattern : customPatterns) {\n            result.insert(result.length(), customPattern);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int pos = 0;\n    while (pos < pattern.length()) {\n        if (pattern.charAt(pos) == START_FE) {\n            int depth = 1;\n            for (int i = pos + 1; i < pattern.length(); i++) {\n                if (pattern.charAt(i) == START_FE) {\n                    depth++;\n                } else if (pattern.charAt(i) == END_FE) {\n                    depth--;\n                    if (depth == 0) {\n                        break;\n                    }\n                }\n            }\n            String formatDesc = parseFormatDescription(pattern, new ParsePosition(pos));\n            if (registry != null) {\n                Format format = getFormat(formatDesc);\n                if (format != null) {\n                    result.append(QUOTE).append(format.format(new Date())).append(QUOTE);\n                } else {\n                    result.append(formatDesc);\n                }\n            } else {\n                result.append(formatDesc);\n            }\n            pos = i;\n        } else {\n            result.append(pattern.charAt(pos));\n            pos++;\n        }\n    }\n    if (customPatterns != null) {\n        for (String customPattern : customPatterns) {\n            result.append(customPattern);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder fullPattern = new StringBuilder();\n    int pos = 0;\n    while (pos < pattern.length()) {\n        if (pattern.charAt(pos) == START_FE) {\n            int depth = 1;\n            pos++;\n            while (pos < pattern.length() && depth > 0) {\n                switch (pattern.charAt(pos)) {\n                case START_FE:\n                    depth++;\n                    break;\n                case END_FE:\n                    depth--;\n                    if (depth == 0) {\n                        fullPattern.append(pattern.substring(pos - 1, pos));\n                        pos++;\n                        break;\n                    }\n                    break;\n                case QUOTE:\n                    getQuotedString(pattern, pos, false);\n                    break;\n                }\n                pos++;\n            }\n        } else {\n            fullPattern.append(pattern.charAt(pos));\n            pos++;\n        }\n    }\n    if (customPatterns != null) {\n        for (String customPattern : customPatterns) {\n            fullPattern.append(customPattern);\n        }\n    }\n    return fullPattern.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder fullPattern = new StringBuilder(pattern.length());\n    int pos = 0;\n    while (pos < pattern.length()) {\n        if (pattern.charAt(pos) == START_FE) {\n            int depth = 1;\n            for (int i = pos + 1; i < pattern.length(); i++) {\n                if (pattern.charAt(i) == START_FE) {\n                    depth++;\n                } else if (pattern.charAt(i) == END_FE) {\n                    depth--;\n                    if (depth == 0) {\n                        break;\n                    }\n                }\n            }\n            String formatDesc = parseFormatDescription(pattern, new ParsePosition(pos));\n            if (registry != null) {\n                Format format = getFormat(formatDesc);\n                if (format != null) {\n                    if (customPatterns != null) {\n                        for (String customPattern : customPatterns) {\n                            if (formatDesc.equals(customPattern)) {\n                                fullPattern.append(customPattern);\n                                pos += customPattern.length();\n                                break;\n                            }\n                        }\n                    }\n                    fullPattern.append(format.format(new Date()));\n                } else {\n                    fullPattern.append(formatDesc);\n                }\n            } else {\n                fullPattern.append(formatDesc);\n            }\n            pos = i;\n        } else {\n            fullPattern.append(pattern.charAt(pos));\n            pos++;\n        }\n    }\n    return fullPattern.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    int start = 0;\n    while (start < pattern.length()) {\n        int pos = readArgumentIndex(pattern, start);\n        if (pos == -1) {\n            result.append(pattern.substring(start));\n            start = pattern.length();\n        } else {\n            result.append(pattern.substring(start, pos));\n            final String desc = parseFormatDescription(pattern, new ParsePosition(pos));\n            if (registry != null) {\n                final FormatFactory factory = registry.get(desc);\n                if (factory != null) {\n                    final Format format = factory.getFormat();\n                    result.append(QUOTE).append(format.format(0)).append(QUOTE);\n                } else {\n                    result.append(desc);\n                }\n            } else {\n                result.append(desc);\n            }\n            start = pos + 1;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder stripCustom = new StringBuilder(pattern.length());\n    int start = 0;\n    for (int i = 0; i < pattern.length(); i++) {\n        char c = pattern.charAt(i);\n        if (c == START_FE) {\n            start = i;\n        } else if (c == END_FE) {\n            if (start > 0) {\n                stripCustom.append(pattern.substring(start, i));\n                if (registry != null) {\n                    String desc = parseFormatDescription(pattern, new ParsePosition(i));\n                    Format format = getFormat(desc);\n                    if (format != null) {\n                        if (customPatterns != null) {\n                            customPatterns.add(desc);\n                        }\n                        stripCustom.append(format.format(new Date()));\n                    } else {\n                        stripCustom.append(pattern.substring(start, i));\n                    }\n                } else {\n                    stripCustom.append(pattern.substring(start, i));\n                }\n            }\n            start = -1;\n        }\n    }\n    if (start > 0) {\n        stripCustom.append(pattern.substring(start));\n    }\n    return stripCustom.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder stripCustom = new StringBuilder(pattern.length());\n    int pos = 0;\n    while (pos < pattern.length()) {\n        if (pattern.charAt(pos) == START_FE) {\n            int depth = 1;\n            pos++;\n            while (pos < pattern.length() && pattern.charAt(pos) != END_FE) {\n                if (pattern.charAt(pos) == QUOTE) {\n                    getQuotedString(pattern, pos, false);\n                }\n                pos++;\n                if (pattern.charAt(pos) == START_FE) {\n                    depth++;\n                } else if (pattern.charAt(pos) == END_FE) {\n                    depth--;\n                    if (depth == 0) {\n                        break;\n                    }\n                }\n            }\n            pos++;\n        } else {\n            stripCustom.append(pattern.charAt(pos));\n        }\n        pos++;\n    }\n    String result = stripCustom.toString();\n    if (customPatterns != null) {\n        for (String customPattern : customPatterns) {\n            result = result.replace(\"{\" + customPattern + \"}\", customPattern);\n        }\n    }\n    return result;\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder fullPattern = new StringBuilder(pattern.length());\n    int pos = 0;\n    while (pos < pattern.length()) {\n        if (pattern.charAt(pos) == START_FE) {\n            int depth = 1;\n            for (; pos < pattern.length(); pos++) {\n                switch (pattern.charAt(pos)) {\n                case START_FE:\n                    depth++;\n                    break;\n                case END_FE:\n                    depth--;\n                    if (depth == 0) {\n                        fullPattern.append(pattern.substring(pos - 1, pos));\n                        pos++;\n                        break;\n                    }\n                    break;\n                case QUOTE:\n                    getQuotedString(pattern, pos, false);\n                    break;\n                }\n            }\n        } else {\n            fullPattern.append(pattern.charAt(pos));\n        }\n        pos++;\n    }\n    if (customPatterns != null) {\n        for (String customPattern : customPatterns) {\n            fullPattern.append(customPattern);\n        }\n    }\n    return fullPattern.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    int pos = 0;\n    while (pos < pattern.length()) {\n        if (pattern.charAt(pos) == START_FE) {\n            int depth = 1;\n            for (int i = pos + 1; i < pattern.length(); i++) {\n                if (pattern.charAt(i) == START_FE) {\n                    depth++;\n                } else if (pattern.charAt(i) == END_FE) {\n                    depth--;\n                    if (depth == 0) {\n                        break;\n                    }\n                }\n            }\n            result.append(pattern.substring(pos, pos + i));\n            pos = i;\n            if (registry != null) {\n                final String desc = parseFormatDescription(pattern, new ParsePosition(pos));\n                final Format format = getFormat(desc);\n                if (format != null) {\n                    if (registry.containsKey(desc)) {\n                        format = registry.get(desc);\n                    }\n                    result.append(format.format(new Date()));\n                }\n            } else {\n                result.append(pattern.substring(pos, pos + i));\n            }\n        } else {\n            result.append(pattern.charAt(pos));\n            pos++;\n        }\n    }\n    return result.toString();\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromTypeArguments = from.getActualTypeArguments();\n    Type[] toTypeArguments = to.getActualTypeArguments();\n    if (fromTypeArguments.length != toTypeArguments.length) {\n      return false;\n    }\n    for (int i = 0; i < fromTypeArguments.length; i++) {\n      Type fromArg = fromTypeArguments[i];\n      Type toArg = toTypeArguments[i];\n      if (!matches(fromArg, toArg, typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromTypeArgs = from.getActualTypeArguments();\n    Type[] toTypeArgs = to.getActualTypeArguments();\n    if (fromTypeArgs.length != toTypeArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromTypeArgs.length; i++) {\n      if (!matches(fromTypeArgs[i], toTypeArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      if (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(((TypeVariable<?>) fromArg).getName());\n      }\n      if (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(((TypeVariable<?>) toArg).getName());\n      }\n      if (!matches(fromArg, toArg, typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        return iPeriodConverters.add(converter, null);\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        PeriodConverter old = iPeriodConverters.select(converter.getClass());\n        if (old != null) {\n            iPeriodConverters.remove(old);\n        }\n        iPeriodConverters.add(converter, new PeriodConverter[0]);\n        return old;\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        return iPeriodConverters.add(converter, null);\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        return iPeriodConverters.add(converter, null);\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        return iPeriodConverters.add(converter, null);\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        return iPeriodConverters.add(converter, null);\n    }"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n    for (int i = 0; i < colorToNodeMap.length; i++) {\n      if (colorToNodeMap[i] == node) {\n        return node;\n      }\n    }\n    return null;\n  }",
      "public N getPartitionSuperNode(N node)  {\n    for (int i = 0; i < colorToNodeMap.length; i++) {\n      if (colorToNodeMap[i] == node) {\n        return node;\n      }\n    }\n    return null;\n  }",
      "public N getPartitionSuperNode(N node)  {\n  int color = color();\n  return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n  int color = graph.getDirectedGraphNode(node).getAnnotation(Color.class).value;\n  return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n  int color = (int) graph.getGraphNode(node).getAnnotation();\n  return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n    int color = color();\n    return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n    for (int i = 0; i < colorToNodeMap.length; i++) {\n      if (colorToNodeMap[i] == node) {\n        return node;\n      }\n    }\n    return null;\n  }",
      "public N getPartitionSuperNode(N node)  {\n    int color = graph.getDirectedGraphNode(node).getAnnotation(Color.class).value;\n    return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n    N superNode = null;\n    for (N n : graph.getNodes()) {\n        if (colorToNodeMap[color(n)] == n) {\n            superNode = n;\n            break;\n        }\n    }\n    return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n  int color = (int) graph.getGraphNode(node).getAnnotation();\n  return colorToNodeMap[color];\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null && map2 == null) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key = (Comparable) iterator1.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator = keys1.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator = keys1.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator = keys1.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    for (Map.Entry entry : map1.entrySet()) {\n        Comparable key = (Comparable) entry.getKey();\n        Paint paint = (Paint) entry.getValue();\n        if (!equalPaintMaps(map2, key, paint)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (keys1.size() != keys2.size()) {\n        return false;\n    }\n    Iterator iterator1 = keys1.iterator();\n    Iterator iterator2 = keys2.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key1 = (Comparable) iterator1.next();\n        Comparable key2 = (Comparable) iterator2.next();\n        if (!key1.equals(key2)) {\n            return false;\n        }\n        Paint paint1 = (Paint) map1.get(key1);\n        Paint paint2 = (Paint) map2.get(key2);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null && map2 == null) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator = keys1.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null && map2 == null) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    for (Comparable key : keys1) {\n        if (!map1.get(key).equals(map2.get(key))) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n      String key = getReplacement(expr.getString());\n      if (key != null) {\n        recordReplacement(parent, key);\n        return IR.string(key);\n      }\n    }\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // EXPR_RESULT\n    //   expression\n    Node expression = expr.getFirstChild();\n    if (nameIncludesFieldNameToStrip(expression) ||\n        qualifiedNameBeginsWithStripType(expression)) {\n      if (parent.isExprResult()) {\n        Node gramps = parent.getParent();\n        replaceWithEmpty(parent, gramps);\n        compiler.reportCodeChange();\n      } else {\n        replaceWithEmpty(n, parent);\n      }\n      return null;\n    }\n    // CALL/NEW\n    //   function\n    //   arguments\n    if (isMethodOrCtorCallThatTriggersRemoval(t, expr, parent)) {\n      replaceHighestNestedCallWithNull(expr, parent);\n      return null;\n    }\n    // Build a replacement abstract syntax tree for the string expression expr.\n    // Appends any string literal values that are encountered to keyBuilder,\n    // to build the expression's replacement key.\n    StringBuilder keyBuilder = new StringBuilder();\n    Node replacement = buildReplacement(expr, null, keyBuilder);\n    recordReplacement(expr, keyBuilder.toString());\n    return replacement;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // EXPR_RESULT\n    //   expression\n    Node expression = expr.getFirstChild();\n    if (expression.getType() == Token.STRING) {\n      String key = getReplacement(expression.getString());\n      if (key != null) {\n        Node replacement = buildReplacement(expression, parent, new StringBuilder());\n        recordReplacement(parent, key);\n        return replacement;\n      }\n    }\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // If the expression is a string literal, return it as is.\n    if (expr.getType() == Token.STRING) {\n      return expr;\n    }\n\n    // If the expression is a property access, replace it with the property\n    // name.\n    if (expr.getType() == Token.PROPERTY_ACCESS) {\n      Node property = expr.getFirstChild();\n      if (property.getType() == Token.STRING) {\n        return IR.string(property.getString());\n      }\n    }\n\n    // If the expression is a function call, replace it with the function name.\n    if (expr.getType() == Token.CALL) {\n      Node function = expr.getFirstChild();\n      if (function.getType() == Token.STRING) {\n        return IR.string(function.getString());\n      }\n    }\n\n    // If the expression is a binary expression, recursively replace the left\n    // and right operands.\n    if (expr.getType() == Token.BINARY) {\n      Node left = expr.getFirstChild();\n      Node right = left.getNext();\n      return IR.add(IR.replaceExpression(t, left, parent), IR.replaceExpression(t, right, parent));\n    }\n\n    // If the expression is a unary expression, recursively replace the operand.\n    if (expr.getType() == Token.UNARY) {\n      Node operand = expr.getFirstChild();\n      return IR.unary(IR.replaceExpression(t, operand, parent));\n    }\n\n    // If the expression is not a string literal, property access, function call,\n    // binary expression, or unary expression, return it as is.\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.getType() == Token.STRING) {\n      String key = getReplacement(expr.getString());\n      if (key != null) {\n        Node replacement = buildReplacement(expr, parent, new StringBuilder(key));\n        recordReplacement(parent, key);\n        return replacement;\n      }\n    }\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n      String key = getReplacement(expr.getString());\n      if (key != null) {\n        Node replacement = results.get(key).replacement;\n        recordReplacement(parent, key);\n        return replacement;\n      }\n    }\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.getType() == Token.STRING) {\n      String key = getReplacement(expr.getString());\n      if (key != null) {\n        Node replacement = buildReplacement(expr, parent, new StringBuilder(key));\n        recordReplacement(parent, key);\n        return replacement;\n      }\n    }\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // Check if the expression is a string literal\n    if (expr.getType() == Token.STRING) {\n      // Get the string value\n      String str = expr.getString();\n      // Check if the string value is a placeholder token\n      if (str.equals(placeholderToken)) {\n        // Replace the expression with a new replacement node\n        Node replacement = buildReplacement(expr, parent, new StringBuilder());\n        recordReplacement(parent, str);\n        return replacement;\n      }\n    }\n    // If the expression is not a string literal, return the original expression\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.getType() == Token.STRING) {\n      String key = getReplacement(expr.getString());\n      if (key != null) {\n        Node replacement = buildReplacement(expr, parent, new StringBuilder(key));\n        recordReplacement(parent, key);\n        return replacement;\n      }\n    }\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.getType() == Token.STRING) {\n      String key = getReplacement(expr.getString());\n      if (key != null) {\n        Node replacement = buildReplacement(expr, parent, new StringBuilder(key));\n        recordReplacement(parent, key);\n        return replacement;\n      }\n    }\n    return expr;\n  }"
    ],
    [
      "public double[] getCoefficients()  {\n    double[] out = new double[c.length];\n    System.arraycopy(c, 0, out, 0, c.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[c.length];\n    System.arraycopy(c, 0, out, 0, c.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[c.length];\n    System.arraycopy(c, 0, out, 0, c.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[c.length];\n    System.arraycopy(c, 0, out, 0, c.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[c.length];\n    System.arraycopy(c, 0, out, 0, c.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[c.length];\n    System.arraycopy(c, 0, out, 0, c.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[c.length];\n    System.arraycopy(c, 0, out, 0, c.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[c.length];\n    System.arraycopy(c, 0, out, 0, c.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[c.length];\n    System.arraycopy(c, 0, out, 0, c.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[c.length];\n    System.arraycopy(c, 0, out, 0, c.length);\n    return out;\n}"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  if (node.isJsDocInfo()) {\n    JSDocInfo docInfo = node.getJsDocInfo();\n    if (hasNoSideEffectsAnnotation(docInfo)) {\n      builder.setIsNoSideEffects(true);\n    }\n    if (hasSideEffectsThisAnnotation(docInfo)) {\n      builder.setIsSideEffectsThis(true);\n    }\n    if (hasSideEffectsArgumentsAnnotation(docInfo)) {\n      builder.setIsSideEffectsArguments(true);\n    }\n    if (docInfo.getDescription() != null) {\n      builder.setDesc(docInfo.getDescription());\n    }\n    return true;\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  if (node.isJsDocInfoNode()) {\n    JSDocInfo docInfo = node.getJsDocInfo();\n    if (hasNoSideEffectsAnnotation(docInfo)) {\n      builder.setIsNoSideEffects(true);\n    }\n    if (hasSideEffectsThisAnnotation(docInfo)) {\n      builder.setSideEffectsFlags(SideEffectFlags.MODIFIES_THIS);\n    }\n    if (hasSideEffectsArgumentsAnnotation(docInfo)) {\n      builder.setSideEffectsFlags(SideEffectFlags.MODIFIES_ARGUMENTS);\n    }\n    if (docInfo.getDescription() != null) {\n      builder.setDesc(docInfo.getDescription());\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  if (node.isJsDocInfo()) {\n    JSDocInfo docInfo = node.getJsDocInfo();\n    if (hasNoSideEffectsAnnotation(docInfo)) {\n      builder.setIsNoSideEffects(true);\n    }\n    if (hasSideEffectsThisAnnotation(docInfo)) {\n      builder.setIsSideEffectsThis(true);\n    }\n    if (hasSideEffectsArgumentsAnnotation(docInfo)) {\n      builder.setIsSideEffectsArguments(true);\n    }\n    String desc = docInfo.getDescription();\n    if (desc != null) {\n      builder.setDesc(desc);\n    }\n    return true;\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node.isJsDoc()) {\n        JSDocInfo docInfo = node.getJsDocInfo();\n        if (docInfo != null) {\n            if (hasNoSideEffectsAnnotation(docInfo)) {\n                builder.setIsNoSideEffects(true);\n            }\n            if (hasSideEffectsThisAnnotation(docInfo)) {\n                builder.setIsSideEffectsThis(true);\n            }\n            if (hasSideEffectsArgumentsAnnotation(docInfo)) {\n                builder.setIsSideEffectsArguments(true);\n            }\n            String desc = docInfo.getDescription();\n            if (desc != null) {\n                builder.setDesc(desc);\n            }\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  if (node.isJsDoc()) {\n    JSDocInfo jsDocInfo = node.getJSDocInfo();\n    if (jsDocInfo != null) {\n      if (hasNoSideEffectsAnnotation(jsDocInfo)) {\n        builder.setIsNoSideEffects(true);\n      }\n      if (hasSideEffectsThisAnnotation(jsDocInfo)) {\n        builder.setIsSideEffectsThis(true);\n      }\n      if (hasSideEffectsArgumentsAnnotation(jsDocInfo)) {\n        builder.setIsSideEffectsArguments(true);\n      }\n      String desc = jsDocInfo.getDescription();\n      if (desc != null) {\n        builder.setDesc(desc);\n      }\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node.isJsDoc()) {\n        JSDocInfo jsDocInfo = node.getJsDocInfo();\n        if (jsDocInfo != null) {\n            String desc = jsDocInfo.getDescription();\n            if (desc != null) {\n                builder.setDesc(desc);\n                return true;\n            }\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  if (node.isJsDoc()) {\n    JSDocInfo docInfo = node.getJsDocInfo();\n    if (hasNoSideEffectsAnnotation(docInfo)) {\n      builder.setIsNoSideEffects(true);\n    }\n    if (hasSideEffectsThisAnnotation(docInfo)) {\n      builder.setSideEffectsThis(true);\n    }\n    if (hasSideEffectsArgumentsAnnotation(docInfo)) {\n      builder.setSideEffectsArguments(true);\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  if (node.isJsDocInfoNode()) {\n    JSDocInfo docInfo = node.getJsDocInfo();\n    if (hasNoSideEffectsAnnotation(docInfo)) {\n      builder.setIsNoSideEffects(true);\n    }\n    if (hasSideEffectsThisAnnotation(docInfo)) {\n      builder.setIsSideEffectsThis(true);\n    }\n    if (hasSideEffectsArgumentsAnnotation(docInfo)) {\n      builder.setIsSideEffectsArguments(true);\n    }\n    if (docInfo.getDescription() != null) {\n      builder.setDesc(docInfo.getDescription());\n    }\n    return true;\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  if (node.isJsDoc()) {\n    JSDocInfo jsDocInfo = node.getJSDocInfo();\n    if (jsDocInfo != null) {\n      if (hasNoSideEffectsAnnotation(jsDocInfo)) {\n        builder.setIsNoSideEffects(true);\n      }\n      if (hasSideEffectsThisAnnotation(jsDocInfo)) {\n        builder.setIsSideEffectsThis(true);\n      }\n      if (hasSideEffectsArgumentsAnnotation(jsDocInfo)) {\n        builder.setIsSideEffectsArguments(true);\n      }\n      String desc = jsDocInfo.getDescription();\n      if (desc != null) {\n        builder.setDesc(desc);\n      }\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  JSDocInfo docInfo = node.getJSDocInfo();\n  if (docInfo != null) {\n    String desc = docInfo.getDescription();\n    if (desc != null) {\n      builder.setDesc(desc);\n      return true;\n    }\n  }\n  return false;\n}"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        Clusterable center = clusters.get(clusterIndex).getCenter();\n        double distance = distanceMeasure.distance(p, center);\n        for (int i = 0; i < clusters.size(); i++) {\n            if (i != clusterIndex) {\n                Clusterable c = clusters.get(i).getCenter();\n                double d = distanceMeasure.distance(p, c);\n                if (d < distance) {\n                    clusterIndex = i;\n                    distance = d;\n                }\n            }\n        }\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        Clusterable center = clusters.get(clusterIndex).getCenter();\n        double distance = distance(p, center);\n        for (int i = 0; i < clusters.size(); i++) {\n            if (i != clusterIndex) {\n                double tempDistance = distance(p, clusters.get(i).getCenter());\n                if (tempDistance < distance) {\n                    clusterIndex = i;\n                    distance = tempDistance;\n                }\n            }\n        }\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        clusters.get(clusterIndex).addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        Clusterable center = clusters.get(clusterIndex).getCenter();\n        double distance = distanceMeasure.distance(p, center);\n        double minDistance = Double.MAX_VALUE;\n        int nearestClusterIndex = -1;\n        for (int i = 0; i < clusters.size(); i++) {\n            Clusterable c = clusters.get(i).getCenter();\n            double dist = distanceMeasure.distance(p, c);\n            if (dist < minDistance) {\n                minDistance = dist;\n                nearestClusterIndex = i;\n            }\n        }\n        if (nearestClusterIndex != clusterIndex) {\n            assignedDifferently++;\n        }\n        assignments[pointIndex++] = nearestClusterIndex;\n    }\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        Clusterable center = clusters.get(clusterIndex).getCenter();\n        double distance = distance(p, center);\n        for (int i = 0; i < clusters.size(); i++) {\n            if (i != clusterIndex) {\n                double tempDistance = distance(p, clusters.get(i).getCenter());\n                if (tempDistance < distance) {\n                    clusterIndex = i;\n                    distance = tempDistance;\n                }\n            }\n        }\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        clusters.get(clusterIndex).addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        clusters.get(clusterIndex).addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        clusters.get(clusterIndex).addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        Clusterable center = clusters.get(clusterIndex).getCenter();\n        double distance = distance(p, center);\n        for (int i = 0; i < clusters.size(); i++) {\n            if (i != clusterIndex) {\n                double dist = distance(p, clusters.get(i).getCenter());\n                if (dist < distance) {\n                    clusterIndex = i;\n                    distance = dist;\n                }\n            }\n        }\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        clusters.get(clusterIndex).addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    checkSufficientData(getCovarianceMatrix());\n    int n = getN();\n    double[] x = new double[n];\n    double[] y = new double[n];\n    for (int i = 0; i < n; i++) {\n        x[i] = xArray[i];\n        y[i] = yArray[i];\n    }\n    double meanX = 0;\n    double meanY = 0;\n    for (int i = 0; i < n; i++) {\n        meanX += x[i];\n        meanY += y[i];\n    }\n    meanX /= n;\n    meanY /= n;\n    double cov = 0;\n    for (int i = 0; i < n; i++) {\n        cov += (x[i] - meanX) * (y[i] - meanY);\n    }\n    cov /= (n - 1);\n    if (!biasCorrected) {\n        cov /= n;\n    }\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    checkSufficientData(getCovarianceMatrix());\n    int n = getN();\n    double[] x = new double[n];\n    double[] y = new double[n];\n    for (int i = 0; i < n; i++) {\n        x[i] = xArray[i];\n        y[i] = yArray[i];\n    }\n    double sumXY = 0;\n    double sumX = 0;\n    double sumY = 0;\n    double sumXSq = 0;\n    double sumYSq = 0;\n    for (int i = 0; i < n; i++) {\n        sumXY += x[i] * y[i];\n        sumX += x[i];\n        sumY += y[i];\n        sumXSq += x[i] * x[i];\n        sumYSq += y[i] * y[i];\n    }\n    double covariance = 0;\n    if (biasCorrected) {\n        covariance = (sumXY - sumX * sumY / n) / (sumXSq - sumX * sumX / n) / (sumYSq - sumY * sumY / n);\n    } else {\n        covariance = sumXY / (sumXSq - sumX * sumX / n);\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    checkSufficientData(getCovarianceMatrix());\n    int n = getN();\n    double sumX = 0, sumY = 0, sumXY = 0, sumXSq = 0, sumYSq = 0;\n    for (int i = 0; i < n; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumXSq += xArray[i] * xArray[i];\n        sumYSq += yArray[i] * yArray[i];\n    }\n    double meanX = sumX / n;\n    double meanY = sumY / n;\n    double cov = 0;\n    if (biasCorrected) {\n        cov = (sumXY - sumX * meanY - sumY * meanX + sumX * sumY / n) / (n - 1);\n    } else {\n        cov = (sumXY - sumX * meanY - sumY * meanX + sumX * sumY / n) / n;\n    }\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    checkSufficientData(getCovarianceMatrix());\n    int n = getN();\n    double[] meanX = new double[n];\n    double[] meanY = new double[n];\n    double sumXX = 0;\n    double sumYY = 0;\n    double sumXY = 0;\n    for (int i = 0; i < n; i++) {\n        meanX[i] = getEntry(i, 0);\n        meanY[i] = getEntry(i, 1);\n        sumXX += Math.pow(getEntry(i, 0) - meanX[i], 2);\n        sumYY += Math.pow(getEntry(i, 1) - meanY[i], 2);\n        sumXY += (getEntry(i, 0) - meanX[i]) * (getEntry(i, 1) - meanY[i]);\n    }\n    double covariance = (biasCorrected) ? (sumXY - sumXX * sumYY / n) / (n - 1) : sumXY / n;\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    checkSufficientData(getCovarianceMatrix());\n    int n = getN();\n    double[] meanX = new double[n];\n    double[] meanY = new double[n];\n    double[] deviationsX = new double[n];\n    double[] deviationsY = new double[n];\n    double sumX = 0;\n    double sumY = 0;\n    double sumXY = 0;\n    double sumXSq = 0;\n    double sumYSq = 0;\n    for (int i = 0; i < n; i++) {\n        meanX[i] = xArray[i];\n        meanY[i] = yArray[i];\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumXSq += xArray[i] * xArray[i];\n        sumYSq += yArray[i] * yArray[i];\n    }\n    double meanXVal = sumX / n;\n    double meanYVal = sumY / n;\n    for (int i = 0; i < n; i++) {\n        deviationsX[i] = xArray[i] - meanXVal;\n        deviationsY[i] = yArray[i] - meanYVal;\n    }\n    double cov = 0;\n    for (int i = 0; i < n; i++) {\n        cov += deviationsX[i] * deviationsY[i];\n    }\n    cov /= (n - 1);\n    if (!biasCorrected) {\n        cov /= n;\n    }\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    checkSufficientData(getCovarianceMatrix());\n    int n = getN();\n    double[] meanX = new double[1];\n    double[] meanY = new double[1];\n    for (int i = 0; i < n; i++) {\n        meanX[0] += xArray[i];\n        meanY[0] += yArray[i];\n    }\n    meanX[0] /= n;\n    meanY[0] /= n;\n    double numerator = 0;\n    for (int i = 0; i < n; i++) {\n        numerator += (xArray[i] - meanX[0]) * (yArray[i] - meanY[0]);\n    }\n    double varianceX = 0;\n    double varianceY = 0;\n    for (int i = 0; i < n; i++) {\n        varianceX += (xArray[i] - meanX[0]) * (xArray[i] - meanX[0]);\n        varianceY += (yArray[i] - meanY[0]) * (yArray[i] - meanY[0]);\n    }\n    varianceX /= n;\n    varianceY /= n;\n    double covariance = numerator / (n - 1);\n    if (!biasCorrected) {\n        covariance /= varianceX;\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    checkSufficientData(getCovarianceMatrix());\n    int n = getN();\n    double[] meanX = new double[1];\n    double[] meanY = new double[1];\n    for (int i = 0; i < n; i++) {\n        meanX[0] += xArray[i];\n        meanY[0] += yArray[i];\n    }\n    meanX[0] /= n;\n    meanY[0] /= n;\n    double sumXX = 0;\n    double sumYY = 0;\n    double sumXY = 0;\n    for (int i = 0; i < n; i++) {\n        sumXX += (xArray[i] - meanX[0]) * (xArray[i] - meanX[0]);\n        sumYY += (yArray[i] - meanY[0]) * (yArray[i] - meanY[0]);\n        sumXY += (xArray[i] - meanX[0]) * (yArray[i] - meanY[0]);\n    }\n    double covariance = sumXY / n;\n    if (!biasCorrected) {\n        covariance = sumXY / (n - 1);\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    checkSufficientData(getCovarianceMatrix());\n    int n = getN();\n    double sumX = 0, sumY = 0, sumXSq = 0, sumYSq = 0, sumXY = 0;\n    for (int i = 0; i < n; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXSq += xArray[i] * xArray[i];\n        sumYSq += yArray[i] * yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n    double meanX = sumX / n;\n    double meanY = sumY / n;\n    double varianceX = sumXSq / n - meanX * meanX;\n    double varianceY = sumYSq / n - meanY * meanY;\n    double covariance = sumXY / n - meanX * meanY;\n    if (biasCorrected) {\n        covariance -= varianceX * varianceY / (varianceX + varianceY);\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    checkSufficientData(getCovarianceMatrix());\n    int n = getN();\n    double[] meanX = new double[1];\n    double[] meanY = new double[1];\n    for (int i = 0; i < n; i++) {\n        meanX[0] += xArray[i];\n        meanY[0] += yArray[i];\n    }\n    meanX[0] /= n;\n    meanY[0] /= n;\n    double sumXX = 0;\n    double sumYY = 0;\n    double sumXY = 0;\n    for (int i = 0; i < n; i++) {\n        sumXX += (xArray[i] - meanX[0]) * (xArray[i] - meanX[0]);\n        sumYY += (yArray[i] - meanY[0]) * (yArray[i] - meanY[0]);\n        sumXY += (xArray[i] - meanX[0]) * (yArray[i] - meanY[0]);\n    }\n    double covariance = sumXY / n;\n    if (!biasCorrected) {\n        covariance = sumXY / (n - 1);\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    checkSufficientData(getCovarianceMatrix());\n    int n = getN();\n    double sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;\n    for (int i = 0; i < n; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumX2 += xArray[i] * xArray[i];\n        sumY2 += yArray[i] * yArray[i];\n    }\n    double meanX = sumX / n;\n    double meanY = sumY / n;\n    double cov = 0;\n    if (biasCorrected) {\n        cov = (sumXY - sumX * meanY - sumY * meanX + sumX * sumY / n) / (n - 1);\n    } else {\n        cov = (sumXY - sumX * meanY - sumY * meanX + sumX * sumY / n) / n;\n    }\n    return cov;\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    if (value <= 0) {\n        return;\n    }\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) {\n                return;\n            }\n            skipped += x;\n        }\n        return;\n    }\n    throw new IOException(\"Invalid skip value: \" + value);\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value <= 0) {\n        return;\n    }\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = in.read(buf.array(), 0, (int) (buf.length > rem ? rem : buf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException();\n    }\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) {\n                return;\n            }\n            skipped += x;\n        }\n        return;\n    }\n    throw new IOException(\"Invalid skip value: \" + value);\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = readOneByte();\n            if (x == -1) {\n                return;\n            }\n            skipped += 1;\n        }\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = in.read(buf.array(), 0, (int) (buf.length > rem ? rem : buf.length));\n            if (x == -1) {\n                return;\n            }\n            skipped += x;\n        }\n        count(skipped);\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) {\n                return;\n            }\n            skipped += x;\n        }\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value <= 0) {\n        return;\n    }\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = in.read(buf.array(), 0, (int) (buf.length > rem ? rem : buf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) {\n                return;\n            }\n            skipped += x;\n        }\n    }\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n      if (part instanceof PlaceholderReference) {\n        sb.append(CaseFormat.LOWER_CAMEL.to(\n            CaseFormat.UPPER_UNDERSCORE,\n            ((PlaceholderReference) part).getName()));\n      } else {\n        sb.append(part);\n      }\n    }\n    return FP.fingerprint(sb.toString());\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n      sb.append(part);\n    }\n    return FP.fingerprint(sb.toString());\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n      sb.append(part.toString());\n    }\n    return FP.fingerprint(sb.toString());\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n      if (part instanceof PlaceholderReference) {\n        sb.append(CaseFormat.LOWER_CAMEL.to(\n            CaseFormat.UPPER_UNDERSCORE,\n            ((PlaceholderReference) part).getName()));\n      } else {\n        sb.append(part);\n      }\n    }\n    return sb.toString();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n      if (part instanceof PlaceholderReference) {\n        sb.append(CaseFormat.LOWER_CAMEL.to(\n            CaseFormat.UPPER_UNDERSCORE,\n            ((PlaceholderReference) part).getName()));\n      } else {\n        sb.append(part);\n      }\n    }\n    return FP.fingerprint(sb.toString());\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n      sb.append(part);\n    }\n    return String.valueOf(word64At(sb.toString().getBytes(), 0));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n      if (part instanceof PlaceholderReference) {\n        sb.append(CaseFormat.LOWER_CAMEL.to(\n            CaseFormat.UPPER_UNDERSCORE,\n            ((PlaceholderReference) part).getName()));\n      } else {\n        sb.append(part);\n      }\n    }\n    return sb.toString();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n      sb.append(part.toString());\n    }\n    return String.valueOf(word64At(sb.toString().getBytes(), 0));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n      if (part instanceof PlaceholderReference) {\n        sb.append(CaseFormat.LOWER_CAMEL.to(\n            CaseFormat.UPPER_UNDERSCORE,\n            ((PlaceholderReference) part).getName()));\n      } else {\n        sb.append(part);\n      }\n    }\n    return sb.toString();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n      if (part instanceof PlaceholderReference) {\n        sb.append(CaseFormat.LOWER_CAMEL.to(\n            CaseFormat.UPPER_UNDERSCORE,\n            ((PlaceholderReference) part).getName()));\n      } else {\n        sb.append(part);\n      }\n    }\n    return sb.toString();\n}"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long maxPosition = currentPosition + maxDistanceFromEnd;\n    long minPosition = currentPosition + minDistanceFromEnd;\n    while (currentPosition > minPosition && currentPosition < maxPosition) {\n        archive.position(currentPosition);\n        byte[] buffer = new byte[sig.length];\n        int bytesRead = archive.read(buffer);\n        if (bytesRead == sig.length && Arrays.equals(buffer, sig)) {\n            archive.position(currentPosition - sig.length);\n            return true;\n        }\n        currentPosition -= sig.length;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long maxPosition = currentPosition + maxDistanceFromEnd;\n    long minPosition = currentPosition + minDistanceFromEnd;\n    long position = maxPosition;\n    while (position >= minPosition) {\n        skipBytes((int) (position - currentPosition));\n        if (Arrays.equals(archive.readFully(wordBuf), sig)) {\n            archive.position(position);\n            return true;\n        }\n        position -= WORD;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long maxPosition = currentPosition + maxDistanceFromEnd;\n    long minPosition = currentPosition + minDistanceFromEnd;\n    for (long position = maxPosition; position >= minPosition; position--) {\n        archive.position(position);\n        ByteBuffer buffer = ByteBuffer.allocate(sig.length);\n        int bytesRead = archive.read(buffer);\n        if (bytesRead == sig.length) {\n            if (Arrays.equals(sig, buffer.array())) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long maxPosition = currentPosition + maxDistanceFromEnd;\n    long minPosition = currentPosition + minDistanceFromEnd;\n    long position = maxPosition;\n    while (position >= minPosition) {\n        archive.position(position);\n        byte[] buffer = new byte[sig.length];\n        int bytesRead = archive.read(buffer);\n        if (bytesRead == sig.length && Arrays.equals(buffer, sig)) {\n            archive.position(position);\n            return true;\n        }\n        position--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long maxPosition = currentPosition + maxDistanceFromEnd;\n    long minPosition = currentPosition + minDistanceFromEnd;\n    for (long position = maxPosition; position >= minPosition; position--) {\n        archive.position(position);\n        byte[] buffer = new byte[sig.length];\n        int bytesRead = archive.read(buffer);\n        if (bytesRead == sig.length && Arrays.equals(buffer, sig)) {\n            archive.position(position);\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long newPosition = currentPosition - minDistanceFromEnd;\n    if (newPosition < 0) {\n        throw new IOException(\"Invalid position\");\n    }\n    archive.position(newPosition);\n    byte[] buffer = new byte[(int) maxDistanceFromEnd];\n    int bytesRead = archive.read(buffer);\n    if (bytesRead != buffer.length) {\n        throw new IOException(\"Premature end of file\");\n    }\n    for (int i = buffer.length - sig.length; i >= 0; i--) {\n        boolean match = true;\n        for (int j = 0; j < sig.length; j++) {\n            if (buffer[i + j] != sig[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long position = archive.position();\n    long distanceFromEnd = archive.size() - position;\n    if (distanceFromEnd < minDistanceFromEnd || distanceFromEnd > maxDistanceFromEnd) {\n        return false;\n    }\n    long start = position + distanceFromEnd - maxDistanceFromEnd;\n    long end = position + distanceFromEnd - minDistanceFromEnd;\n    ByteBuffer buffer = ByteBuffer.allocate((int) (end - start));\n    archive.read(buffer);\n    buffer.rewind();\n    if (buffer.hasRemaining()) {\n        buffer.get(buffer.array(), 0, buffer.remaining());\n    }\n    return Arrays.equals(buffer.array(), sig);\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long end = archive.size();\n    long maxPosition = end - maxDistanceFromEnd;\n    long minPosition = end - minDistanceFromEnd;\n\n    if (currentPosition > maxPosition) {\n        currentPosition = maxPosition;\n    }\n\n    if (currentPosition < minPosition) {\n        return false;\n    }\n\n    while (currentPosition >= minPosition) {\n        archive.position(currentPosition);\n        byte[] buffer = new byte[sig.length];\n        archive.read(buffer);\n        if (Arrays.equals(buffer, sig)) {\n            archive.position(currentPosition);\n            return true;\n        }\n        currentPosition--;\n    }\n\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long maxPosition = currentPosition + maxDistanceFromEnd;\n    long minPosition = currentPosition + minDistanceFromEnd;\n    for (long position = maxPosition; position >= minPosition; position--) {\n        archive.position(position);\n        byte[] buffer = new byte[sig.length];\n        int bytesRead = archive.read(buffer);\n        if (bytesRead == sig.length && Arrays.equals(buffer, sig)) {\n            archive.position(position);\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long newPosition = currentPosition - minDistanceFromEnd;\n    if (newPosition < 0) {\n        newPosition = 0;\n    }\n    archive.position(newPosition);\n    int bytesRead = 0;\n    while (bytesRead < sig.length) {\n        int read = archive.read(wordBuf);\n        if (read <= 0) {\n            throw new EOFException();\n        }\n        bytesRead += read;\n        int i = bytesRead - sig.length;\n        while (i >= 0) {\n            boolean match = true;\n            for (int j = 0; j < sig.length; j++) {\n                if (wordBuf[i + j] != sig[j]) {\n                    match = false;\n                    break;\n                }\n            }\n            if (match) {\n                return true;\n            }\n            i--;\n        }\n    }\n    return false;\n}"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= this.dataset.getSeriesCount()) {\n        return null;\n    }\n    return this.dataset.getSeriesKey(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    return new Integer(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    return new Integer(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= this.dataset.getSeriesCount()) {\n        return null;\n    }\n    return this.dataset.getSeriesKey(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= this.dataset.getSeriesCount()) {\n}\n}",
      "protected Comparable getSectionKey(int section)  {\n    return new Integer(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    return this.dataset.getSeriesKey(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    return this.dataset.getSeriesKey(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    return new Integer(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    return null;\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            Number n = getNumberValue();\n            return n instanceof Double && Double.isNaN(((Double) n).doubleValue());\n        }",
      "@Override\n        public boolean isNaN()  {\n            return getNumberType() == NumberType.FLOAT || getNumberType() == NumberType.DOUBLE;\n        }",
      "@Override\n        public boolean isNaN()  {\n            Number n = getNumberValue();\n            return n instanceof Double && Double.isNaN(((Double) n).doubleValue());\n        }",
      "@Override\n        public boolean isNaN()  {\n            return getNumberValue() instanceof Double && ((Double) getNumberValue()).isNaN();\n        }",
      "@Override\n        public boolean isNaN()  {\n            return getNumberType() == NumberType.FLOAT || getNumberType() == NumberType.DOUBLE;\n        }",
      "@Override\n        public boolean isNaN()  {\n            return getNumberValue() instanceof Double && ((Double) getNumberValue()).isNaN();\n        }",
      "@Override\n        public boolean isNaN()  {\n            return _currToken == JsonToken.VALUE_NUMBER_FLOAT && ((Number) _currentObject()).isNaN();\n        }",
      "@Override\n        public boolean isNaN()  {\n            return getNumberValue().isNaN();\n        }",
      "@Override\n        public boolean isNaN()  {\n            return getNumberType() == NumberType.FLOAT || getNumberType() == NumberType.DOUBLE;\n        }",
      "@Override\n        public boolean isNaN()  {\n            return getNumberValue().isNaN();\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (ignoreCase) {\n        return CharSequenceUtils.regionMatches(str, true, 0, prefix, 0, prefix.length());\n    } else {\n        return CharSequenceUtils.regionMatches(str, false, 0, prefix, 0, prefix.length());\n    }\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (ignoreCase) {\n        return CharSequenceUtils.regionMatches(str, true, 0, prefix, 0, prefix.length());\n    } else {\n        return CharSequenceUtils.regionMatches(str, false, 0, prefix, 0, prefix.length());\n    }\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (ignoreCase) {\n        int strIndex = 0;\n        int prefixIndex = 0;\n        while (strIndex < str.length() && prefixIndex < prefix.length()) {\n            char strChar = Character.toLowerCase(str.charAt(strIndex));\n            char prefixChar = Character.toLowerCase(prefix.charAt(prefixIndex));\n            if (strChar != prefixChar) {\n                return false;\n            }\n            strIndex++;\n            prefixIndex++;\n        }\n        return strIndex == prefixIndex;\n    } else {\n        int strIndex = 0;\n        int prefixIndex = 0;\n        while (strIndex < str.length() && prefixIndex < prefix.length()) {\n            if (str.charAt(strIndex) != prefix.charAt(prefixIndex)) {\n                return false;\n            }\n            strIndex++;\n            prefixIndex++;\n        }\n        return strIndex == prefixIndex;\n    }\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (ignoreCase) {\n        int strOffset = 0;\n        int prefixOffset = 0;\n        while (strOffset < str.length() && prefixOffset < prefix.length()) {\n            char c1 = Character.toLowerCase((char) str.charAt(strOffset));\n            char c2 = Character.toLowerCase((char) prefix.charAt(prefixOffset));\n            if (c1 != c2) {\n                return false;\n            }\n            strOffset++;\n            prefixOffset++;\n        }\n        return strOffset == str.length() && prefixOffset == prefix.length();\n    } else {\n        int strOffset = 0;\n        int prefixOffset = 0;\n        while (strOffset < str.length() && prefixOffset < prefix.length()) {\n            if (str.charAt(strOffset) != prefix.charAt(prefixOffset)) {\n                return false;\n            }\n            strOffset++;\n            prefixOffset++;\n        }\n        return strOffset == str.length() && prefixOffset == prefix.length();\n    }\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return ignoreCase ? CharSequenceUtils.regionMatches(str, true, 0, prefix, 0, prefix.length()) : str.subSequence(0, prefix.length()).equals(prefix);\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (ignoreCase) {\n        return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n    } else {\n        return str.toString().startsWith(prefix.toString());\n    }\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (ignoreCase) {\n        int strOffset = 0;\n        int prefixOffset = 0;\n        while (strOffset < str.length() && prefixOffset < prefix.length()) {\n            char strChar = Character.toLowerCase(Character.codePointAt(str, strOffset));\n            char prefixChar = Character.toLowerCase(Character.codePointAt(prefix, prefixOffset));\n            if (strChar != prefixChar) {\n                return false;\n            }\n            strOffset++;\n            prefixOffset++;\n        }\n        return strOffset == str.length() && prefixOffset == prefix.length();\n    } else {\n        return str.startsWith(prefix.toString());\n    }\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (ignoreCase) {\n        return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n    } else {\n        return str.toString().startsWith(prefix.toString());\n    }\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (ignoreCase) {\n        int strIndex = 0;\n        int prefixIndex = 0;\n        while (strIndex < str.length() && prefixIndex < prefix.length()) {\n            char strChar = Character.toLowerCase(str.charAt(strIndex));\n            char prefixChar = Character.toLowerCase(prefix.charAt(prefixIndex));\n            if (strChar != prefixChar) {\n                return false;\n            }\n            strIndex++;\n            prefixIndex++;\n        }\n        return strIndex == str.length() && prefixIndex == prefix.length();\n    } else {\n        return str.toString().startsWith(prefix.toString());\n    }\n}"
    ],
    [
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED) {\n      return nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      return nextQuotedValue('\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      return nextUnquotedValue();\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n      return peekedString;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED) {\n      return nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      return nextQuotedValue('\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      return nextUnquotedValue();\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n      return peekedString;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED) {\n      return nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      return nextQuotedValue('\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      return nextUnquotedValue();\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n      return peekedString;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED) {\n      return nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      return nextQuotedValue('\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      return nextUnquotedValue();\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n      return peekedString;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED) {\n      return nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      return nextQuotedValue('\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      return nextUnquotedValue();\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n      return peekedString;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED) {\n      return nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      return nextQuotedValue('\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      return nextUnquotedValue();\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n      return peekedString;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED) {\n      return nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      return nextQuotedValue('\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      return nextUnquotedValue();\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n      return peekedString;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED) {\n      return nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      return nextQuotedValue('\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      return nextUnquotedValue();\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n      return peekedString;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED) {\n      return nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      return nextQuotedValue('\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      return nextUnquotedValue();\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n      return peekedString;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED) {\n      return nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n      return nextQuotedValue('\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      return nextUnquotedValue();\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n      return peekedString;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum width is 4\");\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    final int len = str.length();\n    if (offset > len) {\n        offset = len;\n    }\n    if (offset + maxWidth > len) {\n        return str.substring(0, offset) + \"...\";\n    }\n    if (offset + maxWidth <= len) {\n        return str.substring(0, offset) + \"...\";\n    }\n    return str.substring(0, len);\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum width is 4\");\n    }\n    final int len = str.length();\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (offset > len) {\n        offset = len;\n    }\n    if (offset + 3 > maxWidth) {\n        return str.substring(0, offset) + \"...\";\n    }\n    if (len - offset > maxWidth - 3) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    return str;\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"maxWidth must be at least 4\");\n    }\n    final int len = str.length();\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (offset > len) {\n        offset = len;\n    }\n    if (offset + maxWidth > len) {\n        return str.substring(0, offset) + \"...\";\n    }\n    if (offset + maxWidth <= len) {\n        return str.substring(0, offset) + \"...\";\n    }\n    return str;\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"maxWidth must be at least 4\");\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    final int len = str.length();\n    if (len <= offset) {\n        return str;\n    }\n    if (len - offset <= maxWidth - 3) {\n        return str.substring(offset);\n    }\n    return str.substring(0, offset) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"maxWidth must be at least 4\");\n    }\n    final int len = str.length();\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (offset > len) {\n        offset = len;\n    }\n    if (offset + 3 > len) {\n        return str;\n    }\n    if (len - offset > maxWidth - 3) {\n        return str.substring(0, offset) + \"...\";\n    }\n    return str.substring(0, offset) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum width is 4\");\n    }\n    final int len = str.length();\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (offset > len) {\n        offset = len;\n    }\n    if (len <= maxWidth) {\n        return str;\n    }\n    if (offset + 3 > maxWidth) {\n        return str.substring(0, offset) + \"...\";\n    }\n    return str.substring(0, offset) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Maximum width must be at least 4\");\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    final int len = str.length();\n    if (len <= offset) {\n        return str;\n    }\n    if (len <= maxWidth) {\n        return str;\n    }\n    final int end = Math.min(len, offset + maxWidth - 3);\n    return str.substring(0, end) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Maximum width must be at least 4\");\n    }\n    final int len = str.length();\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (offset > len) {\n        offset = len;\n    }\n    if (offset + maxWidth > len) {\n        return str.substring(0, offset) + \"...\";\n    }\n    return str.substring(0, offset) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"maxWidth must be at least 4\");\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (offset + 3 > maxWidth) {\n        return str.substring(0, offset) + \"...\";\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    return str.substring(0, offset) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"maxWidth must be at least 4\");\n    }\n    final int len = str.length();\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (offset > len) {\n        offset = len;\n    }\n    if (offset + maxWidth > len) {\n        return str.substring(0, offset) + \"...\";\n    }\n    if (offset + maxWidth <= len) {\n        return str.substring(0, offset) + \"...\";\n    }\n    return str;\n}"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (s1[i] == null) {\n            if (s2[i] != null) {\n                return false;\n            }\n        }\n        if (s2[i] == null) {\n            if (s1[i] != null) {\n                return false;\n            }\n        }\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (s1[i] == null) {\n            if (s2[i] != null) {\n                return false;\n            }\n        }\n        if (s2[i] == null) {\n            if (s1[i] != null) {\n                return false;\n            }\n        }\n        if (!equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (s1[i] == null) {\n            if (s2[i] != null) {\n                return false;\n            }\n        }\n        if (s2[i] == null) {\n            if (s1[i] != null) {\n                return false;\n            }\n        }\n        if (!equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (s1[i] == null) {\n            if (s2[i] != null) {\n                return false;\n            }\n        }\n        if (s2[i] == null) {\n            if (s1[i] != null) {\n                return false;\n            }\n        }\n        if (!equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (s1[i] == null) {\n            if (s2[i] != null) {\n                return false;\n            }\n        }\n        if (s2[i] == null) {\n            if (s1[i] != null) {\n                return false;\n            }\n        }\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (s1[i] == null) {\n            if (s2[i] != null) {\n                return false;\n            }\n        }\n        if (s2[i] == null) {\n            if (s1[i] != null) {\n                return false;\n            }\n        }\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (s1[i] == null) {\n            if (s2[i] != null) {\n                return false;\n            }\n        }\n        if (s2[i] == null) {\n            if (s1[i] != null) {\n                return false;\n            }\n        }\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (s1[i] == null) {\n            if (s2[i] != null) {\n                return false;\n            }\n        }\n        if (s2[i] == null) {\n            if (s1[i] != null) {\n                return false;\n            }\n        }\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (s1[i] == null) {\n            if (s2[i] != null) {\n                return false;\n            }\n        }\n        if (s2[i] == null) {\n            if (s1[i] != null) {\n                return false;\n            }\n        }\n        if (!equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (s1[i] == null) {\n            if (s2[i] != null) {\n                return false;\n            }\n        }\n        if (s2[i] == null) {\n            if (s1[i] != null) {\n                return false;\n            }\n        }\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n        if (symbolName != lastSourceFile) {\n            lastSourceFile = symbolName;\n            Integer index = originalNameMap.get(symbolName);\n            if (index != null) {\n                lastSourceFileIndex = index;\n            } else {\n                lastSourceFileIndex = originalNameMap.size();\n                originalNameMap.put(symbolName, lastSourceFileIndex);\n            }\n        }\n        return lastSourceFileIndex;\n    } else {\n        return -1;\n    }\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n      if (symbolName != lastSourceFile) {\n        lastSourceFile = symbolName;\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) {\n          lastSourceFileIndex = index;\n        } else {\n          lastSourceFileIndex = originalNameMap.size();\n          originalNameMap.put(symbolName, lastSourceFileIndex);\n        }\n      }\n      return lastSourceFileIndex;\n    } else {\n      return -1;\n    }\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n      if (symbolName != lastSourceFile) {\n        lastSourceFile = symbolName;\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) {\n          lastSourceFileIndex = index;\n        } else {\n          lastSourceFileIndex = originalNameMap.size();\n          originalNameMap.put(symbolName, lastSourceFileIndex);\n        }\n      }\n      return lastSourceFileIndex;\n    } else {\n      return -1;\n    }\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n        if (symbolName != lastSourceFile) {\n            lastSourceFile = symbolName;\n            Integer index = originalNameMap.get(symbolName);\n            if (index != null) {\n                lastSourceFileIndex = index;\n            } else {\n                lastSourceFileIndex = originalNameMap.size();\n                originalNameMap.put(symbolName, lastSourceFileIndex);\n            }\n        }\n        return lastSourceFileIndex;\n    }\n    return -1;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n      if (symbolName != lastSourceFile) {\n        lastSourceFile = symbolName;\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) {\n          lastSourceFileIndex = index;\n        } else {\n          lastSourceFileIndex = originalNameMap.size();\n          originalNameMap.put(symbolName, lastSourceFileIndex);\n        }\n      }\n      return lastSourceFileIndex;\n    }\n    return -1;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n      if (symbolName != lastSourceFile) {\n        lastSourceFile = symbolName;\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) {\n          lastSourceFileIndex = index;\n        } else {\n          lastSourceFileIndex = originalNameMap.size();\n          originalNameMap.put(symbolName, lastSourceFileIndex);\n        }\n      }\n      return lastSourceFileIndex;\n    } else {\n      return -1;\n    }\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n        if (symbolName != lastSourceFile) {\n            lastSourceFile = symbolName;\n            Integer index = originalNameMap.get(symbolName);\n            if (index != null) {\n                lastSourceFileIndex = index;\n            } else {\n                lastSourceFileIndex = originalNameMap.size();\n                originalNameMap.put(symbolName, lastSourceFileIndex);\n            }\n        }\n        return lastSourceFileIndex;\n    } else {\n        return -1;\n    }\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n        if (symbolName != lastSourceFile) {\n            lastSourceFile = symbolName;\n            Integer index = originalNameMap.get(symbolName);\n            if (index != null) {\n                lastSourceFileIndex = index;\n            } else {\n                lastSourceFileIndex = originalNameMap.size();\n                originalNameMap.put(symbolName, lastSourceFileIndex);\n            }\n        }\n        return lastSourceFileIndex;\n    }\n    return -1;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n      if (symbolName != lastSourceFile) {\n        lastSourceFile = symbolName;\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) {\n          lastSourceFileIndex = index;\n        } else {\n          lastSourceFileIndex = originalNameMap.size();\n          originalNameMap.put(symbolName, lastSourceFileIndex);\n        }\n      }\n      return lastSourceFileIndex;\n    } else {\n      return UNMAPPED;\n    }\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n        if (symbolName != lastSourceFile) {\n            lastSourceFile = symbolName;\n            Integer index = originalNameMap.get(symbolName);\n            if (index != null) {\n                lastSourceFileIndex = index;\n            } else {\n                lastSourceFileIndex = originalNameMap.size();\n                originalNameMap.put(symbolName, lastSourceFileIndex);\n            }\n        }\n        return lastSourceFileIndex;\n    } else {\n        return -1;\n    }\n}"
    ],
    [
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n  }\n  throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    }\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    }\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    }\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n  }",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n\n  if (p == PEEKED_NUMBER) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n  }\n  throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n\n  if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return peekedLong;\n  }\n  if (p == PEEKED_NUMBER) {\n    String str = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n    try {\n      return Double.parseDouble(str);\n    } catch (NumberFormatException e) {\n      throw syntaxError(\"Expected a number but was \" + str + locationString());\n    }\n  }\n  throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n  }\n  throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    } else {\n      throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n  }",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n\n  if (p == PEEKED_NUMBER) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n  } else {\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n  }\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n\n  if (p == PEEKED_NUMBER) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n  } else if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return peekedLong;\n  } else {\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n  }\n}"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null || repeat <= 0) {\n            return str;\n        }\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < repeat; i++) {\n            result.append(str);\n        }\n        return result.toString();\n    }",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null || repeat <= 0) {\n        return str;\n    }\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        result.append(str);\n    }\n    return result.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat < 0) {\n        return EMPTY;\n    }\n    if (repeat == 0) {\n        return EMPTY;\n    }\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        result.append(str);\n    }\n    return result.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat < 0) {\n        return EMPTY;\n    }\n    if (repeat == 0) {\n        return EMPTY;\n    }\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        result.append(str);\n    }\n    return result.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null || repeat <= 0) {\n            return str;\n        }\n        if (repeat < 0) {\n            repeat = 0;\n        }\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < repeat; i++) {\n            result.append(str);\n        }\n        return result.toString();\n    }",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null || repeat <= 0) {\n        return str;\n    }\n    if (repeat < 0) {\n        return EMPTY;\n    }\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        result.append(str);\n    }\n    return result.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null || repeat <= 0) {\n        return str;\n    }\n    if (repeat < 0) {\n        repeat = 0;\n    }\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        result.append(str);\n    }\n    return result.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null || repeat <= 0) {\n            return str;\n        }\n        if (repeat < 0) {\n            repeat = 0;\n        }\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < repeat; i++) {\n            result.append(str);\n        }\n        return result.toString();\n    }\n    //-----------------------------------------------------------------------\n    // Substring",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null || repeat <= 0) {\n        return str;\n    }\n    if (repeat < 0) {\n        return EMPTY;\n    }\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        result.append(str);\n    }\n    return result.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat < 0) {\n        return EMPTY;\n    }\n    if (repeat == 0) {\n        return EMPTY;\n    }\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        sb.append(str);\n    }\n    return sb.toString();\n}"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField();\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        clazz = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    try {\n        return (ZipExtraField) Class.forName(\"archivers/zip/\" + headerId.getValue() + \"ExtraField\").newInstance();\n    } catch (ClassNotFoundException e) {\n        return new UnrecognizedExtraField(headerId);\n    }\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        clazz = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        clazz = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        return new UnrecognizedExtraField(headerId);\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        clazz = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) clazz.newInstance();\n}"
    ],
    [
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for(int i=0; i<sz; i++) {\n        if(chars.contains(chrs[i])) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for (int i = 0; i < sz; i++) {\n        if (chars.contains(chrs[i])) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for (int i = 0; i < sz; i++) {\n        if (chars.contains(chrs[i])) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for (int i = 0; i < sz; i++) {\n        if (chars.contains(chrs[i])) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for(int i=0; i<sz; i++) {\n        if(chars.contains(chrs[i])) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for (int i = 0; i < sz; i++) {\n        if (chars.contains(chrs[i])) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for(int i=0; i<sz; i++) {\n        if(chars.contains(chrs[i])) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (str == null || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for(int i=0; i<sz; i++) {\n        if(chars.contains(chrs[i])) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for (int i = 0; i < sz; i++) {\n        if (chars.contains(chrs[i])) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for (int i = 0; i < sz; i++) {\n        if (chars.contains(chrs[i])) {\n            count++;\n        }\n    }\n    return count;\n}"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    if (map == null) {\n        return null;\n    }\n    Map clone = new HashMap();\n    for (Map.Entry entry : map.entrySet()) {\n        clone.put(entry.getKey(), entry.getValue().clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    if (map == null) {\n        return null;\n    }\n    Map clone = new HashMap();\n    for (Map.Entry entry : map.entrySet()) {\n        clone.put(entry.getKey(), entry.getValue().clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    for (Object key : map.keySet()) {\n        clone.put(key, ((Marker) map.get(key)).clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    for (Map.Entry entry : map.entrySet()) {\n        clone.put(entry.getKey(), entry.getValue().clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    if (map == null) {\n        return null;\n    }\n    Map clone = new HashMap();\n    for (Map.Entry entry : map.entrySet()) {\n        clone.put(entry.getKey(), entry.getValue().clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    if (map == null) {\n        return null;\n    }\n    Map clone = new HashMap();\n    for (Map.Entry entry : map.entrySet()) {\n        clone.put(entry.getKey(), entry.getValue().clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    for (Map.Entry entry : map.entrySet()) {\n        clone.put(entry.getKey(), entry.getValue().clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    if (map == null) {\n        return null;\n    }\n    Map clone = new HashMap();\n    for (Object key : map.keySet()) {\n        clone.put(key, ((Marker) map.get(key)).clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    if (map == null) {\n        return null;\n    }\n    Map clone = new HashMap();\n    for (Map.Entry entry : map.entrySet()) {\n        clone.put(entry.getKey(), entry.getValue().clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    if (map == null) {\n        return null;\n    }\n    Map clone = new HashMap();\n    for (Map.Entry entry : map.entrySet()) {\n        clone.put(entry.getKey(), entry.getValue().clone());\n    }\n    return clone;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount = lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount = lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount = lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount = lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount = lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e : coll) {\n            if (!set.contains(e)) {\n                super.add(index++, e);\n                set.add(e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (set.contains(e) == false) {\n                toAdd.add(e);\n                changed = true;\n            }\n        }\n        if (changed) {\n            super.addAll(index, toAdd);\n            set.addAll(toAdd);\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds elements if unique\n        for (final E element : coll) {\n            if (!set.contains(element)) {\n                add(index++, element);\n                changed = true;\n            }\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (contains(e)) {\n                continue;\n            }\n            toAdd.add(e);\n            changed = true;\n        }\n        if (changed) {\n            super.addAll(index, toAdd);\n            set.addAll(toAdd);\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds elements if unique\n        for (final E element : coll) {\n            if (!set.contains(element)) {\n                add(index++, element);\n                changed = true;\n            }\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e : coll) {\n            if (!set.contains(e)) {\n                super.add(index++, e);\n                set.add(e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e : coll) {\n            if (!set.contains(e)) {\n                super.add(index++, e);\n                set.add(e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // adds elements if unique\n        for (final E element : coll) {\n            if (!set.contains(element)) {\n                add(index++, element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds elements if unique\n        for (final E element : coll) {\n            if (!set.contains(element)) {\n                add(index++, element);\n                changed = true;\n            }\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds elements if unique\n        for (final E element : coll) {\n            if (!set.contains(element)) {\n                add(index++, element);\n                changed = true;\n            }\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  {\n    try {\n        evaluations.incrementCount();\n        return f.value(x);\n    } catch (MaxCountExceededException e) {\n        throw new TooManyEvaluationsException(e.getMessage());\n    }\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    try {\n        return f.value(x);\n    } catch (TooManyEvaluationsException e) {\n        throw new TooManyEvaluationsException(\"Maximal number of evaluations exceeded\");\n    }\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    try {\n        return f.value(x);\n    } catch (TooManyEvaluationsException e) {\n        throw new TooManyEvaluationsException(\"Maximal number of evaluations exceeded\", e);\n    }\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    try {\n        evaluations.incrementCount();\n        return f.value(x);\n    } catch (TooManyEvaluationsException e) {\n        throw e;\n    }\n}"
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> newConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            newConstraints.add(normalize(constraint));\n        } else {\n            newConstraints.add(constraint);\n        }\n    }\n    return newConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> newConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            newConstraints.add(normalize(constraint));\n        } else {\n            newConstraints.add(constraint);\n        }\n    }\n    return newConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> newConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            newConstraints.add(normalize(constraint));\n        } else {\n            newConstraints.add(constraint);\n        }\n    }\n    return newConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> newConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            newConstraints.add(normalize(constraint));\n        } else {\n            newConstraints.add(constraint);\n        }\n    }\n    return newConstraints;\n}"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound <= bin.getUpperBound() && this.upperBound >= bin.getLowerBound()) {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound > bin.getUpperBound()) {\n        return false;\n    }\n    if (this.upperBound < bin.getLowerBound()) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound > bin.upperBound || this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"bin\");\n    }\n    return !(this.lowerBound > bin.upperBound || this.upperBound < bin.lowerBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound > bin.upperBound || this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"bin\");\n    }\n    if (this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound) {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"bin\");\n    }\n    if (this.lowerBound > bin.upperBound || this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound <= bin.getUpperBound() && this.upperBound >= bin.getLowerBound()) {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound <= bin.getUpperBound() && this.upperBound >= bin.getLowerBound()) {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new NullPointerException(\"Bin is null\");\n    }\n    if (this.lowerBound <= bin.getUpperBound() && this.upperBound >= bin.getLowerBound()) {\n        return true;\n    }\n    return false;\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder sb = new StringBuilder();\n    final char[] chars = str.toCharArray();\n    boolean inToken = false;\n    for (char c : chars) {\n        int type = Character.getType(c);\n        if (type == Character.UPPERCASE_LETTER) {\n            if (camelCase && sb.length() > 0 && Character.isLowerCase(sb.charAt(sb.length() - 1))) {\n                sb.append(c);\n                continue;\n            }\n            inToken = true;\n        } else if (type == Character.LOWERCASE_LETTER) {\n            if (!inToken) {\n                sb.append(c);\n                continue;\n            }\n            inToken = false;\n        } else {\n            if (inToken) {\n                sb.append(c);\n            } else {\n                sb.append(' ');\n                sb.append(c);\n            }\n            inToken = false;\n        }\n    }\n    return sb.toString().trim().split(\"\\\\s+\");\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    List<String> tokens = new ArrayList<>();\n    int pos = 0;\n    int lastPos = 0;\n    char prevChar = 0;\n    char currentChar = 0;\n    int type = Character.getType(0);\n    boolean inToken = false;\n    for (int i = 0; i < str.length(); i++) {\n        currentChar = str.charAt(i);\n        int currentType = Character.getType(currentChar);\n        if (currentType == type) {\n            if (inToken) {\n                tokens.add(str.substring(lastPos, i));\n                inToken = false;\n            }\n        } else {\n            if (!inToken) {\n                tokens.add(str.substring(lastPos, i));\n                inToken = true;\n            }\n            lastPos = i;\n            type = currentType;\n        }\n        if (camelCase && Character.isUpperCase(currentChar) && Character.isLowerCase(prevChar)) {\n            inToken = false;\n        }\n        prevChar = currentChar;\n    }\n    if (inToken) {\n        tokens.add(str.substring(lastPos));\n    }\n    return tokens.toArray(new String[0]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder[] tokens = new StringBuilder[Character.MAX_VALUE + 1];\n    int tokenIndex = 0;\n    int pos = 0;\n    char prevChar = 0;\n    char currChar = 0;\n    boolean inToken = false;\n    for (int i = 0; i < str.length(); i++) {\n        currChar = str.charAt(i);\n        if (Character.isLetter(currChar)) {\n            if (Character.isUpperCase(currChar)) {\n                if (inToken) {\n                    tokens[tokenIndex].append(currChar);\n                } else {\n                    inToken = true;\n                    tokens[tokenIndex] = new StringBuilder(currChar);\n                }\n            } else if (Character.isLowerCase(currChar)) {\n                if (!inToken) {\n                    inToken = true;\n                    tokens[tokenIndex] = new StringBuilder(currChar);\n                } else {\n                    tokens[tokenIndex].append(currChar);\n                }\n            }\n        } else if (Character.isDigit(currChar)) {\n            if (inToken) {\n                tokens[tokenIndex].append(currChar);\n            } else {\n                inToken = true;\n                tokens[tokenIndex] = new StringBuilder(currChar);\n            }\n        } else if (Character.isWhitespace(currChar)) {\n            if (inToken) {\n                tokens[tokenIndex].append(currChar);\n                inToken = false;\n                tokenIndex++;\n            }\n        } else {\n            if (inToken) {\n                tokens[tokenIndex].append(currChar);\n                inToken = false;\n                tokenIndex++;\n            }\n        }\n        if (camelCase && Character.isUpperCase(currChar) && Character.isLowerCase(prevChar)) {\n            tokens[tokenIndex].append(currChar);\n            inToken = false;\n            tokenIndex++;\n        }\n        prevChar = currChar;\n    }\n    if (inToken) {\n        tokens[tokenIndex].append(prevChar);\n        tokenIndex++;\n    }\n    String[] result = new String[tokenIndex];\n    for (int i = 0; i < tokenIndex; i++) {\n        result[i] = tokens[i].toString();\n    }\n    return result;\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    List<String> tokens = new ArrayList<>();\n    int pos = 0;\n    char prevChar = 0;\n    char currentChar = 0;\n    boolean inToken = false;\n    boolean inCamelCase = false;\n    while (pos < str.length()) {\n        currentChar = str.charAt(pos);\n        if (Character.isLetter(currentChar)) {\n            if (!inToken) {\n                inToken = true;\n                tokens.add(\"\");\n            }\n            if (Character.isUpperCase(currentChar)) {\n                if (prevChar != 0 && Character.isLowerCase(prevChar)) {\n                    inCamelCase = true;\n                }\n            } else if (inCamelCase) {\n                inCamelCase = false;\n            }\n            tokens.set(tokens.size() - 1, tokens.get(tokens.size() - 1) + currentChar);\n        } else {\n            inToken = false;\n            if (inCamelCase) {\n                inCamelCase = false;\n            }\n        }\n        prevChar = currentChar;\n        pos++;\n    }\n    if (inToken) {\n        tokens.add(\"\");\n    }\n    return tokens.toArray(new String[0]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder token = new StringBuilder();\n    final StringBuilder temp = new StringBuilder();\n    final char[] chars = str.toCharArray();\n    for (char c : chars) {\n        final int type = Character.getType(c);\n        if (type == Character.UPPERCASE_LETTER) {\n            if (camelCase && temp.length() > 0 && Character.getType(temp.charAt(temp.length() - 1)) == Character.LOWERCASE_LETTER) {\n                token.append(temp.toString());\n                temp.setLength(0);\n            }\n            token.append(c);\n        } else {\n            temp.append(c);\n        }\n    }\n    if (temp.length() > 0) {\n        token.append(temp.toString());\n    }\n    return token.toString().split(\"\\\\s+\");\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    List<String> result = new ArrayList<>();\n    char prevChar = Character.MIN_VALUE;\n    StringBuilder currentToken = new StringBuilder();\n    for (int i = 0; i < len; i++) {\n        char ch = str.charAt(i);\n        int type = Character.getType(ch);\n        if (type == Character.UPPERCASE_LETTER && (camelCase || prevChar != Character.LOWERCASE_LETTER)) {\n            currentToken.append(ch);\n        } else if (type == Character.LOWERCASE_LETTER && prevChar == Character.UPPERCASE_LETTER) {\n            currentToken.append(ch);\n        } else if (type == Character.DIGIT || type == Character.SPACE_SEPARATOR || type == Character.LINE_SEPARATOR || type == Character.PARAGRAPH_SEPARATOR) {\n            if (currentToken.length() > 0) {\n                result.add(currentToken.toString());\n                currentToken = new StringBuilder();\n            }\n            currentToken.append(ch);\n        } else {\n            if (currentToken.length() > 0) {\n                result.add(currentToken.toString());\n                currentToken = new StringBuilder();\n            }\n            currentToken.append(ch);\n        }\n        prevChar = ch;\n    }\n    if (currentToken.length() > 0) {\n        result.add(currentToken.toString());\n    }\n    return result.toArray(new String[0]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    List<String> result = new ArrayList<>();\n    int pos = 0;\n    while (pos < str.length()) {\n        char c = str.charAt(pos);\n        int type = Character.getType(c);\n        if (type == Character.UPPERCASE_LETTER) {\n            if (camelCase && pos > 0 && Character.getType(str.charAt(pos - 1)) == Character.LOWERCASE_LETTER) {\n                pos++;\n            }\n        }\n        int end = pos;\n        while (end < str.length() && Character.getType(str.charAt(end)) == type) {\n            end++;\n        }\n        result.add(str.substring(pos, end));\n        pos = end;\n    }\n    return result.toArray(new String[0]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    List<String> result = new ArrayList<>();\n    char[] chars = str.toCharArray();\n    int start = 0;\n    for (int i = 0; i < len; i++) {\n        char c = chars[i];\n        int type = Character.getType(c);\n        if (type == Character.UPPERCASE_LETTER && (camelCase || i > 0 && Character.getType(chars[i - 1]) == Character.LOWERCASE_LETTER)) {\n            start = i;\n        } else if (type == Character.LOWERCASE_LETTER && i > 0 && Character.getType(chars[i - 1]) == Character.UPPERCASE_LETTER) {\n            // do nothing\n        } else if (type == Character.DASH_PUNCTUATION || type == Character.OTHER_PUNCTUATATION || type == Character.CURRENCY_SYMBOL || type == Character.SPACE_SEPARATOR || type == Character.LINE_SEPARATOR || type == Character.CONTROL_CHAR) {\n            if (start != i) {\n                result.add(new String(chars, start, i - start));\n                start = i;\n            }\n        } else {\n            if (start != i) {\n                result.add(new String(chars, start, i - start));\n                start = i;\n            }\n        }\n    }\n    if (start != len) {\n        result.add(new String(chars, start, len - start));\n    }\n    return result.toArray(new String[0]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder[] tokens = new StringBuilder[0];\n    final StringBuilder token = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        final int type = Character.getType(ch);\n        if (type == Character.UPPERCASE_LETTER) {\n            if (camelCase && i > 0 && Character.getType(str.charAt(i - 1)) == Character.LOWERCASE_LETTER) {\n                token.append(ch);\n            } else {\n                tokens = addToken(tokens, token.toString());\n                token = new StringBuilder();\n                token.append(ch);\n            }\n        } else {\n            token.append(ch);\n        }\n    }\n    tokens = addToken(tokens, token.toString());\n    return tokens.length == 0 ? new String[0] : tokens;\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final StringBuilder sb = new StringBuilder();\n    final int length = str.length();\n    for (int i = 0; i < length; i++) {\n        final char c = str.charAt(i);\n        if (Character.isLetter(c)) {\n            if (camelCase && i > 0 && Character.isUpperCase(c) && Character.isLowerCase(str.charAt(i - 1))) {\n                sb.append(' ');\n            }\n            sb.append(c);\n        } else {\n            if (sb.length() > 0) {\n                sb.append(' ');\n            }\n            sb.append(c);\n        }\n    }\n    return sb.toString().split(\"\\\\s+\");\n}"
    ],
    [
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new UnsupportedOperationException(\"Parsing is not supported\");\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = Chronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new UnsupportedOperationException(\"Parsing not supported\");\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = Chronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(millis);\n            chrono = chrono.withZone(parsedZone);\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new UnsupportedOperationException();\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new DateTimeParseException(\"Text did not match expected pattern\", text, newPos);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = Chronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(millis);\n            chrono = chrono.withZone(parsedZone);\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new UnsupportedOperationException(\"Parsing is not supported\");\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = Chronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new UnsupportedOperationException();\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = Chronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            DateTimeZone parsedZone = DateTimeZone.getDefault();\n            chrono = chrono.withZone(parsedZone);\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new UnsupportedOperationException(\"Parsing is not supported\");\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new UnsupportedOperationException(\"Parsing is not supported\");\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = Chronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new DateTimeParseException(\"Failed to parse to millisecond\", text, newPos);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = Chronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            DateTimeZone parsedZone = DateTimeZone.getDefault();\n            chrono = chrono.withZone(parsedZone);\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new UnsupportedOperationException(\"Parsing is not supported\");\n}"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n    return new MinimizedCondition(MeasuredNode.create(n, 0, false),\n        MeasuredNode.create(new Node(Token.SCRIPT), Integer.MAX_VALUE, true));\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n  MeasuredNode positive = new MeasuredNode(n, n.length, false);\n  MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false);\n  return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return new MinimizedCondition(MeasuredNode.addNode(new Node(Token.NOT).srcref(n), null, null), MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n), null, null));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    return new MinimizedCondition(MeasuredNode.create(n, 0, false),\n        MeasuredNode.create(new Node(Token.SCRIPT), Integer.MAX_VALUE, true));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return new MinimizedCondition(MeasuredNode.create(n, 0, false),\n      MeasuredNode.create(new Node(Token.SCRIPT), Integer.MAX_VALUE, true));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    MeasuredNode positive = new MeasuredNode(n, n.length, false);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, true);\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  MeasuredNode positive = new MeasuredNode(n, n.length, false);\n  MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false);\n  return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  MeasuredNode positive = new MeasuredNode(n, n.getLength(), false);\n  MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, true);\n  return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return new MinimizedCondition(MeasuredNode.create(n, 0, false),\n      MeasuredNode.create(new Node(Token.SCRIPT), Integer.MAX_VALUE, true));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return new MinimizedCondition(MeasuredNode.create(n, 0, false),\n      MeasuredNode.create(new Node(Token.SCRIPT), Integer.MAX_VALUE, true));\n}"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    Validate.notNull(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[(int) Math.ceil((double) values.spliterator().estimateSize() / Long.SIZE)];\n    int index = 0;\n    for (final E value : values) {\n        Validate.notNull(value);\n        result[index++] |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    Validate.notNull(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[(int) Math.ceil((double) values.spliterator().estimateSize() / Long.SIZE)];\n    int index = 0;\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[index++] |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    Validate.noNullElements(values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : values) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    Validate.notNull(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[(int) Math.ceil(Math.log(enumClass.getEnumConstants().length) / Math.log(2))];\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[(int) (Math.log(value.ordinal() + 1) / Math.log(2))] |= 1 << (int) (value.ordinal() % (int) Math.pow(2, (int) Math.log(2)));\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    Validate.noNullElements(values);\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : values) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[(int) Math.ceil(((double) values.spliterator().estimateSize() / Long.SIZE))];\n    int index = 0;\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[index++] |= 1 << value.ordinal();\n        if (index == result.length) {\n            index = 0;\n        }\n    }\n    return result;\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        return iPartialConverters.add(converter, null);\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        return iPartialConverters.add(converter, null);\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        return iPartialConverters.add(converter, null);\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        return iPartialConverters.add(converter, null);\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        return iPartialConverters.add(converter, null);\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        return iPartialConverters.add(converter, null);\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        return iPartialConverters.add(converter, null);\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        return iPartialConverters.add(converter, null);\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        return iPartialConverters.add(converter, null);\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        return add(converter, new Converter[] {null});\n    }"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n        int depth = 0;\n        SymbolScope currentScope = scope;\n        while (currentScope != null && !currentScope.isLexicalScope()) {\n            depth++;\n            currentScope = currentScope.getParentScope();\n        }\n        return depth + (currentScope != null ? currentScope.getScopeDepth() : 0);\n    } else {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n      return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n      int depth = 0;\n      SymbolScope currentScope = scope;\n      while (currentScope.isPropertyScope()) {\n        depth++;\n        currentScope = currentScope.getParentScope();\n      }\n      return depth + currentScope.getScopeDepth();\n    } else {\n      return 0;\n    }\n  }",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n        int depth = 0;\n        SymbolScope currentScope = scope;\n        while (currentScope != null && !currentScope.isLexicalScope()) {\n            depth++;\n            currentScope = currentScope.getParentScope();\n        }\n        return depth + (currentScope != null ? currentScope.getScopeDepth() : 0);\n    } else {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n        int depth = 0;\n        SymbolScope currentScope = scope;\n        while (currentScope != null && !currentScope.isLexicalScope()) {\n            depth++;\n            currentScope = currentScope.getParentScope();\n        }\n        return depth + (currentScope != null ? currentScope.getScopeDepth() : 0);\n    } else {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n        int depth = 0;\n        SymbolScope parent = scope.getParentScope();\n        while (parent != null && !parent.isLexicalScope()) {\n            depth++;\n            parent = parent.getParentScope();\n        }\n        return depth + scope.getScopeDepth();\n    } else {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n        int depth = 0;\n        SymbolScope currentScope = scope;\n        while (currentScope != null && !currentScope.isLexicalScope()) {\n            depth++;\n            currentScope = currentScope.getParentScope();\n        }\n        return depth + (currentScope != null ? currentScope.getScopeDepth() : 0);\n    } else {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n      return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n      int depth = 0;\n      SymbolScope parent = scope.getParentScope();\n      while (parent != null && !parent.isLexicalScope()) {\n        depth++;\n        parent = parent.getParentScope();\n      }\n      return depth + scope.getScopeDepth();\n    } else {\n      return 0;\n    }\n  }",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n      return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n      int depth = 0;\n      SymbolScope parentScope = scope.getParentScope();\n      while (parentScope != null && !parentScope.isLexicalScope()) {\n        depth++;\n        parentScope = parentScope.getParentScope();\n      }\n      return depth + scope.getScopeDepth();\n    } else {\n      return 0;\n    }\n  }",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n      return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n      int depth = 0;\n      SymbolScope parentScope = scope.getParentScope();\n      while (parentScope != null && !parentScope.isLexicalScope()) {\n        depth++;\n        parentScope = parentScope.getParentScope();\n      }\n      return depth + scope.getScopeDepth();\n    } else {\n      return 0;\n    }\n  }",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n      return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n      int depth = 0;\n      SymbolScope parentScope = scope.getParentScope();\n      while (parentScope != null && !parentScope.isLexicalScope()) {\n        depth++;\n        parentScope = parentScope.getParentScope();\n      }\n      return depth + scope.getScopeDepth();\n    } else {\n      return 0;\n    }\n  }"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocksLayout = new double[blockRows * BLOCK_SIZE][blockColumns * BLOCK_SIZE];\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < columns; j++) {\n            int blockRow = i / BLOCK_SIZE;\n            int blockColumn = j / BLOCK_SIZE;\n            int blockIndex = blockRow * blockColumns + blockColumn;\n            int elementIndex = i % BLOCK_SIZE * BLOCK_SIZE + j % BLOCK_SIZE;\n            blocksLayout[blockIndex][elementIndex] = rawData[i][j];\n        }\n    }\n\n    return blocksLayout;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blockData = new double[blockRows * BLOCK_SIZE][blockColumns * BLOCK_SIZE];\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < columns; j++) {\n            int blockRow = i / BLOCK_SIZE;\n            int blockColumn = j / BLOCK_SIZE;\n            int blockIndex = blockRow * blockColumns + blockColumn;\n            int elementIndex = i * columns + j;\n            blockData[blockIndex][elementIndex % BLOCK_SIZE] = rawData[i][j];\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocksLayout = new double[blockRows * BLOCK_SIZE][blockColumns * BLOCK_SIZE];\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < columns; j++) {\n            int blockRow = i / BLOCK_SIZE;\n            int blockColumn = j / BLOCK_SIZE;\n            int elementRow = i % BLOCK_SIZE;\n            int elementColumn = j % BLOCK_SIZE;\n            blocksLayout[blockRow * BLOCK_SIZE + elementRow][blockColumn * BLOCK_SIZE + elementColumn] = rawData[i][j];\n        }\n    }\n\n    return blocksLayout;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocksLayout = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int i = 0; i < rows; i += BLOCK_SIZE) {\n        for (int j = 0; j < columns; j += BLOCK_SIZE) {\n            int rowStart = i;\n            int rowEnd = Math.min(i + BLOCK_SIZE, rows);\n            int columnStart = j;\n            int columnEnd = Math.min(j + BLOCK_SIZE, columns);\n\n            double[] block = new double[(rowEnd - rowStart) * (columnEnd - columnStart)];\n            int k = 0;\n            for (int r = rowStart; r < rowEnd; r++) {\n                for (int c = columnStart; c < columnEnd; c++) {\n                    block[k++] = rawData[r][c];\n                }\n            }\n            blocksLayout[blockIndex++] = block;\n        }\n    }\n    return blocksLayout;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocksLayout = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int i = 0; i < rows; i += BLOCK_SIZE) {\n        for (int j = 0; j < columns; j += BLOCK_SIZE) {\n            int blockRowsInBlock = Math.min(BLOCK_SIZE, rows - i);\n            int blockColumnsInBlock = Math.min(BLOCK_SIZE, columns - j);\n            double[] blockData = new double[blockRowsInBlock * blockColumnsInBlock];\n            int blockRow = 0;\n            int blockColumn = 0;\n            for (int k = i; k < i + blockRowsInBlock; k++) {\n                for (int l = j; l < j + blockColumnsInBlock; l++) {\n                    blockData[blockRow * blockColumnsInBlock + blockColumn] = rawData[k][l];\n                    blockColumn++;\n                    if (blockColumn == blockColumnsInBlock) {\n                        blockColumn = 0;\n                        blockRow++;\n                    }\n                }\n            }\n            blocksLayout[blockIndex] = blockData;\n            blockIndex++;\n        }\n    }\n    return blocksLayout;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocksLayout = new double[blockRows * BLOCK_SIZE][blockColumns * BLOCK_SIZE];\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < columns; j++) {\n            int blockRow = i / BLOCK_SIZE;\n            int blockColumn = j / BLOCK_SIZE;\n            int elementRow = i % BLOCK_SIZE;\n            int elementColumn = j % BLOCK_SIZE;\n\n            blocksLayout[blockRow * BLOCK_SIZE + elementRow][blockColumn * BLOCK_SIZE + elementColumn] = rawData[i][j];\n        }\n    }\n\n    return blocksLayout;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocksLayout = new double[blockRows * BLOCK_SIZE][blockColumns * BLOCK_SIZE];\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < columns; j++) {\n            int blockRow = i / BLOCK_SIZE;\n            int blockColumn = j / BLOCK_SIZE;\n            int rowOffset = i % BLOCK_SIZE;\n            int columnOffset = j % BLOCK_SIZE;\n            blocksLayout[blockRow * BLOCK_SIZE + rowOffset][blockColumn * BLOCK_SIZE + columnOffset] = rawData[i][j];\n        }\n    }\n    return blocksLayout;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocksLayout = new double[blockRows * BLOCK_SIZE][blockColumns * BLOCK_SIZE];\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < columns; j++) {\n            int blockRow = i / BLOCK_SIZE;\n            int blockColumn = j / BLOCK_SIZE;\n            int rowOffset = i % BLOCK_SIZE;\n            int columnOffset = j % BLOCK_SIZE;\n\n            blocksLayout[blockRow * BLOCK_SIZE + rowOffset][blockColumn * BLOCK_SIZE + columnOffset] = rawData[i][j];\n        }\n    }\n\n    return blocksLayout;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blockData = new double[blockRows * BLOCK_SIZE][blockColumns * BLOCK_SIZE];\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < columns; j++) {\n            int blockRow = i / BLOCK_SIZE;\n            int blockColumn = j / BLOCK_SIZE;\n            int elementRow = i % BLOCK_SIZE;\n            int elementColumn = j % BLOCK_SIZE;\n            blockData[blockRow * BLOCK_SIZE + elementRow][blockColumn * BLOCK_SIZE + elementColumn] = rawData[i][j];\n        }\n    }\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocksLayout = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int i = 0; i < rows; i += blockRows) {\n        for (int j = 0; j < columns; j += blockColumns) {\n            int blockRow = i / blockRows;\n            int blockColumn = j / blockColumns;\n            int rowStart = i % blockRows;\n            int rowEnd = Math.min(i + blockRows, rows);\n            int columnStart = j % blockColumns;\n            int columnEnd = Math.min(j + blockColumns, columns);\n            blocksLayout[blockIndex++] = copyBlockPart(rawData, columns, i, rowEnd, j, columnEnd);\n        }\n    }\n    return blocksLayout;\n}"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.notNull(constant);\n        condensed.add(constant);\n    }\n    final long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.notNull(constant);\n        condensed.add(constant);\n    }\n    final long result = 0;\n    for (final E value : condensed) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.notNull(constant);\n        condensed.add(constant);\n    }\n    final long result = 0;\n    for (final E value : condensed) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.notNull(constant);\n        condensed.add(constant);\n    }\n    final long result = 0;\n    for (final E value : condensed) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.notNull(constant);\n        condensed.add(constant);\n    }\n    final long result = 0;\n    for (final E value : condensed) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.notNull(constant);\n        condensed.add(constant);\n    }\n    final long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.notNull(constant);\n        condensed.add(constant);\n    }\n    final long result = 0;\n    for (final E value : condensed) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.notNull(constant);\n        condensed.add(constant);\n    }\n    final long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.notNull(constant);\n        condensed.add(constant);\n    }\n    final long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.notNull(constant);\n        condensed.add(constant);\n    }\n    final long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp y = a;\n    Dfp x = y;\n    Dfp fact = a.getOne();\n    Dfp py = new Dfp(y);\n\n    int i = 2;\n    while (true) {\n        x = x.multiply(y);\n        x = x.negate();\n        fact = fact.divide((i - 1) * i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n        i += 2;\n    }\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.newInstance();\n    Dfp x = a;\n    Dfp fact = a.getOne();\n    Dfp py = new Dfp(a);\n\n    for (int i = 1; i < 90; i += 2) {\n        x = x.multiply(a);\n        x = x.negate();\n\n        fact = fact.divide((i-1)*i);  // 1 over fact\n        result = result.add(x.multiply(fact));\n        if (result.equals(py)) {\n            break;\n        }\n        py = new Dfp(result);\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.newInstance();\n    Dfp x = a;\n    Dfp fact = a.getOne();\n    Dfp py = new Dfp(a);\n\n    for (int i = 1; i < 90; i++) {\n        x = x.multiply(a);\n        x = x.negate();\n\n        fact = fact.divide((i-1)*i);  // 1 over fact\n        result = result.add(x.multiply(fact));\n        if (result.equals(py)) {\n            break;\n        }\n        py = new Dfp(result);\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.newInstance(this);\n    Dfp x = a;\n    Dfp y = a;\n    Dfp sum = a.getOne();\n    Dfp fact = a.getOne();\n    Dfp py = new Dfp(y);\n\n    for (int i = 1; i < 100; i++) {\n        x = x.multiply(a);\n        y = y.add(x);\n        fact = fact.multiply(i);\n        sum = sum.add(y.divide(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return sum;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = newInstance(a);\n    Dfp x = a;\n    int i = 0;\n    while (x.remainder(two).equals(zero)) {\n        x = x.divide(two);\n        i++;\n    }\n    Dfp y = x;\n    Dfp fact = newInstance(two);\n    while (i > 0) {\n        x = x.multiply(y);\n        y = y.multiply(fact);\n        fact = fact.multiply(two);\n        i--;\n    }\n    return result.add(x);\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.newInstance(this);\n    Dfp x = a;\n    int n = 0;\n    while (x.compareTo(getOne()) > 0) {\n        x = x.multiply(a);\n        n++;\n    }\n    Dfp y = x;\n    x = x.negate();\n    Dfp fact = a.getOne();\n    Dfp py = new Dfp(y);\n    for (int i = 1; i < 90; i += 2) {\n        x = x.multiply(y);\n        x = x.negate();\n        fact = fact.divide((i-1)*i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n    return result.multiply(y);\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = newInstance(this);\n    Dfp x = a;\n    Dfp y = newInstance(getOne());\n    Dfp sum = newInstance(getOne());\n    int i = 0;\n    while (true) {\n        x = x.multiply(a);\n        y = y.multiply(x);\n        sum = sum.add(y);\n        if (x.equals(getZero())) {\n            break;\n        }\n        i++;\n    }\n    return sum;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp y = a;\n    Dfp result = a.getOne();\n    int n = 0;\n    while (true) {\n        y = y.multiply(a);\n        result = result.add(y);\n        if (y.equals(y)) {\n            break;\n        }\n        n++;\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.newInstance(getOne());\n    int i = 1;\n    while (true) {\n        Dfp term = a.multiply(a.newInstance(i));\n        term = term.divide(new Dfp(i * (i + 1)));\n        if (term.equals(a.newInstance(0))) {\n            break;\n        }\n        result = result.add(term);\n        i++;\n    }\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp y = a;\n    Dfp sum = a;\n    Dfp fact = a.getOne();\n    Dfp x = a;\n\n    for (int i = 2; i < 100; i++) {\n        x = x.multiply(y);\n        sum = sum.add(x.divide(fact));\n        fact = fact.multiply(i);\n    }\n\n    return sum;\n}"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (x == 0) {\n        if (y == 0) {\n            if (z == 0) {\n                throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n            }\n            return new FieldVector3D<>(0, 1, -z / y);\n        }\n        return new FieldVector3D<>(0, z / y, -1);\n    }\n    if (y == 0) {\n        return new FieldVector3D<>(-z / x, 0, 1);\n    }\n    return new FieldVector3D<>(y / x, -1, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = maximum;\n    T max = minimum;\n    if (other.minimum.compareTo(min) < 0) {\n        min = other.minimum;\n    }\n    if (other.maximum.compareTo(max) > 0) {\n        max = other.maximum;\n    }\n    return between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = (comparator == null) ? (Comparable) Math.min(minimum, other.minimum) : comparator.compare(minimum, other.minimum) <= 0 ? minimum : other.minimum;\n    T max = (comparator == null) ? (Comparable) Math.max(maximum, other.maximum) : comparator.compare(maximum, other.maximum) >= 0 ? maximum : other.maximum;\n    return between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = maximum;\n    T max = minimum;\n    if (other.minimum.compareTo(minimum) < 0) {\n        min = other.minimum;\n    }\n    if (other.maximum.compareTo(maximum) > 0) {\n        max = other.maximum;\n    }\n    return between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    T min = maximum;\n    T max = minimum;\n    if (contains(other.minimum)) {\n        min = other.minimum;\n    }\n    if (contains(other.maximum)) {\n        max = other.maximum;\n    }\n    return between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    T min = maximum;\n    T max = minimum;\n    if (other.contains(minimum)) {\n        min = minimum;\n    }\n    if (other.contains(maximum)) {\n        max = maximum;\n    }\n    if (min.compareTo(max) > 0) {\n        throw new IllegalArgumentException(\"other does not overlap this\");\n    }\n    return between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = maximum;\n    T max = minimum;\n    if (other.minimum.compareTo(minimum) < 0) {\n        min = other.minimum;\n    }\n    if (other.maximum.compareTo(maximum) > 0) {\n        max = other.maximum;\n    }\n    return between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = (minimum.compareTo(other.minimum) <= 0) ? minimum : other.minimum;\n    T max = (maximum.compareTo(other.maximum) >= 0) ? maximum : other.maximum;\n    return between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    T min = minimum;\n    T max = maximum;\n    if (other.contains(minimum)) {\n        min = other.minimum;\n    }\n    if (other.contains(maximum)) {\n        max = other.maximum;\n    }\n    if (min.compareTo(max) > 0) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    return between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = (minimum.compareTo(other.minimum) <= 0) ? minimum : other.minimum;\n    T max = (maximum.compareTo(other.maximum) >= 0) ? maximum : other.maximum;\n    return between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = maximum;\n    T max = minimum;\n    if (other.minimum.compareTo(minimum) < 0) {\n        min = other.minimum;\n    }\n    if (other.maximum.compareTo(maximum) > 0) {\n        max = other.maximum;\n    }\n    return between(min, max, comparator);\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8StreamJsonGenerator(ctxt, _generatorFeatures, out, _objectCodec);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8StreamJsonGenerator(ctxt, _generatorFeatures, out, _objectCodec);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8StreamJsonGenerator(ctxt, _generatorFeatures, out, _objectCodec);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8OutputStreamJsonGenerator(ctxt, _generatorFeatures, out, _objectCodec);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8OutputStreamJsonGenerator(ctxt, _generatorFeatures, out, _objectCodec);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8StreamJsonGenerator(ctxt, _generatorFeatures, out, _objectCodec);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8StreamJsonGenerator(ctxt, _generatorFeatures, out, _objectCodec);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8StreamJsonGenerator(ctxt, _generatorFeatures, out, _objectCodec);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8OutputStreamJsonGenerator(ctxt, _generatorFeatures, out, _objectCodec);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8StreamJsonGenerator(ctxt, _generatorFeatures, out, _objectCodec);\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isPrimitive()) {\n        if (type.equals(Boolean.TYPE)) {\n            return ((Boolean) o1) == ((Boolean) o2);\n        }\n        if (type.equals(Byte.TYPE)) {\n            return ((Byte) o1) == ((Byte) o2);\n        }\n        if (type.equals(Short.TYPE)) {\n            return ((Short) o1) == ((Short) o2);\n        }\n        if (type.equals(Integer.TYPE)) {\n            return ((Integer) o1) == ((Integer) o2);\n        }\n        if (type.equals(Long.TYPE)) {\n            return ((Long) o1) == ((Long) o2);\n        }\n        if (type.equals(Float.TYPE)) {\n            return Float.compare((Float) o1, (Float) o2) == 0;\n        }\n        if (type.equals(Double.TYPE)) {\n            return Double.compare((Double) o1, (Double) o2) == 0;\n        }\n        if (type.equals(Character.TYPE)) {\n            return ((Character) o1).charValue() == ((Character) o2).charValue();\n        }\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1 == o2;\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isPrimitive()) {\n        return o1 == o2;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isPrimitive()) {\n        if (type.equals(Boolean.TYPE)) {\n            return ((Boolean) o1) == ((Boolean) o2);\n        }\n        if (type.equals(Byte.TYPE)) {\n            return ((Byte) o1) == ((Byte) o2);\n        }\n        if (type.equals(Short.TYPE)) {\n            return ((Short) o1) == ((Short) o2);\n        }\n        if (type.equals(Integer.TYPE)) {\n            return ((Integer) o1) == ((Integer) o2);\n        }\n        if (type.equals(Long.TYPE)) {\n            return ((Long) o1) == ((Long) o2);\n        }\n        if (type.equals(Float.TYPE)) {\n            return Float.compare(((Float) o1), ((Float) o2)) == 0;\n        }\n        if (type.equals(Double.TYPE)) {\n            return Double.compare(((Double) o1), ((Double) o2)) == 0;\n        }\n        if (type.equals(Character.TYPE)) {\n            return ((Character) o1).charValue() == ((Character) o2).charValue();\n        }\n        return false;\n    }\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1 == o2;\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  return getNativeType(JSTypeNative.NO_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n    if (type.isNoType()) {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n    if (type.isNoObjectType()) {\n      return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  return getNativeType(JSTypeNative.NO_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    return type.getNativeType(JSTypeNative.NO_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n    if (type.isNoType()) {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  if (type.isNoType()) {\n    return type;\n  }\n  return type.getNativeType(JSTypeNative.NO_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  return type.getNativeType(JSTypeNative.NO_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n    if (type.isUnknownType()) {\n      return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n    }\n    return type;\n  }",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    if (type.isNoType()) {\n        return type;\n    }\n    if (type.isNoObjectType()) {\n        return type;\n    }\n    return type.getNativeType(JSTypeNative.NO_TYPE);\n}"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && !restrictedType.equals(originalType)) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && !restrictedType.equals(originalType)) {\n        return blindScope.createChildFlowScope();\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && !restrictedType.equals(originalType)) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n      return null;\n    }\n    functionType.addChildToFront(typeParameters);\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    Node resultType = parseTypeExpression(token);\n    if (resultType == null) {\n      return null;\n    }\n    functionType.addChildToFront(resultType);\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n      return null;\n    }\n    Node params = parseParametersType(token);\n    if (params == null) {\n      return null;\n    }\n    Node resultType = parseTypeExpression(token);\n    if (resultType == null) {\n      return null;\n    }\n    functionType.addChildToBack(typeParameters);\n    functionType.addChildToBack(params);\n    functionType.addChildToBack(resultType);\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n      return null;\n    }\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    Node thisType = parseTypeName(token);\n    if (thisType == null) {\n      return null;\n    }\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    Node parametersType = parseParametersType(token);\n    if (parametersType == null) {\n      return null;\n    }\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    Node resultType = parseTypeExpression(token);\n    if (resultType == null) {\n      return null;\n    }\n    functionType.addChildToBack(typeParameters);\n    functionType.addChildToBack(thisType);\n    functionType.addChildToBack(parametersType);\n    functionType.addChildToBack(resultType);\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n      return null;\n    }\n    functionType.addChildToFront(typeParameters);\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    Node thisNode = newStringNode(\"this\", lineno, charno);\n    functionType.addChildToFront(thisNode);\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    Node typeNameNode = parseTypeName(token);\n    if (typeNameNode == null) {\n      return null;\n    }\n    functionType.addChildToFront(typeNameNode);\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n    }\n    next();\n    skipEOLs();\n    Node parametersType = parseParametersType(token);\n    if (parametersType == null) {\n      return null;\n    }\n    functionType.addChildToFront(parametersType);\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    Node resultType = parseTypeExpression(token);\n    if (resultType == null) {\n      return null;\n    }\n    functionType.addChildToFront(resultType);\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n      return null;\n    }\n    functionType.addChildToFront(typeParameters);\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    Node parametersType = parseParametersType(token);\n    if (parametersType == null) {\n      return null;\n    }\n    functionType.addChildToFront(parametersType);\n    skipEOLs();\n    if (!match(JsDocToken.RC)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n    }\n    next();\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n      return null;\n    }\n    Node parametersType = parseParametersType(token);\n    if (parametersType == null) {\n      return null;\n    }\n    Node resultType = parseTypeExpression(token);\n    if (resultType == null) {\n      return null;\n    }\n    functionType.addChildToBack(typeParameters);\n    functionType.addChildToBack(newNode(Token.LP));\n    functionType.addChildToBack(newStringNode(\"this\", lineno, charno));\n    functionType.addChildToBack(newStringNode(\":\", lineno, charno));\n    functionType.addChildToBack(typeNameNode);\n    functionType.addChildToBack(newNode(Token.COMMA));\n    functionType.addChildToBack(parametersType);\n    functionType.addChildToBack(newNode(Token.RP));\n    functionType.addChildToBack(resultType);\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n      return null;\n    }\n    functionType.addChildToBack(typeParameters);\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    Node resultType = parseTypeExpression(token);\n    if (resultType == null) {\n      return null;\n    }\n    functionType.addChildToBack(resultType);\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n      return null;\n    }\n    functionType.addChildToFront(typeParameters);\n\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    Node thisType = parseTypeExpression(next());\n    if (thisType == null) {\n      return null;\n    }\n    functionType.addChildToFront(thisType);\n\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n    }\n    next();\n    skipEOLs();\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n      return null;\n    }\n    functionType.addChildToFront(parametersType);\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    Node resultType = parseTypeExpression(next());\n    if (resultType == null) {\n      return null;\n    }\n    functionType.addChildToFront(resultType);\n\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n      return null;\n    }\n    functionType.addChildToBack(typeParameters);\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    Node parametersType = parseParametersType(token);\n    if (parametersType == null) {\n      return null;\n    }\n    functionType.addChildToBack(parametersType);\n    skipEOLs();\n    if (!match(JsDocToken.RC)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n    }\n    next();\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n      return null;\n    }\n    functionType.addChildToBack(typeParameters);\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    Node resultType = parseTypeExpression(token);\n    if (resultType == null) {\n      return null;\n    }\n    functionType.addChildToBack(resultType);\n    return functionType;\n  }"
    ],
    [
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        return str.replaceAll(\"\\\\s\", \"\");\n    }",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        return str.replaceAll(\"\\\\s\", \"\");\n    }",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        return str.replaceAll(\"\\\\s\", \"\");\n    }",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        return str.replaceAll(\"\\\\s\", \"\");\n    }",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        return str.replaceAll(\"\\\\s\", \"\");\n    }",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        return str.replaceAll(\"\\\\s\", \"\");\n    }",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        return str.replaceAll(\"\\\\s\", \"\");\n    }",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        return str.replaceAll(\"\\\\s\", \"\");\n    }",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        return str.replaceAll(\"\\\\s\", \"\");\n    }",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        return str.replaceAll(\"\\\\s\", \"\");\n    }"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if(statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    SummaryStatistics aggregatedStatistics = new SummaryStatistics();\n    for(SummaryStatistics stat : statistics) {\n        aggregatedStatistics.addValue(stat.getSum());\n        aggregatedStatistics.addValue(stat.getSumsq());\n        aggregatedStatistics.addValue(stat.getMin());\n        aggregatedStatistics.addValue(stat.getMax());\n        aggregatedStatistics.addValue(stat.getSumOfLogs());\n        aggregatedStatistics.addValue(stat.getGeometricMean());\n        aggregatedStatistics.addValue(stat.getSecondMoment());\n    }\n    return new StatisticalSummaryValues(aggregatedStatistics.getMean(), aggregatedStatistics.getVariance(), aggregatedStatistics.getN(), aggregatedStatistics.getMax(), aggregatedStatistics.getMin(), aggregatedStatistics.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics aggregateStatistics = new SummaryStatistics();\n    for (SummaryStatistics stats : statistics) {\n        aggregateStatistics.addValue(stats.getSum());\n        aggregateStatistics.addValue(stats.getSumsq());\n        aggregateStatistics.addValue(stats.getSumOfLogs());\n        aggregateStatistics.addValue(stats.getGeometricMean());\n        aggregateStatistics.addValue(stats.getSecondMoment());\n    }\n\n    return new StatisticalSummaryValues(\n            aggregateStatistics.getMean(),\n            aggregateStatistics.getVariance(),\n            aggregateStatistics.getN(),\n            aggregateStatistics.getMax(),\n            aggregateStatistics.getMin(),\n            aggregateStatistics.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if(statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    SummaryStatistics aggregatedStatistics = new SummaryStatistics();\n    for(SummaryStatistics stat : statistics) {\n        aggregatedStatistics.addValue(stat.getSum());\n        aggregatedStatistics.addValue(stat.getSumsq());\n        aggregatedStatistics.addValue(stat.getMin());\n        aggregatedStatistics.addValue(stat.getMax());\n        aggregatedStatistics.addValue(stat.getSumOfLogs());\n        aggregatedStatistics.addValue(stat.getGeometricMean());\n        aggregatedStatistics.addValue(stat.getSecondMoment());\n    }\n    return new StatisticalSummaryValues(aggregatedStatistics.getMean(), aggregatedStatistics.getVariance(), aggregatedStatistics.getN(), aggregatedStatistics.getMax(), aggregatedStatistics.getMin(), aggregatedStatistics.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if(statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    SummaryStatistics aggregateStatistics = new SummaryStatistics();\n    for(SummaryStatistics stat : statistics) {\n        aggregateStatistics.addValue(stat.getSum());\n        aggregateStatistics.addValue(stat.getSumsq());\n        aggregateStatistics.addValue(stat.getMin());\n        aggregateStatistics.addValue(stat.getMax());\n        aggregateStatistics.addValue(stat.getMean());\n        aggregateStatistics.addValue(stat.getStandardDeviation());\n        aggregateStatistics.addValue(stat.getVariance());\n    }\n    return new StatisticalSummaryValues(aggregateStatistics.getMean(), aggregateStatistics.getVariance(), aggregateStatistics.getN(), aggregateStatistics.getMax(), aggregateStatistics.getMin(), aggregateStatistics.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0;\n    double sumsq = 0;\n    double sumLog = 0;\n    double sumOfSquares = 0;\n    double sumOfLogs = 0;\n    double sumOfSquaresOfLogs = 0;\n    double sumOfSquaresOfSquares = 0;\n    double sumOfSquaresOfLogsOfSquares = 0;\n    double sumOfSquaresOfSquaresOfSquares = 0;\n    double sumOfSquaresOfSquaresOfSquaresOfSquares = 0;\n    double sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquares = 0;\n    double sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares = 0;\n    double sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares = 0;\n    double sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares = 0;\n    double sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares = 0;\n    double sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares = 0;\n    double sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares = 0;\n    double sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares = 0;\n    double sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares = 0;\n    double sumOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquaresOfSquares = 0;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if(statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    SummaryStatistics aggregateStatistics = new SummaryStatistics();\n    for(SummaryStatistics statisticsObject : statistics) {\n        aggregateStatistics.addValue(statisticsObject.getSum());\n        aggregateStatistics.addValue(statisticsObject.getSumsq());\n        aggregateStatistics.addValue(statisticsObject.getSumLog());\n        aggregateStatistics.addValue(statisticsObject.getGeoMean());\n        aggregateStatistics.addValue(statisticsObject.getMean());\n        aggregateStatistics.addValue(statisticsObject.getMin());\n        aggregateStatistics.addValue(statisticsObject.getMax());\n    }\n    return new StatisticalSummaryValues(aggregateStatistics.getMean(), aggregateStatistics.getVariance(), aggregateStatistics.getN(), aggregateStatistics.getMax(), aggregateStatistics.getMin(), aggregateStatistics.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics aggregateStatistics = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregateStatistics.addValue(stat.getSum());\n        aggregateStatistics.addValue(stat.getSumsq());\n        aggregateStatistics.addValue(stat.getSumLog());\n        aggregateStatistics.addValue(stat.getGeoMean());\n        aggregateStatistics.addValue(stat.getMean());\n        aggregateStatistics.addValue(stat.getVariance());\n        aggregateStatistics.addValue(stat.getMax());\n        aggregateStatistics.addValue(stat.getMin());\n        aggregateStatistics.addValue(stat.getN());\n    }\n\n    return new StatisticalSummaryValues(\n            aggregateStatistics.getMean(),\n            aggregateStatistics.getVariance(),\n            aggregateStatistics.getN(),\n            aggregateStatistics.getMax(),\n            aggregateStatistics.getMin(),\n            aggregateStatistics.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics aggregateStatistics = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregateStatistics.addValue(stat.getSum());\n        aggregateStatistics.addValue(stat.getSumsq());\n        aggregateStatistics.addValue(stat.getMin());\n        aggregateStatistics.addValue(stat.getMax());\n        aggregateStatistics.addValue(stat.getSumOfLogs());\n        aggregateStatistics.addValue(stat.getGeometricMean());\n        aggregateStatistics.addValue(stat.getSecondMoment());\n    }\n\n    return new StatisticalSummaryValues(\n            aggregateStatistics.getMean(),\n            aggregateStatistics.getVariance(),\n            aggregateStatistics.getN(),\n            aggregateStatistics.getMax(),\n            aggregateStatistics.getMin(),\n            aggregateStatistics.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics aggregatedStatistics = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregatedStatistics.addValue(stat.getSum());\n        aggregatedStatistics.addValue(stat.getSumsq());\n        aggregatedStatistics.addValue(stat.getMin());\n        aggregatedStatistics.addValue(stat.getMax());\n        aggregatedStatistics.addValue(stat.getMean());\n        aggregatedStatistics.addValue(stat.getStandardDeviation());\n        aggregatedStatistics.addValue(stat.getVariance());\n        aggregatedStatistics.addValue(stat.getSumOfLogs());\n        aggregatedStatistics.addValue(stat.getGeometricMean());\n        aggregatedStatistics.addValue(stat.getSecondMoment());\n    }\n\n    return new StatisticalSummaryValues(\n            aggregatedStatistics.getMean(),\n            aggregatedStatistics.getVariance(),\n            aggregatedStatistics.getN(),\n            aggregatedStatistics.getMax(),\n            aggregatedStatistics.getMin(),\n            aggregatedStatistics.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0;\n    double sumsq = 0;\n    double sumLog = 0;\n    double geoMean = 1;\n    double mean = 0;\n    double variance = 0;\n    long n = 0;\n    double max = Double.NEGATIVE_INFINITY;\n    double min = Double.POSITIVE_INFINITY;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        sumLog += stat.getSumOfLogs();\n        geoMean *= Math.exp(stat.getSumOfLogs() / stat.getN());\n        mean += stat.getMean();\n        variance += stat.getVariance();\n        n += stat.getN();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n    }\n\n    StatisticalSummaryValues summaryValues = new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n    return summaryValues;\n}"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    double[] differences = new double[sample1.length];\n    for (int i = 0; i < sample1.length; i++) {\n        differences[i] = sample1[i] - sample2[i];\n    }\n    return StatUtils.variance(differences);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    double[] differences = new double[sample1.length];\n    for (int i = 0; i < sample1.length; i++) {\n        differences[i] = sample1[i] - sample2[i];\n    }\n    return StatUtils.variance(differences);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    double[] differences = new double[sample1.length];\n    for (int i = 0; i < sample1.length; i++) {\n        differences[i] = sample1[i] - sample2[i];\n    }\n    return StatUtils.variance(differences);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    double[] differences = new double[sample1.length];\n    for (int i = 0; i < sample1.length; i++) {\n        differences[i] = sample1[i] - sample2[i];\n    }\n    return StatUtils.variance(differences);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    double[] differences = new double[sample1.length];\n    for (int i = 0; i < sample1.length; i++) {\n        differences[i] = sample1[i] - sample2[i];\n    }\n    return StatUtils.variance(differences);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    double[] differences = new double[sample1.length];\n    for (int i = 0; i < sample1.length; i++) {\n        differences[i] = sample1[i] - sample2[i];\n    }\n    return StatUtils.variance(differences);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    double[] differences = new double[sample1.length];\n    for (int i = 0; i < sample1.length; i++) {\n        differences[i] = sample1[i] - sample2[i];\n    }\n    return StatUtils.variance(differences);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    double[] differences = new double[sample1.length];\n    for (int i = 0; i < sample1.length; i++) {\n        differences[i] = sample1[i] - sample2[i];\n    }\n    return StatUtils.variance(differences);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    double[] differences = new double[sample1.length];\n    for (int i = 0; i < sample1.length; i++) {\n        differences[i] = sample1[i] - sample2[i];\n    }\n    return StatUtils.variance(differences);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    double[] differences = new double[sample1.length];\n    for (int i = 0; i < sample1.length; i++) {\n        differences[i] = sample1[i] - sample2[i];\n    }\n    return StatUtils.variance(differences);\n}"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.size(); i++) {\n        Comparable key = dataset.getKey(i);\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            double val = value.doubleValue();\n            if (val > 0.0) {\n                total += val;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.size(); i++) {\n        Comparable key = dataset.getKey(i);\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            double v = value.doubleValue();\n            if (v > 0.0) {\n                total += v;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.size(); i++) {\n        Comparable key = dataset.getKey(i);\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            double val = value.doubleValue();\n            if (val > 0.0) {\n                total += val;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.size(); i++) {\n        Comparable key = dataset.getKey(i);\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            double val = value.doubleValue();\n            if (val > 0.0) {\n                total += val;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.size(); i++) {\n        Comparable key = dataset.getKey(i);\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            double val = value.doubleValue();\n            if (val > 0.0) {\n                total += val;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.size(); i++) {\n        Comparable key = dataset.getKey(i);\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            double val = value.doubleValue();\n            if (val > 0.0) {\n                total += val;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Comparable key = dataset.getKey(i);\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            double val = value.doubleValue();\n            if (val > 0.0) {\n                total += val;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (Object key : dataset.keySet()) {\n        Number value = dataset.getValue(key);\n        if (value != null && value.doubleValue() >= 0.0) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.size(); i++) {\n        Comparable key = dataset.getKey(i);\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.size(); i++) {\n        Comparable key = dataset.getKey(i);\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            double v = value.doubleValue();\n            if (v > 0.0) {\n                total += v;\n            }\n        }\n    }\n    return total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n      return nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      return nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      return nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n  }",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_UNQUOTED_NAME) {\n    return nextQuotedValue(p == PEEKED_SINGLE_QUOTED_NAME ? '\\'' : p == PEEKED_DOUBLE_QUOTED_NAME ? '\"' : '\\0');\n  } else if (p == PEEKED_BUFFERED) {\n    return peekedString;\n  } else {\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_UNQUOTED_NAME) {\n      return nextQuotedValue(p == PEEKED_SINGLE_QUOTED_NAME ? '\\'' : '\"');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n      return nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      return nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      return nextQuotedValue('\"');\n    } else {\n      throw new IllegalStateException(\"Expected a property name but was \" + peek() + locationString());\n    }\n  }",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_UNQUOTED_NAME) {\n    return nextQuotedValue(p == PEEKED_SINGLE_QUOTED_NAME ? '\\'' : '\"');\n  } else {\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }\n}",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED_NAME) {\n    return nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    return nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    return nextQuotedValue('\"');\n  } else {\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_UNQUOTED_NAME) {\n      return nextQuotedValue(p == PEEKED_SINGLE_QUOTED_NAME ? '\\'' : p == PEEKED_DOUBLE_QUOTED_NAME ? '\"' : '\\0');\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n  }",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_UNQUOTED_NAME) {\n    return nextQuotedValue(p == PEEKED_SINGLE_QUOTED_NAME ? '\\'' : p == PEEKED_DOUBLE_QUOTED_NAME ? '\"' : '\\0');\n  } else {\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_UNQUOTED_NAME) {\n      return nextQuotedValue(p == PEEKED_SINGLE_QUOTED_NAME ? '\\'' : '\"');\n    } else if (p == PEEKED_BUFFERED) {\n      return peekedString;\n    } else {\n      throw new IllegalStateException(\"Expected a property name but was \" + peek() + locationString());\n    }\n  }",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_UNQUOTED_NAME) {\n    return nextQuotedValue(p == PEEKED_SINGLE_QUOTED_NAME ? '\\'' : p == PEEKED_DOUBLE_QUOTED_NAME ? '\"' : '\\0');\n  } else {\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }\n}"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int bytesRead = Math.min(len, uncompressedBytesRemaining);\n        if (bytesRead > 0) {\n            in.read(b, off, bytesRead);\n            uncompressedBytesRemaining -= bytesRead;\n        }\n        return bytesRead;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = in.read(b, off, len);\n        if (read == -1) {\n            endReached = true;\n        }\n        uncompressedBytesRemaining -= read;\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = in.read(b, off, len);\n        if (read == -1) {\n            endReached = true;\n        }\n        uncompressedBytesRemaining -= read;\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = Math.min(uncompressedBytesRemaining, len);\n        if (read > 0) {\n            in.read(b, off, read);\n            uncompressedBytesRemaining -= read;\n        }\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = in.read(b, off, len);\n        if (read == -1) {\n            endReached = true;\n        }\n        uncompressedBytesRemaining -= read;\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = in.read(b, off, len);\n        if (read == -1) {\n            endReached = true;\n        }\n        uncompressedBytesRemaining -= read;\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = Math.min(len, uncompressedBytesRemaining);\n        if (read == 0) {\n            inUncompressedChunk = false;\n            return -1;\n        }\n        System.arraycopy(in.readNBytes(read), 0, b, off, read);\n        uncompressedBytesRemaining -= read;\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = Math.min(uncompressedBytesRemaining, len);\n        if (read == len) {\n            uncompressedBytesRemaining = 0;\n        } else {\n            uncompressedBytesRemaining -= read;\n        }\n        System.arraycopy(in.readNBytes(read), 0, b, off, read);\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = in.read(b, off, len);\n        if (read == -1) {\n            endReached = true;\n        }\n        uncompressedBytesRemaining -= read;\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = in.read(b, off, len);\n        if (read == -1) {\n            endReached = true;\n        }\n        uncompressedBytesRemaining -= read;\n        return read;\n    } else if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node arg = null;\n    if (site.node.isCall()) {\n        arg = getArgumentForCallOrNew(site.node, argIndex);\n    } else if (site.node.isDotCall()) {\n        Node obj = site.node.getFirstChild();\n        Node prop = obj.getLastChild();\n        if (prop.isString() && \"call\".equals(prop.getString())) {\n            arg = getArgumentForCallOrNew(obj, argIndex);\n        }\n    }\n    return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (node.isCall()) {\n        return getArgumentForCallOrNew(node, argIndex);\n    } else if (node.isDotCall()) {\n        return getArgumentForDotCall(node, argIndex);\n    } else {\n        return null;\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (node.isCall()) {\n        return getArgumentForCallOrNew(node, argIndex);\n    } else if (node.isDotCall()) {\n        Node property = node.getFirstChild().getLastChild();\n        if (property.isString()) {\n            String propName = property.getString();\n            if (propName.equals(\"call\")) {\n                return getArgumentForCallOrNew(node, argIndex);\n            } else if (propName.equals(\"apply\")) {\n                return getArgumentForCallOrNew(node, argIndex);\n            }\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (node.isCall()) {\n        return getArgumentForCallOrNew(node, argIndex);\n    } else if (node.isDotCall()) {\n        return getArgumentForDotCall(node, argIndex);\n    } else {\n        return null;\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (NodeUtil.isCallOrNew(site.node)) {\n        return NodeUtil.getArgumentForCallOrNew(site.node, argIndex);\n    } else {\n        return NodeUtil.getArgumentForCallOrNew(site.node, argIndex);\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (node.isCall()) {\n        return getArgumentForCallOrNew(node, argIndex);\n    } else if (node.isDotCall()) {\n        Node propNode = node.getFirstChild();\n        if (isGet(propNode)) {\n            Node last = propNode.getLastChild();\n            if (last != null && last.isString()) {\n                String propName = last.getString();\n                if (propName.equals(\"call\") || propName.equals(\"apply\")) {\n                    return getArgumentForCallOrNew(node, argIndex);\n                }\n            }\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (node.isCall()) {\n        return getArgumentForCallOrNew(node, argIndex);\n    } else if (node.isDotCall()) {\n        return getArgumentForCallOrNew(node.getFirstChild(), argIndex);\n    } else {\n        return null;\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (node.isCall() || node.isNew()) {\n        return getArgumentForCallOrNew(node, argIndex);\n    } else if (node.isDotCall()) {\n        return getArgumentForDotCall(node, argIndex);\n    } else {\n        throw new AssertionError(\"Unexpected node type: \" + node.getType());\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node arg = getArgumentForCallOrNew(site, argIndex);\n    if (arg == null) {\n        // Check if it's a property access\n        Node prop = site.getSite().getLastChild();\n        if (prop.isGet()) {\n            Node propNode = prop.getLastChild();\n            if (propNode.isString()) {\n                String propName = propNode.getString();\n                if (propName.equals(\"call\") || propName.equals(\"apply\")) {\n                    arg = propNode;\n                }\n            }\n        }\n    }\n    return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (NodeUtil.isCallOrNew(site.node)) {\n        return NodeUtil.getArgumentForCallOrNew(site.node, argIndex);\n    } else {\n        return NodeUtil.getArgumentForDotCall(site.node, argIndex);\n    }\n}"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n        return null;\n    }\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n        if (info.getDeprecationReason() != null) {\n            return info.getDeprecationReason();\n        }\n        return \"\";\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n        return null;\n    }\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n        if (info.getDeprecationReason() != null) {\n            return info.getDeprecationReason();\n        }\n        return \"\";\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n        return null;\n    }\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n        if (info.getDeprecationReason() != null) {\n            return info.getDeprecationReason();\n        }\n        return \"\";\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) {\n        JSDocInfo info = type.getJSDocInfo();\n        if (info != null && info.isDeprecated()) {\n            return info.getDeprecationReason();\n        }\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n        return null;\n    }\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n        if (info.getDeprecationReason() != null) {\n            return info.getDeprecationReason();\n        }\n        return \"\";\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n        return null;\n    }\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n        if (info.getDeprecationReason() != null) {\n            return info.getDeprecationReason();\n        }\n        return \"\";\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) {\n        JSDocInfo info = type.getJSDocInfo();\n        if (info != null && info.isDeprecated()) {\n            return info.getDeprecationReason();\n        }\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) {\n        JSDocInfo info = type.getJSDocInfo();\n        if (info != null && info.isDeprecated()) {\n            return info.getDeprecationReason();\n        }\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) {\n      JSDocInfo info = type.getJSDocInfo();\n      if (info != null && info.isDeprecated()) {\n        if (info.getDeprecationReason() != null) {\n          return info.getDeprecationReason();\n        }\n        return \"\";\n      }\n    }\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) {\n        JSDocInfo info = type.getJSDocInfo();\n        if (info != null && info.isDeprecated()) {\n            return info.getDeprecationReason();\n        }\n    }\n    return null;\n}"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cTimeZoneDisplayCache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, result);\n    }\n    return result;\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    return underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return underlying.getColumnIndex(key);\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point >= lower - tolerance && point <= upper + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point < lower) {\n        return Location.OUTSIDE;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (Math.abs(point - getLower()) < tolerance) {\n        return Location.BOUNDARY;\n    }\n    if (Math.abs(point - getUpper()) < tolerance) {\n        return Location.BOUNDARY;\n    }\n    if (point >= getLower() && point <= getUpper()) {\n        return Location.INSIDE;\n    }\n    return Location.OUTSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (Math.abs(point - lower) < tolerance) {\n        return Location.BOUNDARY;\n    }\n    if (Math.abs(point - upper) < tolerance) {\n        return Location.BOUNDARY;\n    }\n    if (point >= lower && point <= upper) {\n        return Location.INSIDE;\n    }\n    return Location.OUTSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point >= lower - tolerance && point <= upper + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point < lower) {\n        return Location.OUTSIDE;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point >= lower && point <= upper) {\n        return Location.INSIDE;\n    } else if (point < lower - tolerance || point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point >= lower - tolerance && point <= upper + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point < lower) {\n        return Location.OUTSIDE;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point >= lower - tolerance && point <= upper + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point < lower) {\n        return Location.OUTSIDE;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point >= lower - tolerance && point <= upper + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point < lower) {\n        return Location.OUTSIDE;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point >= lower - tolerance && point <= upper + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point < lower) {\n        return Location.OUTSIDE;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point >= getLower() && point <= getUpper()) {\n        return Location.INSIDE;\n    } else if (point < getLower() - tolerance || point > getUpper() + tolerance) {\n        return Location.OUTSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    DecimalFormat df0 = new DecimalFormat(\"0\");\n    DecimalFormat df1 = new DecimalFormat(\"#,##0\");\n    units.add(new NumberTickUnit(1, df0, 2));\n    units.add(new NumberTickUnit(3, df0, 2));\n    units.add(new NumberTickUnit(10, df0, 2));\n    units.add(new NumberTickUnit(30, df0, 2));\n    units.add(new NumberTickUnit(100, df0, 2));\n    units.add(new NumberTickUnit(300, df0, 2));\n    units.add(new NumberTickUnit(1000, df1, 2));\n    units.add(new NumberTickUnit(3000, df1, 2));\n    units.add(new NumberTickUnit(10000, df1, 2));\n    units.add(new NumberTickUnit(30000, df1, 2));\n    units.add(new NumberTickUnit(100000, df1, 2));\n    units.add(new NumberTickUnit(300000, df1, 2));\n    units.add(new NumberTickUnit(1000000, df1, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(3, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(30, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(300, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(3000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(30000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(300000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    DecimalFormat df0 = new DecimalFormat(\"0\");\n    DecimalFormat df1 = new DecimalFormat(\"#,##0\");\n    units.add(new NumberTickUnit(1, df0, 2));\n    units.add(new NumberTickUnit(3, df0, 2));\n    units.add(new NumberTickUnit(10, df0, 2));\n    units.add(new NumberTickUnit(30, df0, 2));\n    units.add(new NumberTickUnit(100, df0, 2));\n    units.add(new NumberTickUnit(300, df0, 2));\n    units.add(new NumberTickUnit(1000, df1, 2));\n    units.add(new NumberTickUnit(3000, df1, 2));\n    units.add(new NumberTickUnit(10000, df1, 2));\n    units.add(new NumberTickUnit(30000, df1, 2));\n    units.add(new NumberTickUnit(100000, df1, 2));\n    units.add(new NumberTickUnit(300000, df1, 2));\n    units.add(new NumberTickUnit(1000000, df1, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(0.1, numberFormat, 2));\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000, numberFormat, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    DecimalFormat df0 = new DecimalFormat(\"0\");\n    DecimalFormat df1 = new DecimalFormat(\"#,##0\");\n    units.add(new NumberTickUnit(1, df0, 2));\n    units.add(new NumberTickUnit(3, df0, 2));\n    units.add(new NumberTickUnit(10, df0, 2));\n    units.add(new NumberTickUnit(30, df0, 2));\n    units.add(new NumberTickUnit(100, df0, 2));\n    units.add(new NumberTickUnit(300, df0, 2));\n    units.add(new NumberTickUnit(1000, df1, 2));\n    units.add(new NumberTickUnit(3000, df1, 2));\n    units.add(new NumberTickUnit(10000, df1, 2));\n    units.add(new NumberTickUnit(30000, df1, 2));\n    units.add(new NumberTickUnit(100000, df1, 2));\n    units.add(new NumberTickUnit(300000, df1, 2));\n    units.add(new NumberTickUnit(1000000, df1, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    DecimalFormat df0 = new DecimalFormat(\"0\");\n    DecimalFormat df1 = new DecimalFormat(\"#,##0\");\n    units.add(new NumberTickUnit(1, df0, 2));\n    units.add(new NumberTickUnit(3, df0, 2));\n    units.add(new NumberTickUnit(10, df0, 2));\n    units.add(new NumberTickUnit(30, df0, 2));\n    units.add(new NumberTickUnit(100, df0, 2));\n    units.add(new NumberTickUnit(300, df0, 2));\n    units.add(new NumberTickUnit(1000, df1, 2));\n    units.add(new NumberTickUnit(3000, df1, 2));\n    units.add(new NumberTickUnit(10000, df1, 2));\n    units.add(new NumberTickUnit(30000, df1, 2));\n    units.add(new NumberTickUnit(100000, df1, 2));\n    units.add(new NumberTickUnit(300000, df1, 2));\n    units.add(new NumberTickUnit(1000000, df1, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(0.1, numberFormat, 2));\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000000.0, numberFormat, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    DecimalFormat df0 = new DecimalFormat(\"0\");\n    DecimalFormat df1 = new DecimalFormat(\"#,##0\");\n    units.add(new NumberTickUnit(1, df0, 2));\n    units.add(new NumberTickUnit(3, df0, 2));\n    units.add(new NumberTickUnit(10, df0, 2));\n    units.add(new NumberTickUnit(30, df0, 2));\n    units.add(new NumberTickUnit(100, df0, 2));\n    units.add(new NumberTickUnit(300, df0, 2));\n    units.add(new NumberTickUnit(1000, df1, 2));\n    units.add(new NumberTickUnit(3000, df1, 2));\n    units.add(new NumberTickUnit(10000, df1, 2));\n    units.add(new NumberTickUnit(30000, df1, 2));\n    units.add(new NumberTickUnit(100000, df1, 2));\n    units.add(new NumberTickUnit(300000, df1, 2));\n    units.add(new NumberTickUnit(1000000, df1, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    DecimalFormat df0 = new DecimalFormat(\"0\");\n    DecimalFormat df1 = new DecimalFormat(\"#,##0\");\n    units.add(new NumberTickUnit(0.1, df0, 2));\n    units.add(new NumberTickUnit(1, df0, 2));\n    units.add(new NumberTickUnit(10, df0, 2));\n    units.add(new NumberTickUnit(100, df0, 2));\n    units.add(new NumberTickUnit(1000, df1, 2));\n    units.add(new NumberTickUnit(10000, df1, 2));\n    units.add(new NumberTickUnit(100000, df1, 2));\n    units.add(new NumberTickUnit(1000000, df1, 2));\n    units.add(new NumberTickUnit(10000000, df1, 2));\n    units.add(new NumberTickUnit(100000000, df1, 2));\n    units.add(new NumberTickUnit(1000000000, df1, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    DecimalFormat df0 = new DecimalFormat(\"0\");\n    DecimalFormat df1 = new DecimalFormat(\"#,##0\");\n    units.add(new NumberTickUnit(1, df0, 2));\n    units.add(new NumberTickUnit(3, df0, 2));\n    units.add(new NumberTickUnit(10, df0, 2));\n    units.add(new NumberTickUnit(30, df0, 2));\n    units.add(new NumberTickUnit(100, df0, 2));\n    units.add(new NumberTickUnit(300, df0, 2));\n    units.add(new NumberTickUnit(1000, df1, 2));\n    units.add(new NumberTickUnit(3000, df1, 2));\n    units.add(new NumberTickUnit(10000, df1, 2));\n    units.add(new NumberTickUnit(30000, df1, 2));\n    units.add(new NumberTickUnit(100000, df1, 2));\n    units.add(new NumberTickUnit(300000, df1, 2));\n    units.add(new NumberTickUnit(1000000, df1, 2));\n    return units;\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int col = -1;\n    double minCoeff = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getNumDecisionVariables(); i++) {\n        final double coeff = tableau.getEntry(0, i);\n        if (Precision.compareTo(coeff, 0d, maxUlps) < 0 && coeff < minCoeff) {\n            minCoeff = coeff;\n            col = i;\n        }\n    }\n    return col;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = 0;\n    double minCoeff = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getNumDecisionVariables(); i++) {\n        double coeff = tableau.getEntry(0, i);\n        if (Precision.compareTo(coeff, 0d, maxUlps) < 0) {\n            if (coeff < minCoeff) {\n                minCoeff = coeff;\n                pivotCol = i;\n            }\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double maxNeg = Double.MIN_VALUE;\n    Integer pivotCol = null;\n    for (int i = 0; i < tableau.getNumDecisionVariables(); i++) {\n        double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0 && entry < maxNeg) {\n            maxNeg = entry;\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int col = 0;\n    double minCoeff = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth(); i++) {\n        final double coeff = tableau.getEntry(tableau.getNumObjectiveFunctions(), i);\n        if (Precision.compareTo(coeff, 0d, maxUlps) < 0 && coeff < minCoeff) {\n            minCoeff = coeff;\n            col = i;\n        }\n    }\n    return col;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int col = 0;\n    double minCoeff = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getNumDecisionVariables(); i++) {\n        double coeff = tableau.getEntry(0, i);\n        if (Precision.compareTo(coeff, 0d, maxUlps) < 0 && coeff < minCoeff) {\n            minCoeff = coeff;\n            col = i;\n        }\n    }\n    return col;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoeff = Double.MAX_VALUE;\n    int pivotCol = -1;\n    for (int i = 0; i < tableau.getNumDecisionVariables(); i++) {\n        double coeff = tableau.getEntry(0, i);\n        if (Precision.compareTo(coeff, 0d, maxUlps) < 0 && coeff < minCoeff) {\n            minCoeff = coeff;\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoeff = Double.MAX_VALUE;\n    int pivotCol = -1;\n    for (int i = 0; i < tableau.getNumDecisionVariables(); i++) {\n        double coeff = tableau.getEntry(0, i);\n        if (Precision.compareTo(coeff, 0d, maxUlps) < 0 && coeff < minCoeff) {\n            minCoeff = coeff;\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoeff = Double.MAX_VALUE;\n    int pivotCol = -1;\n    for (int i = 0; i < tableau.getNumDecisionVariables(); i++) {\n        double coeff = tableau.getEntry(0, i);\n        if (Precision.compareTo(coeff, 0d, maxUlps) < 0 && coeff < minCoeff) {\n            minCoeff = coeff;\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int maxIndex = -1;\n    double maxVal = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth(); i++) {\n        double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) {\n            if (entry < maxVal) {\n                maxIndex = i;\n                maxVal = entry;\n            }\n        }\n    }\n    return maxIndex;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int maxNegCoeffIndex = 0;\n    double maxNegCoeff = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getNumDecisionVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) {\n            if (entry < maxNegCoeff) {\n                maxNegCoeff = entry;\n                maxNegCoeffIndex = i;\n            }\n        }\n    }\n    return maxNegCoeffIndex;\n}"
    ]
  ]
}