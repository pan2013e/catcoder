{
  "benchmark": "javaeval_xc",
  "lastest_eval": {
    "compile@1": 0.6884422110552764,
    "pass@1": 0.42010050251256265,
    "compile@3": 0.7964824120603017,
    "pass@3": 0.4992043551088777,
    "compile@5": 0.828906436946638,
    "pass@5": 0.5251256281407036
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }"
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long startTime = duration.getStart().getTime();\n            long endTime = duration.getEnd().getTime();\n            long currentTime = System.currentTimeMillis();\n            if (currentTime > endTime) \n            {\n                result = new Double(100);\n            } \n            else if (currentTime < startTime) \n            {\n                result = new Double(0);\n            } \n            else \n            {\n                long elapsedTime = currentTime - startTime;\n                double percentComplete = (double) elapsedTime / (double) (endTime - startTime);\n                result = new Double(percentComplete * 100);\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = new Date().getTime();\n            if (now > start && now < end) \n            {\n                result = new Double((now - start) / (double) (end - start));\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = new Date().getTime();\n            if (now > start && now < end) \n            {\n                result = new Double((now - start) / (double) (end - start));\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = System.currentTimeMillis();\n            if (now > start && now < end) \n            {\n                result = new Double((now - start) / (double) (end - start));\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long startTime = duration.getStart().getTime();\n            long endTime = duration.getEnd().getTime();\n            long currentTime = System.currentTimeMillis();\n            if (currentTime > endTime) \n            {\n                result = new Double(100.0);\n            } \n            else if (currentTime > startTime) \n            {\n                result = new Double((currentTime - startTime) * 100.0 / (endTime - startTime));\n            } \n            else \n            {\n                result = new Double(0.0);\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = new Date().getTime();\n            if (now > start && now < end) \n            {\n                result = new Double((now - start) / (double) (end - start));\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = new Date().getTime();\n            if (now > start && now < end) \n            {\n                result = new Double(100.0 * (now - start) / (end - start));\n            } \n            else if (now > end) \n            {\n                result = new Double(100.0);\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long startTime = duration.getStart().getTime();\n            long endTime = duration.getEnd().getTime();\n            long currentTime = System.currentTimeMillis();\n            if (currentTime > startTime && currentTime < endTime) \n            {\n                long elapsedTime = currentTime - startTime;\n                long totalTime = endTime - startTime;\n                result = new Double((double) elapsedTime / totalTime * 100);\n            } \n            else \n            {\n                result = new Double(100);\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        double percent = task.getPercentComplete();\n        result = new Double(percent);\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) \n        {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = System.currentTimeMillis();\n            if (now > start && now < end) \n            {\n                result = new Double((now - start) / (double) (end - start));\n            } \n            else \n            {\n                result = new Double(1.0);\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) \n    {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null)\n    {\n        int index = indexOf(str, 0);\n        if (index >= 0)\n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, true);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, true);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, true);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, true);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, true);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    checkNotNull(iterator);\n    return new IteratorIterable<E>(iterator, true);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    checkNotNull(iterator);\n    return new Iterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    checkNotNull(iterator);\n    return new IteratorIterable<E>(iterator, true);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    checkNotNull(iterator);\n    return new Iterable<E>() \n    {\n}\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final double[][] d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[0][c] = m.getEntry(c, c);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            d[i][i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final double[][] d = new double[m.getColumnDimension()][1];\n        for (int i = 0; i < m.getColumnDimension(); i++) {\n            d[i][0] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final double[][] d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[0][c] = m.getEntry(c, c);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int rd = m.getRowDimension();\n    final int cd = m.getColumnDimension();\n    final double[][] d = new double[rd][cd];\n    for (int r = 0; r < rd; r++) {\n        for (int c = 0; c < cd; c++) {\n            d[r][c] = r == c ? m.getEntry(r, c) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int rows = m.getRowDimension();\n    final int cols = m.getColumnDimension();\n    final double[][] d = new double[rows][cols];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            d[i][j] = i == j ? m.getEntry(i, j) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int dim = m.getColumnDimension();\n    final double[][] d = new double[dim][dim];\n    for (int i = 0; i < dim; i++) {\n        d[i][i] = m.getEntry(0, i);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int rd = m.getRowDimension();\n    final int cd = m.getColumnDimension();\n    final double[][] d = new double[rd][cd];\n    for (int r = 0; r < rd; r++) {\n        for (int c = 0; c < cd; c++) {\n            d[r][c] = r == c ? m.getEntry(r, c) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][r] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final double[][] d = new double[m.getColumnDimension()][1];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[c][0] = m.getEntry(c, c);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int n = m.getColumnDimension();\n    final double[][] d = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        d[i][i] = m.getEntry(0, i);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][0] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else if (m.getRowDimension() == 1) {\n        final double[][] d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            d[0][c] = m.getEntry(0, c);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        throw new IllegalArgumentException(\"Input matrix must be either a column or a row matrix\");\n    }\n}"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // initialize block with zeros\n            Arrays.fill(block, 0.0);\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) \n    {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) \n        {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n            blocks[blockIndex] = new double[iHeight * jWidth];\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) \n    {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) \n        {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) \n            {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    } \n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    } \n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    } \n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    } \n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    } \n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    } \n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    } \n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    } \n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    } \n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    } \n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"Cannot parse time zone: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        id = id.trim();\n        if (id.length() == 0) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffsetMillis(parseOffset(id));\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz == null) {\n            dtz = cProvider.getZone(getConvertedId(id));\n        }\n        if (dtz == null) {\n            throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n        }\n        return dtz;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffsetMillis(parseOffset(id));\n        }\n        id = getConvertedId(id);\n        if (id == null) {\n            throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz == null) {\n            throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n        }\n        return dtz;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return fixedOffsetZone(id, parseOffset(id));\n        }\n        if (id.indexOf(':') >= 0) {\n            return fixedOffsetZone(id, parseOffset(id));\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        id = id.trim();\n        if (id.length() == 0) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.charAt(0) == '+' || id.charAt(0) == '-') {\n            return forOffsetMillis(parseOffset(id));\n        }\n        id = getConvertedId(id);\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz == null) {\n            throw new IllegalArgumentException(\"Cannot parse time zone: \" + id);\n        }\n        return dtz;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        id = id.trim();\n        if (id.length() == 0) {\n            throw new IllegalArgumentException(\"The datetime zone id must not be null or empty\");\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.charAt(0) == '+' || id.charAt(0) == '-') {\n            return forOffsetMillis(parseOffset(id));\n        }\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            id = convId;\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz == null) {\n            throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n        }\n        return dtz;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"Illegal time zone id: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        id = id.trim();\n        if (id.length() == 0) {\n            throw new IllegalArgumentException(\"The datetime zone id must not be null\");\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Check if offset\n        if (id.charAt(0) == '+' || id.charAt(0) == '-') {\n            return forOffsetMillis(parseOffset(id));\n        }\n\n        throw new IllegalArgumentException(\"The datetime zone id is invalid: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        id = id.trim();\n        if (id.length() == 0) {\n            throw new IllegalArgumentException(\"The datetime zone id must not be null or empty\");\n        }\n        if (id.equals(\"UTC\")) {\n            return UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffsetMillis(parseOffset(id));\n        }\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id is invalid: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffsetMillis(parseOffset(id));\n        }\n        id = getConvertedId(id);\n        if (id == null) {\n            throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz == null) {\n            throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n        }\n        return dtz;\n    }"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + mant[i];\n            final int rh = r / x;\n            rl = r - rh * x;\n            mant[i] = rh;\n        }\n        return this;\n    }",
      "private Dfp multiplyFast(final int x)  {\n    int rl = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = rl*RADIX + mant[i];\n        final int rh = r / x;\n        rl = r - rh * x;\n        mant[i] = rh;\n    }\n\n    // if result is zero, set exp to zero\n    if (mant[mant.length-1] == 0) {\n        exp = 0;\n    }\n\n    return this;\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return newInstance(getZero());\n    }\n\n    if (x == 1) {\n        return newInstance(this);\n    }\n\n    if (x == RADIX-1) {\n        return add(this);\n    }\n\n    if (x == RADIX) {\n        return shiftLeft();\n    }\n\n    if (x == RADIX+1) {\n        return add(shiftLeft());\n    }\n\n    if (x == RADIX-2) {\n        return subtract(this);\n    }\n\n    if (x == RADIX-3) {\n        return subtract(add(this));\n    }\n\n    if (x == RADIX+2) {\n        return subtract(shiftLeft());\n    }\n\n    if (x == RADIX+3) {\n        return subtract(add(shiftLeft()));\n    }\n\n    // General case\n    Dfp result = newInstance(getZero());\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[i] = (mant[i] * x) % RADIX;\n        if (result.mant[i] < 0) {\n            result.mant[i] += RADIX;\n        }\n    }\n    result.exp = exp;\n    result.sign = sign;\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return getZero();\n    }\n\n    final Dfp result = newInstance(getZero());\n\n    int rl = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = rl*RADIX + mant[i];\n        final int rh = r / x;\n        rl = r - rh * x;\n        result.mant[i] = rh;\n    }\n\n    // if result is zero, set exp to zero\n    if (result.mant[mant.length-1] == 0) {\n        result.exp = 0;\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n        // Handle special cases\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Test for divide by zero\n        if (x == 0) {\n            field.setIEEEFlagsBits(DfpField.FLAG_DIV_ZERO);\n            Dfp result = newInstance(getZero());\n            result.sign = sign;\n            result.nans = INFINITE;\n            result = dotrap(DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero(), result);\n            return result;\n        }\n\n        // range check divisor\n        if (x < 0 || x >= RADIX) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);\n            return result;\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / x;\n            rl = r - rh * x;\n            result.mant[i] = rh;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        // check for overflow\n        if (mant[mant.length-1] >= RADIX/x) \n        {\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return newInstance(getZero());\n        }\n\n        // check for underflow\n        if (mant[mant.length-1] < RADIX/x) \n        {\n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return newInstance(getZero());\n        }\n\n        // multiply\n        for (int i = mant.length-1; i >= 0; i--) \n        {\n            mant[i] *= x;\n        }\n\n        // normalize\n        int shift = 0;\n        while (mant[mant.length-1] >= RADIX) \n        {\n            mant[mant.length-1] /= RADIX;\n            shift++;\n        }\n\n        // adjust exponent\n        exp -= shift;\n\n        // check for underflow\n        if (exp < MIN_EXP) \n        {\n            field.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\n            return newInstance(getZero());\n        }\n\n        // check for overflow\n        if (exp > MAX_EXP) \n        {\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return newInstance(getZero());\n        }\n\n        return this;\n    }\n}",
      "private Dfp multiplyFast(final int x)  {\n    // check for zero\n    if (x == 0) {\n        return newInstance(getZero());\n    }\n\n    // check for one\n    if (x == 1) {\n        return newInstance(this);\n    }\n\n    // check for negative\n    final byte sign = (byte) (this.sign * x);\n\n    // create a new instance\n    Dfp result = newInstance(getZero());\n    result.sign = sign;\n\n    // multiply the mantissa\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[i] = mant[i] * x;\n    }\n\n    // compute the new exponent\n    result.exp = exp + (mant.length-1);\n\n    // check for overflow\n    if (result.exp > MAX_EXP) {\n        field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n        result.nans = INFINITE;\n        result = dotrap(DfpField.FLAG_OVERFLOW, MULTIPLY_TRAP, this, result);\n    }\n\n    // return the result\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n        if (x == 0) {\n            return newInstance(getZero());\n        }\n\n        if (x == 1) {\n            return newInstance(this);\n        }\n\n        final int[] product = new int[mant.length+1];\n        for (int i = 0; i < mant.length; i++) {\n            product[i] = mant[i] * x;\n        }\n\n        final Dfp result = newInstance(getZero());\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[i] = product[i];\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return newInstance(getZero());\n    }\n\n    int rl = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = rl*RADIX + mant[i];\n        final int rh = r / x;\n        rl = r - rh * x;\n        mant[i] = rh;\n    }\n\n    if (rl == 0) {\n        return this;\n    }\n\n    // If we're here, we have a non-zero remainder.\n    // We need to shift the mantissa to the right and\n    // set the exponent appropriately.\n    for (int i = mant.length-1; i > 0; i--) {\n        mant[i] = mant[i-1];\n    }\n    mant[0] = rl;\n    exp++;\n\n    // If the result is zero, set exp to zero\n    if (mant[mant.length-1] == 0) {\n        exp = 0;\n    }\n\n    return this;\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return newInstance(getZero());\n    }\n\n    Dfp result = newInstance(getZero());\n\n    int rl = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = rl*RADIX + result.mant[i];\n        final int rh = r / x;\n        rl = r - rh * x;\n        result.mant[i] = rh;\n    }\n\n    if (rl != 0) {\n        result.mant[0] = rl;\n        result.exp = mant.length;\n    } else {\n        result.exp = mant.length - 1;\n    }\n\n    return result;\n}"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n      Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n      function.setJSType(exportedFunction.getJSType());\n\n      // This is an indirect way of telling the typed code generator\n      // \"print the type of this\"\n      function.setJSDocInfo(new JSDocInfo());\n\n      return function;\n    }",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(\n      IR.name(\"\"),\n      IR.paramList(),\n      IR.block());\n\n  function.setJSType(exportedFunction.getJSType());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  int index = 1;\n  for (Node child = exportedFunction.getFirstChild();\n       child != null;\n       child = child.getNext()) {\n    // TODO(user): handle getters or setters?\n    if (child.isStringKey()) {\n      function.addChildToBack(\n          IR.propdef(\n              IR.stringKey(child.getString()),\n              IR.number(index++)));\n    }\n  }\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n  function.setJSType(exportedFunction.getJSType());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  int index = 1;\n  for (Node child = exportedFunction.getFirstChild();\n       child != null;\n       child = child.getNext()) {\n    // TODO(user): handle getters or setters?\n    if (child.isStringKey()) {\n      function.addChildToBack(\n          IR.propdef(\n              IR.stringKey(child.getString()),\n              IR.number(index++)));\n    }\n  }\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    function.setJSType(exportedFunction.getJSType());\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    function.setJSDocInfo(new JSDocInfo());\n\n    int index = 1;\n    for (Node child = exportedFunction.getFirstChild();\n         child != null;\n         child = child.getNext()) {\n        // TODO(user): handle getters or setters?\n        if (child.isParamList()) {\n            for (Node param = child.getFirstChild();\n                 param != null;\n                 param = param.getNext()) {\n                function.addChildToBack(\n                    IR.param(\n                        IR.name(param.getString()),\n                        IR.number(index++)));\n            }\n        } else if (child.isBlock()) {\n            // TODO(user): handle function body?\n        }\n    }\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n  function.setJSType(exportedFunction.getJSType());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  int index = 1;\n  for (Node child = exportedFunction.getFirstChild();\n       child != null;\n       child = child.getNext()) {\n    // TODO(user): handle getters or setters?\n    if (child.isParamList()) {\n      for (Node param = child.getFirstChild();\n           param != null;\n           param = param.getNext()) {\n        function.addChildToBack(\n            IR.param(\n                IR.name(param.getString()),\n                IR.number(index++)));\n      }\n    } else if (child.isBlock()) {\n      // TODO(user): handle function body?\n    }\n  }\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    function.setJSType(exportedFunction.getJSType());\n    Node name = function.getFirstChild();\n    name.setString(exportedFunction.getFirstChild().getString());\n    Node paramList = name.getNext();\n    Node block = paramList.getNext();\n    for (Node child = exportedFunction.getSecondChild(); child != null; child = child.getNext()) {\n        if (child.isParamList()) {\n            for (Node param = child.getFirstChild(); param != null; param = param.getNext()) {\n                paramList.addChildToBack(param.cloneTree());\n            }\n        } else if (child.isBlock()) {\n            block.addChildrenToBack(child.cloneTree().getChildren());\n        }\n    }\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(\n      IR.name(\"\"),\n      IR.paramList(),\n      IR.block());\n  function.setJSType(exportedFunction.getJSType());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  int index = 1;\n  for (Node child = exportedFunction.getFirstChild();\n       child != null;\n       child = child.getNext()) {\n    // TODO(user): handle getters or setters?\n    if (child.isStringKey()) {\n      function.addChildToBack(\n          IR.propdef(\n              IR.stringKey(child.getString()),\n              IR.number(index++)));\n    }\n  }\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    function.setJSType(exportedFunction.getJSType());\n    NodeUtil.copyNameTypeAnnotations(exportedFunction, function);\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    function.setJSDocInfo(new JSDocInfo());\n\n    // If the function has parameters, add them to the extern function.\n    Node paramList = exportedFunction.getSecondChild();\n    for (Node param = paramList.getFirstChild(); param != null; param = param.getNext()) {\n        function.getSecondChild().addChildToBack(param.cloneTree());\n    }\n\n    // If the function has a return type, add it to the extern function.\n    JSDocInfo info = exportedFunction.getJSDocInfo();\n    if (info != null && info.hasReturnType()) {\n        function.setJSDocInfo(info);\n    }\n\n    // If the function has a parameter type, add it to the extern function.\n    for (Node param = paramList.getFirstChild(); param != null; param = param.getNext()) {\n        if (info != null && info.hasParameterType(param.getString())) {\n            function.setJSDocInfo(info);\n        }\n    }\n\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(\n      IR.name(\"\"),\n      IR.paramList(),\n      IR.block());\n\n  function.setJSType(exportedFunction.getJSType());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  int index = 1;\n  for (Node child = exportedFunction.getFirstChild();\n       child != null;\n       child = child.getNext()) {\n    // TODO(user): handle getters or setters?\n    if (child.isStringKey()) {\n      function.addChildToBack(\n          IR.propdef(\n              IR.stringKey(child.getString()),\n              IR.number(index++)));\n    }\n  }\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(\n      IR.name(\"\"),\n      IR.paramList(),\n      IR.block());\n  function.setJSType(exportedFunction.getJSType());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  return function;\n}"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    RealMatrix covar = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < sigma.length; i++) {\n        sigma[i] = FastMath.sqrt(covar.getEntry(i, i));\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    RealMatrix covar = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < sigma.length; ++i) {\n        sigma[i] = FastMath.sqrt(covar.getEntry(i, i));\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    RealMatrix cov = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; ++i) {\n        sigma[i] = FastMath.sqrt(cov.getEntry(i, i));\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    RealMatrix cov = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < sigma.length; i++) {\n        sigma[i] = FastMath.sqrt(cov.getEntry(i, i));\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    RealMatrix cov = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigmas = new double[params.length];\n    for (int i = 0; i < params.length; i++) {\n        sigmas[i] = FastMath.sqrt(cov.getEntry(i, i));\n    }\n    return sigmas;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    RealMatrix covar = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; ++i) {\n        sigma[i] = FastMath.sqrt(covar.getEntry(i, i));\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    RealMatrix covariance = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; ++i) {\n        sigma[i] = FastMath.sqrt(covariance.getEntry(i, i));\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    RealMatrix covar = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < sigma.length; ++i) {\n        sigma[i] = FastMath.sqrt(covar.getEntry(i, i));\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    RealMatrix covariance = computeCovariances(params,\n                                              covarianceSingularityThreshold);\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < sigma.length; ++i) {\n        sigma[i] = FastMath.sqrt(covariance.getEntry(i, i));\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < sigma.length; ++i) {\n        sigma[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return sigma;\n}"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        final StringBuilder buf = new StringBuilder();\n        buf.append(varName);\n        buf.append(\" in \");\n        buf.append(priorVariables);\n        throw new IllegalStateException(\"Cyclic substitution: \" + buf.toString());\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables != null) \n    {\n        for (String priorVar : priorVariables) \n        {\n            if (varName.equals(priorVar)) \n            {\n                throw new IllegalStateException(\"Cyclic substitution: \" + varName);\n            }\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables != null && priorVariables.contains(varName)) \n    {\n        final StringBuilder buf = new StringBuilder();\n        buf.append(varName);\n        buf.append(\" substitution in variable \");\n        buf.append(varName);\n        buf.append(\" is detected in the stack.\");\n        buf.append(\" Stack: \");\n        buf.append(priorVariables);\n        throw new IllegalStateException(buf.toString());\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables != null && priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"Cyclic substitution: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic substitution: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables != null) {\n        for (int i = priorVariables.size() - 1; i >= 0; i--) {\n            if (varName.equals(priorVariables.get(i))) {\n                throw new IllegalStateException(\"Cyclic substitution: \" + varName);\n            }\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables != null) {\n        for (int i = priorVariables.size() - 1; i >= 0; i--) {\n            if (priorVariables.get(i).equals(varName)) {\n                throw new IllegalStateException(\"Cyclic substitution: \" + varName);\n            }\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalStateException(\"Cyclic substitution: \" + varName + \" in \" + priorVariables);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables != null) {\n        for (int i = priorVariables.size() - 1; i >= 0; i--) {\n            if (varName.equals(priorVariables.get(i))) {\n                throw new IllegalStateException(\"Cyclic substitution: \" + varName\n                        + \" is already in the substitution stack\");\n            }\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables != null) {\n        for (String priorVariable : priorVariables) {\n            if (priorVariable.equals(varName)) {\n                throw new IllegalStateException(\"Cyclic substitution: \" + varName);\n            }\n        }\n    }\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  List<INPUT> result = Lists.newArrayList();\n  Set<INPUT> seen = Sets.newHashSet();\n  for (INPUT root : roots) {\n    getDependenciesOf(root, seen, result);\n  }\n  if (sorted) {\n    result = topologicalStableSort(result, getDependencies());\n  }\n  return Collections.unmodifiableList(result);\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<>();\n    Set<INPUT> visited = new HashSet<>();\n    for (INPUT root : roots) {\n      collectDependencies(root, visited, result);\n    }\n    if (sorted) {\n      result = topologicalStableSort(result, getDependencies());\n    }\n    return Collections.unmodifiableList(result);\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  List<INPUT> dependencies = new ArrayList<>();\n  Set<INPUT> visited = new HashSet<>();\n  for (INPUT root : roots) {\n    getDependenciesOf(root, visited, dependencies);\n  }\n  if (sorted) {\n    dependencies = topologicalStableSort(dependencies, getDependencies());\n  }\n  return Collections.unmodifiableList(dependencies);\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    Set<INPUT> visited = Sets.newHashSet();\n    List<INPUT> result = Lists.newArrayList();\n    for (INPUT root : roots) {\n      getDependenciesOf(root, visited, result);\n    }\n    if (sorted) {\n      result = topologicalStableSort(result, buildDependencyMap());\n    }\n    return Collections.unmodifiableList(result);\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    List<INPUT> result = Lists.newArrayList();\n    Set<INPUT> visited = Sets.newHashSet();\n    for (INPUT root : roots) {\n      getDependenciesOf(root, visited, result);\n    }\n    if (sorted) {\n      result = topologicalStableSort(result, getDependencies());\n    }\n    return result;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    Set<INPUT> visited = new HashSet<>();\n    List<INPUT> result = new ArrayList<>();\n    for (INPUT root : roots) {\n      getDependenciesOf(root, visited, result);\n    }\n    if (sorted) {\n      result = topologicalStableSort(result, getDependencies());\n    }\n    return result;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    List<INPUT> result = Lists.newArrayList();\n    Set<INPUT> visited = Sets.newHashSet();\n    for (INPUT root : roots) {\n      collectDependencies(root, visited, result);\n    }\n    if (sorted) {\n      result = topologicalStableSort(result, getDependencyMap());\n    }\n    return Collections.unmodifiableList(result);\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    List<INPUT> result = Lists.newArrayList();\n    for (INPUT root : roots) {\n      if (!result.contains(root)) {\n        result.addAll(getDependenciesOfHelper(root, new HashSet<INPUT>()));\n      }\n    }\n    if (sorted) {\n      result = topologicalStableSort(result, getDependencies());\n    }\n    return result;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    Set<INPUT> visited = Sets.newHashSet();\n    List<INPUT> result = Lists.newArrayList();\n    for (INPUT root : roots) {\n      getDependenciesOf(root, visited, result);\n    }\n    if (sorted) {\n      result = topologicalStableSort(result, buildDependencyMap());\n    }\n    return Collections.unmodifiableList(result);\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  List<INPUT> dependencies = Lists.newArrayList();\n  for (INPUT root : roots) {\n    dependencies.addAll(getDependenciesOf(root, sorted));\n  }\n  return dependencies;\n}"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen];\n    int outOffset = 0;\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n            buf[outOffset++] = ch;\n        } else if (uncapitalizeNext) {\n            buf[outOffset++] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        } else {\n            buf[outOffset++] = ch;\n        }\n    }\n    return new String(buf, 0, outOffset);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buffer = new char[strLen];\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        } \n        else \n        {\n            buffer[i] = ch;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    if (delimiters != null && delimiters.length == 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen];\n    int outOffset = 0;\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n            buf[outOffset++] = ch;\n        } \n        else if (uncapitalizeNext) \n        {\n            buf[outOffset++] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        } \n        else \n        {\n            buf[outOffset++] = ch;\n        }\n    }\n    return new String(buf, 0, outOffset);\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = new char[a.getField().getRadixDigits()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}"
    ],
    [
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    if (hasAttr(\"id\"))\n    {\n        selector.append(\"#\");\n        selector.append(attr(\"id\"));\n    }\n    else\n    {\n        Element parent = parent();\n        if (parent != null)\n        {\n            selector.append(parent.cssSelector());\n            selector.append(\" > \");\n        }\n        selector.append(tagName());\n        if (hasAttr(\"class\"))\n        {\n            selector.append(\".\");\n            selector.append(attr(\"class\"));\n        }\n        if (parent != null)\n        {\n            int index = parent.childElementsList().indexOf(this);\n            selector.append(\":nth-child(\");\n            selector.append(index + 1);\n            selector.append(\")\");\n        }\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    if (id() != null)\n        return \"#\" + id();\n    else if (parentNode == null)\n        return \"\";\n    else\n    {\n        StringBuilder selector = new StringBuilder();\n        Element parent = parent();\n        if (parent.parentNode != null)\n            selector.append(parent.cssSelector()).append(\" > \");\n        selector.append(tagName());\n        if (attributes().size() > 0)\n        {\n            for (Attribute attribute : attributes().asList())\n            {\n                if (attribute.getValue() != null)\n                    selector.append(\"[\" + attribute.getKey() + \"='\" + attribute.getValue() + \"']\");\n                else\n                    selector.append(\"[\" + attribute.getKey() + \"]\");\n            }\n        }\n        return selector.toString();\n    }\n}",
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    Element el = this;\n    while (el != null) \n    {\n        if (el.id() != null) \n        {\n            selector.insert(0, \"#\" + el.id());\n            break;\n        } \n        else \n        {\n            Elements siblings = el.parent().children();\n            int index = siblings.indexOf(el);\n            selector.insert(0, \":nth-child(\" + (index + 1) + \")\");\n            selector.insert(0, \".\" + el.className());\n            selector.insert(0, \".\");\n            selector.insert(0, el.tagName());\n            selector.insert(0, \" > \");\n            el = el.parent();\n        }\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    if (hasAttr(\"id\"))\n        return \"#\" + attr(\"id\");\n    else\n    {\n        Elements parents = parents();\n        StringBuilder selector = new StringBuilder();\n        for (Element parent : parents)\n        {\n            int index = parent.childIndexOf(this);\n            if (index != -1)\n            {\n                selector.insert(0, \":nth-child(\" + index + \")\");\n                selector.insert(0, parent.tagName());\n            }\n        }\n        return selector.toString();\n    }\n}",
      "public String cssSelector()  {\n    if (hasAttr(\"id\"))\n        return \"#\" + attr(\"id\");\n\n    Elements parents = parents();\n    StringBuilder selector = new StringBuilder();\n    for (int i = parents.size() - 1; i >= 0; i--) \n    {\n        Element parent = parents.get(i);\n        Elements siblings = parent.children();\n        int index = siblings.indexOf(this);\n        selector.append(parent.tagName()).append(\":nth-child(\").append(index + 1).append(\")\");\n        if (i > 0) \n        {\n            selector.insert(0, \" > \");\n        }\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    Element el = this;\n    while (el.parent() != null) \n    {\n        int index = el.siblingIndex();\n        String tagName = el.tagName();\n        selector.insert(0, \"> \" + tagName);\n        if (el.id().length() > 0) \n        {\n            selector.insert(0, \"#\" + el.id());\n            break;\n        } \n        else if (index > 0) \n        {\n            selector.insert(0, \":nth-child(\" + index + \")\");\n        }\n        el = el.parent();\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    if (id() != null)\n        return \"#\" + id();\n\n    StringBuilder selector = new StringBuilder();\n    Element el = this;\n    while (el.parent() != null)\n    {\n        if (el.parent().childNodeSize() > 1)\n        {\n            int index = el.siblingIndex();\n            selector.insert(0, \":nth-child(\" + (index + 1) + \")\");\n        }\n        selector.insert(0, el.tagName());\n        el = el.parent();\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    if (id() != null)\n        return \"#\" + id();\n    else\n    {\n        Element parent = parent();\n        if (parent == null)\n            return tagName();\n        else\n            return parent.cssSelector() + \" > \" + tagName() + \":nth-child(\" + (parent.childElementsList().indexOf(this) + 1) + \")\";\n    }\n}",
      "public String cssSelector()  {\n    if (id() != null)\n        return \"#\" + id();\n\n    if (parent() == null)\n        return \"\";\n\n    Elements parents = parents();\n    StringBuilder selector = new StringBuilder();\n    for (int i = parents.size() - 1; i >= 0; i--) \n    {\n        Element parent = parents.get(i);\n        Elements siblings = parent.children();\n        int index = siblings.indexOf(this);\n        selector.append(parent.tagName()).append(\":nth-child(\").append(index + 1).append(\")\");\n        if (i > 0) \n        {\n            selector.insert(0, \" > \");\n        }\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    if (hasAttr(\"id\"))\n    {\n        selector.append(\"#\");\n        selector.append(attr(\"id\"));\n    }\n    else\n    {\n        if (parent() != null)\n        {\n            selector.append(parent().cssSelector());\n            selector.append(\" > \");\n        }\n        selector.append(tagName());\n        if (hasAttr(\"class\"))\n        {\n            selector.append(\".\");\n            selector.append(attr(\"class\"));\n        }\n        if (parent() != null)\n        {\n            int index = parent().childNodes().indexOf(this);\n            selector.append(\":nth-child(\");\n            selector.append(index + 1);\n            selector.append(\")\");\n        }\n    }\n    return selector.toString();\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost += NAME_COST_ESTIMATE;\n      break;\n    case Token.AND:\n    case Token.OR:\n      cost += COMMA_COST;\n      break;\n    case Token.CALL:\n      cost += PAREN_COST;\n      break;\n    default:\n      break;\n  }\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost = 1;\n      break;\n    case Token.NE:\n    case Token.EQ:\n    case Token.SHEQ:\n    case Token.SHNE:\n      cost = 2;\n      break;\n    default:\n      break;\n  }\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost += 2; // \"!\"\n      break;\n    case Token.NE:\n    case Token.SHNE:\n      cost += 3; // \"!=\"\n      break;\n    case Token.EQ:\n    case Token.SHEQ:\n      cost += 2; // \"==\"\n      break;\n    case Token.AND:\n    case Token.OR:\n      cost += 1; // \"&&\" or \"||\"\n      break;\n    default:\n      cost += 1; // \"(\"\n      cost += estimateCostOneLevel(n.getFirstChild());\n      cost += 1; // \")\"\n      break;\n  }\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  switch (n.getType()) {\n    case Token.NOT:\n      return NAME_COST_ESTIMATE;\n    case Token.NE:\n    case Token.EQ:\n    case Token.SHNE:\n    case Token.SHEQ:\n      return COMMA_COST + NAME_COST_ESTIMATE;\n    default:\n      return PAREN_COST;\n  }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    switch (n.getType()) {\n      case Token.NOT:\n        return NAME_COST_ESTIMATE;\n      case Token.AND:\n      case Token.OR:\n      case Token.HOOK:\n        return COMMA_COST;\n      default:\n        return PAREN_COST;\n    }\n  }",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n      case Token.NOT:\n        cost += NAME_COST_ESTIMATE;\n        break;\n      case Token.NE:\n      case Token.EQ:\n      case Token.SHNE:\n      case Token.SHEQ:\n        cost += NAME_COST_ESTIMATE * 2;\n        break;\n      default:\n        cost += PAREN_COST;\n    }\n    return cost;\n  }",
      "private static int estimateCostOneLevel(Node n)  {\n  switch (n.getType()) {\n    case Token.NOT:\n      return NAME_COST_ESTIMATE;\n    case Token.AND:\n    case Token.OR:\n    case Token.HOOK:\n      return COMMA_COST;\n    default:\n      return PAREN_COST;\n  }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost += NAME_COST_ESTIMATE;\n      break;\n    case Token.LPAREN:\n    case Token.RPAREN:\n      cost += PAREN_COST;\n      break;\n    default:\n      break;\n  }\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost = 1;\n      break;\n    case Token.NE:\n    case Token.EQ:\n    case Token.SHEQ:\n    case Token.SHNE:\n      cost = 2;\n      break;\n    default:\n      break;\n  }\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  switch (n.getType()) {\n    case Token.NOT:\n      return 1;\n    case Token.AND:\n    case Token.OR:\n    case Token.HOOK:\n      return COMMA_COST;\n    default:\n      return PAREN_COST;\n  }\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    final char[] buf = buffer;\n    int len = size;\n    int i = 0;\n    int j = len - 1;\n    char swap;\n    while (j > i) \n    {\n        swap = buf[i];\n        buf[i] = buf[j];\n        buf[j] = swap;\n        i++;\n        j--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    final int len = length();\n    final char[] chars = buffer;\n    for (int i = 0; i < len / 2; i++) \n    {\n        final char tmp = chars[i];\n        chars[i] = chars[len - i - 1];\n        chars[len - i - 1] = tmp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int len = length();\n    int mid = len / 2;\n    char[] buf = buffer;\n    for (int i = 0; i < mid; i++) \n    {\n        char tmp = buf[i];\n        buf[i] = buf[len - i - 1];\n        buf[len - i - 1] = tmp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int len = length();\n    char chars[] = buffer;\n    for (int i = 0; i < len / 2; i++) \n    {\n        char temp = chars[i];\n        chars[i] = chars[len - i - 1];\n        chars[len - i - 1] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) {\n        return this;\n    }\n    final char chars[] = toCharArray();\n    ArrayUtils.reverse(chars);\n    setSize(chars.length);\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int len = length();\n    char[] buf = buffer;\n    for (int i = 0; i < len / 2; i++) \n    {\n        char swap = buf[i];\n        buf[i] = buf[len - i - 1];\n        buf[len - i - 1] = swap;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int len = length();\n    char chars[] = buffer;\n    for (int i = 0; i < len / 2; i++) \n    {\n        char tmp = chars[i];\n        chars[i] = chars[len - i - 1];\n        chars[len - i - 1] = tmp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int len = length();\n    char chars[] = buffer;\n    for (int i = 0; i < len / 2; i++) \n    {\n        char tmp = chars[i];\n        chars[i] = chars[len - i - 1];\n        chars[len - i - 1] = tmp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) \n    {\n        return this;\n    }\n    final char[] buf = buffer;\n    int left = 0;\n    int right = size - 1;\n    char ch;\n    while (left < right) \n    {\n        ch = buf[left];\n        buf[left] = buf[right];\n        buf[right] = ch;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) \n    {\n        return this;\n    }\n    final char[] buf = buffer;\n    int left = 0;\n    int right = size - 1;\n    char swap;\n    while (left < right) \n    {\n        swap = buf[left];\n        buf[left] = buf[right];\n        buf[right] = swap;\n        left++;\n        right--;\n    }\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Offset must be not be negative\");\n    Validate.isTrue(offset <= value.length(), \"Offset must not be greater than current text length\");\n\n    String before = value.substring(0, offset);\n    String after = value.substring(offset);\n\n    TextNode afterNode = new TextNode(after);\n    parent().insertChild(index() + 1, afterNode);\n    coreValue(before);\n\n    return afterNode;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > value.length()) \n    {\n        throw new IllegalArgumentException(\"Split offset must be within the text length\");\n    }\n    TextNode after = new TextNode(value.substring(offset));\n    parent().insertChildren(indexOf(), after);\n    value = value.substring(0, offset);\n    return after;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > text().length()) \n    {\n        throw new IllegalArgumentException(\"Cannot split text at offset \" + offset + \": document text is \" + text().length() + \" characters long\");\n    }\n\n    String before = text().substring(0, offset);\n    String after = text().substring(offset);\n\n    TextNode newNode = new TextNode(after);\n    replaceWith(newNode);\n\n    coreValue(before);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Offset must be not be negative\");\n    Validate.isTrue(offset < value.length(), \"Offset must not be greater than current node length\");\n\n    TextNode secondHalf = new TextNode(value.substring(offset));\n    parentNode.addChild(siblingIndex() + 1, secondHalf);\n    value = value.substring(0, offset);\n    return secondHalf;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > value.length())\n        throw new IllegalArgumentException(\"Offset must be between 0 and text length\");\n    TextNode first = new TextNode(value.substring(0, offset));\n    TextNode second = new TextNode(value.substring(offset));\n    replaceWith(first);\n    first.after(second);\n    return second;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > value.length()) \n    {\n        throw new IllegalArgumentException(\"Offset must be between 0 and \" + value.length());\n    }\n\n    TextNode after = new TextNode(value.substring(offset));\n    after.parent = parent;\n    after.nextSibling = nextSibling;\n    after.previousSibling = this;\n\n    if (nextSibling != null) \n    {\n        nextSibling.previousSibling = after;\n    }\n    nextSibling = after;\n\n    value = value.substring(0, offset);\n    return after;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Offset must be not be negative\");\n    Validate.isTrue(offset < value.length(), \"Offset must not be greater than current node length\");\n\n    TextNode secondPart = new TextNode(value.substring(offset));\n    parent().insertChildren(indexOf() + 1, secondPart);\n    value = value.substring(0, offset);\n    return secondPart;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Offset must be not be negative\");\n    Validate.isTrue(offset <= value.length(), \"Offset must not be greater than current node length\");\n    \n    TextNode after = new TextNode(value.substring(offset));\n    parent().insertChild(index() + 1, after);\n    value = value.substring(0, offset);\n    return after;\n}",
      "public TextNode splitText(int offset)  {\n    Validate.isTrue(offset >= 0, \"Offset must be not be negative\");\n    Validate.isTrue(offset <= value.length(), \"Offset must not be greater than current node length\");\n\n    TextNode after = new TextNode(value.substring(offset));\n    after.parent = parent;\n    after.nextSibling = nextSibling;\n    after.previousSibling = this;\n\n    if (nextSibling != null)\n        nextSibling.previousSibling = after;\n    nextSibling = after;\n\n    value = value.substring(0, offset);\n\n    return after;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > value.length()) \n    {\n        throw new IllegalArgumentException(\"Split offset must be between 0 and text length\");\n    }\n\n    TextNode after = new TextNode(value.substring(offset));\n    after.parent = parent;\n    after.nextSibling = nextSibling;\n    after.previousSibling = this;\n\n    if (nextSibling != null) \n    {\n        nextSibling.previousSibling = after;\n    }\n\n    nextSibling = after;\n\n    value = value.substring(0, offset);\n\n    return after;\n}"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return subtract(union(a, b), intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = value.toByteArray();\n    if (bytes[0] == 0)\n    {\n        bytes = Arrays.copyOfRange(bytes, 1, bytes.length);\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    if (value == null) \n    {\n        throw new IllegalArgumentException(\"value must not be null\");\n    }\n    if (value.bitLength() > 64) \n    {\n        throw new IllegalArgumentException(\"value must be less than 2^64\");\n    }\n    final byte[] result = new byte[8];\n    putLong(value.longValue(), result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    if (value.bitLength() > 64) \n    {\n        throw new IllegalArgumentException(\"BigInteger too large\");\n    }\n    byte[] bytes = value.toByteArray();\n    if (bytes[0] < 0) \n    {\n        bytes = Arrays.copyOfRange(bytes, 1, bytes.length);\n    }\n    if (bytes.length < 8) \n    {\n        bytes = Arrays.copyOf(bytes, 8);\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = value.toByteArray();\n    if (bytes[0] == 0) \n    {\n        bytes = Arrays.copyOfRange(bytes, 1, bytes.length);\n    }\n    if (bytes.length > 8) \n    {\n        throw new IllegalArgumentException(\"BigInteger out of range: \" + value);\n    }\n    byte[] result = new byte[8];\n    System.arraycopy(bytes, 0, result, 8 - bytes.length, bytes.length);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    if (value.bitLength() > 63)\n    {\n        throw new IllegalArgumentException(\"ZipEightByteInteger cannot represent numbers with more than 63 bits\");\n    }\n\n    final byte[] result = new byte[8];\n    putLong(value.longValue(), result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    if (value.bitLength() > 63) \n    {\n        throw new IllegalArgumentException(\"BigInteger cannot be converted to ZipEightByteInteger\");\n    }\n    byte[] bytes = value.toByteArray();\n    if (bytes[0] < 0) \n    {\n        bytes = Arrays.copyOfRange(bytes, 1, bytes.length);\n    }\n    if (bytes.length < 8) \n    {\n        bytes = Arrays.copyOf(bytes, 8);\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    if (value == null) \n    {\n        throw new IllegalArgumentException(\"value must not be null\");\n    }\n    if (value.bitLength() > 64) \n    {\n        throw new IllegalArgumentException(\"value too large\");\n    }\n    byte[] bytes = value.toByteArray();\n    if (bytes[0] < 0) \n    {\n        bytes = Arrays.copyOfRange(bytes, 1, bytes.length);\n    }\n    if (bytes.length < 8) \n    {\n        bytes = Arrays.copyOf(bytes, 8);\n    }\n    return bytes;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] valueBytes = value.toByteArray();\n    int valueLength = valueBytes.length;\n    int resultOffset = 8 - valueLength;\n    System.arraycopy(valueBytes, 0, result, resultOffset, valueLength);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    if (value.bitLength() > 64) \n    {\n        throw new IllegalArgumentException(\"BigInteger cannot be converted to ZipEightByteInteger: \" + value);\n    }\n    final byte[] result = new byte[8];\n    putLong(value.longValue(), result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = value.toByteArray();\n    if (bytes[0] == 0) \n    {\n        bytes = Arrays.copyOfRange(bytes, 1, bytes.length);\n    }\n    if (bytes.length > 8) \n    {\n        throw new IllegalArgumentException(\"BigInteger out of range for a ZipEightByteInteger\");\n    }\n    byte[] result = new byte[8];\n    System.arraycopy(bytes, 0, result, 8 - bytes.length, bytes.length);\n    return result;\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    StringBuilder sb = new StringBuilder();\n    final CharSet chars = CharSet.getInstance(set);\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder sb = new StringBuilder();\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder sb = new StringBuilder();\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder builder = new StringBuilder();\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            builder.append(c);\n        }\n    }\n    return builder.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder sb = new StringBuilder();\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    StringBuilder sb = new StringBuilder();\n    final CharSet chars = CharSet.getInstance(set);\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder sb = new StringBuilder();\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder sb = new StringBuilder();\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder builder = new StringBuilder();\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            builder.append(c);\n        }\n    }\n    return builder.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder builder = new StringBuilder();\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            builder.append(c);\n        }\n    }\n    return builder.toString();\n}"
    ],
    [
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_SYMMETRIC_MATRIX);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_POSITIVE_DEFINITE_MATRIX);\n    }\n\n    final int n = getRowDimension();\n    final RealMatrix sqrt = new Array2DRowRealMatrix(n, n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            double sum = 0;\n            for (int k = 0; k < n; k++) {\n                sum += getEntry(i, k) * getEntry(k, j);\n            }\n            sqrt.setEntry(i, j, FastMath.sqrt(sum));\n        }\n    }\n    return sqrt;\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n        if (!isSymmetric) {\n            throw new MathUnsupportedOperationException(\n                \"Square root of a non-symmetric matrix is not supported\");\n        }\n        if (hasComplexEigenvalues()) {\n            throw new MathUnsupportedOperationException(\n                \"Square root of a matrix with complex eigenvalues is not supported\");\n        }\n        if (cachedV == null) {\n            cachedV = getV();\n        }\n        if (cachedD == null) {\n            cachedD = getD();\n        }\n        if (cachedVt == null) {\n            cachedVt = getV().transpose();\n        }\n        final RealMatrix sqrt = cachedV.multiply(cachedD.getDiagonalMatrix()).multiply(cachedVt);\n        return sqrt;\n    }\n}",
      "public RealMatrix getSquareRoot()  {\n    if (isSymmetric) {\n        return getL().transpose().multiply(getL());\n    } else {\n        throw new MathUnsupportedOperationException();\n    }\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n        if (!isSymmetric) {\n            throw new MathUnsupportedOperationException();\n        }\n        if (hasComplexEigenvalues()) {\n            throw new MathUnsupportedOperationException();\n        }\n        if (cachedVt == null) {\n            cachedVt = getV().transpose();\n        }\n        if (cachedD == null) {\n            cachedD = new Array2DRowRealMatrix(realEigenvalues.length,\n                                              realEigenvalues.length);\n            for (int i = 0; i < realEigenvalues.length; i++) {\n                cachedD.setEntry(i, i, realEigenvalues[i]);\n            }\n        }\n        return cachedVt.multiply(cachedD).multiply(cachedVt);\n    }\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n        if (!isSymmetric) {\n            throw new MathUnsupportedOperationException(\n                \"Matrix is not symmetric\");\n        }\n        if (hasComplexEigenvalues()) {\n            throw new MathUnsupportedOperationException(\n                \"Matrix has complex eigenvalues\");\n        }\n        if (!isPositiveDefinite()) {\n            throw new MathUnsupportedOperationException(\n                \"Matrix is not positive definite\");\n        }\n\n        // Create the square root matrix.\n        final int dim = main.length;\n        final RealMatrix sqrt = MatrixUtils.createRealMatrix(dim, dim);\n        for (int i = 0; i < dim; ++i) {\n            sqrt.setEntry(i, i, FastMath.sqrt(main[i]));\n        }\n\n        // Multiply by the eigenvectors.\n        return sqrt.multiply(MatrixUtils.createRealMatrix(eigenvectors));\n    }\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n    if (!isSymmetric) {\n        throw new MathUnsupportedOperationException(\n            \"square root of non-symmetric matrix\");\n    }\n    if (hasComplexEigenvalues()) {\n        throw new MathUnsupportedOperationException(\n            \"square root of matrix with complex eigenvalues\");\n    }\n    if (!isPositiveDefinite) {\n        throw new MathUnsupportedOperationException(\n            \"square root of non-positive definite matrix\");\n    }\n    if (cachedSquareRoot == null) {\n        cachedSquareRoot = createSquareRootMatrix();\n    }\n    return cachedSquareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (isSymmetric) {\n        if (isPositiveDefinite) {\n            return new Array2DRowRealMatrix(squareRoot(cachedL.getData()));\n        } else {\n            throw new MathUnsupportedOperationException(\n                \"The matrix is not positive definite.\");\n        }\n    } else {\n        throw new MathUnsupportedOperationException(\n            \"The matrix is not symmetric.\");\n    }\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n        if (!isSymmetric) {\n            throw new MathUnsupportedOperationException();\n        }\n        if (hasComplexEigenvalues()) {\n            throw new MathUnsupportedOperationException();\n        }\n        if (cachedVt == null) {\n            cachedVt = getV().transpose();\n        }\n        if (cachedD == null) {\n            cachedD = new Array2DRowRealMatrix(realEigenvalues.length,\n                                              realEigenvalues.length);\n            for (int i = 0; i < realEigenvalues.length; ++i) {\n                cachedD.setEntry(i, i, realEigenvalues[i]);\n            }\n        }\n        return cachedVt.multiply(cachedD).multiply(cachedVt);\n    }\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n        if (!isSymmetric) {\n            throw new MathUnsupportedOperationException(\n                \"Matrix is not symmetric\");\n        }\n        if (hasComplexEigenvalues()) {\n            throw new MathUnsupportedOperationException(\n                \"Matrix has complex eigenvalues\");\n        }\n        if (!isPositiveDefinite()) {\n            throw new MathUnsupportedOperationException(\n                \"Matrix is not positive definite\");\n        }\n        if (cachedSquareRoot == null) {\n            cachedSquareRoot = buildSquareRoot();\n        }\n        return cachedSquareRoot;\n    }",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n        if (!isSymmetric) {\n            throw new MathUnsupportedOperationException();\n        }\n        if (hasComplexEigenvalues()) {\n            throw new MathUnsupportedOperationException();\n        }\n        if (cachedVt == null) {\n            cachedVt = getV().transpose();\n        }\n        return cachedVt.multiply(getD()).multiply(cachedVt);\n    }\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // 26-Oct-2016, tatu: Will fail, but let the original deserializer provide message\n        return _delegate.deserialize(p, ctxt, value);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // 26-Oct-2016, tatu: Will fail, but let the original deserializer provide message\n        return _delegate.deserialize(p, ctxt, value);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.START_OBJECT || t == JsonToken.FIELD_NAME) {\n            return deserializeFromObject(p, ctxt);\n        }\n        if (t == JsonToken.END_OBJECT) {\n            return _valueInstantiator.createObject(ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            Object value = p.getEmbeddedObject();\n            if (value == null) {\n                return null;\n            }\n            if (value instanceof byte[]) {\n                return _deserializeByteArray(p, ctxt);\n            }\n            if (handledType().isInstance(value)) {\n                return value;\n            }\n            throw ctxt.mappingException(handledType(), value);\n        }\n        return deserializeFromScalar(p, ctxt, t);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.START_OBJECT || t == JsonToken.FIELD_NAME) {\n            return _deserializeFromObject(p, ctxt);\n        }\n        if (t == JsonToken.START_ARRAY) {\n            return _deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_STRING) {\n            return _deserializeFromString(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return _deserializeFromNumber(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return _deserializeFromDouble(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return Boolean.TRUE;\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return Boolean.FALSE;\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return _deserializeFromNull(p, ctxt);\n        }\n        if (t == JsonToken.START_OBJECT_OR_ARRAY) {\n            return _deserializeFromObjectOrArray(p, ctxt);\n        }\n        return ctxt.handleUnexpectedToken(_valueType, p);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // 26-Oct-2016, tatu: Will fail, but let the original deserializer provide message\n        return _delegate.deserialize(p, ctxt, value);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // 26-Oct-2016, tatu: Will fail, but let the original deserializer provide message\n        return _delegate.deserialize(p, ctxt, value);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // 26-Oct-2016, tatu: Will fail, but let the original deserializer provide message\n        return _delegate.deserialize(p, ctxt, value);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // 26-Oct-2016, tatu: Will fail, but let the original deserializer provide message\n        return _delegate.deserialize(p, ctxt, value);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // 26-Oct-2016, tatu: Will fail, but let the original deserializer provide message\n        return _delegate.deserialize(p, ctxt, value);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.START_OBJECT) {\n            return deserializeFromObject(p, ctxt);\n        }\n        if (t == JsonToken.START_ARRAY) {\n            return deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            Object value = p.getEmbeddedObject();\n            if (value == null) {\n                return null;\n            }\n            if (value instanceof byte[]) {\n                return _deserializeByteArray(p, ctxt, (byte[]) value);\n            }\n            if (value instanceof InputStream) {\n                return _deserializeInputStream(p, ctxt, (InputStream) value);\n            }\n            if (value instanceof Reader) {\n                return _deserializeReader(p, ctxt, (Reader) value);\n            }\n            throw ctxt.mappingException(_valueClass);\n        }\n        if (t == JsonToken.VALUE_STRING) {\n            return _deserializeString(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return _deserializeNumber(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return _deserializeDouble(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return Boolean.TRUE;\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return Boolean.FALSE;\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return _deserializeNull(p, ctxt);\n        }\n        if (t == JsonToken.START_OBJECT) {\n            return deserializeFromObject(p, ctxt);\n        }\n        if (t == JsonToken.START_ARRAY) {\n            return deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n}\n}"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0d;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException();\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0d;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException();\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException();\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException();\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        _size += fullChunk.length;\n        return resetAndStart();\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int chunkSize = fullChunk.length;\n        _size += chunkSize;\n        if (_tail != null) {\n            _tail.next = new LinkedNode<Object[]>(fullChunk);\n            _tail = _tail.next;\n        } else {\n            _head = new LinkedNode<Object[]>(fullChunk);\n            _tail = _head;\n        }\n        return new Object[chunkSize];\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int chunkSize = fullChunk.length;\n        _size += chunkSize;\n        if (_tail == null) {\n            _head = _tail = new LinkedNode<Object[]>(fullChunk);\n        } else {\n            _tail = _tail.next = new LinkedNode<Object[]>(fullChunk);\n        }\n        return new Object[chunkSize];\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int newSize = _size + fullChunk.length;\n        if (_freeBuffer == null) {\n            _freeBuffer = new Object[newSize];\n        } else if (_freeBuffer.length < newSize) {\n            _freeBuffer = new Object[Math.max(12, newSize)];\n        }\n        System.arraycopy(fullChunk, 0, _freeBuffer, _size, fullChunk.length);\n        _size = newSize;\n        return _freeBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int chunkSize = fullChunk.length;\n        if (_freeBuffer == null) {\n            _freeBuffer = new Object[Math.max(12, chunkSize)];\n        } else if (_freeBuffer.length < chunkSize) {\n            _freeBuffer = new Object[chunkSize];\n        }\n        _size += chunkSize;\n        return _freeBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        _size += fullChunk.length;\n        return _freeBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int chunkSize = fullChunk.length;\n        if (_freeBuffer == null) {\n            _freeBuffer = new Object[chunkSize];\n        } else {\n            Object[] newBuffer = new Object[_freeBuffer.length + chunkSize];\n            System.arraycopy(_freeBuffer, 0, newBuffer, 0, _freeBuffer.length);\n            _freeBuffer = newBuffer;\n        }\n        _size += chunkSize;\n        return _freeBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int oldSize = _size;\n        _size += fullChunk.length;\n        if (_head == null) {\n            _head = new LinkedNode<Object[]>(fullChunk);\n            _tail = _head;\n        } else {\n            _tail.next = new LinkedNode<Object[]>(fullChunk);\n            _tail = _tail.next;\n        }\n        return new Object[Math.max(12, oldSize + 1)];\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        _size += fullChunk.length;\n        return _freeBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int oldSize = _size;\n        _size += fullChunk.length;\n        Object[] newBuffer = new Object[_size];\n        System.arraycopy(_freeBuffer, 0, newBuffer, 0, oldSize);\n        System.arraycopy(fullChunk, 0, newBuffer, oldSize, fullChunk.length);\n        _freeBuffer = newBuffer;\n        return _freeBuffer;\n    }"
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        appendPatternTo(builder, pattern);\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        parsePatternTo(builder, pattern);\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatter formatter = PATTERN_CACHE.get(pattern);\n    if (formatter == null) {\n        synchronized (DateTimeFormat.class) {\n            formatter = PATTERN_CACHE.get(pattern);\n            if (formatter == null) {\n                DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n                appendPatternTo(builder, pattern);\n                formatter = builder.toFormatter();\n                if (PATTERN_CACHE.size() >= PATTERN_CACHE_SIZE) {\n                    PATTERN_CACHE.clear();\n                }\n                PATTERN_CACHE.put(pattern, formatter);\n            }\n        }\n    }\n    return formatter;\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    if (pattern == null) {\n        throw new IllegalArgumentException(\"No pattern supplied\");\n    }\n    DateTimeFormatter formatter = PATTERN_CACHE.get(pattern);\n    if (formatter == null) {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        appendPatternTo(builder, pattern);\n        formatter = builder.toFormatter();\n        if (PATTERN_CACHE.size() < PATTERN_CACHE_SIZE) {\n            PATTERN_CACHE.put(pattern, formatter);\n        }\n    }\n    return formatter;\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatter formatter = PATTERN_CACHE.get(pattern);\n    if (formatter == null) {\n        synchronized (DateTimeFormat.class) {\n            formatter = PATTERN_CACHE.get(pattern);\n            if (formatter == null) {\n                DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n                appendPatternTo(builder, pattern);\n                formatter = builder.toFormatter();\n                if (PATTERN_CACHE.size() >= PATTERN_CACHE_SIZE) {\n                    PATTERN_CACHE.clear();\n                }\n                PATTERN_CACHE.put(pattern, formatter);\n            }\n        }\n    }\n    return formatter;\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        appendPatternTo(builder, pattern);\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatter formatter = PATTERN_CACHE.get(pattern);\n        if (formatter == null) {\n            synchronized (PATTERN_CACHE) {\n                formatter = PATTERN_CACHE.get(pattern);\n                if (formatter == null) {\n                    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n                    appendPatternTo(builder, pattern);\n                    formatter = builder.toFormatter();\n                    if (PATTERN_CACHE.size() >= PATTERN_CACHE_SIZE) {\n                        PATTERN_CACHE.clear();\n                    }\n                    PATTERN_CACHE.put(pattern, formatter);\n                }\n            }\n        }\n        return formatter;\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        appendPatternTo(builder, pattern);\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatter formatter = PATTERN_CACHE.get(pattern);\n    if (formatter == null) {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        appendPatternTo(builder, pattern);\n        formatter = builder.toFormatter();\n        if (PATTERN_CACHE.size() < PATTERN_CACHE_SIZE) {\n            PATTERN_CACHE.put(pattern, formatter);\n        }\n    }\n    return formatter;\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatter formatter = PATTERN_CACHE.get(pattern);\n    if (formatter == null) {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        appendPatternTo(builder, pattern);\n        formatter = builder.toFormatter();\n        if (PATTERN_CACHE.size() >= PATTERN_CACHE_SIZE) {\n            PATTERN_CACHE.clear();\n        }\n        PATTERN_CACHE.put(pattern, formatter);\n    }\n    return formatter;\n}"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.MUL) {\n    return newNode(Token.QMARK);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.VOID);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(next());\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(next());\n  } else if (token == JsDocToken.LP) {\n    return parseFunctionType(next());\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  ",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else if (token == JsDocToken.LP) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else if (token == JsDocToken.LP) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.PIPE) {\n    return parseUnionType(token);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) {\n    case ASTERISK:\n      return newNode(Token.STAR);\n    case NULL:\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      return newNode(Token.VOID);\n    case STRING:\n      return parseTypeName(token);\n    case LC:\n      return parseFunctionType(token);\n    case PIPE:\n      return parseUnionType(token);\n    case LB:\n      return parseRecordType(token);\n    case LPAREN:\n      return parseArrayType(token);\n    default:\n      return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.LC) {\n    return parseUnionType(next());\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(next());\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(next());\n  } else if (token == JsDocToken.LC) {\n    return parseFunctionType(next());\n  } else {\n    return parseTypeNameAnnotation(token);\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.QMARK);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.VOID);\n  } else if (token == JsDocToken.LC) {\n    return parseUnionType(next());\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(next());\n  } else if (token == JsDocToken.LCURLY) {\n    return parseRecordType(next());\n  } else if (token == JsDocToken.LPAREN) {\n    return parseFunctionType(next());\n  } else {\n    return parseTypeName(token);\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.MUL) {\n    return newNode(Token.QMARK);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.VOID);\n  } else if (token == JsDocToken.LC) {\n    return parseUnionType(next());\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(next());\n  } else if (token == JsDocToken.LCURLY) {\n    return parseRecordType(next());\n  } else if (token == JsDocToken.LPAREN) {\n    return parseFunctionType(next());\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) {\n    case ASTERISK:\n      next();\n      return newNode(Token.QMARK);\n    case NULL:\n      next();\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      next();\n      return newNode(Token.VOID);\n    case STRING:\n      return parseTypeName(token);\n    case LC:\n      return parseFunctionType(token);\n    case LB:\n      return parseArrayType(token);\n    case LT:\n      return parseUnionType(token);\n    case LCURLY:\n      return parseRecordType(token);\n    default:\n      return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.QMARK);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEF);\n  } else if (token == JsDocToken.LC) {\n    return parseUnionType(next());\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(next());\n  } else if (token == JsDocToken.LCURLY) {\n    return parseRecordType(next());\n  } else if (token == JsDocToken.LPAREN) {\n    return parseFunctionType(next());\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else {\n    return null;\n  }\n}"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) \n  {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) \n  {\n    throw new IllegalStateException(\"Dangling name: \" + deferredName);\n  }\n  deferredName = name;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) \n  {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) \n  {\n    throw new IllegalStateException();\n  }\n  if (stackSize == 0) \n  {\n    throw new IllegalStateException(\"JsonWriter is closed.\");\n  }\n  deferredName = name;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) \n  {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) \n  {\n    throw new IllegalStateException();\n  }\n  if (stackSize == 0) \n  {\n    throw new IllegalStateException(\"JsonWriter is closed.\");\n  }\n  deferredName = name;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) {\n    throw new IllegalStateException();\n  }\n  if (stackSize == 0) {\n    throw new IllegalStateException(\"JsonWriter is closed.\");\n  }\n  deferredName = name;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) \n    {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) {\n    throw new IllegalStateException();\n  }\n  if (stackSize == 0) {\n    throw new IllegalStateException(\"JsonWriter is closed.\");\n  }\n  deferredName = name;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) \n    {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) {\n    throw new IllegalStateException();\n  }\n  if (stackSize == 0) {\n    throw new IllegalStateException(\"JsonWriter is closed.\");\n  }\n  deferredName = name;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) \n    {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) \n    {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n}"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) \n                {\n                    positive[groupIndex[series]]\n                             = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) \n                {\n                    negative[groupIndex[series]]\n                             = negative[groupIndex[series]] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) \n        {\n            minimum = Math.min(minimum, negative[g]);\n        }\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) \n                {\n                    positive[groupIndex[series]]\n                             = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) \n                {\n                    negative[groupIndex[series]]\n                             = negative[groupIndex[series]] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) \n        {\n            minimum = Math.min(minimum, negative[g]);\n        }\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[groupIndex[series]]\n                             = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) {\n                    negative[groupIndex[series]]\n                             = negative[groupIndex[series]] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum = Math.min(minimum, negative[g]);\n        }\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) \n                {\n                    positive[groupIndex[series]]\n                             = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) \n                {\n                    negative[groupIndex[series]]\n                             = negative[groupIndex[series]] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) \n        {\n            minimum = Math.min(minimum, negative[g]);\n        }\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[groupIndex[series]]\n                             = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) {\n                    negative[groupIndex[series]]\n                             = negative[groupIndex[series]] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum = Math.min(minimum, negative[g]);\n        }\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[groupIndex[series]]\n                             = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) {\n                    negative[groupIndex[series]]\n                             = negative[groupIndex[series]] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum = Math.min(minimum, negative[g]);\n        }\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[groupIndex[series]]\n                             = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) {\n                    negative[groupIndex[series]]\n                             = negative[groupIndex[series]] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum = Math.min(minimum, negative[g]);\n        }\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) \n                {\n                    positive[groupIndex[series]]\n                             = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) \n                {\n                    negative[groupIndex[series]]\n                             = negative[groupIndex[series]] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) \n        {\n            minimum = Math.min(minimum, negative[g]);\n        }\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[groupIndex[series]]\n                             = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) {\n                    negative[groupIndex[series]]\n                             = negative[groupIndex[series]] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum = Math.min(minimum, negative[g]);\n        }\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[groupIndex[series]]\n                             = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) {\n                    negative[groupIndex[series]]\n                             = negative[groupIndex[series]] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum = Math.min(minimum, negative[g]);\n        }\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element == null) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n        if (element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder result = new StringBuilder();\n    boolean nextIsUpper = true;\n    for (final char c : buffer) {\n        if (isDelimiter(c, delimiters)) {\n            nextIsUpper = true;\n        } else if (nextIsUpper) {\n            result.append(Character.toUpperCase(c));\n            nextIsUpper = false;\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder sb = new StringBuilder();\n    boolean uncapitalizeNext = true;\n    for (final char ch : buffer) {\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            sb.append(Character.toUpperCase(ch));\n            uncapitalizeNext = false;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            sb.append(Character.toUpperCase(ch));\n            uncapitalizeNext = false;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] chars = str.toCharArray();\n    final StringBuilder sb = new StringBuilder();\n    boolean next = true;\n    for (final char c : chars) {\n        if (next && !Character.isWhitespace(c)) {\n            sb.append(c);\n            next = false;\n        } else if (Character.isWhitespace(c)) {\n            next = true;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder result = new StringBuilder(buffer.length);\n    boolean nextIsUpper = true;\n    for (final char ch : buffer) {\n        if (isDelimiter(ch, delimiters)) {\n            nextIsUpper = true;\n        } else if (nextIsUpper) {\n            result.append(Character.toUpperCase(ch));\n            nextIsUpper = false;\n        } else {\n            result.append(ch);\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder sb = new StringBuilder();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            sb.append(Character.toUpperCase(ch));\n            uncapitalizeNext = false;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null) {\n        return str;\n    }\n    final StringBuilder initials = new StringBuilder();\n    boolean nextInitial = true;\n    for (final char ch : str.toCharArray()) {\n        if (nextInitial && !isDelimiter(ch, delimiters)) {\n            initials.append(ch);\n            nextInitial = false;\n        } else if (isDelimiter(ch, delimiters)) {\n            nextInitial = true;\n        }\n    }\n    return initials.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder result = new StringBuilder(buffer.length);\n    boolean nextIsUpper = true;\n    for (final char c : buffer) {\n        if (isDelimiter(c, delimiters)) {\n            nextIsUpper = true;\n        } else if (nextIsUpper) {\n            result.append(Character.toUpperCase(c));\n            nextIsUpper = false;\n        } else {\n            result.append(c);\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toUpperCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder sb = new StringBuilder(buffer.length);\n    boolean uncapitalizeNext = true;\n    for (final char ch : buffer) {\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            sb.append(Character.toUpperCase(ch));\n            uncapitalizeNext = false;\n        }\n    }\n    return sb.toString();\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(new HashSet<E>(), list);\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final Set<E> set = new HashSet<E>(temp);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(new HashSet<E>(), new ArrayList<E>(list));\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final Set<E> set = new HashSet<E>(temp);\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(set, new ArrayList<E>(set));\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(new HashSet<E>(), list);\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final Set<E> set = new HashSet<E>(temp);\n    return new ListOrderedSet<E>(set, list);\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range range = plot.getDataRange(axis);\n            if (result == null) {\n                result = range;\n            }\n            else {\n                result = Range.combine(result, range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range range = plot.getDataRange(axis);\n            if (result == null) {\n                result = range;\n            }\n            else {\n                result = Range.combine(result, range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            result = Range.combine(result, plot.getDataRange(axis));\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range range = plot.getDataRange(axis);\n            if (result == null) {\n                result = range;\n            }\n            else {\n                result = Range.combine(result, range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (result == null) \n            {\n                result = more;\n            } \n            else \n            {\n                result = Range.combine(result, more);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            result = Range.combine(result, plot.getDataRange(axis));\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (result == null) \n            {\n                result = more;\n            } \n            else \n            {\n                result = Range.combine(result, more);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (result == null) \n            {\n                result = more;\n            } \n            else \n            {\n                result = Range.combine(result, more);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (result == null) {\n                result = more;\n            }\n            else {\n                result = Range.combine(result, more);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            result = Range.combine(result, plot.getDataRange(axis));\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = Math.log(val + 1.0) / LOG10_VALUE; //invert adjustPow10\n    } \n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.log(10) / Math.log(10)) * val; //invert adjustPow10\n    } \n    else \n    {\n        res = Math.log(val) / Math.log(10);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.log(10) / Math.log(10)) * val; //invert adjustLog10\n    } \n    else \n    {\n        res = Math.log(val) / Math.log(10);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.log(val + 1.0) / Math.log(10)) - 1.0; //invert adjustLog10\n    } \n    else \n    {\n        res = Math.log(val) / Math.log(10);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.log(val + 1.0) - Math.log(1.0)) / Math.log(10.0); //invert adjustLog10\n    } \n    else \n    {\n        res = Math.log(val) / Math.log(10.0);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = Math.log(val + 1.0) / Math.log(10); //invert adjustPow10\n    } \n    else \n    {\n        res = Math.log(val) / Math.log(10);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.log(10) / Math.log(10)) * (val + 1.0) - 1.0; //invert adjustPow10\n    } \n    else \n    {\n        res = Math.log(val) / Math.log(10);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.log(val + 1.0) / LOG10_VALUE) - 1.0; //invert switchedLog10\n    } \n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.log(val + 1.0) - Math.log(10)) / Math.log(10); //invert adjustPow10\n    } \n    else \n    {\n        res = Math.log(val) / Math.log(10);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.log(10) / Math.log(val + 1.0)) - 1.0; //invert adjustLog10\n    } \n    else \n    {\n        res = Math.log(val) / Math.log(10);\n    }\n    return negFlag ? (-res) : res;\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  boolean allPathsReturn = true;\n  for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getDirectedGraphNodes()) \n  {\n    if (node == cfg.getImplicitReturn()) \n    {\n      continue;\n    }\n    if (node == cfg.getEntry()) \n    {\n      continue;\n    }\n    boolean hasReturn = false;\n    for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : node.getOutEdges()) \n    {\n      if (edge.getValue() == ControlFlowGraph.Branch.ON_TRUE) \n      {\n        hasReturn |= fastAllPathsReturnCheckHelper(cfg, edge.getDestination());\n      }\n      else \n      {\n        hasReturn |= fastAllPathsReturnCheckHelper(cfg, edge.getDestination());\n      }\n    }\n    if (!hasReturn) \n    {\n      allPathsReturn = false;\n    }\n  }\n  return allPathsReturn;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getNodes()) \n  {\n    if (node.getControlFlowGraph().getImplicitReturn().equals(node)) \n    {\n      continue;\n    }\n\n    boolean foundReturn = false;\n    for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : node.getOutEdges()) \n    {\n      if (edge.getValue().isConditional()) \n      {\n        DiGraphNode<Node, ControlFlowGraph.Branch> trueNode = edge.getDestination();\n        DiGraphNode<Node, ControlFlowGraph.Branch> falseNode = edge.getDestination();\n        if (cfg.isImplicitReturn(trueNode)) \n        {\n          foundReturn = true;\n        }\n        if (cfg.isImplicitReturn(falseNode)) \n        {\n          foundReturn = true;\n        }\n      } else \n      {\n        DiGraphNode<Node, ControlFlowGraph.Branch> destNode = edge.getDestination();\n        if (cfg.isImplicitReturn(destNode)) \n        {\n          foundReturn = true;\n        }\n      }\n    }\n\n    if (!foundReturn) \n    {\n      return false;\n    }\n  }\n\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getDirectedGraphNodes()) \n  {\n    if (node.getOutEdges().isEmpty()) \n    {\n      // This is the implicit return node.\n      return true;\n    }\n    if (node.getOutEdges().size() > 1) \n    {\n      // This node has more than one outgoing edge.\n      return false;\n    }\n    DiGraphEdge<Node, ControlFlowGraph.Branch> edge = node.getOutEdges().get(0);\n    if (edge.getValue() != ControlFlowGraph.Branch.ON_TRUE) \n    {\n      // This edge does not go through the true condition.\n      return false;\n    }\n  }\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getNodes()) \n  {\n}\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getDirectedPredecessors(cfg.getImplicitReturn())) \n  {\n    if (!fastAllPathsReturnCheck(node)) \n    {\n      return false;\n    }\n  }\n\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  Set<DiGraphNode<Node, ControlFlowGraph.Branch>> visited = new HashSet<>();\n  Stack<DiGraphNode<Node, ControlFlowGraph.Branch>> stack = new Stack<>();\n  stack.push(cfg.getEntry());\n\n  while (!stack.isEmpty()) {\n    DiGraphNode<Node, ControlFlowGraph.Branch> node = stack.pop();\n    if (visited.contains(node)) {\n      continue;\n    }\n    visited.add(node);\n\n    if (node.getValue().getType() == Token.RETURN) {\n      return true;\n    }\n\n    for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : node.getOutEdges()) {\n      if (edge.getValue().isConditional()) {\n        stack.push(edge.getDestination());\n      }\n    }\n  }\n\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // If there is no implicit return, there are no paths that don't return.\n  if (!cfg.isImplicitReturn(cfg.getImplicitReturn())) {\n    return true;\n  }\n\n  // If there is no entry node, there are no paths that don't return.\n  if (!cfg.isImplicitReturn(cfg.getEntry())) {\n    return true;\n  }\n\n  // If there is a return statement in the entry node, there are no paths that\n  // don't return.\n  if (cfg.getEntry().getChildren().stream().anyMatch(n -> n.isReturn())) {\n    return true;\n  }\n\n  // If there is a return statement in the implicit return node, there are no\n  // paths that don't return.\n  if (cfg.getImplicitReturn().getChildren().stream().anyMatch(n -> n.isReturn())) {\n    return true;\n  }\n\n  // If there is a return statement in the entry node, there are no paths that\n  // don't return.\n  if (cfg.getEntry().getChildren().stream().anyMatch(n -> n.isReturn())) {\n    return true;\n  }\n\n  // If there is a return statement in the implicit return node, there are no\n  // paths that don't return.\n  if (cfg.getImplicitReturn().getChildren().stream().anyMatch(n -> n.isReturn())) {\n    return true;\n  }\n\n  // If there is a return statement in the entry node, there are no paths that\n  // don't return.\n  if (cfg.getEntry().getChildren().stream().anyMatch(n -> n.isReturn())) {\n    return true;\n  }\n\n  // If there is a return statement in the implicit return node, there are no\n  // paths that don't return.\n  if (cfg.getImplicitReturn().getChildren().stream().anyMatch(n -> n.isReturn())) {\n    return true;\n  }\n\n  // If there is a return statement in the entry node, there are no paths that\n  // don't return.\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getNodes()) \n  {\n    if (!node.isEntry() && !node.isImplicitReturn()) \n    {\n      if (!node.getOutEdges().isEmpty()) \n      {\n        boolean hasReturn = false;\n        for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge : node.getOutEdges()) \n        {\n          if (edge.getValue() == ControlFlowGraph.Branch.TRUE_CONDITION) \n          {\n            if (hasReturn) \n            {\n              return false;\n            }\n            hasReturn = fastAllPathsReturnCheck(cfg.getSubGraph(edge.getTarget()));\n          } \n          else \n          {\n            if (!fastAllPathsReturnCheck(cfg.getSubGraph(edge.getTarget()))) \n            {\n              return false;\n            }\n          }\n        }\n        if (!hasReturn) \n        {\n          return false;\n        }\n      } \n      else \n      {\n        return false;\n      }\n    }\n  }\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  boolean allPathsReturn = true;\n  for (DiGraphNode<Node, ControlFlowGraph.Branch> node : cfg.getDirectedGraphNodes()) \n  {\n    if (node.getOutEdges().isEmpty()) \n    {\n      allPathsReturn &= node.getLabel().isReturn();\n    }\n  }\n  return allPathsReturn;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // TODO(user): Implement a fast check.\n  return false;\n}"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    double x[] = new double[2];\n    double y[] = new double[2];\n    double a2[] = new double[2];\n    double a3[] = new double[2];\n    double a4[] = new double[2];\n    double a5[] = new double[2];\n    double a6[] = new double[2];\n    double a7[] = new double[2];\n    double a8[] = new double[2];\n    double a9[] = new double[2];\n    double a10[] = new double[2];\n    double a11[] = new double[2];\n    double a12[] = new double[2];\n    double a13[] = new double[2];\n    double a14[] = new double[2];\n    double a15[] = new double[2];\n    double a16[] = new double[2];\n    double a17[] = new double[2];\n    double a18[] = new double[2];\n    double a19[] = new double[2];\n    double a20[] = new double[2];\n    double a21[] = new double[2];\n    double a22[] = new double[2];\n    double a23[] = new double[2];\n    double a24[] = new double[2];\n    double a25[] = new double[2];\n    double a26[] = new double[2];\n    double a27[] = new double[2];\n    double a28[] = new double[2];\n    double a29[] = new double[2];\n    double a30[] = new double[2];\n    double a31[] = new double[2];\n    double a32[] = new double[2];\n    double a33[] = new double[2];\n    double a34[] = new double[2];\n    double a35[] = new double[2];\n    double a36[] = new double[2];\n    double a37[] = new double[2];\n    double a38[] = new double[2];\n    double a39[] = new double[2];\n    double a40[] = new double[2];\n    double a41[] = new double[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp x[] = new Dfp[2];\n        Dfp y[] = new Dfp[2];\n        Dfp a1[] = new Dfp[2];\n        Dfp a2[] = new Dfp[2];\n        Dfp a3[] = new Dfp[2];\n        Dfp a4[] = new Dfp[2];\n        Dfp a5[] = new Dfp[2];\n        Dfp a6[] = new Dfp[2];\n        Dfp a7[] = new Dfp[2];\n        Dfp a8[] = new Dfp[2];\n        Dfp a9[] = new Dfp[2];\n        Dfp a10[] = new Dfp[2];\n        Dfp a11[] = new Dfp[2];\n        Dfp a12[] = new Dfp[2];\n        Dfp a13[] = new Dfp[2];\n        Dfp a14[] = new Dfp[2];\n        Dfp a15[] = new Dfp[2];\n        Dfp a16[] = new Dfp[2];\n        Dfp a17[] = new Dfp[2];\n        Dfp a18[] = new Dfp[2];\n        Dfp a19[] = new Dfp[2];\n        Dfp a20[] = new Dfp[2];\n        Dfp a21[] = new Dfp[2];\n        Dfp a22[] = new Dfp[2];\n        Dfp a23[] = new Dfp[2];\n        Dfp a24[] = new Dfp[2];\n        Dfp a25[] = new Dfp[2];\n        Dfp a26[] = new Dfp[2];\n        Dfp a27[] = new Dfp[2];\n        Dfp a28[] = new Dfp[2];\n        Dfp a29[] = new Dfp[2];\n        Dfp a30[] = new Dfp[2];\n        Dfp a31[] = new Dfp[2];\n        Dfp a32[] = new Dfp[2];\n        Dfp a33[] = new Dfp[2];\n        Dfp a34[] = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] x = new Dfp[2];\n    Dfp[] y = new Dfp[2];\n\n    /* Set X = (a-1)/(a+1) */\n    splitSubtract(a, new Dfp[]{new Dfp(a[0].getField(), 1), new Dfp(a[1].getField(), 0)}, x);\n    splitReciprocal(x, y);\n    splitAdd(y, new Dfp[]{new Dfp(y[0].getField(), 1), new Dfp(y[1].getField(), 0)}, x);\n\n    /* Square X -> X2*/\n    splitMult(x, x, y);\n\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n    for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n        splitMult(y, x, x);\n        splitAdd(y, LN_SPLIT_COEF[i], x);\n    }\n\n    return y;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    double x[] = new double[2];\n    double y[] = new double[2];\n    double a2[] = new double[2];\n    double b2[] = new double[2];\n    double a3[] = new double[2];\n    double b3[] = new double[2];\n    double a4[] = new double[2];\n    double b4[] = new double[2];\n    double a5[] = new double[2];\n    double b5[] = new double[2];\n    double a6[] = new double[2];\n    double b6[] = new double[2];\n    double a7[] = new double[2];\n    double b7[] = new double[2];\n    double a8[] = new double[2];\n    double b8[] = new double[2];\n    double a9[] = new double[2];\n    double b9[] = new double[2];\n    double a10[] = new double[2];\n    double b10[] = new double[2];\n    double a11[] = new double[2];\n    double b11[] = new double[2];\n    double a12[] = new double[2];\n    double b12[] = new double[2];\n    double a13[] = new double[2];\n    double b13[] = new double[2];\n    double a14[] = new double[2];\n    double b14[] = new double[2];\n    double a15[] = new double[2];\n    double b15[] = new double[2];\n    double a16[] = new double[2];\n    double b16[] = new double[2];\n    double a17[] = new double[2];\n    double b17[] = new double[2];\n    double a18[] = new double[2];\n    double b18[] = new double[2];\n    double a19[] = new double[2];\n    double b19[] = new double[2];\n    double a20[] = new double[2];\n    double b20[] = new double[2];\n    double a21[] = new double[2];\n    double b21[] = new double[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x[] = new Dfp[2];\n    Dfp y[] = new Dfp[2];\n    Dfp z[] = new Dfp[2];\n    Dfp w[] = new Dfp[2];\n    Dfp u[] = new Dfp[2];\n    Dfp v[] = new Dfp[2];\n\n    /* Set X = (a-1)/(a+1) */\n    splitSubtract(a, new Dfp[]{new Dfp(a[0].getField(), 1.0), new Dfp(a[1].getField(), 0.0)}, x);\n    splitReciprocal(x, y);\n    splitAdd(y, new Dfp[]{new Dfp(y[0].getField(), 1.0), new Dfp(y[1].getField(), 0.0)}, z);\n    splitDivide(z, new Dfp[]{new Dfp(z[0].getField(), 2.0), new Dfp(z[1].getField(), 0.0)}, w);\n\n    /* Square W -> U */\n    splitMult(w, w, u);\n\n    /* Compute the series */\n    y[0] = w[0];\n    y[1] = w[1];\n    for (int i = 0; i < LN_SPLIT_COEF.length; i++) {\n        splitMult(y, u, v);\n        y[0] = v[0];\n        y[1] = v[1];\n        splitAdd(y, LN_SPLIT_COEF[i], v);\n        y[0] = v[0];\n        y[1] = v[1];\n    }\n\n    return y;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    double x[] = new double[2];\n    double y[] = new double[2];\n    double a2[] = new double[2];\n    double a3[] = new double[2];\n    double a4[] = new double[2];\n    double a5[] = new double[2];\n    double a6[] = new double[2];\n    double a7[] = new double[2];\n    double a8[] = new double[2];\n    double a9[] = new double[2];\n    double a10[] = new double[2];\n    double a11[] = new double[2];\n    double a12[] = new double[2];\n    double a13[] = new double[2];\n    double a14[] = new double[2];\n    double a15[] = new double[2];\n    double a16[] = new double[2];\n    double a17[] = new double[2];\n    double a18[] = new double[2];\n    double a19[] = new double[2];\n    double a20[] = new double[2];\n    double a21[] = new double[2];\n    double a22[] = new double[2];\n    double a23[] = new double[2];\n    double a24[] = new double[2];\n    double a25[] = new double[2];\n    double a26[] = new double[2];\n    double a27[] = new double[2];\n    double a28[] = new double[2];\n    double a29[] = new double[2];\n    double a30[] = new double[2];\n    double a31[] = new double[2];\n    double a32[] = new double[2];\n    double a33[] = new double[2];\n    double a34[] = new double[2];\n    double a35[] = new double[2];\n    double a36[] = new double[2];\n    double a37[] = new double[2];\n    double a38[] = new double[2];\n    double a39[] = new double[2];\n    double a40[] = new double[2];\n    double a41[] = new double[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        double x[] = new double[2];\n        double y[] = new double[2];\n        double a2[] = new double[2];\n        double a3[] = new double[2];\n        double a4[] = new double[2];\n        double a5[] = new double[2];\n        double a6[] = new double[2];\n        double a7[] = new double[2];\n        double a8[] = new double[2];\n        double a9[] = new double[2];\n        double a10[] = new double[2];\n        double a11[] = new double[2];\n        double a12[] = new double[2];\n        double a13[] = new double[2];\n        double a14[] = new double[2];\n        double a15[] = new double[2];\n        double a16[] = new double[2];\n        double a17[] = new double[2];\n        double a18[] = new double[2];\n        double a19[] = new double[2];\n        double a20[] = new double[2];\n        double a21[] = new double[2];\n        double a22[] = new double[2];\n        double a23[] = new double[2];\n        double a24[] = new double[2];\n        double a25[] = new double[2];\n        double a26[] = new double[2];\n        double a27[] = new double[2];\n        double a28[] = new double[2];\n        double a29[] = new double[2];\n        double a30[] = new double[2];\n        double a31[] = new double[2];\n        double a32[] = new double[2];\n        double a33[] = new double[2];\n        double a34[] = new double[2];\n        double a35[] = new double[2];\n        double a36[] = new double[2];\n        double a37[] = new double[2];\n        double a38[] = new double[2];\n        double a39[] = new double[2];\n        double a40[] = new double[2];\n        double a41[] = new double[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp x[] = new Dfp[2];\n        Dfp y[] = new Dfp[2];\n        Dfp a0[] = new Dfp[2];\n        Dfp a1[] = new Dfp[2];\n        Dfp a2[] = new Dfp[2];\n        Dfp a3[] = new Dfp[2];\n        Dfp a4[] = new Dfp[2];\n        Dfp a5[] = new Dfp[2];\n        Dfp a6[] = new Dfp[2];\n        Dfp a7[] = new Dfp[2];\n        Dfp a8[] = new Dfp[2];\n        Dfp a9[] = new Dfp[2];\n        Dfp a10[] = new Dfp[2];\n        Dfp a11[] = new Dfp[2];\n        Dfp a12[] = new Dfp[2];\n        Dfp a13[] = new Dfp[2];\n        Dfp a14[] = new Dfp[2];\n        Dfp a15[] = new Dfp[2];\n        Dfp a16[] = new Dfp[2];\n        Dfp a17[] = new Dfp[2];\n        Dfp a18[] = new Dfp[2];\n        Dfp a19[] = new Dfp[2];\n        Dfp a20[] = new Dfp[2];\n        Dfp a21[] = new Dfp[2];\n        Dfp a22[] = new Dfp[2];\n        Dfp a23[] = new Dfp[2];\n        Dfp a24[] = new Dfp[2];\n        Dfp a25[] = new Dfp[2];\n        Dfp a26[] = new Dfp[2];\n        Dfp a27[] = new Dfp[2];\n        Dfp a28[] = new Dfp[2];\n        Dfp a29[] = new Dfp[2];\n        Dfp a30[] = new Dfp[2];\n        Dfp a31[] = new Dfp[2];\n        Dfp a32[] = new Dfp[2];\n        Dfp a33[] = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp[] x = new Dfp[2];\n        Dfp[] y = new Dfp[2];\n        Dfp[] z = new Dfp[2];\n        Dfp[] w = new Dfp[2];\n\n        /* Set X = (a-1)/(a+1) */\n        splitSubtract(a, 1, x);\n        splitAdd(a, 1, w);\n        splitReciprocal(w, z);\n        splitMult(x, z, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, y);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x, z);\n            y[0] = z[0];\n            y[1] = z[1];\n            splitAdd(y, LN_SPLIT_COEF[i], z);\n            y[0] = z[0];\n            y[1] = z[1];\n        }\n\n        splitMult(y, x, z);\n        y[0] = z[0];\n        y[1] = z[1];\n\n        return y;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp[] x = new Dfp[2];\n        Dfp[] y = new Dfp[2];\n        Dfp[] z = new Dfp[2];\n\n        /* Set X = (a-1)/(a+1) */\n        splitSubtract(a, DfpMath.ONE, x);\n        splitReciprocal(x, z);\n        splitAdd(z, DfpMath.ONE, x);\n        resplit(x);\n\n        /* Square X -> X2*/\n        splitMult(x, x, z);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, z, x);\n            y[0] = x[0];\n            y[1] = x[1];\n            splitAdd(y, LN_SPLIT_COEF[i], x);\n            y[0] = x[0];\n            y[1] = x[1];\n        }\n\n        splitMult(y, x, z);\n        y[0] = z[0];\n        y[1] = z[1];\n\n        return y;\n    }"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"Key or value cannot be null\");\n        }\n\n        Collection<V> values = getCollection(key);\n        if (values == null) {\n            return false;\n        }\n\n        return values.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"Key and value cannot be null\");\n        }\n        Collection<V> collection = getCollection(key);\n        if (collection == null) {\n            return false;\n        }\n        return collection.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) \n        {\n            throw new NullPointerException(\"Key or value cannot be null\");\n        }\n        \n        final Collection<V> collection = getCollection(key);\n        if (collection == null) \n        {\n            return false;\n        }\n        \n        return collection.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        // Your implementation goes here\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"Key or value cannot be null\");\n        }\n        Collection<V> values = getCollection(key);\n        if (values == null) {\n            return false;\n        }\n        return values.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) \n        {\n            throw new NullPointerException(\"Key and value must not be null\");\n        }\n\n        final Collection<V> collection = getCollection(key);\n        if (collection == null) \n        {\n            return false;\n        }\n\n        final boolean removed = collection.remove(value);\n        if (removed && collection.isEmpty()) \n        {\n            decorated().remove(key);\n        }\n\n        return removed;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) \n        {\n            throw new NullPointerException(\"Key and value must not be null\");\n        }\n        \n        Collection<V> values = getCollection(key);\n        if (values != null) \n        {\n            return values.remove(value);\n        }\n        \n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        // TODO: Implement this method\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"Key and value cannot be null\");\n        }\n        if (!containsKey(key)) {\n            return false;\n        }\n        Collection<V> values = getCollection(key);\n        return values.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"Key or value cannot be null\");\n        }\n\n        Collection<V> values = getCollection(key);\n        if (values == null) {\n            return false;\n        }\n\n        return values.remove(value);\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) {\n        Node newNode = newNode(Token.STRING);\n        newNode.setString(((Name) n).getIdentifier());\n        newNode.setSourcePosition(n.getSourcePosition());\n        return newNode;\n    } else if (n.getType() == Token.STRING) {\n        return n;\n    } else {\n        return transform(n);\n    }\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) \n    {\n        n = newString(n.getString());\n    }\n    if (n.getType() == Token.STRING) \n    {\n        n = newString(n.getString());\n    }\n    return n;\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) \n    {\n        n = newNode(Token.STRING, n.getString());\n        n.setSourceEncodedPosition(n.getSourceEncodedPosition());\n    }\n    return transform(n);\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) {\n        n.setType(Token.STRING);\n        n.setString(n.getString());\n    }\n    return transform(n);\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) {\n        return newString(n.getString());\n    } else if (n.getType() == Token.STRING) {\n        return transformStringLiteral((StringLiteral) n);\n    } else {\n        throw new IllegalStateException(\"Unexpected type: \" + n.getType());\n    }\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node = newString(node.getString());\n    } else if (node.getType() == Token.STRING) {\n        node.setQuotedString();\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node = newString(node.getString());\n    } else if (node.getType() != Token.STRING) {\n        errorReporter.error(\n            \"invalid assignment target\",\n            sourceName,\n            node.getLineno(), \"\", 0);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) {\n        Node name = (Node) n;\n        n = newString(name.getString());\n        n.setSourceEncodedPosition(name.getSourceEncodedPosition());\n    }\n    if (n.getType() == Token.STRING) {\n        Node string = (Node) n;\n        n = newString(\"\\\"\" + string.getString() + \"\\\"\");\n        n.setSourceEncodedPosition(string.getSourceEncodedPosition());\n    }\n    return n;\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) \n    {\n        n.setType(Token.STRING);\n        n.setString(n.getString());\n    }\n    else if (n.getType() == Token.STRING) \n    {\n        n.setString(\"\\\"\" + n.getString() + \"\\\"\");\n    }\n    return n;\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) \n    {\n        String name = n.getString();\n        n = newString(name);\n        n.setQuotedString();\n    }\n    return n;\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    List result = new ArrayList();\n    for (int row : includedRows) {\n        double value = dataset.getValue(row, category).doubleValue();\n        if (asPercentages) {\n            value = value / total;\n        }\n        result.add(new Double(value + base));\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int i : includedRows) {\n        Number n = dataset.getValue(i, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            v += base;\n            values.add(new Double(v));\n        }\n        else {\n            values.add(null);\n        }\n    }\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        double v = dataset.getValue(includedRows[i], category).doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        result.add(new Double(v + base));\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    List result = new ArrayList();\n    for (int row : includedRows) {\n        Number n = dataset.getValue(row, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            v += base;\n            result.add(new Double(v));\n        }\n        else {\n            result.add(null);\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int row : includedRows) {\n        Number n = dataset.getValue(row, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            result.add(new Double(v + base));\n        }\n        else {\n            result.add(new Double(base));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int row : includedRows) {\n        Number n = dataset.getValue(row, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            v += base;\n            result.add(new Double(v));\n        }\n        else {\n            result.add(new Double(base));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int row : includedRows) {\n        Number n = dataset.getValue(row, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            v += base;\n            values.add(new Double(v));\n        }\n        else {\n            values.add(new Double(base));\n        }\n    }\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        double value = dataset.getValue(includedRows[i], category).doubleValue();\n        if (asPercentages) {\n            value = value / total;\n        }\n        result.add(new Double(value + base));\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        double v = dataset.getValue(includedRows[i], category).doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        result.add(new Double(v + base));\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int row : includedRows) {\n        Number n = dataset.getValue(row, category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            v += base;\n            values.add(new Double(v));\n        }\n    }\n    return values;\n}"
    ],
    [
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null) \n    {\n        List<Element> shadowChildren = new ArrayList<>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element) \n            {\n                shadowChildren.add((Element) node);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(shadowChildren);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null) \n    {\n        List<Element> shadowChildren = new ArrayList<>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element) \n            {\n                shadowChildren.add((Element) node);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(shadowChildren);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n        List<Element> children = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                children.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(children);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n        List<Element> shadowChildren = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                shadowChildren.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(shadowChildren);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null) \n    {\n        List<Element> shadowChildren = new ArrayList<>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element) \n            {\n                shadowChildren.add((Element) node);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(shadowChildren);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n        List<Element> children = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                children.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(children);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null) \n    {\n        List<Element> elements = new ArrayList<>();\n        for (Node node : childNodes) \n        {\n            if (node instanceof Element) \n            {\n                elements.add((Element) node);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(elements);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n        List<Element> elements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(elements);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n        List<Element> children = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                children.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(children);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n        List<Element> elements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(elements);\n    }\n    return shadowChildrenRef.get();\n}"
    ],
    [
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return Math.abs(hash % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode() & 0x7fffffff;\n    return hash % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode() % buckets.length;\n\n    if (hash < 0) {\n        hash = -hash;\n    }\n\n    return hash;\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash ^= hash >>> 16;\n    hash ^= hash >>> 8;\n    hash ^= hash >>> 4;\n    hash ^= hash >>> 2;\n    hash ^= hash >>> 1;\n    return Math.abs(hash) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode() % buckets.length;\n\n    if (hash < 0) {\n        hash = -hash;\n    }\n\n    return hash;\n}"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r >= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r >= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    double threshold = epsilon * norm;\n    while (im < matrixT.length - 1) \n    {\n        double diag = matrixT[im][im];\n        double offDiag = matrixT[im + 1][im];\n        double absOffDiag = FastMath.abs(offDiag);\n\n        if (absOffDiag <= threshold) \n        {\n            break;\n        }\n\n        double ratio = offDiag / diag;\n        double absRatio = FastMath.abs(ratio);\n        if (absRatio < 1.0) \n        {\n            double angle = 0.5 * ratio * ratio * (diag - matrixT[im + 2][im + 2]);\n            if (angle < absOffDiag) \n            {\n                break;\n            }\n        }\n\n        im++;\n    }\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    double threshold = epsilon * norm;\n    while (idx < matrixT.length - 1) \n    {\n        double z = matrixT[idx][idx];\n        double r = matrixT[idx][idx + 1];\n        double s = matrixT[idx + 1][idx + 1];\n        double h = Math.abs(r) + Math.abs(s);\n        if (h == 0.0) \n        {\n            idx++;\n            continue;\n        }\n        double lhs = Math.abs(z) * (Math.abs(r) + Math.abs(s));\n        double rhs = threshold * h;\n        if (lhs < rhs) \n        {\n            break;\n        }\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    double threshold = epsilon * norm;\n    while (im < matrixT.length - 1) {\n        double hVec = matrixT[im][im + 1];\n        if (FastMath.abs(hVec) <= threshold) {\n            break;\n        }\n        im++;\n    }\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    double eps = epsilon * norm;\n    while (idx >= 0 && FastMath.abs(matrixT[idx][idx - 1]) > eps) {\n        idx--;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    double threshold = epsilon * norm;\n    while (im < matrixT.length - 1) \n    {\n        double z = matrixT[im][im];\n        double r = matrixT[im + 1][im] * matrixT[im + 1][im] + matrixT[im + 1][im + 1] * matrixT[im + 1][im + 1];\n        if (r < threshold) \n        {\n            break;\n        }\n        im++;\n    }\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    double threshold = epsilon * norm;\n    while (idx >= 0) {\n        final double diag = matrixT[idx][idx];\n        final double subDiag = matrixT[idx][idx - 1];\n        if (FastMath.abs(subDiag) > threshold) {\n            // The sub-diagonal element is not small enough, continue the search\n            idx--;\n        } else {\n            // The sub-diagonal element is small enough, return its index\n            return idx;\n        }\n    }\n    // No small sub-diagonal element found, return the starting index\n    return startIdx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    double eps = epsilon * norm;\n    while (im < matrixT.length - 1) \n    {\n        double z = matrixT[im][im];\n        double r = matrixT[im + 1][im + 1] - z;\n        double s = matrixT[im + 1][im] * matrixT[im][im + 1];\n        double lhs = FastMath.abs(matrixT[im][im + 1]) * (FastMath.abs(r) + FastMath.abs(s));\n        double rhs = FastMath.abs(s) * (FastMath.abs(matrixT[im - 1][im - 1]) +\n                                        FastMath.abs(z) +\n                                        FastMath.abs(matrixT[im + 2][im + 2]));\n\n        if (lhs < eps * rhs) \n        {\n            break;\n        }\n        im++;\n    }\n\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    double eps = epsilon * norm;\n    while (idx < matrixT.length - 1) \n    {\n        double h = FastMath.abs(matrixT[idx][idx]) + FastMath.abs(matrixT[idx + 1][idx + 1]);\n        if (FastMath.abs(matrixT[idx][idx + 1]) < eps * h) \n        {\n            break;\n        }\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    double threshold = epsilon * norm;\n    while (idx >= 0 && matrixT[idx][idx - 1] > threshold) \n    {\n        idx--;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    double eps = epsilon * norm;\n    while (idx >= 0 && FastMath.abs(matrixT[idx][idx - 1]) > eps) {\n        idx--;\n    }\n    return idx;\n}"
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) >= 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) >= 0) \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) >= 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) >= 0) \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  if (irNode.getType() == com.google.javascript.rhino.head.Token.NAME) \n  {\n    JSDocInfo jsDocInfo = handleInlineJsDoc(node);\n    if (jsDocInfo != null) \n    {\n      irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n  }\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  if (node instanceof Name) \n  {\n    Name name = (Name) node;\n    if (name.getParent().getType() == com.google.javascript.rhino.head.Token.PARAM_LIST) \n    {\n      JSDocInfo info = name.getJSDocInfo();\n      if (info != null && info.hasType()) \n      {\n        return transformNameAsString(name);\n      }\n    }\n  }\n  return transform(node);\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) \n  {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) \n  {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  if (node instanceof Name) \n  {\n    Name name = (Name) node;\n    if (name.getParent().getType() == com.google.javascript.rhino.head.Token.PARAM_LIST) \n    {\n      JSDocInfo info = name.getJSDocInfo();\n      if (info != null) \n      {\n        // inline type docs attached to parameters are valid, if at the root of an expression.\n        boolean valid = isExprStmt(name.getParent().getParent());\n        if (!valid) \n        {\n          errorReporter.warning(MISPLACED_TYPE_ANNOTATION,\n              sourceName,\n              name.getLineno(), \"\", 0);\n        }\n      }\n    }\n  }\n  return transform(node);\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) \n  {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n\n    do \n    {\n      Node expr = parseTypeExpression(token);\n\n      if (expr == null) \n      {\n        return null;\n      }\n\n      arrayType.addChildToBack(expr);\n\n      skipEOLs();\n      if (!match(JsDocToken.COMMA)) \n      {\n        break;\n      }\n\n      // Move to the comma token.\n      next();\n\n      // Move to the token passed the comma.\n      skipEOLs();\n      token = next();\n    } while (true);\n\n    if (!match(JsDocToken.RB)) \n    {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n\n    next();\n\n    return arrayType;\n  }\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n  Node elementTypeList = parseElementTypeList(token);\n\n  if (elementTypeList == null) \n  {\n    return reportGenericTypeSyntaxWarning();\n  }\n\n  arrayType.addChildToBack(elementTypeList);\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n\n    if (elementTypeList == null) \n    {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n\n    if (elementTypeList == null) \n    {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n\n    if (elementTypeList == null) \n    {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n\n    do \n    {\n      Node expr = parseTypeExpression(token);\n\n      if (expr == null) \n      {\n        return null;\n      }\n\n      arrayType.addChildToBack(expr);\n\n      skipEOLs();\n      if (!match(JsDocToken.COMMA)) \n      {\n        break;\n      }\n\n      // Move to the comma token.\n      next();\n\n      // Move to the token passed the comma.\n      skipEOLs();\n      token = next();\n    } while (true);\n\n    if (!match(JsDocToken.RB)) \n    {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n\n    next();\n\n    return arrayType;\n  }\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n\n  do {\n    Node elementType = parseTypeExpression(token);\n\n    if (elementType == null) {\n      return null;\n    }\n\n    arrayType.addChildToBack(elementType);\n\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n      break;\n    }\n\n    // Move to the comma token.\n    next();\n\n    // Move to the token passed the comma.\n    skipEOLs();\n    token = next();\n  } while (true);\n\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n\n  next();\n\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n\n    if (elementTypeList == null) \n    {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    arrayType.addChildToBack(elementTypeList);\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n\n  do \n  {\n    Node elementType = parseTypeExpression(token);\n\n    if (elementType == null) \n    {\n      return null;\n    }\n\n    arrayType.addChildToBack(elementType);\n\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) \n    {\n      break;\n    }\n\n    // Move to the comma token.\n    next();\n\n    // Move to the token passed the comma.\n    skipEOLs();\n    token = next();\n  } while (true);\n\n  if (!match(JsDocToken.RB)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n\n  next();\n\n  arrayType.addChildToBack(elementType);\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.LB);\n\n  if (token != JsDocToken.RB) \n  {\n    do \n    {\n      if (match(JsDocToken.ELLIPSIS)) \n      {\n        next();\n        arrayType.addChildToBack(newNode(Token.ELLIPSIS));\n      } \n      else \n      {\n        Node expr = parseTypeExpression(token);\n        if (expr == null) \n        {\n          return null;\n        }\n        arrayType.addChildToBack(expr);\n      }\n\n      skipEOLs();\n      if (!match(JsDocToken.COMMA)) \n      {\n        break;\n      }\n\n      // Move to the comma token.\n      next();\n\n      // Move to the token passed the comma.\n      skipEOLs();\n      token = next();\n    } while (true);\n  }\n\n  if (!match(JsDocToken.RB)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n\n  next();\n\n  return arrayType;\n}"
    ],
    [
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) \n    {\n        return new Vector3D(1, 0, 0);\n    } \n    else \n    {\n        return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n    }\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) \n    {\n        return new Vector3D(1, 0, 0);\n    } \n    else \n    {\n        return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n    }\n}",
      "public Vector3D getAxis()  {\n    return axis;\n}",
      "public Vector3D getAxis()  {\n    return axis;\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) \n    {\n        return new Vector3D(1, 0, 0);\n    } \n    else \n    {\n        return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n    }\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) \n    {\n        return new Vector3D(1, 0, 0);\n    } \n    else \n    {\n        return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n    }\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) \n    {\n        return new Vector3D(1, 0, 0);\n    } \n    else \n    {\n        return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n    }\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) \n    {\n        return new Vector3D(1, 0, 0);\n    } \n    else \n    {\n        return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n    }\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) \n    {\n        return new Vector3D(1, 0, 0);\n    } \n    else \n    {\n        return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n    }\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) \n    {\n        return new Vector3D(1, 0, 0);\n    } \n    else \n    {\n        return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n    }\n}"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        final int b = bytes[i];\n        if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else if (b == '%') \n        {\n            if (i + 2 >= bytes.length) \n            {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n            final int u = Character.digit((char)bytes[i + 1], 16);\n            final int l = Character.digit((char)bytes[i + 2], 16);\n            if (u == -1 || l == -1) \n            {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n            buffer.write((char)((u << 4) + l));\n            i += 2;\n        } \n        else \n        {\n            buffer.write(b);\n        }\n        i++;\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        final int b = bytes[i];\n        if (b == '+') \n        {\n            buffer.write(' ');\n            i++;\n        } \n        else if (b == '%') \n        {\n            if (i + 2 >= bytes.length) \n            {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n            final int u = Character.digit((char)bytes[i + 1], 16);\n            final int l = Character.digit((char)bytes[i + 2], 16);\n            if (u == -1 || l == -1) \n            {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n            buffer.write((char)(u << 4 | l));\n            i += 3;\n        } \n        else \n        {\n            buffer.write(b);\n            i++;\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        final int b = bytes[i];\n        if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else if (b == '%') \n        {\n            if (i + 2 >= bytes.length) \n            {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n            final int u = Character.digit((char)bytes[i + 1], 16);\n            final int l = Character.digit((char)bytes[i + 2], 16);\n            if (u == -1 || l == -1) \n            {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n            buffer.write((u << 4) + l);\n            i += 2;\n        } \n        else \n        {\n            buffer.write(b);\n        }\n        i++;\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        final int b = bytes[i++];\n        if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else if (b == '%') \n        {\n            if (i + 2 > bytes.length) \n            {\n                throw new DecoderException(\"Invalid encoded sequence\");\n            }\n            final int u = Character.digit((char)bytes[i++], 16);\n            final int l = Character.digit((char)bytes[i++], 16);\n            if (u == -1 || l == -1) \n            {\n                throw new DecoderException(\"Invalid encoded sequence\");\n            }\n            buffer.write((char)((u << 4) + l));\n        } \n        else \n        {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        final int b = bytes[i++];\n        if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else if (b == '%') \n        {\n            try \n            {\n                final int u = Character.digit((char)bytes[i++], 16);\n                final int l = Character.digit((char)bytes[i++], 16);\n                if (u == -1 || l == -1) \n                {\n                    throw new DecoderException(\"Invalid URL encoding: \" + new String(bytes));\n                }\n                buffer.write((char)((u << 4) + l));\n            } \n            catch (final IndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding: \" + new String(bytes), e);\n            }\n        } \n        else \n        {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        final int b = bytes[i];\n        if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else if (b == '%') \n        {\n            if (i + 2 >= bytes.length) \n            {\n                throw new DecoderException(\"Invalid encoding\");\n            }\n            final int u = Character.digit((char)bytes[i + 1], 16);\n            final int l = Character.digit((char)bytes[i + 2], 16);\n            if (u == -1 || l == -1) \n            {\n                throw new DecoderException(\"Invalid encoding\");\n            }\n            buffer.write((char)(u << 4 | l));\n            i += 2;\n        } \n        else \n        {\n            buffer.write(b);\n        }\n        i++;\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        final int b = bytes[i++];\n        if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else if (b == '%') \n        {\n            try \n            {\n                final int u = Character.digit((char)bytes[i++], 16);\n                final int l = Character.digit((char)bytes[i++], 16);\n                if (u == -1 || l == -1) \n                {\n                    throw new DecoderException(\"Invalid URL encoding: \" + new String(bytes));\n                }\n                buffer.write((char)((u << 4) + l));\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding: \" + new String(bytes));\n            }\n        } \n        else \n        {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        final int b = bytes[i];\n        if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else if (b == '%') \n        {\n            if (i + 2 >= bytes.length) \n            {\n                throw new DecoderException(\"Invalid encoding\");\n            }\n            final int u = Character.digit((char)bytes[i + 1], 16);\n            final int l = Character.digit((char)bytes[i + 2], 16);\n            if (u == -1 || l == -1) \n            {\n                throw new DecoderException(\"Invalid encoding\");\n            }\n            buffer.write((char)((u << 4) + l));\n            i += 2;\n        } \n        else \n        {\n            buffer.write(b);\n        }\n        i++;\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        final int b = bytes[i];\n        if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else if (b == '%') \n        {\n            if (i + 2 >= bytes.length) \n            {\n                throw new DecoderException(\"Invalid encoded byte sequence\");\n            }\n            final int u = Character.digit((char)bytes[i + 1], 16);\n            final int l = Character.digit((char)bytes[i + 2], 16);\n            if (u == -1 || l == -1) \n            {\n                throw new DecoderException(\"Invalid encoded byte sequence\");\n            }\n            buffer.write((char)((u << 4) + l));\n            i += 2;\n        } \n        else \n        {\n            buffer.write(b);\n        }\n        i++;\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int i = 0;\n    while (i < bytes.length) \n    {\n        final int b = bytes[i++];\n        if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else if (b == '%') \n        {\n            if (i + 2 > bytes.length) \n            {\n                throw new DecoderException(\"Invalid encoded string\");\n            }\n            final int u = Character.digit((char)bytes[i++], 16);\n            final int l = Character.digit((char)bytes[i++], 16);\n            if (u == -1 || l == -1) \n            {\n                throw new DecoderException(\"Invalid encoded string\");\n            }\n            buffer.write((char)((u << 4) + l));\n        } \n        else \n        {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) {\n        DateTimeFieldType fieldType = partial.getFieldType(i);\n        DateTimeField field = partial.getField(i);\n        DateTimeFieldType nextFieldType = partial.getFieldType(i + 1);\n        DateTimeField nextField = partial.getField(i + 1);\n        if (field.getRangeDurationField() != nextField.getRangeDurationField()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) {\n        DateTimeFieldType fieldType = partial.getFieldType(i);\n        DateTimeField field = partial.getField(i);\n        DateTimeFieldType nextFieldType = partial.getFieldType(i + 1);\n        DateTimeField nextField = partial.getField(i + 1);\n        if (field.getRangeDurationField() != nextField.getRangeDurationField()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    DateTimeFieldType[] fieldTypes = partial.getFieldTypes();\n    int size = fieldTypes.length;\n    for (int i = 0; i < size - 1; i++) {\n        DateTimeFieldType fieldType = fieldTypes[i];\n        DateTimeField field = partial.getField(i);\n        DateTimeFieldType nextFieldType = fieldTypes[i + 1];\n        DateTimeField nextField = partial.getField(i + 1);\n        if (!field.getRangeDurationField().equals(nextField.getDurationField())) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    DateTimeField[] fields = partial.getFields();\n    for (int i = 0; i < fields.length - 1; i++) {\n        DateTimeFieldType fieldType = fields[i].getType();\n        DateTimeFieldType nextFieldType = fields[i + 1].getType();\n        if (!fieldType.getRangeDurationField().equals(nextFieldType.getDurationField())) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    DateTimeFieldType[] types = partial.getFieldTypes();\n    for (int i = 0; i < types.length - 1; i++) {\n        DateTimeFieldType type1 = types[i];\n        DateTimeFieldType type2 = types[i + 1];\n        if (type1.getRangeDurationField() != type2.getDurationField()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    DateTimeFieldType[] types = partial.getFieldTypes();\n    int size = types.length;\n    for (int i = 0; i < size - 1; i++) {\n        if (types[i].getRangeDurationField() != types[i + 1].getDurationField()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) {\n        DateTimeFieldType fieldType = partial.getFieldType(i);\n        DateTimeField field = partial.getField(i);\n        DateTimeFieldType nextFieldType = partial.getFieldType(i + 1);\n        DateTimeField nextField = partial.getField(i + 1);\n        if (!field.getRangeDurationField().equals(nextField.getDurationField())) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    DateTimeFieldType[] fieldTypes = partial.getFieldTypes();\n    for (int i = 0; i < fieldTypes.length - 1; i++) {\n        DateTimeField field = partial.getField(i);\n        DateTimeField nextField = partial.getField(i + 1);\n        if (field.getRangeDurationField() != nextField.getDurationField()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    DateTimeFieldType[] types = partial.getFieldTypes();\n    int size = types.length;\n    for (int i = 0; i < size - 1; i++) {\n        if (types[i].getRangeDurationField() != types[i + 1].getDurationField()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeFieldType fieldType = partial.getFieldType(size - 1);\n    DateTimeField field = partial.getField(size - 1);\n    DateTimeFieldType nextFieldType = partial.getFieldType(size - 2);\n    DateTimeField nextField = partial.getField(size - 2);\n    return fieldType.getRangeDurationField().equals(nextField.getDurationField());\n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final ArrayList<O> list = new ArrayList<O>();\n    final HashBag<O> bag = new HashBag<O>();\n    for (final O element : b) {\n        bag.add(element);\n    }\n    for (final O element : a) {\n        bag.add(element);\n    }\n    list.addAll(bag);\n    return list;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final ArrayList<O> list = new ArrayList<O>();\n    final HashBag<O> bag = new HashBag<O>();\n    for (final O element : b) {\n        bag.add(element);\n    }\n    for (final O element : a) {\n        bag.add(element);\n    }\n    list.addAll(bag);\n    return list;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final ArrayList<O> list = new ArrayList<O>();\n    final HashBag<O> bag = new HashBag<O>();\n    for (final O element : b) {\n        bag.add(element);\n    }\n    for (final O element : a) {\n        bag.add(element);\n    }\n    list.addAll(bag);\n    return list;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final ArrayList<O> list = new ArrayList<O>();\n    final HashBag<O> bag = new HashBag<O>();\n    for (final O element : a) {\n        bag.add(element);\n    }\n    for (final O element : b) {\n        bag.add(element);\n    }\n    for (final O element : bag) {\n        list.add(element);\n    }\n    return list;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final ArrayList<O> list = new ArrayList<O>();\n    final HashBag<O> bag = new HashBag<O>();\n    for (final O element : a) {\n        bag.add(element);\n    }\n    for (final O element : b) {\n        bag.add(element);\n    }\n    list.addAll(bag);\n    return list;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final ArrayList<O> list = new ArrayList<O>();\n    final HashBag<O> bag = new HashBag<O>();\n    for (final O element : a) {\n        bag.add(element);\n    }\n    for (final O element : b) {\n        bag.add(element);\n    }\n    for (final O element : bag) {\n        list.add(element);\n    }\n    return list;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final ArrayList<O> list = new ArrayList<O>();\n    final HashBag<O> bag = new HashBag<O>();\n    for (final O element : a) {\n        bag.add(element);\n    }\n    for (final O element : b) {\n        bag.add(element);\n    }\n    list.addAll(bag);\n    return list;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final ArrayList<O> list = new ArrayList<O>();\n    final HashBag<O> bag = new HashBag<O>();\n    for (final O element : a) {\n        bag.add(element);\n    }\n    for (final O element : b) {\n        bag.add(element);\n    }\n    for (final O element : bag) {\n        list.add(element);\n    }\n    return list;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final ArrayList<O> list = new ArrayList<O>();\n    final HashBag<O> bag = new HashBag<O>();\n    for (final O element : b) {\n        bag.add(element);\n    }\n    for (final O element : a) {\n        bag.add(element);\n    }\n    list.addAll(bag);\n    return list;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final ArrayList<O> list = new ArrayList<O>();\n    final HashBag<O> bag = new HashBag<O>();\n    for (final O element : b) {\n        bag.add(element);\n    }\n    for (final O element : a) {\n        bag.add(element);\n    }\n    for (final O element : bag) {\n        list.add(element);\n    }\n    return list;\n}"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = Lists.newArrayList();\n  for (Node param : params.children()) \n  {\n    result.add(Node.newString(param.getString()));\n  }\n  return result;\n}\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = Lists.newArrayList();\n  for (Node param : params.children()) {\n    strings.add(Node.newString(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = Lists.newArrayList();\n  for (Node param : params.children()) {\n    strings.add(Node.newString(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = new ArrayList<Node>();\n  Node param = params.getFirstChild();\n  while (param != null) \n  {\n    result.add(Node.newString(param.getString()));\n    param = param.getNext();\n  }\n  return result;\n}\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = Lists.newArrayList();\n  for (Node param : params.children()) {\n    result.add(Node.newString(param.getString()));\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<Node>();\n  for (Node param = params.getFirstChild(); param != null; \n      param = param.getNext()) \n  {\n    strings.add(Node.newString(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = new ArrayList<Node>();\n  Node param = params.getFirstChild();\n  while (param != null) {\n    result.add(Node.newString(param.getString()));\n    param = param.getNext();\n  }\n  return result;\n}\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = Lists.newArrayList();\n  for (Node param : params.children()) {\n    strings.add(Node.newString(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = Lists.newArrayList();\n  for (Node param : params.children()) {\n    strings.add(Node.newString(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = Lists.newArrayList();\n  for (Node param : params.children()) {\n    strings.add(Node.newString(param.getString()));\n  }\n  return strings;\n}\n}"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = strLen; i < width; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size);\n        }\n        size += width;\n    }\n    return this;\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.trim();\n    if (str.isEmpty()) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n    str = str.toLowerCase();\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) \n    {\n        return null;\n    }\n    str = str.toLowerCase();\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    str = str.toLowerCase();\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null) \n    {\n        return null;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } \n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"ACT\", \"Australia/Sydney\");\n        cZoneIdConversion.put(\"ACST\", \"Australia/Adelaide\");\n        cZoneIdConversion.put(\"ACWST\", \"Australia/Darwin\");\n        cZoneIdConversion.put(\"ADT\", \"Canada/Atlantic\");\n        cZoneIdConversion.put(\"AEDT\", \"Australia/Melbourne\");\n        cZoneIdConversion.put(\"AEST\", \"Australia/Brisbane\");\n        cZoneIdConversion.put(\"Afghanistan\", \"Asia/Kabul\");\n        cZoneIdConversion.put(\"Africa/Abidjan\", \"Africa/Abidjan\");\n        cZoneIdConversion.put(\"Africa/Accra\", \"Africa/Accra\");\n        cZoneIdConversion.put(\"Africa/Addis_Ababa\", \"Africa/Addis_Ababa\");\n        cZoneIdConversion.put(\"Africa/Algiers\", \"Africa/Algiers\");\n        cZoneIdConversion.put(\"Africa/Asmara\", \"Africa/Asmara\");\n        cZoneIdConversion.put(\"Africa/Bamako\", \"Africa/Bamako\");\n        cZoneIdConversion.put(\"Africa/Bangui\", \"Africa/Bangui\");\n        cZoneIdConversion.put(\"Africa/Banjul\", \"Africa/Banjul\");\n        cZoneIdConversion.put(\"Africa/Bissau\", \"Africa/Bissau\");\n        cZoneIdConversion.put(\"Africa/Blantyre\", \"Africa/Blantyre\");\n        cZoneIdConversion.put(\"Africa/Brazzaville\", \"Africa/Brazzaville\");\n        cZoneIdConversion.put(\"Africa/Bujumbura\", \"Africa/Bujumbura\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"EST\", \"America/New_York\");\n        cZoneIdConversion.put(\"EDT\", \"America/New_York\");\n        cZoneIdConversion.put(\"CST\", \"America/Chicago\");\n        cZoneIdConversion.put(\"CDT\", \"America/Chicago\");\n        cZoneIdConversion.put(\"MST\", \"America/Denver\");\n        cZoneIdConversion.put(\"MDT\", \"America/Denver\");\n        cZoneIdConversion.put(\"PST\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"PDT\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"AST\", \"Canada/Atlantic\");\n        cZoneIdConversion.put(\"NST\", \"Canada/Newfoundland\");\n        cZoneIdConversion.put(\"HST\", \"Pacific/Honolulu\");\n        cZoneIdConversion.put(\"CAT\", \"Africa/Harare\");\n        cZoneIdConversion.put(\"ECT\", \"Europe/Paris\");\n        cZoneIdConversion.put(\"MEZ\", \"Europe/Berlin\");\n        cZoneIdConversion.put(\"MESZ\", \"Europe/Berlin\");\n        cZoneIdConversion.put(\"CET\", \"Europe/Berlin\");\n        cZoneIdConversion.put(\"CEST\", \"Europe/Berlin\");\n        cZoneIdConversion.put(\"WEST\", \"Europe/Lisbon\");\n        cZoneIdConversion.put(\"WESZ\", \"Europe/Lisbon\");\n        cZoneIdConversion.put(\"EET\", \"Europe/Athens\");\n        cZoneIdConversion.put(\"EEST\", \"Europe/Athens\");\n        cZoneIdConversion.put(\"GMT\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"BST\", \"Europe/London\");\n        cZoneIdConversion.put(\"IST\", \"Asia/Kolkata\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n        if (cZoneIdConversion == null) {\n            cZoneIdConversion = new HashMap<String, String>();\n            cZoneIdConversion.put(\"ACT\", \"Australia/Sydney\");\n            cZoneIdConversion.put(\"ADT\", \"America/Thule\");\n            cZoneIdConversion.put(\"AEDT\", \"Australia/Sydney\");\n            cZoneIdConversion.put(\"AEST\", \"Australia/Sydney\");\n            cZoneIdConversion.put(\"AFT\", \"Asia/Kabul\");\n            cZoneIdConversion.put(\"AKDT\", \"America/Juneau\");\n            cZoneIdConversion.put(\"AKST\", \"America/Juneau\");\n            cZoneIdConversion.put(\"AMST\", \"America/Manaus\");\n            cZoneIdConversion.put(\"AMT\", \"America/Manaus\");\n            cZoneIdConversion.put(\"ART\", \"America/Argentina/Buenos_Aires\");\n            cZoneIdConversion.put(\"AST\", \"America/Halifax\");\n            cZoneIdConversion.put(\"AT\", \"Europe/Vienna\");\n            cZoneIdConversion.put(\"Australia/ACT\", \"Australia/Sydney\");\n            cZoneIdConversion.put(\"Australia/Adelaide\", \"Australia/Adelaide\");\n            cZoneIdConversion.put(\"Australia/Brisbane\", \"Australia/Brisbane\");\n            cZoneIdConversion.put(\"Australia/Broken_Hill\", \"Australia/Broken_Hill\");\n            cZoneIdConversion.put(\"Australia/Canberra\", \"Australia/Sydney\");\n            cZoneIdConversion.put(\"Australia/Currie\", \"Australia/Currie\");\n            cZoneIdConversion.put(\"Australia/Darwin\", \"Australia/Darwin\");\n            cZoneIdConversion.put(\"Australia/Eucla\", \"Australia/Eucla\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"HST\", \"US/Hawaii\");\n        cZoneIdConversion.put(\"CLST\", \"Chile/Continental\");\n        cZoneIdConversion.put(\"CLT\", \"Chile/Continental\");\n        cZoneIdConversion.put(\"NZST\", \"Pacific/Auckland\");\n        cZoneIdConversion.put(\"NZDT\", \"Pacific/Auckland\");\n        cZoneIdConversion.put(\"EST\", \"US/Eastern\");\n        cZoneIdConversion.put(\"EDT\", \"US/Eastern\");\n        cZoneIdConversion.put(\"MST\", \"US/Mountain\");\n        cZoneIdConversion.put(\"MDT\", \"US/Mountain\");\n        cZoneIdConversion.put(\"PST\", \"US/Pacific\");\n        cZoneIdConversion.put(\"PDT\", \"US/Pacific\");\n        cZoneIdConversion.put(\"AST\", \"Canada/Atlantic\");\n        cZoneIdConversion.put(\"ADT\", \"Canada/Atlantic\");\n        cZoneIdConversion.put(\"WST\", \"Australia/Perth\");\n        cZoneIdConversion.put(\"JST\", \"Asia/Tokyo\");\n        cZoneIdConversion.put(\"GMT\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"UTC\", \"Etc/UTC\");\n        cZoneIdConversion.put(\"BST\", \"Europe/London\");\n        cZoneIdConversion.put(\"IST\", \"Asia/Kolkata\");\n        cZoneIdConversion.put(\"CAT\", \"Africa/Harare\");\n        cZoneIdConversion.put(\"SAST\", \"Africa/Johannesburg\");\n        cZoneIdConversion.put(\"CET\", \"Europe/Paris\");\n        cZoneIdConversion.put(\"MET\", \"Europe/Paris\");\n        cZoneIdConversion.put(\"MEST\", \"Europe/Paris\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"GMT\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"GMT+0\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"GMT-0\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"GMT+1\", \"Etc/GMT-1\");\n        cZoneIdConversion.put(\"GMT-1\", \"Etc/GMT+1\");\n        cZoneIdConversion.put(\"GMT+2\", \"Etc/GMT-2\");\n        cZoneIdConversion.put(\"GMT-2\", \"Etc/GMT+2\");\n        cZoneIdConversion.put(\"GMT+3\", \"Etc/GMT-3\");\n        cZoneIdConversion.put(\"GMT-3\", \"Etc/GMT+3\");\n        cZoneIdConversion.put(\"GMT+4\", \"Etc/GMT-4\");\n        cZoneIdConversion.put(\"GMT-4\", \"Etc/GMT+4\");\n        cZoneIdConversion.put(\"GMT+5\", \"Etc/GMT-5\");\n        cZoneIdConversion.put(\"GMT-5\", \"Etc/GMT+5\");\n        cZoneIdConversion.put(\"GMT+6\", \"Etc/GMT-6\");\n        cZoneIdConversion.put(\"GMT-6\", \"Etc/GMT+6\");\n        cZoneIdConversion.put(\"GMT+7\", \"Etc/GMT-7\");\n        cZoneIdConversion.put(\"GMT-7\", \"Etc/GMT+7\");\n        cZoneIdConversion.put(\"GMT+8\", \"Etc/GMT-8\");\n        cZoneIdConversion.put(\"GMT-8\", \"Etc/GMT+8\");\n        cZoneIdConversion.put(\"GMT+9\", \"Etc/GMT-9\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<String, String>();\n        // Add any known conversions here.\n        // Note that this is a simple conversion, and may not cover all cases.\n        cZoneIdConversion.put(\"EST\", \"America/New_York\");\n        cZoneIdConversion.put(\"EDT\", \"America/New_York\");\n        cZoneIdConversion.put(\"CST\", \"America/Chicago\");\n        cZoneIdConversion.put(\"CDT\", \"America/Chicago\");\n        cZoneIdConversion.put(\"MST\", \"America/Denver\");\n        cZoneIdConversion.put(\"MDT\", \"America/Denver\");\n        cZoneIdConversion.put(\"PST\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"PDT\", \"America/Los_Angeles\");\n    }\n    return cZoneIdConversion.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"GMT\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"GMT+0\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"GMT-0\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"GMT+1\", \"Etc/GMT-1\");\n        cZoneIdConversion.put(\"GMT-1\", \"Etc/GMT+1\");\n        cZoneIdConversion.put(\"GMT+2\", \"Etc/GMT-2\");\n        cZoneIdConversion.put(\"GMT-2\", \"Etc/GMT+2\");\n        cZoneIdConversion.put(\"GMT+3\", \"Etc/GMT-3\");\n        cZoneIdConversion.put(\"GMT-3\", \"Etc/GMT+3\");\n        cZoneIdConversion.put(\"GMT+4\", \"Etc/GMT-4\");\n        cZoneIdConversion.put(\"GMT-4\", \"Etc/GMT+4\");\n        cZoneIdConversion.put(\"GMT+5\", \"Etc/GMT-5\");\n        cZoneIdConversion.put(\"GMT-5\", \"Etc/GMT+5\");\n        cZoneIdConversion.put(\"GMT+6\", \"Etc/GMT-6\");\n        cZoneIdConversion.put(\"GMT-6\", \"Etc/GMT+6\");\n        cZoneIdConversion.put(\"GMT+7\", \"Etc/GMT-7\");\n        cZoneIdConversion.put(\"GMT-7\", \"Etc/GMT+7\");\n        cZoneIdConversion.put(\"GMT+8\", \"Etc/GMT-8\");\n        cZoneIdConversion.put(\"GMT-8\", \"Etc/GMT+8\");\n        cZoneIdConversion.put(\"GMT+9\", \"Etc/GMT-9\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"EST\", \"America/New_York\");\n        cZoneIdConversion.put(\"EDT\", \"America/New_York\");\n        cZoneIdConversion.put(\"CST\", \"America/Chicago\");\n        cZoneIdConversion.put(\"CDT\", \"America/Chicago\");\n        cZoneIdConversion.put(\"MST\", \"America/Denver\");\n        cZoneIdConversion.put(\"MDT\", \"America/Denver\");\n        cZoneIdConversion.put(\"PST\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"PDT\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"JST\", \"Asia/Tokyo\");\n        cZoneIdConversion.put(\"ACT\", \"Australia/Sydney\");\n        cZoneIdConversion.put(\"AET\", \"Australia/Sydney\");\n        cZoneIdConversion.put(\"ACST\", \"Australia/Adelaide\");\n        cZoneIdConversion.put(\"ACDT\", \"Australia/Darwin\");\n        cZoneIdConversion.put(\"WST\", \"Australia/Perth\");\n        cZoneIdConversion.put(\"CAT\", \"Africa/Harare\");\n        cZoneIdConversion.put(\"EAT\", \"Africa/Addis_Ababa\");\n        cZoneIdConversion.put(\"NAT\", \"Pacific/Nauru\");\n        cZoneIdConversion.put(\"HST\", \"Pacific/Honolulu\");\n        cZoneIdConversion.put(\"SST\", \"Pacific/Pitcairn\");\n        cZoneIdConversion.put(\"GMT\", \"Etc/GMT\");\n        cZoneIdConversion.put(\"UTC\", \"Etc/UTC\");\n        cZoneIdConversion.put(\"BST\", \"Europe/London\");\n        cZoneIdConversion.put(\"IST\", \"Asia/Kolkata\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"HST\", \"US/Hawaii\");\n        cZoneIdConversion.put(\"MST\", \"US/Mountain\");\n        cZoneIdConversion.put(\"PST\", \"US/Pacific\");\n        cZoneIdConversion.put(\"IST\", \"Asia/Kolkata\");\n        cZoneIdConversion.put(\"BST\", \"Europe/London\");\n        cZoneIdConversion.put(\"WET\", \"Europe/London\");\n        cZoneIdConversion.put(\"CET\", \"Europe/Paris\");\n        cZoneIdConversion.put(\"EET\", \"Europe/Helsinki\");\n        cZoneIdConversion.put(\"ART\", \"Africa/Cairo\");\n        cZoneIdConversion.put(\"AZOST\", \"Atlantic/Azores\");\n        cZoneIdConversion.put(\"AZOT\", \"Atlantic/Azores\");\n        cZoneIdConversion.put(\"MET\", \"Europe/Berlin\");\n        cZoneIdConversion.put(\"MEST\", \"Europe/Berlin\");\n        cZoneIdConversion.put(\"CAT\", \"Africa/Harare\");\n        cZoneIdConversion.put(\"EAT\", \"Africa/Addis_Ababa\");\n        cZoneIdConversion.put(\"NZST\", \"Pacific/Auckland\");\n        cZoneIdConversion.put(\"NZDT\", \"Pacific/Auckland\");\n        cZoneIdConversion.put(\"EST\", \"US/Eastern\");\n        cZoneIdConversion.put(\"EDT\", \"US/Eastern\");\n        cZoneIdConversion.put(\"CST\", \"US/Central\");\n        cZoneIdConversion.put(\"CDT\", \"US/Central\");\n        cZoneIdConversion.put(\"MST\", \"US/Mountain\");\n        cZoneIdConversion.put(\"MDT\", \"US/Mountain\");\n        cZoneIdConversion.put(\"PST\", \"US/Pacific\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n        if (cZoneIdConversion == null) \n        {\n            cZoneIdConversion = new HashMap<String, String>();\n            cZoneIdConversion.put(\"Hong Kong\", \"Asia/Hong_Kong\");\n            cZoneIdConversion.put(\"Hong Kong Time\", \"Asia/Hong_Kong\");\n            cZoneIdConversion.put(\"Hong Kong Island Time\", \"Asia/Hong_Kong\");\n            cZoneIdConversion.put(\"New Taipei\", \"Asia/Taipei\");\n            cZoneIdConversion.put(\"China Standard Time\", \"Asia/Shanghai\");\n            cZoneIdConversion.put(\"Taiwan\", \"Asia/Taiwan\");\n            cZoneIdConversion.put(\"Taiwan Time\", \"Asia/Taiwan\");\n            cZoneIdConversion.put(\"Western European Time\", \"Europe/London\");\n            cZoneIdConversion.put(\"Mitteleurop\u00e4ische Zeit\", \"Europe/Berlin\");\n            cZoneIdConversion.put(\"Central European Time\", \"Europe/Paris\");\n            cZoneIdConversion.put(\"Eastern European Time\", \"Europe/Rome\");\n            cZoneIdConversion.put(\"French Central European Time\", \"Europe/Paris\");\n            cZoneIdConversion.put(\"Russian Standard Time\", \"Europe/Moscow\");\n            cZoneIdConversion.put(\"Azores Standard Time\", \"Atlantic/Azores\");\n            cZoneIdConversion.put(\"Cape Verde Standard Time\", \"Atlantic/Cape_Verde\");\n            cZoneIdConversion.put(\"Greenwich Mean Time\", \"Etc/GMT\");\n            cZoneIdConversion.put(\"British Summer Time\", \"Europe/London\");\n            cZoneIdConversion.put(\"Central European Summer Time\", \"Europe/Paris\");\n            cZoneIdConversion.put(\"Eastern European Summer Time\", \"Europe/Rome\");\n            cZoneIdConversion.put(\"French Central European Summer Time\", \"Europe/Paris\");\n}\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Compute the Jacobian matrix.\n    final double[][] jacobian = computeJacobian(params);\n    final int rows = jacobian.length;\n    final int cols = jacobian[0].length;\n\n    // Check if the Jacobian dimension matches the problem dimension.\n    if (rows != getTarget().length) {\n        throw new DimensionMismatchException(rows, getTarget().length);\n    }\n    if (cols != params.length) {\n        throw new DimensionMismatchException(cols, params.length);\n    }\n\n    // Compute the weighted Jacobian matrix.\n    final RealMatrix weightedJacobian = getWeightMatrix().getSolver().getInverse().multiply(\n        new Array2DRowRealMatrix(jacobian));\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        final int nR = getResidualDimension();\n        final int nC = getParameterDimension();\n\n        // Check if the Jacobian dimension matches the problem dimension.\n        if (nR != jF.getN()) {\n            throw new DimensionMismatchException(nR, jF.getN());\n        }\n        if (nC != jF.getP()) {\n            throw new DimensionMismatchException(nC, jF.getP());\n        }\n\n        // Compute the Jacobian.\n        final double[][] jacobian = jF.jacobian(params);\n\n        // Compute the weighted Jacobian.\n        final RealMatrix weightedJacobian = getWeight().multiply(new Array2DRowRealMatrix(jacobian));\n\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        // Get the jacobian function.\n        MultivariateMatrixFunction jacobian = getJacobian();\n        // Compute the jacobian.\n        double[][] j = jacobian.value(params);\n        // Get the weight matrix.\n        RealMatrix weightMatrix = getWeight();\n        // Compute the weighted jacobian.\n        RealMatrix weightedJacobian = weightMatrix.multiply(new Array2DRowRealMatrix(j));\n        // Return the weighted jacobian.\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        final int nR = getResidualDimension();\n        final int nC = getParameterDimension();\n\n        // Compute the Jacobian.\n        final double[][] jacobian = computeJacobian(params);\n        if (jacobian.length != nR) {\n            throw new DimensionMismatchException(jacobian.length, nR);\n        }\n        if (jacobian[0].length != nC) {\n            throw new DimensionMismatchException(jacobian[0].length, nC);\n        }\n\n        // Compute the square root of the weight matrix.\n        final RealMatrix weightMatrix = getWeight();\n        if (weightMatrix.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n        }\n        if (weightMatrix.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n        }\n        final RealMatrix weightMatrixSqrt = squareRoot(weightMatrix);\n\n        // Compute the weighted Jacobian.\n        final RealMatrix weightedJacobian = weightMatrixSqrt.multiply(\n            new Array2DRowRealMatrix(jacobian));\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        // Compute the Jacobian matrix.\n        final double[][] jacobianArray = computeJacobian(params);\n        final int rows = jacobianArray.length;\n        final int cols = jacobianArray[0].length;\n        if (rows != getTarget().length) {\n            throw new DimensionMismatchException(rows, getTarget().length);\n        }\n        if (cols != params.length) {\n            throw new DimensionMismatchException(cols, params.length);\n        }\n\n        // Compute the square root of the weight matrix.\n        final RealMatrix weightMatrix = getWeight();\n        final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n\n        // Compute the weighted Jacobian matrix.\n        final RealMatrix weightedJacobian = new Array2DRowRealMatrix(rows, cols);\n        for (int i = 0; i < rows; ++i) {\n            final double[] grad = jacobianArray[i];\n            for (int j = 0; j < cols; ++j) {\n                weightedJacobian.setEntry(i, j, weightMatrixSqrt.getEntry(i, i) * grad[j]);\n            }\n        }\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Compute the Jacobian matrix.\n    final double[][] jacobian = computeJacobian(params);\n    final int nR = jacobian.length;\n    final int nC = jacobian[0].length;\n\n    // Check if the Jacobian dimension matches problem dimension.\n    if (nR != getTarget().length) {\n        throw new DimensionMismatchException(nR, getTarget().length);\n    }\n\n    // Compute the square root of the weight matrix.\n    final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n    if (weightMatrixSqrt.getRowDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrixSqrt.getRowDimension(), nR);\n    }\n    if (weightMatrixSqrt.getColumnDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrixSqrt.getColumnDimension(), nR);\n    }\n\n    // Compute the weighted Jacobian matrix.\n    final RealMatrix weightedJacobian = weightMatrixSqrt.multiply(new Array2DRowRealMatrix(jacobian));\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        // Compute the Jacobian of the model function.\n        final double[][] jacobian = computeJacobian(params);\n\n        // Compute the square root of the weight matrix.\n        final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n\n        // Compute the weighted Jacobian.\n        final RealMatrix weightedJacobian = weightMatrixSqrt.multiply(new Array2DRowRealMatrix(jacobian));\n\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        // Compute the Jacobian.\n        final double[][] jacobianArray = computeJacobian(params);\n        final int nR = jacobianArray.length;\n        if (nR != rows) {\n            throw new DimensionMismatchException(nR, rows);\n        }\n        final int nC = jacobianArray[0].length;\n        if (nC != cols) {\n            throw new DimensionMismatchException(nC, cols);\n        }\n\n        // Compute the square root of the weight matrix.\n        final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n        if (weightMatrixSqrt.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrixSqrt.getRowDimension(), nR);\n        }\n        if (weightMatrixSqrt.getColumnDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrixSqrt.getColumnDimension(), nR);\n        }\n\n        // Compute the weighted Jacobian.\n        final RealMatrix weightedJacobian = new Array2DRowRealMatrix(nR, nC);\n        for (int i = 0; i < nR; ++i) {\n            for (int j = 0; j < nC; ++j) {\n                weightedJacobian.setEntry(i, j, jacobianArray[i][j] * weightMatrixSqrt.getEntry(i, j));\n            }\n        }\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Compute the Jacobian matrix.\n    final double[][] jacobian = computeJacobian(params);\n    if (jacobian.length != getTarget().length) {\n        throw new DimensionMismatchException(jacobian.length, getTarget().length);\n    }\n    if (jacobian[0].length != params.length) {\n        throw new DimensionMismatchException(jacobian[0].length, params.length);\n    }\n\n    // Compute the square root of the weight matrix.\n    final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n\n    // Compute the weighted Jacobian.\n    final RealMatrix weightedJacobian = new Array2DRowRealMatrix(jacobian.length, jacobian[0].length);\n    for (int i = 0; i < jacobian.length; ++i) {\n        for (int j = 0; j < jacobian[0].length; ++j) {\n            weightedJacobian.setEntry(i, j, jacobian[i][j] * weightMatrixSqrt.getEntry(i, i));\n        }\n    }\n\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Get the Jacobian.\n    double[][] jacobian = computeJacobian(params);\n    // Get the weight matrix.\n    RealMatrix weightMatrix = getWeight();\n    // Check the dimensions.\n    if (jacobian.length != weightMatrix.getRowDimension()) {\n        throw new DimensionMismatchException(jacobian.length, weightMatrix.getRowDimension());\n    }\n    if (jacobian[0].length != weightMatrix.getColumnDimension()) {\n        throw new DimensionMismatchException(jacobian[0].length, weightMatrix.getColumnDimension());\n    }\n    // Compute the weighted Jacobian.\n    RealMatrix weightedJacobian = new Array2DRowRealMatrix(jacobian);\n    weightedJacobian = weightedJacobian.multiply(weightMatrix.getCholeskyDecomposition().getSolver().getInverse());\n    return weightedJacobian;\n}"
    ],
    [
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = -1;\n    E leastValue = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            final E value = values.get(i);\n            if (leastValue == null || comparator.compare(value, leastValue) < 0) {\n                least = i;\n                leastValue = value;\n            }\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = 0;\n    for (int i = 1; i < values.size(); i++) {\n        if (values.get(i) != null && comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = -1;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (least == -1 || comparator.compare(values.get(least), values.get(i)) > 0) {\n                least = i;\n            }\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = -1;\n    for (int i = 0; i < valueSet.size(); i++) {\n        if (valueSet.get(i)) {\n            if (least == -1 || comparator.compare(values.get(least), values.get(i)) > 0) {\n                least = i;\n            }\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    E leastValue = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i) == false) {\n            set(i);\n        }\n        if (leastIndex == -1 || comparator.compare(values.get(i), leastValue) < 0) {\n            leastIndex = i;\n            leastValue = values.get(i);\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < values.size(); i++) \n    {\n        if (valueSet.get(i)) \n        {\n            if (leastIndex == -1 || comparator.compare(values.get(leastIndex), values.get(i)) > 0) \n            {\n                leastIndex = i;\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    for (int i = 0; i < valueSet.size(); i++) {\n        if (valueSet.get(i)) {\n            if (leastIndex == -1 || comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n                leastIndex = i;\n            }\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int leastIndex = -1;\n    E leastValue = null;\n    for (int i = 0; i < values.size(); i++) \n    {\n        if (valueSet.get(i) == false) \n        {\n            set(i);\n        }\n        if (leastIndex == -1 || comparator.compare(values.get(i), leastValue) < 0) \n        {\n            leastIndex = i;\n            leastValue = values.get(i);\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = 0;\n    for (int i = 1; i < values.size(); i++) {\n        if (values.get(i) != null && comparator.compare(values.get(i), values.get(least)) < 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = -1;\n    for (int i = 0; i < valueSet.size(); i++) \n    {\n        if (valueSet.get(i)) \n        {\n            if (least == -1 || comparator.compare(values.get(i), values.get(least)) < 0) \n            {\n                least = i;\n            }\n        }\n    }\n    return least;\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodeTest nodeTest = step.getNodeTest();\n    if (nodeTest instanceof NodeNameTest) {\n        NodeNameTest nameTest = (NodeNameTest) nodeTest;\n        QName name = nameTest.getNodeName();\n        return parentPointer.getPropertyPointer(name);\n    }\n    return new NullPropertyPointer(parentPointer);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodeTest nodeTest = step.getNodeTest();\n        if (nodeTest instanceof NodeNameTest) {\n            QName name = ((NodeNameTest) nodeTest).getNodeName();\n            return parentPointer.getPropertyPointer(name);\n        }\n        return parentPointer.getPropertyPointer();\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n        return new ChildPropertyPointer(parentPointer, name);\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n        return newChildNodePointer(parentPointer, name, null);\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n        if (parentPointer.isDynamicPropertyDeclarationSupported()) {\n            return parentPointer.getPropertyPointer(name);\n        }\n        return newChildNodePointer(parentPointer, name, null);\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n        return parentPointer.getPropertyPointer(name);\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n        return parentPointer.getPropertyPointer(name);\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    return parentPointer.getPropertyPointer(name);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n        return parentPointer.getPropertyPointer().getChildPointer(name);\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n        return newChildNodePointer(parentPointer, name, null);\n    }"
    ],
    [
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache = cache.putIfAbsent(locale, strategy);\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            strategy= inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache = cache.putIfAbsent(locale, strategy);\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache = cache.putIfAbsent(locale, strategy);\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= createStrategy(field, definingCalendar);\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            strategy= inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache = cache.putIfAbsent(locale, strategy);\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            strategy= inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        final Strategy existingStrategy = cache.putIfAbsent(locale, strategy);\n        if (existingStrategy != null) {\n            strategy = existingStrategy;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache = cache.putIfAbsent(locale, strategy);\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache = cache.putIfAbsent(locale, strategy);\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}"
    ],
    [
      "private boolean setNextObject()  {\n    if (nextObjectSet) \n    {\n        return true;\n    }\n    if (iterator == null) \n    {\n        return false;\n    }\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate == null || predicate.evaluate(nextObject)) \n        {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (nextObjectSet) \n    {\n        return true;\n    }\n\n    while (iterator.hasNext()) \n    {\n        E candidate = iterator.next();\n        if (predicate.evaluate(candidate)) \n        {\n            nextObject = candidate;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (nextObjectSet) \n    {\n        return true;\n    }\n    while (iterator.hasNext()) \n    {\n        E object = iterator.next();\n        if (predicate.evaluate(object)) \n        {\n            nextObject = object;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        E candidate = iterator.next();\n        if (predicate.evaluate(candidate)) \n        {\n            nextObject = candidate;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObject = null;\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (nextObjectSet)\n    {\n        return true;\n    }\n\n    while (iterator.hasNext())\n    {\n        E obj = iterator.next();\n        if (predicate.evaluate(obj))\n        {\n            nextObject = obj;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n\n    nextObject = null;\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (nextObjectSet)\n    {\n        return true;\n    }\n\n    while (iterator.hasNext())\n    {\n        E object = iterator.next();\n        if (predicate.evaluate(object))\n        {\n            nextObject = object;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n\n    nextObject = null;\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (nextObjectSet) \n    {\n        return true;\n    }\n    while (iterator.hasNext()) \n    {\n        E object = iterator.next();\n        if (predicate.evaluate(object)) \n        {\n            nextObject = object;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    nextObject = null;\n    nextObjectSet = false;\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (nextObjectSet) \n    {\n        return true;\n    }\n\n    if (iterator == null) \n    {\n        return false;\n    }\n\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate == null || predicate.evaluate(nextObject)) \n        {\n            nextObjectSet = true;\n            return true;\n        }\n    }\n\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (nextObjectSet) \n    {\n        return true;\n    }\n\n    if (iterator == null) \n    {\n        return false;\n    }\n\n    while (iterator.hasNext()) \n    {\n        E object = iterator.next();\n        if (predicate == null || predicate.evaluate(object)) \n        {\n            nextObject = object;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n\n    return false;\n}",
      "private boolean setNextObject()  {\n    if (nextObjectSet) \n    {\n        return true;\n    }\n    while (iterator.hasNext()) \n    {\n        E candidate = iterator.next();\n        if (predicate.evaluate(candidate)) \n        {\n            nextObject = candidate;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}"
    ],
    [
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        double lB = CMAESOptimizer.this.getLowerBound()[i];\n        double uB = CMAESOptimizer.this.getUpperBound()[i];\n        if (x[i] < lB) \n        {\n            repaired[i] = lB;\n        } \n        else if (x[i] > uB) \n        {\n            repaired[i] = uB;\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        double value = x[i];\n        double lowerBound = CMAESOptimizer.this.getLowerBound()[i];\n        double upperBound = CMAESOptimizer.this.getUpperBound()[i];\n        if (value < lowerBound) \n        {\n            repaired[i] = lowerBound;\n        } \n        else if (value > upperBound) \n        {\n            repaired[i] = upperBound;\n        } \n        else \n        {\n            repaired[i] = value;\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        double value = x[i];\n        double lB = CMAESOptimizer.this.getLowerBound()[i];\n        double uB = CMAESOptimizer.this.getUpperBound()[i];\n        if (value < lB) {\n            repaired[i] = lB;\n        } else if (value > uB) {\n            repaired[i] = uB;\n        } else {\n            repaired[i] = value;\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        double lB = CMAESOptimizer.this.getLowerBound()[i];\n        double uB = CMAESOptimizer.this.getUpperBound()[i];\n        repaired[i] = Math.max(lB, Math.min(x[i], uB));\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        double value = x[i];\n        double lowerBound = CMAESOptimizer.this.getLowerBound()[i];\n        double upperBound = CMAESOptimizer.this.getUpperBound()[i];\n        if (value < lowerBound) \n        {\n            repaired[i] = lowerBound;\n        } \n        else if (value > upperBound) \n        {\n            repaired[i] = upperBound;\n        } \n        else \n        {\n            repaired[i] = value;\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        double value = x[i];\n        double lowerBound = CMAESOptimizer.this.getLowerBound()[i];\n        double upperBound = CMAESOptimizer.this.getUpperBound()[i];\n        if (value < lowerBound) {\n            value = lowerBound;\n        }\n        if (value > upperBound) {\n            value = upperBound;\n        }\n        repaired[i] = value;\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        double lB = CMAESOptimizer.this.getLowerBound()[i];\n        double uB = CMAESOptimizer.this.getUpperBound()[i];\n        if (x[i] < lB) \n        {\n            repaired[i] = lB;\n        } \n        else if (x[i] > uB) \n        {\n            repaired[i] = uB;\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        double lB = CMAESOptimizer.this.getLowerBound()[i];\n        double uB = CMAESOptimizer.this.getUpperBound()[i];\n        repaired[i] = Math.max(lB, Math.min(uB, x[i]));\n    }\n    return repaired;\n}"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    final int n = matrix.getRowDimension();\n    final double[][] matrixT = matrix.getData();\n    final double[][] matrixP = new double[n][n];\n    final double[] realEigenvalues = new double[n];\n    final double[] imagEigenvalues = new double[n];\n    final double[] work = new double[n];\n\n    // copy matrix to T\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            matrixT[i][j] = matrix.getEntry(i, j);\n        }\n    }\n\n    // copy matrix to P\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            matrixP[i][j] = (i == j) ? 1 : 0;\n        }\n    }\n\n    // perform QR iteration\n    for (int i = 0; i < n; i++) {\n        // find the sub-matrix to transform\n        final int l = (i == 0) ? i : i + 1;\n        final int u = n - 1;\n\n        // find the shift\n        final ShiftInfo shift = new ShiftInfo();\n        findShift(l, u, i, shift);\n\n        // perform the QR iteration\n        final int idx = initQRStep(l, u, shift, work);\n        performQRStep(l, idx, u, shift, work);\n    }\n\n    // extract eigenvalues\n    for (int i = 0; i < n; i++) {\n        realEigenvalues[i] = matrixT[i][i];\n        imagEigenvalues[i] = 0;\n    }\n\n    // return the Schur transform\n    return new SchurTransformer(matrixT, matrixP, realEigenvalues, imagEigenvalues);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    // transform the matrix to tridiagonal\n    transformToTridiagonal(matrix);\n\n    // transform to Schur form\n    final SchurTransformer schur = new SchurTransformer(transformer.getQ().getData());\n    main = transformer.getMainDiagonalRef();\n    secondary = transformer.getSecondaryDiagonalRef();\n\n    // compute eigenvalues\n    findEigenValues(schur);\n\n    return schur;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    // transform the matrix to tridiagonal\n    transformToTridiagonal(matrix);\n    // find the eigenvalues and eigenvectors\n    final SchurTransformer schur = new SchurTransformer(transformer.getQT());\n    findEigenVectorsFromSchur(schur);\n    return schur;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    final int n = matrix.getColumnDimension();\n    final double[][] matrixT = matrix.getData();\n\n    // Compute the Schur form\n    final SchurTransformer schur = new SchurTransformer(matrix);\n    final double[][] matrixTShur = schur.getT().getData();\n\n    // Compute the eigenvalues\n    final double[] realEigenvalues = new double[n];\n    final double[] imagEigenvalues = new double[n];\n    for (int i = 0; i < n; i++) {\n        realEigenvalues[i] = matrixTShur[i][i];\n        if (i < n - 1 && FastMath.abs(matrixTShur[i][i + 1]) > 0) {\n            imagEigenvalues[i] = matrixTShur[i + 1][i];\n            imagEigenvalues[i + 1] = -matrixTShur[i][i + 1];\n        } else {\n            imagEigenvalues[i] = 0;\n        }\n    }\n\n    return new SchurTransformer(schur, realEigenvalues, imagEigenvalues);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    // transform the matrix to tridiagonal\n    transformToTridiagonal(matrix);\n    final double[][] matrixT = transformer.getT().getData();\n    final double[][] matrixQ = transformer.getQ().getData();\n\n    // create a copy of the matrix T\n    final double[][] matrixTcopy = new double[matrixT.length][matrixT.length];\n    for (int i = 0; i < matrixT.length; i++) {\n        System.arraycopy(matrixT[i], 0, matrixTcopy[i], 0, matrixT.length);\n    }\n\n    // create a copy of the matrix Q\n    final double[][] matrixQcopy = new double[matrixQ.length][matrixQ.length];\n    for (int i = 0; i < matrixQ.length; i++) {\n        System.arraycopy(matrixQ[i], 0, matrixQcopy[i], 0, matrixQ.length);\n    }\n\n    // create a copy of the matrix Q^T\n    final double[][] matrixQtcopy = new double[matrixQ.length][matrixQ.length];\n    for (int i = 0; i < matrixQ.length; i++) {\n        System.arraycopy(matrixQ[i], 0, matrixQtcopy[i], 0, matrixQ.length);\n    }\n    MatrixUtils.transposeInPlace(matrixQtcopy);\n\n    // perform the QR algorithm\n    for (int i = 0; i < matrixT.length; i++) {\n        // find the index of the smallest sub-diagonal element\n        int idx = findSmallSubDiagonalElement(i, getNorm());\n        if (idx != i) {\n            // swap the sub-diagonal elements\n            double tmp = matrixT[i][idx];\n            matrixT[i][idx] = matrixT[idx][i];\n            matrixT[idx][i] = tmp;\n            // swap the corresponding elements of Q\n            tmp = matrixQ[i][idx];\n            matrixQ[i][idx] = matrixQ[idx][i];\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    final int n = matrix.getColumnDimension();\n    final double[][] matrixT = matrix.getData();\n    final double[][] matrixP = new double[n][n];\n    final double[] realEigenvalues = new double[n];\n    final double[] imagEigenvalues = new double[n];\n    final double[][] matrixZ = new double[n][n];\n    final double[][] matrixQ = new double[n][n];\n    final double[][] matrixQt = new double[n][n];\n\n    // copy matrix to T\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            matrixT[i][j] = matrix.getEntry(i, j);\n        }\n    }\n\n    // initialize Q and Z\n    for (int i = 0; i < n; i++) {\n        matrixQ[i][i] = 1.0;\n        matrixZ[i][i] = 1.0;\n    }\n\n    // perform the Schur transformation\n    int iteration = 0;\n    boolean converged = false;\n    while (!converged) {\n        final ShiftInfo shift = new ShiftInfo();\n        final int idx = findSmallSubDiagonalElement(0, n - 1, iteration, shift);\n        if (idx == n - 1) {\n            converged = true;\n        } else {\n            final int im = idx + 1;\n            final double[] hVec = new double[n];\n            final int il = initQRStep(idx, im, n - 1, shift, hVec);\n            performDoubleQRStep(il, im, n - 1, shift, hVec);\n            iteration++;\n        }\n    }\n\n    // extract the eigenvalues and eigenvectors\n    for (int i = 0; i < n; i++) {\n        realEigenvalues[i] = matrixT[i][i];\n        imagEigenvalues[i] = 0.0;\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    // transform the matrix to tridiagonal\n    transformToTridiagonal(matrix);\n\n    // create a new SchurTransformer\n    final SchurTransformer schur = new SchurTransformer(transformer.getQT());\n\n    // transform the matrix to Schur form\n    int n = matrixT.length;\n    int i = 0;\n    int j = 0;\n    int iteration = 0;\n    int idx = 0;\n    double[] hVec = new double[n];\n    double[] hVec2 = new double[n];\n    double norm = 0.0;\n    double maxNorm = 0.0;\n    double maxNorm2 = 0.0;\n    double maxNorm3 = 0.0;\n    double maxNorm4 = 0.0;\n    double maxNorm5 = 0.0;\n    double maxNorm6 = 0.0;\n    double maxNorm7 = 0.0;\n    double maxNorm8 = 0.0;\n    double maxNorm9 = 0.0;\n    double maxNorm10 = 0.0;\n    double maxNorm11 = 0.0;\n    double maxNorm12 = 0.0;\n    double maxNorm13 = 0.0;\n    double maxNorm14 = 0.0;\n    double maxNorm15 = 0.0;\n    double maxNorm16 = 0.0;\n    double maxNorm17 = 0.0;\n    double maxNorm18 = 0.0;\n    double maxNorm19 = 0.0;\n    double maxNorm20 = 0.0;\n    double maxNorm21 = 0.0;\n    double maxNorm22 = 0.0;\n    double maxNorm23 = 0.0;\n    double maxNorm24 = 0.0;\n    double maxNorm25 = 0.0;\n    double maxNorm26 = 0.0;\n    double maxNorm27 = 0.0;\n    double maxNorm28 = 0.0;\n    double maxNorm29 = 0.0;\n    double maxNorm30 = 0.0;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    final SchurTransformer schur = new SchurTransformer(matrix);\n    final double[][] matrixT = schur.getT().getData();\n    final double[][] matrixP = schur.getP().getData();\n\n    final int n = matrixT.length;\n\n    // compute matrix norm\n    double norm = 0.0;\n    for (int i = 0; i < n; i++) {\n        for (int j = FastMath.max(i - 1, 0); j < n; j++) {\n            norm = norm + FastMath.abs(matrixT[i][j]);\n        }\n    }\n\n    // we can not handle a matrix with zero norm\n    if (Precision.equals(norm, 0.0, EPSILON)) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    // Backsubstitute to find vectors of upper triangular form\n\n    double r = 0.0;\n    double s = 0.0;\n    double z = 0.0;\n\n    for (int idx = n - 1; idx >= 0; idx--) {\n        double p = realEigenvalues[idx];\n        double q = imagEigenvalues[idx];\n\n        // look for two consecutive small sub-diagonal elements\n        // (a 1x1 block with eigenvalues p and q)\n        final int l = findSmallSubDiagonalElement(idx, norm);\n\n        // if two small sub-diagonal elements found,\n        // then a 2x2 block with eigenvalues p, q and r\n        if (l < idx) {\n            // use a Householder transformation to shift the 2x2 block\n            // to the top-left corner of the matrix T\n            final double[] hVec = transformer.getHouseholderVectorsRef()[idx];\n            final double alpha = hVec[0];\n            final double beta = hVec[1];\n            final double gamma = hVec[2];\n            final double delta = hVec[3];\n\n            // apply the transformation to matrix T\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    final SchurTransformer schur = new SchurTransformer(matrix);\n    final double[][] matrixT = schur.getT().getData();\n    final double[][] matrixP = schur.getP().getData();\n\n    final int n = matrixT.length;\n\n    // compute matrix norm\n    double norm = 0.0;\n    for (int i = 0; i < n; i++) {\n        for (int j = FastMath.max(i - 1, 0); j < n; j++) {\n            norm = norm + FastMath.abs(matrixT[i][j]);\n        }\n    }\n\n    // we can not handle a matrix with zero norm\n    if (Precision.equals(norm, 0.0, EPSILON)) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    // Backsubstitute to find vectors of upper triangular form\n\n    double r = 0.0;\n    double s = 0.0;\n    double z = 0.0;\n\n    for (int idx = n - 1; idx >= 0; idx--) {\n        double p = realEigenvalues[idx];\n        double q = imagEigenvalues[idx];\n\n        // Look for small sub-diagonal elements\n        int l = idx;\n        while (l > 0 && FastMath.abs(matrixT[l - 1][idx]) > epsilon * norm) {\n            l--;\n        }\n\n        // Determine the shift.\n        final ShiftInfo shift = new ShiftInfo();\n        if (l == idx) {\n            // Single eigenvalue.\n            shift.x = matrixT[idx][idx];\n            shift.y = 0;\n            shift.w = shift.x;\n            shift.exShift = 0;\n        } else if (l == idx - 1) {\n            // Double eigenvalue.\n            shift.x = matrixT[idx][idx];\n            shift.y = matrixT[idx - 1][idx];\n            shift.w = matrixT[idx - 1][idx - 1];\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    final SchurTransformer schur = new SchurTransformer(matrix);\n    final double[][] matrixT = schur.getT().getData();\n    final double[][] matrixP = schur.getP().getData();\n\n    final int n = matrixT.length;\n\n    // compute matrix norm\n    double norm = 0.0;\n    for (int i = 0; i < n; i++) {\n        for (int j = FastMath.max(i - 1, 0); j < n; j++) {\n            norm = norm + FastMath.abs(matrixT[i][j]);\n        }\n    }\n\n    // we can not handle a matrix with zero norm\n    if (Precision.equals(norm, 0.0, EPSILON)) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    // Backsubstitute to find vectors of upper triangular form\n    double r = 0.0;\n    double s = 0.0;\n    double z = 0.0;\n\n    for (int idx = n - 1; idx >= 0; idx--) {\n        double p = realEigenvalues[idx];\n        double q = imagEigenvalues[idx];\n        if (q == 0) {\n            // real eigenvalue\n            int l = idx - 1;\n            while (l >= 0 && realEigenvalues[l] == 0) {\n                l--;\n            }\n            if (l < 0) {\n                // eigenvalue at the end of the block, back substitute\n                final double t = matrixT[idx][idx];\n                if (t != 0) {\n                    final double[] v = new double[n];\n                    v[idx] = 1;\n                    for (int i = idx - 1; i >= 0; i--) {\n                        final double[] hVec = matrixT[i];\n                        double tau = 0;\n                        for (int j = l + 1; j <= idx; j++) {\n}\n}\n}\n}\n}\n}\n}"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    ArrayUtils.reverse(values);\n    for (int i = 0; i < values.length; i++) {\n        final long value = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((value & (1L << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    ArrayUtils.reverse(values);\n    for (int i = 0; i < values.length; i++) {\n        final long value = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((value & 1L << j) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    ArrayUtils.reverse(values);\n    for (int i = 0; i < values.length; i++) {\n        final long value = values[i];\n        for (int j = 0; j < Long.SIZE && i * Long.SIZE + j < enumClass.getEnumConstants().length; j++) {\n            if ((value & 1 << j) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    ArrayUtils.reverse(values);\n    for (int i = 0; i < values.length; i++) {\n        final long value = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((value & 1L << j) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    ArrayUtils.reverse(values);\n    for (int i = 0; i < values.length; i++) {\n        final long value = values[i];\n        for (int j = 0; j < Long.SIZE && i * Long.SIZE + j < enumClass.getEnumConstants().length; j++) {\n            if ((value & (1L << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long instantLocal = oldInstant + offset;\n    long instantNew = newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n    return instantNew;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localMillis = oldInstant + getOffset(oldInstant);\n    return newZone.convertUTCToLocal(localMillis);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long instantLocal = oldInstant + offset;\n    return newZone.convertLocalToUTC(instantLocal, true, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long newInstant = oldInstant + offset - newZone.getOffset(oldInstant + offset);\n    if (newInstant < -MAX_MILLIS || newInstant > MAX_MILLIS) {\n        throw new ArithmeticException(\"The calculation for getting the millis to keep the local time in another zone overflowed\");\n    }\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localMillis = oldInstant + getOffset(oldInstant);\n    return newZone.convertUTCToLocal(localMillis);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long instantLocal = oldInstant + getOffset(oldInstant);\n    return newZone.convertLocalToUTC(instantLocal, true);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long newInstant = oldInstant + offset - newZone.getOffset(oldInstant);\n    if (newInstant < -9223372036854775808L || newInstant > 9223372036854775807L) {\n        throw new ArithmeticException(\"The result exceeds the range of a long\");\n    }\n    return newInstant;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = getDefault();\n    }\n    long localMillis = oldInstant + getOffset(oldInstant);\n    return newZone.convertUTCToLocal(localMillis) - newZone.getOffset(localMillis);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long instantLocal = oldInstant + offset;\n    long instantNew = newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n    return instantNew - offset;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = getDefault();\n    }\n    int offset = getOffset(oldInstant);\n    long newInstant = oldInstant + offset - newZone.getOffset(oldInstant);\n    if (newInstant < 0 || newInstant > MAX_MILLIS) {\n        throw new ArithmeticException(\"The calculation overflows a long\");\n    }\n    return newInstant;\n}"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count - 1) / count);\n    calendar.set(unit.getCalendarField(), value);\n    calendar.set(Calendar.MILLISECOND, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    if (unit.getCalendarField() == Calendar.DAY_OF_MONTH) {\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n    }\n    else if (unit.getCalendarField() == Calendar.MONTH) {\n        calendar.set(Calendar.MONTH, 0);\n    }\n    else if (unit.getCalendarField() == Calendar.YEAR) {\n        calendar.set(Calendar.YEAR, 1);\n    }\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count - 1) / count);\n    calendar.set(unit.getCalendarField(), value);\n    calendar.set(Calendar.MILLISECOND, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.DAY_OF_MONTH, 1);\n    calendar.set(Calendar.MONTH, 0);\n    calendar.set(Calendar.YEAR, 1970);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count - 1) / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count - 1) / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count - 1) / count);\n    calendar.set(unit.getCalendarField(), value);\n    calendar.set(Calendar.MILLISECOND, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.DAY_OF_MONTH, 1);\n    calendar.set(Calendar.MONTH, 0);\n    calendar.set(Calendar.YEAR, 1970);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count - 1) / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count - 1) / count);\n    calendar.set(unit.getCalendarField(), value);\n    calendar.set(Calendar.MILLISECOND, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    if (unit.getCalendarField() == Calendar.DAY_OF_MONTH) {\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n    }\n    else if (unit.getCalendarField() == Calendar.MONTH) {\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.MONTH, value);\n    }\n    else if (unit.getCalendarField() == Calendar.YEAR) {\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.YEAR, value);\n    }\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count - 1) / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count - 1) / count);\n    calendar.set(unit.getCalendarField(), value);\n    calendar.set(Calendar.MILLISECOND, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    if (unit.getUnitType().equals(DateTickUnitType.DAY)) {\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n    }\n    if (unit.getUnitType().equals(DateTickUnitType.MONTH)) {\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.MONTH, 0);\n    }\n    if (unit.getUnitType().equals(DateTickUnitType.YEAR)) {\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.YEAR, 0);\n    }\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count - 1) / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (this.variableResolver != null) {\n        return this.variableResolver.lookup(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String value = null;\n    if (variableResolver != null) {\n        value = variableResolver.lookup(variableName);\n    }\n    if (value == null && enableSubstitutionInVariables) {\n        final StrBuilder temp = new StrBuilder(variableName.length());\n        temp.append(variableName, 1, variableName.length() - 1);\n        value = substitute(temp, 0, temp.length());\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String value = null;\n    if (this.variableResolver != null) {\n        value = this.variableResolver.lookup(variableName);\n    }\n    if (value == null && this.enableSubstitutionInVariables) {\n        value = substitute(buf, startPos, endPos);\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (this.variableResolver == null) {\n        return null;\n    }\n    return this.variableResolver.lookup(variableName);\n}\n    // Escape",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n        if (this.variableResolver == null) {\n            return null;\n        }\n        final String value = this.variableResolver.lookup(variableName);\n        if (value == null && this.enableSubstitutionInVariables) {\n            return new StrSubstitutor(this.variableResolver).replace(variableName);\n        }\n        return value;\n    }",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n        if (variableResolver != null) {\n            return variableResolver.lookup(variableName);\n        }\n        return null;\n    }",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (this.variableResolver == null) {\n        return null;\n    }\n    return this.variableResolver.lookup(variableName);\n}\n    // Escape",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String value = null;\n    if (variableResolver != null) {\n        value = variableResolver.lookup(variableName);\n    }\n    if (value == null) {\n        value = nullText;\n    }\n    if (value != null) {\n        buf.replace(startPos, endPos, value);\n    }\n    return value;\n}\n    // Escape",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n        if (variableResolver == null) {\n            return null;\n        }\n        return variableResolver.lookup(variableName);\n    }",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String value = null;\n    if (this.variableResolver != null) {\n        value = this.variableResolver.lookup(variableName);\n    }\n    if (value == null) {\n        if (this.enableSubstitutionInVariables) {\n            value = substitute(buf, startPos, endPos);\n        } else {\n            value = \"${\" + variableName + \"}\";\n        }\n    }\n    return value;\n}\n    // Escape"
    ],
    [
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    str = str.toUpperCase();\n    char[] out = new char[4];\n    out[0] = str.charAt(0);\n    int j = 1;\n    for (int i = 1; i < str.length(); i++) \n    {\n        char ch = str.charAt(i);\n        char mappedChar = map(ch);\n        if (mappedChar != '0') \n        {\n            if (j == 1 || mappedChar != out[j - 1]) \n            {\n                out[j++] = mappedChar;\n            }\n        }\n    }\n    while (j < 4) \n    {\n        out[j++] = '0';\n    }\n    return new String(out);\n}",
      "public String soundex(String str)  {\n    char[] soundexMapping = getSoundexMapping();\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    StringBuilder sb = new StringBuilder();\n    sb.append(str.charAt(0));\n    char lastCode = map(str.charAt(0));\n    for (int i = 1; i < str.length(); i++) {\n        char ch = str.charAt(i);\n        char code = map(ch);\n        if (code != '0' && code != lastCode) {\n            sb.append(code);\n            lastCode = code;\n        }\n    }\n    while (sb.length() < 4) {\n        sb.append('0');\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    StringBuilder sb = new StringBuilder();\n    sb.append(str.substring(0, 1).toUpperCase());\n    char last = map(str.substring(0, 1).toUpperCase().charAt(0));\n    for (int i = 1; i < str.length(); i++) \n    {\n        char c = map(str.substring(i, i + 1).toUpperCase().charAt(0));\n        if (c != last) \n        {\n            sb.append(c);\n            last = c;\n        }\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase();\n    final StringBuilder sb = new StringBuilder();\n    sb.append(str.charAt(0));\n    char lastCode = map(str.charAt(0));\n    for (int i = 1; i < str.length(); i++) {\n        final char code = map(str.charAt(i));\n        if (code != '0' && code != lastCode) {\n            sb.append(code);\n            lastCode = code;\n        }\n    }\n    while (sb.length() < 4) {\n        sb.append('0');\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    str = str.toUpperCase();\n    final StringBuilder sb = new StringBuilder();\n    char last = map(str.charAt(0));\n    sb.append(last);\n    for (int i = 1; i < str.length(); i++) \n    {\n        char current = map(str.charAt(i));\n        if (current != '0' && current != last) \n        {\n            sb.append(current);\n            last = current;\n        }\n    }\n    while (sb.length() < 4) \n    {\n        sb.append('0');\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    str = str.toUpperCase();\n    char[] soundex = new char[4];\n    int index = 0;\n    char lastCode = '\\0';\n    for (char c : str.toCharArray()) \n    {\n        char code = map(c);\n        if (index == 0) \n        {\n            soundex[index++] = code;\n        } \n        else if (code != '\\0' && code != lastCode) \n        {\n            if (index < 3) \n            {\n                soundex[index++] = code;\n            } \n            else \n            {\n                break;\n            }\n        }\n        lastCode = code;\n    }\n    while (index < 4) \n    {\n        soundex[index++] = '0';\n    }\n    return new String(soundex);\n}",
      "public String soundex(String str)  {\n    StringBuilder sb = new StringBuilder();\n    char last = map(str.charAt(0));\n    sb.append(last);\n    for (int i = 1; i < str.length(); i++) \n    {\n        char current = map(str.charAt(i));\n        if (current != last) \n        {\n            sb.append(current);\n            last = current;\n        }\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    str = str.toUpperCase();\n    final StringBuilder sb = new StringBuilder();\n    sb.append(str.charAt(0));\n    char lastCode = map(str.charAt(0));\n    for (int i = 1; i < str.length(); i++) \n    {\n        final char c = str.charAt(i);\n        final char code = map(c);\n        if (code != lastCode) \n        {\n            sb.append(code);\n            lastCode = code;\n        }\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    str = str.toUpperCase();\n    char[] chars = str.toCharArray();\n    char[] result = new char[4];\n    int resultIndex = 0;\n    result[resultIndex++] = chars[0];\n    char lastCode = map(chars[0]);\n    for (int i = 1; i < chars.length; i++) \n    {\n        char code = map(chars[i]);\n        if (code != lastCode) \n        {\n            if (code != '0') \n            {\n                result[resultIndex++] = code;\n            }\n            lastCode = code;\n        }\n    }\n    while (resultIndex < 4) \n    {\n        result[resultIndex++] = '0';\n    }\n    return new String(result);\n}",
      "public String soundex(String str)  {\n    StringBuilder sb = new StringBuilder();\n    char[] chars = str.toCharArray();\n    char last = map(chars[0]);\n    sb.append(last);\n    for (int i = 1; i < chars.length; i++) {\n        char ch = map(chars[i]);\n        if (ch != last) {\n            sb.append(ch);\n            last = ch;\n        }\n    }\n    return sb.toString();\n}"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLASS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLASS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLASS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == CLASS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLASS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLASS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLASS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // 11-Feb-2015, tatu: As per [databind#700] need to be careful wrt non-default Map, List.\n    if (_factoryConfig.hasAbstractTypeResolvers()) {\n        JavaType lt = _findRemappedType(ctxt.getConfig(), List.class);\n        JavaType mt = _findRemappedType(ctxt.getConfig(), Map.class);\n        if (lt != null && mt != null) {\n            return _constructSimple(clz, TypeBindings.emptyBindings(), lt, mt);\n        }\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLASS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLASS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLASS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == CLASS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLASS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLASS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLASS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLASS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLASS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == CLASS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLASS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLASS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLASS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLASS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLASS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == CLASS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLASS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLASS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLASS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLASS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLASS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLASS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == CLASS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLASS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLASS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLASS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLASS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLASS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLASS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == CLASS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLASS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLASS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLASS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLASS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLASS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLASS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLASS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == CLASS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLASS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLASS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLASS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // 11-Feb-2015, tatu: As per [databind#700] need to be careful wrt non-default Map, List.\n    if (_factoryConfig.hasAbstractTypeResolvers()) {\n        clz = _findRemappedType(ctxt.getConfig(), clz);\n    }\n    return _unknownType();\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLASS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLASS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLASS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == CLASS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLASS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLASS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    return null;\n}"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isAssign()) {\n    Node lhs = n.getFirstChild();\n    if (lhs.isGetProp() && lhs.getFirstChild().isGetProp()) {\n      Node parent = lhs.getParent();\n      if (parent.isExprResult() && parent.getParent().isScript()) {\n        return new PrototypeMemberDeclaration(lhs, n);\n      }\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (!n.isAssign()) {\n        return null;\n    }\n\n    Node lhs = n.getFirstChild();\n    if (!lhs.isGetProp()) {\n        return null;\n    }\n\n    Node getProp = lhs.getFirstChild();\n    if (!getProp.isGetProp() || !getProp.getLastChild().isString(\"prototype\")) {\n        return null;\n    }\n\n    String className = getProp.getFirstChild().getQualifiedName();\n    return new PrototypeMemberDeclaration(lhs, n);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n      if (n.isAssign()) \n      {\n        Node lhs = n.getFirstChild();\n        if (lhs.isGetProp() && lhs.getLastChild().isString()) \n        {\n          return new PrototypeMemberDeclaration(lhs, n);\n        }\n      }\n      return null;\n    }\n  }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (!n.isAssign()) {\n        return null;\n    }\n    Node lhs = n.getFirstChild();\n    if (!lhs.isGetProp()) {\n        return null;\n    }\n    Node getProp = lhs.getFirstChild();\n    if (!getProp.isGetProp() || !getProp.getLastChild().isString(\"prototype\")) {\n        return null;\n    }\n    String className = getProp.getFirstChild().getQualifiedName();\n    return new PrototypeMemberDeclaration(getProp, n);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (!n.isAssign()) {\n        return null;\n    }\n    Node lhs = n.getFirstChild();\n    if (!lhs.isGetProp()) {\n        return null;\n    }\n    Node getProp = lhs.getFirstChild();\n    if (!getProp.isGetProp() || !getProp.getLastChild().isString(\"prototype\")) {\n        return null;\n    }\n    return new PrototypeMemberDeclaration(getProp, n);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isAssign()) {\n    Node lhs = n.getFirstChild();\n    if (lhs.isGetProp() && lhs.getFirstChild().isGetProp()) {\n      Node parent = lhs.getParent();\n      if (parent.isAssign()) {\n        Node parentLhs = parent.getFirstChild();\n        if (parentLhs.isName() && parentLhs.getString().equals(\"prototype\")) {\n          return new PrototypeMemberDeclaration(lhs, parent);\n        }\n      }\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign()) {\n        Node lhs = n.getFirstChild();\n        if (lhs.isGetProp() && lhs.getLastChild().isString()) {\n            Node getProp = lhs.getFirstChild();\n            if (getProp.isGetProp() && getProp.getLastChild().isString()) {\n                return new PrototypeMemberDeclaration(getProp, n);\n            }\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign()) {\n        Node lhs = n.getFirstChild();\n        if (lhs.isGetProp() && lhs.getLastChild().isString()) {\n            String propName = lhs.getLastChild().getString();\n            if (NodeUtil.isPrototypeProperty(lhs)) {\n                return new PrototypeMemberDeclaration(lhs, n);\n            }\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (!n.isAssign()) {\n        return null;\n    }\n\n    Node lhs = n.getFirstChild();\n    if (!lhs.isGetProp() || !lhs.getLastChild().isString()) {\n        return null;\n    }\n\n    return new PrototypeMemberDeclaration(lhs, n);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (!n.isAssign()) {\n        return null;\n    }\n\n    Node lhs = n.getFirstChild();\n    if (!lhs.isGetProp() || !lhs.getFirstChild().isGetProp()) {\n        return null;\n    }\n\n    Node parent = lhs.getParent();\n    if (!parent.isExprResult()) {\n        return null;\n    }\n\n    return new PrototypeMemberDeclaration(lhs, parent);\n}"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int nr = 0; nr < n; nr++) {\n                for (int mc = 0; mc < m; mc++) {\n                    d[r + nr * mat.getRowDimension()][c + mc * mat.getColumnDimension()] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r + i * mat.getRowDimension()][c + j * mat.getColumnDimension()] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r * n + i][c * m + j] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r + i * mat.getRowDimension()][c + j * mat.getColumnDimension()] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r + i * mat.getRowDimension()][c + j * mat.getColumnDimension()] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r + i * mat.getRowDimension()][c + j * mat.getColumnDimension()] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r + i * mat.getRowDimension()][c + j * mat.getColumnDimension()] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[r + i * mat.getRowDimension()][c + j * mat.getColumnDimension()] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int nr = 0; nr < n; nr++) {\n                for (int nc = 0; nc < m; nc++) {\n                    d[r + nr * mat.getRowDimension()][c + nc * mat.getColumnDimension()] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int nr = 0; nr < n; nr++) {\n                for (int mc = 0; mc < m; mc++) {\n                    d[r * n + nr][c * m + mc] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesInflated();\n    if (bytesInflated < 0) {\n        bytesInflated += TWO_EXP_32;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    if (current.usesZip64) {\n        return current.bytesReadFromStream;\n    }\n    final long totalBytesRead = current.bytesReadFromStream + inf.getBytesRead();\n    final long totalBytesWritten = current.bytesReadFromStream + inf.getBytesWritten();\n    return totalBytesWritten - Math.min(totalBytesRead, totalBytesWritten);\n}",
      "private long getBytesInflated()  {\n    if (inf.finished()) \n    {\n        return current.entry.getSize();\n    } \n    else \n    {\n        final long bytesReadFromStream = current.bytesReadFromStream;\n        final long bytesRead = current.bytesRead;\n        final long bytesInflated = bytesReadFromStream + bytesRead - inf.getTotalIn();\n        return bytesInflated;\n    }\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesWritten();\n    if (bytesInflated < current.bytesReadFromStream) {\n        bytesInflated = current.bytesReadFromStream;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    if (inf.finished()) {\n        return inf.getTotalIn();\n    }\n    if (inf.needsInput()) {\n        return inf.getTotalIn();\n    }\n    final int len = inf.getRemaining();\n    final long totalIn = inf.getTotalIn();\n    return totalIn - len;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesInflated();\n    if (bytesInflated < 0) {\n        bytesInflated += 2L * TWO_EXP_32;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesWritten();\n    if (bytesInflated > current.bytesRead) {\n        bytesInflated = current.bytesRead;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesInflated();\n    if (bytesInflated < 0) {\n        bytesInflated += 2L * TWO_EXP_32;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long total = inf.getBytesWritten();\n    if (total > current.entry.getSize()) {\n        total = current.entry.getSize();\n    }\n    return total;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesWritten();\n    if (bytesInflated > current.bytesRead) {\n        bytesInflated = current.bytesRead;\n    }\n    return bytesInflated;\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    int total = 0;\n    if (object instanceof Map<?,?>) \n    {\n        total = ((Map<?, ?>) object).size();\n    } \n    else if (object instanceof Collection<?>) \n    {\n        total = ((Collection<?>) object).size();\n    } \n    else if (object instanceof Iterable<?>) \n    {\n        total = IterableUtils.size((Iterable<?>) object);\n    } \n    else if (object instanceof Object[]) \n    {\n        total = ((Object[]) object).length;\n    } \n    else if (object instanceof Iterator<?>) \n    {\n        total = IteratorUtils.size((Iterator<?>) object);\n    } \n    else if (object instanceof Enumeration<?>) \n    {\n        final Enumeration<?> it = (Enumeration<?>) object;\n        while (it.hasMoreElements()) \n        {\n            total++;\n            it.nextElement();\n        }\n    } \n    else \n    {\n        try \n        {\n            total = Array.getLength(object);\n        } \n        catch (final IllegalArgumentException ex) \n        {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n    return total == 0;\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    int total = 0;\n    if (object instanceof Map<?,?>) \n    {\n        total = ((Map<?, ?>) object).isEmpty();\n    } \n    else if (object instanceof Collection<?>) \n    {\n        total = ((Collection<?>) object).isEmpty();\n    } \n    else if (object instanceof Iterable<?>) \n    {\n        total = IterableUtils.isEmpty((Iterable<?>) object);\n    } \n    else if (object instanceof Object[]) \n    {\n        total = ((Object[]) object).length == 0;\n    } \n    else if (object instanceof Iterator<?>) \n    {\n        total = IteratorUtils.isEmpty((Iterator<?>) object);\n    } \n    else if (object instanceof Enumeration<?>) \n    {\n        final Enumeration<?> it = (Enumeration<?>) object;\n        while (it.hasMoreElements()) \n        {\n            total++;\n            it.nextElement();\n        }\n    } \n    else \n    {\n        try \n        {\n            total = Array.getLength(object) == 0;\n        } \n        catch (final IllegalArgumentException ex) \n        {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n    return total == 0;\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    if (object instanceof NodeList) \n    {\n        return ((NodeList) object).getLength() == 0;\n    }\n    if (object instanceof Node) \n    {\n        return ((Node) object).getChildNodes().getLength() == 0;\n    }\n    if (object instanceof Dictionary) \n    {\n        return ((Dictionary<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Iterable<?>) \n    {\n        return !((Iterable<?>) object).iterator().hasNext();\n    }\n    if (object.getClass().isArray()) \n    {\n        return Array.getLength(object) == 0;\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    int total = 0;\n    if (object instanceof Map<?,?>) {\n        total = ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        total = ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        total = IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        total = ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        total = IteratorUtils.isEmpty((Iterator<?>) object);\n    } else if (object instanceof Enumeration<?>) {\n        final Enumeration<?> it = (Enumeration<?>) object;\n        while (it.hasMoreElements()) {\n            total++;\n            it.nextElement();\n        }\n    } else {\n        try {\n            total = Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n    return total == 0;\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    int total = 0;\n    if (object instanceof Map<?,?>) \n    {\n        total = ((Map<?, ?>) object).size();\n    } \n    else if (object instanceof Collection<?>) \n    {\n        total = ((Collection<?>) object).size();\n    } \n    else if (object instanceof Iterable<?>) \n    {\n        total = IterableUtils.size((Iterable<?>) object);\n    } \n    else if (object instanceof Object[]) \n    {\n        total = ((Object[]) object).length;\n    } \n    else if (object instanceof Iterator<?>) \n    {\n        total = IteratorUtils.size((Iterator<?>) object);\n    } \n    else if (object instanceof Enumeration<?>) \n    {\n        final Enumeration<?> it = (Enumeration<?>) object;\n        while (it.hasMoreElements()) \n        {\n            total++;\n            it.nextElement();\n        }\n    } \n    else \n    {\n        try \n        {\n            total = Array.getLength(object);\n        } \n        catch (final IllegalArgumentException ex) \n        {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n    return total == 0;\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Map<?,?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    } \n    else if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    } \n    else if (object instanceof Iterable<?>) \n    {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } \n    else if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    } \n    else if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    } \n    else if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } \n    else \n    {\n        try \n        {\n            return Array.getLength(object) == 0;\n        } \n        catch (final IllegalArgumentException ex) \n        {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n  if (name.isEmpty()) {\n    return false;\n  }\n\n  // Namespaces must be valid simple names.\n  if (name.contains(\".\")) {\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n      if (!isValidSimpleName(part)) {\n        return false;\n      }\n    }\n  } else {\n    return isValidSimpleName(name);\n  }\n\n  return true;\n}\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name) ||\n        (name.indexOf('.') > 0 &&\n         isValidQualifiedName(name.substring(0, name.indexOf('.'))));\n  }\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.isEmpty()) {\n      return false;\n    }\n\n    // Check for invalid characters in the name.\n    if (!isValidSimpleName(name)) {\n      return false;\n    }\n\n    // Check for invalid characters in the name.\n    if (name.indexOf(\"..\") != -1) {\n      return false;\n    }\n\n    // Check for invalid characters in the name.\n    if (name.startsWith(\".\") || name.endsWith(\".\")) {\n      return false;\n    }\n\n    // Check for invalid characters in the name.\n    if (name.startsWith(\"-\") || name.endsWith(\"-\")) {\n      return false;\n    }\n\n    // Check for invalid characters in the name.\n    if (name.startsWith(\"_\") || name.endsWith(\"_\")) {\n      return false;\n    }\n\n    // Check for invalid characters in the name.\n    if (name.startsWith(\"$\") || name.endsWith(\"$\")) {\n      return false;\n    }\n\n    // Check for invalid characters in the name.\n    if (name.startsWith(\"@\") || name.endsWith(\"@\")) {\n      return false;\n    }\n\n    // Check for invalid characters in the name.\n    if (name.startsWith(\"!\") || name.endsWith(\"!\")) {\n      return false;\n    }\n\n    // Check for invalid characters in the name.\n    if (name.startsWith(\"?\") || name.endsWith(\"?\")) {\n      return false;\n    }\n\n    // Check for invalid characters in the name.\n    if (name.startsWith(\"+\") || name.endsWith(\"+\")) {\n      return false;\n    }\n\n    // Check for invalid characters in the name.\n    if (name.startsWith(\"-\") || name.endsWith(\"-\")) {\n      return false;\n    }\n\n    // Check for invalid characters in the name.\n    if (name.startsWith(\"*\") || name.endsWith(\"*\")) {\n      return false;\n    }\n\n    // Check for invalid characters in the name.\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.isEmpty()) \n    {\n      return false;\n    }\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) \n    {\n      if (!isValidSimpleName(part)) \n      {\n        return false;\n      }\n    }\n    return true;\n  }\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (!isValidSimpleName(name)) \n    {\n        return false;\n    }\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) \n    {\n        if (!isValidPropertyName(part)) \n        {\n            return false;\n        }\n    }\n    return true;\n}\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n  int len = name.length();\n  if (len == 0) {\n    return false;\n  }\n  int index = 0;\n  while (index < len) {\n    if (!isValidSimpleName(name.substring(index))) {\n      return false;\n    }\n    index += name.substring(index).indexOf('.') + 1;\n    if (index == len) {\n      break;\n    }\n    if (name.charAt(index) != '.') {\n      return false;\n    }\n    index++;\n  }\n  return true;\n}\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    int len = name.length();\n    if (len == 0) {\n      return false;\n    }\n\n    // Check that the first character is a valid identifier start.\n    if (!TokenStream.isJSIdentifierStart(name.charAt(0))) {\n      return false;\n    }\n\n    // Check that the rest of the characters are valid identifier parts.\n    for (int index = 1; index < len; index++) {\n      if (!TokenStream.isJSIdentifierPart(name.charAt(index))) {\n        return false;\n      }\n    }\n\n    // No Unicode escaped characters - some browsers are less tolerant\n    // of Unicode characters that might be valid according to the\n    // language spec.\n    // Note that by this point, Unicode escapes have been converted\n    // to UTF-16 characters, so we're only searching for character\n    // values, not escapes.\n    return isLatin(name);\n  }\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    int index = 0;\n    int len = name.length();\n    while (index < len) \n    {\n      index = name.indexOf('.', index);\n      if (index == -1) \n      {\n        return isValidSimpleName(name);\n      }\n      if (!isValidSimpleName(name.substring(0, index))) \n      {\n        return false;\n      }\n      index++;\n    }\n    return false;\n  }\n}"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = matrixT[iu][iu];\n    double q = matrixT[iu - 1][iu];\n    double r = 0.0;\n    if (il < iu - 1) {\n        r = matrixT[iu - 2][iu - 1];\n    }\n\n    // Compute shift\n    computeShift(il, iu, 0, shift);\n\n    // Compute initial vector\n    hVec[0] = p - shift.x;\n    hVec[1] = q;\n    if (il < iu - 1) {\n        hVec[2] = r;\n    }\n\n    // Compute Householder reflection\n    double norm = FastMath.sqrt(hVec[0] * hVec[0] + hVec[1] * hVec[1] + hVec[2] * hVec[2]);\n    if (norm == 0.0) {\n        return iu - 1;\n    }\n    hVec[0] /= norm;\n    hVec[1] /= norm;\n    hVec[2] /= norm;\n\n    // Compute Householder matrix\n    double[][] H = new double[n][n];\n    for (int i = il; i <= iu; i++) {\n        H[i][i] = 1.0;\n    }\n    H[iu][iu] -= 2.0 * hVec[0] * hVec[0];\n    H[iu - 1][iu - 1] -= 2.0 * hVec[1] * hVec[1];\n    if (il < iu - 1) {\n        H[iu - 2][iu - 2] -= 2.0 * hVec[2] * hVec[2];\n    }\n    H[iu][iu - 1] -= hVec[0] * hVec[1];\n    H[iu - 1][iu] -= hVec[1] * hVec[0];\n    if (il < iu - 1) {\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = matrixT[iu][iu];\n    double q = matrixT[iu - 1][iu];\n    double r = 0.0;\n    if (il < iu - 1) {\n        r = matrixT[iu - 2][iu - 1];\n    }\n    shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n    if (shift.x == 0.0) {\n        shift.x = norm;\n    }\n    p = p / shift.x;\n    q = q / shift.x;\n    r = r / shift.x;\n    double tau = FastMath.sqrt(p * p + q * q + r * r);\n    if (p < 0.0) {\n        tau = -tau;\n    }\n    hVec[0] = tau * p;\n    hVec[1] = tau * q;\n    hVec[2] = tau * r;\n    return il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu;\n    if (il < iu) {\n        double hNorm = FastMath.abs(matrixT[il][il]) + FastMath.abs(matrixT[il + 1][il]);\n        if (hNorm == 0.0) {\n            hNorm = norm;\n        }\n        if (FastMath.abs(matrixT[il + 1][il]) < epsilon * hNorm) {\n            hVec[0] = matrixT[il][il];\n            hVec[1] = matrixT[il + 1][il];\n            hVec[2] = 0.0;\n            im = il;\n        }\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu - 1;\n    if (il < iu - 1) {\n        double x = matrixT[iu - 1][iu - 1];\n        double y = matrixT[iu][iu - 1];\n        double z = matrixT[iu][iu];\n        if (y != 0.0) {\n            double t = (z - x) / y;\n            double r = FastMath.sqrt(t * t + 1.0);\n            if (t < 0.0) {\n                r = -r;\n            }\n            t = y / (z - x - r * r);\n            hVec[0] = 1.0 / (t + r);\n            hVec[1] = t * hVec[0];\n            hVec[2] = -r * hVec[0];\n            im = iu - 2;\n        } else {\n            hVec[0] = 1.0;\n            hVec[1] = 0.0;\n            hVec[2] = 0.0;\n        }\n    } else {\n        hVec[0] = 1.0;\n        hVec[1] = 0.0;\n        hVec[2] = 0.0;\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = 0.0;\n    double q = 0.0;\n    double r = 0.0;\n    int im = iu;\n\n    // Compute shift\n    computeShift(il, iu, 0, shift);\n\n    // Compute the Householder transformation for the current QR step\n    for (int k = iu - 1; k >= il; k--) {\n        double ek = matrixT[k][k] - shift.x;\n        double fk = matrixT[k + 1][k] - shift.x;\n        if (k == iu - 1) {\n            hVec[0] = ek;\n            hVec[1] = fk;\n            hVec[2] = 0.0;\n        } else {\n            double gk = matrixT[k + 2][k] - shift.x;\n            double sk = (ek * ek + fk * fk + gk * gk) / 3.0;\n            double tk = sk - shift.w;\n            if (tk == 0.0) {\n                if (ek < fk) {\n                    tk = -fk;\n                } else {\n                    tk = -ek;\n                }\n            }\n            double ak = ek - tk;\n            double bk = fk - tk;\n            double ck = gk - tk;\n            double absAk = FastMath.abs(ak);\n            double absBk = FastMath.abs(bk);\n            double absCk = FastMath.abs(ck);\n            double maxAbs = FastMath.max(absAk, FastMath.max(absBk, absCk));\n            if (maxAbs == absAk) {\n                p = bk / ak;\n                q = ck / ak;\n            } else if (maxAbs == absBk) {\n                p = 1.0;\n                q = ck / bk;\n            } else {\n                p = ak / ck;\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu;\n    double x = 0.0;\n    double y = 0.0;\n    double z = 0.0;\n    double eps = epsilon;\n\n    if (il < iu) {\n        double scale = 0.0;\n        for (int i = il; i < iu; i++) {\n            scale += FastMath.abs(matrixT[i][i]);\n        }\n        if (scale == 0.0) {\n            scale = norm;\n        }\n\n        for (int i = iu - 1; i >= il; i--) {\n            double h = scale * matrixT[i][i];\n            double t = h + shift.y;\n            shift.y = h - shift.y;\n            shift.x = shift.w;\n            shift.w = -z;\n            z = y;\n            y = x;\n            x = scale * matrixT[i][i + 1];\n            double s = FastMath.abs(x) + FastMath.abs(y);\n            if (s == 0.0) {\n                continue;\n            }\n            if (FastMath.abs(y) >= FastMath.abs(x)) {\n                x /= s;\n                y /= s;\n                z /= s;\n                t /= s;\n            } else {\n                double u = y / x;\n                y /= s;\n                z /= s;\n                t /= s;\n                x = 1.0 + u;\n            }\n            if (t < 0.0) {\n                x = -x;\n                y = -y;\n                z = -z;\n                t = -t;\n            }\n            matrixT[i][i + 1] = x;\n            shift.y = y + z * t;\n            matrixT[i + 1][i] = shift.y;\n            matrixT[i + 1][i + 1] = t;\n            if (i > il) {\n                matrixT[i][i - 1] = z;\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = matrixT[iu][iu];\n    double q = matrixT[iu - 1][iu];\n    double r = matrixT[iu - 2][iu - 1];\n\n    // Compute shift\n    computeShift(il, iu, 0, shift);\n\n    // Compute Householder transformation\n    double s = p - shift.x;\n    double t = q / s;\n    double u = r / s;\n    double v = matrixT[iu - 2][iu];\n    double w = 0.0;\n    double x = 0.0;\n    double y = 0.0;\n    double z = 0.0;\n\n    if (FastMath.abs(u) > FastMath.abs(v)) {\n        x = u / v;\n        w = x * x + 1.0;\n        y = FastMath.sqrt(w);\n        z = x * (y - 1.0) / y;\n    } else if (u != 0.0) {\n        y = v / u;\n        w = y * y + 1.0;\n        x = FastMath.sqrt(w);\n        z = y * (x - 1.0) / x;\n    } else {\n        z = 0.0;\n    }\n\n    if (u < 0.0) {\n        z = -z;\n    }\n\n    if (v != 0.0 || z != 0.0) {\n        hVec[0] = s * z;\n        hVec[1] = t * z;\n        hVec[2] = z;\n    } else {\n        hVec[0] = s;\n        hVec[1] = t;\n        hVec[2] = 0.0;\n    }\n\n    return il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = 0.0;\n    double q = 0.0;\n    double r = 0.0;\n    int im = iu;\n\n    // Compute shift\n    computeShift(il, iu, 0, shift);\n\n    // Find the first small sub-diagonal element and its index\n    im = findSmallSubDiagonalElement(il, getNorm());\n\n    // Check for convergence\n    if (im == iu) {\n        // One root found\n        matrixT[iu][iu] += shift.exShift;\n        iu--;\n    } else if (im == iu - 1) {\n        // Two roots found\n        p = (matrixT[iu - 1][iu - 1] - matrixT[iu][iu]) / 2.0;\n        q = p * p + matrixT[iu][iu - 1] * matrixT[iu - 1][iu];\n        matrixT[iu][iu] += shift.exShift;\n        matrixT[iu - 1][iu - 1] += shift.exShift;\n    }\n\n    // Initialize the householder vectors for the QR step\n    if (im != iu) {\n        p = matrixT[im][im - 1];\n        q = matrixT[im + 1][im - 1];\n        r = (im + 2 < n) ? matrixT[im + 2][im - 1] : 0.0;\n        shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n        if (!Precision.equals(shift.x, 0.0, epsilon)) {\n            p = p / shift.x;\n            q = q / shift.x;\n            r = r / shift.x;\n        }\n    }\n\n    hVec[0] = p;\n    hVec[1] = q;\n    hVec[2] = r;\n\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu;\n    if (il < iu) {\n        double s = matrixT[im][im - 1];\n        if (FastMath.abs(s) > epsilon) {\n            hVec[0] = s;\n            hVec[1] = matrixT[im + 1][im - 1];\n            hVec[2] = matrixT[im + 2][im - 1];\n            computeShift(il, im, 0, shift);\n            im = im - 1;\n        }\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu;\n    if (il < iu) {\n        double x = matrixT[im][im - 1];\n        double y = matrixT[im + 1][im - 1];\n        double z = matrixT[im + 2][im - 1];\n        if (x == 0.0 && y == 0.0 && z == 0.0) {\n            im--;\n        } else {\n            double s = FastMath.sqrt(x * x + y * y + z * z);\n            if (x < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (im != iu) {\n                    matrixT[im][im - 1] = -s * shift.x;\n                } else if (il != im) {\n                    matrixT[im][im - 1] = -matrixT[im][im - 1];\n                }\n                x = x + s;\n                shift.x = x / s;\n                shift.y = y / s;\n                double zz = z / s;\n                y = y / x;\n                z = z / x;\n                for (int k = im; k <= iu; k++) {\n                    double p = matrixT[k][k - 1];\n                    double q = matrixT[k + 1][k - 1];\n                    double r = matrixT[k + 2][k - 1];\n                    hVec[0] = p - shift.x * q;\n                    hVec[1] = q - shift.x * r;\n                    hVec[2] = r - shift.x * zz;\n                    double tau = FastMath.sqrt(hVec[0] * hVec[0] + hVec[1] * hVec[1] + hVec[2] * hVec[2]);\n                    if (tau != 0.0) {\n                        tau = 1.0 / tau;\n}\n}\n}\n}\n}\n}"
    ],
    [
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inExceptionSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inExceptionSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inExceptionSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inExceptionSegments() && !segment.inIncludeSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inExceptionSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inExceptionSegments() && !segment.inIncludeSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inExceptionSegments() && !segment.inIncludeSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inExceptionSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inExceptionSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inExceptionSegments() || !segment.inIncludeSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same field count\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePeriod zeroInstance must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = 0;\n    for (int i = 0; i < start.size(); i++) {\n        DateTimeField field = start.getField(i);\n        amount += field.getDifference(end.getValue(i), start.getValue(i));\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same number of fields\");\n    }\n    int amount = 0;\n    for (int i = 0; i < start.size(); i++) \n    {\n        DateTimeFieldType fieldType = start.getFieldType(i);\n        int startValue = start.getValue(i);\n        int endValue = end.getValue(i);\n        amount += fieldType.getField(zeroInstance.getChronology()).getDifference(endValue, startValue);\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same number of fields\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = 0;\n    for (int i = 0; i < start.size(); i++) {\n        DateTimeField field = start.getField(i);\n        amount += field.getDifference(end.getValue(i), start.getValue(i));\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = 0;\n    for (int i = 0; i < zeroInstance.size(); i++) \n    {\n        amount += zeroInstance.getFieldType(i).getField(chrono).getDifference(end.getValue(i), start.getValue(i));\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same number of fields\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = 0;\n    for (int i = 0; i < start.size(); i++) {\n        DateTimeField field = start.getField(i);\n        if (!field.isSupported(end.getFieldType(i))) {\n            throw new IllegalArgumentException(\"Field types must be compatible\");\n        }\n        amount += field.getDifference(end.getValue(i), start.getValue(i));\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same field count\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = 0;\n    for (int i = 0; i < start.size(); i++) {\n        DateTimeField field = start.getField(i);\n        if (field.isSupported(end.getFieldType(i))) {\n            amount += field.getDifference(end.getValue(i), start.getValue(i));\n        }\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same number of fields\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = 0;\n    for (int i = 0; i < start.size(); i++) {\n        DateTimeField field = start.getField(i);\n        amount += field.getDifference(end.getValue(i), start.getValue(i));\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same number of fields\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = 0;\n    for (int i = 0; i < start.size(); i++) {\n        DateTimeField field = start.getField(i);\n        if (!field.isSupported(end.getFieldType(i))) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same fields\");\n        }\n        amount += field.getDifference(end.getValue(i), start.getValue(i));\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same number of fields\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = 0;\n    for (int i = 0; i < start.size(); i++) \n    {\n        DateTimeField field = start.getField(i);\n        if (!field.isSupported(end.getFieldType(i))) \n        {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same fields\");\n        }\n        amount += field.getDifference(end.getValue(i), start.getValue(i));\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same number of fields\");\n    }\n    int amount = 0;\n    for (int i = 0; i < start.size(); i++) {\n        DateTimeFieldType fieldType = start.getFieldType(i);\n        int startValue = start.getValue(i);\n        int endValue = end.getValue(i);\n        amount += fieldType.getField(start.getChronology()).getDifference(endValue, startValue);\n    }\n    return amount;\n}"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    LegendTitle result = null;\n    if (this.subtitles != null) {\n        for (int i = 0; i < this.subtitles.size(); i++) {\n            Object o = this.subtitles.get(i);\n            if (o instanceof LegendTitle) {\n                if (index == 0) {\n                    result = (LegendTitle) o;\n                    break;\n                }\n                index--;\n            }\n        }\n    }\n    return result;\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle result = null;\n    if (this.subtitles != null) {\n        for (int i = 0; i < this.subtitles.size(); i++) {\n            Object obj = this.subtitles.get(i);\n            if (obj instanceof LegendTitle) {\n                LegendTitle lt = (LegendTitle) obj;\n                if (lt.getPosition() == RectangleEdge.BOTTOM) {\n                    result = lt;\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle result = null;\n    if (this.subtitles != null) {\n        for (int i = 0; i < this.subtitles.size(); i++) {\n            Title subtitle = (Title) this.subtitles.get(i);\n            if (subtitle instanceof LegendTitle) {\n                if (i == index) {\n                    result = (LegendTitle) subtitle;\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle result = null;\n    if (this.subtitles != null) {\n        for (int i = 0; i < this.subtitles.size(); i++) {\n            Object obj = this.subtitles.get(i);\n            if (obj instanceof LegendTitle) {\n                LegendTitle lt = (LegendTitle) obj;\n                if (lt.getPosition() == RectangleEdge.BOTTOM) {\n                    if (index == 0) {\n                        result = lt;\n                        break;\n                    }\n                    index--;\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle result = null;\n    if (this.subtitles != null) \n    {\n        for (int i = 0; i < this.subtitles.size(); i++) \n        {\n            Title t = (Title) this.subtitles.get(i);\n            if (t instanceof LegendTitle) \n            {\n                if (index == 0) \n                {\n                    result = (LegendTitle) t;\n                    break;\n                }\n                index--;\n            }\n        }\n    }\n    return result;\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle result = null;\n    if (this.subtitles != null) \n    {\n        for (int i = 0; i < this.subtitles.size(); i++) \n        {\n            Object obj = this.subtitles.get(i);\n            if (obj instanceof LegendTitle) \n            {\n                LegendTitle lt = (LegendTitle) obj;\n                if (lt.getIndex() == index) \n                {\n                    result = lt;\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle result = null;\n    if (this.subtitles != null) {\n        for (int i = 0; i < this.subtitles.size(); i++) {\n            Title t = (Title) this.subtitles.get(i);\n            if (t instanceof LegendTitle) {\n                if (i == index) {\n                    result = (LegendTitle) t;\n                    break;\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles == null) {\n        return null;\n    }\n    int legendCount = 0;\n    for (int i = 0; i < this.subtitles.size(); i++) {\n        Title subtitle = (Title) this.subtitles.get(i);\n        if (subtitle instanceof LegendTitle) {\n            legendCount++;\n            if (legendCount - 1 == index) {\n                return (LegendTitle) subtitle;\n            }\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    LegendTitle result = null;\n    if (this.subtitles != null) \n    {\n        for (int i = 0; i < this.subtitles.size(); i++) \n        {\n            Title t = (Title) this.subtitles.get(i);\n            if (t instanceof LegendTitle) \n            {\n                if (index == 0) \n                {\n                    result = (LegendTitle) t;\n                    break;\n                }\n                index--;\n            }\n        }\n    }\n    return result;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles == null) {\n        return null;\n    }\n    LegendTitle result = null;\n    for (int i = 0; i < this.subtitles.size(); i++) {\n        Title subtitle = (Title) this.subtitles.get(i);\n        if (subtitle instanceof LegendTitle) {\n            if (i == index) {\n                result = (LegendTitle) subtitle;\n                break;\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return Collections.enumeration(entries);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return Collections.enumeration(entries);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return Collections.enumeration(entries);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return Collections.enumeration(entries);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return Collections.enumeration(entries);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        return Collections.enumeration(entries);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) \n    {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) \n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } \n      else \n      {\n        next();\n      }\n    }\n\n    return typeNode;\n  } \n  else \n  {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } else {\n                next();\n            }\n        }\n\n        return typeNode;\n    } else {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) \n    {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) \n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } \n      else \n      {\n        next();\n      }\n    }\n\n    return typeNode;\n  } \n  else \n  {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  ",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) \n    {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) \n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } \n      else \n      {\n        next();\n      }\n    }\n\n    return typeNode;\n  } \n  else \n  {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) \n    {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) \n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } \n      else \n      {\n        next();\n      }\n    }\n\n    return typeNode;\n  } \n  else \n  {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  } else {\n    return parseTypeExpression(token);\n  }\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    Throwable cause = t;\n    while (cause != null) \n    {\n        for (final StackTraceElement element : cause.getStackTrace()) \n        {\n            list.add(element.toString());\n        }\n        cause = cause.getCause();\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    Throwable throwable = t;\n    while (throwable != null) \n    {\n        for (final StackTraceElement element : throwable.getStackTrace()) \n        {\n            list.add(element.toString());\n        }\n        throwable = throwable.getCause();\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    Throwable cause = t;\n    while (cause != null) \n    {\n        for (final StackTraceElement element : cause.getStackTrace()) \n        {\n            list.add(element.toString());\n        }\n        cause = cause.getCause();\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    if (t == null) \n    {\n        return Collections.emptyList();\n    }\n    final List<String> list = new ArrayList<String>();\n    Throwable cause = t;\n    while (cause != null) \n    {\n        for (final StackTraceElement element : cause.getStackTrace()) \n        {\n            list.add(element.toString());\n        }\n        cause = cause.getCause();\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    if (t == null) \n    {\n        return null;\n    }\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    while (frames.hasMoreTokens()) \n    {\n        list.add(frames.nextToken());\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    Throwable throwable = t;\n    while (throwable != null) \n    {\n        for (final StackTraceElement element : throwable.getStackTrace()) \n        {\n            list.add(element.toString());\n        }\n        throwable = throwable.getCause();\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    if (t == null) \n    {\n        return Collections.emptyList();\n    }\n    final List<String> list = new ArrayList<String>();\n    Throwable cause = t;\n    while (cause != null) \n    {\n        for (final StackTraceElement element : cause.getStackTrace()) \n        {\n            list.add(element.toString());\n        }\n        cause = cause.getCause();\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    Throwable throwable = t;\n    while (throwable != null) \n    {\n        for (final StackTraceElement element : throwable.getStackTrace()) \n        {\n            list.add(element.toString());\n        }\n        throwable = throwable.getCause();\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    if (t == null) {\n        return new ArrayList<String>();\n    }\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    while (frames.hasMoreTokens()) {\n        list.add(frames.nextToken());\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    if (t == null) {\n        return new ArrayList<String>();\n    }\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    while (frames.hasMoreTokens()) {\n        list.add(frames.nextToken());\n    }\n    return list;\n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) \n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } \n  else if (p == PEEKED_FALSE) \n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) \n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  }\n  else if (p == PEEKED_FALSE) \n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  else \n  {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    }\n    if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) \n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  }\n  else if (p == PEEKED_FALSE) \n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  else \n  {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) \n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  }\n  if (p == PEEKED_FALSE) \n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) \n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } \n  else if (p == PEEKED_FALSE) \n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node args = call.getLastChild();\n  for (Node arg = args.getFirstChild(); arg != null; arg = arg.getNext()) \n  {\n    if (NodeUtil.mayHaveSideEffects(arg)) \n    {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getSecondChild(); arg != null; arg = arg.getNext()) \n  {\n    if (NodeUtil.mayHaveSideEffects(arg)) \n    {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node args = call.getLastChild();\n  for (Node arg = args.getFirstChild(); arg != null; arg = arg.getNext()) \n  {\n    if (NodeUtil.mayHaveSideEffects(arg)) \n    {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg : call.getSecondChild().children()) \n  {\n    if (NodeUtil.mayHaveSideEffects(arg)) \n    {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node args = call.getLastChild();\n  for (Node arg = args.getFirstChild(); arg != null; arg = arg.getNext()) \n  {\n    if (NodeUtil.mayHaveSideEffects(arg)) \n    {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node args = call.getSecondChild();\n  for (Node arg = args.getFirstChild(); arg != null; arg = arg.getNext()) \n  {\n    if (NodeUtil.mayHaveSideEffects(arg)) \n    {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node args = call.getLastChild();\n  for (Node arg = args.getFirstChild(); arg != null; arg = arg.getNext()) \n  {\n    if (NodeUtil.mayHaveSideEffects(arg)) \n    {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg : call.children()) \n  {\n    if (NodeUtil.mayHaveSideEffects(arg, compiler)) \n    {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getSecondChild(); arg != null; arg = arg.getNext()) \n  {\n    if (NodeUtil.mayHaveSideEffects(arg)) \n    {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node args = call.getSecondChild();\n  for (Node arg = args.getFirstChild(); arg != null; arg = arg.getNext()) \n  {\n    if (NodeUtil.mayHaveSideEffects(arg)) \n    {\n      return true;\n    }\n  }\n  return false;\n}"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}\n    }"
    ],
    [
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (!eol && !isDelimiter(ch) && !isEndOfFile(ch)) {\n        if (isEscape(ch)) {\n            ch = readEscape();\n        }\n        token.content.append((char) ch);\n        ch = reader.read();\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (!eol && !isDelimiter(ch) && !isEndOfFile(ch)) {\n        if (isEscape(ch)) {\n            ch = readEscape();\n        }\n        token.content.append((char) ch);\n        ch = reader.read();\n    }\n    if (isDelimiter(ch)) {\n        token.type = TOKEN;\n    } else if (eol) {\n        token.type = EORECORD;\n    } else if (isEndOfFile(ch)) {\n        token.type = EOF;\n        token.isReady = true; // there is data at EOF\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (true) \n    {\n        c = reader.read();\n        if (isDelimiter(c)) \n        {\n            // empty token return TOKEN(\"\")\n            token.type = TOKEN;\n            break;\n        } \n        else if (eol) \n        {\n            // empty token return EORECORD(\"\")\n            // noop: token.content.append(\"\");\n            token.type = EORECORD;\n            break;\n        } \n        else if (isEndOfFile(c)) \n        {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            break;\n        } \n        else if (isEscape(c)) \n        {\n            c = readEscape();\n            if (isDelimiter(c)) \n            {\n                // escaped delimiter\n                token.content.append(c);\n            } \n            else \n            {\n                // escaped char\n                token.content.append((char) c);\n            }\n        } \n        else \n        {\n            // normal char\n            token.content.append((char) c);\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (true) \n    {\n        c = reader.read();\n        if (isDelimiter(c)) \n        {\n            // empty token return TOKEN(\"\")\n            token.type = TOKEN;\n            break;\n        } \n        else if (eol) \n        {\n            // empty token return EORECORD(\"\")\n            // noop: token.content.append(\"\");\n            token.type = EORECORD;\n            break;\n        } \n        else if (isEndOfFile(c)) \n        {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            break;\n        } \n        else \n        {\n            token.content.append((char) c);\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (true) {\n        c = reader.read();\n        if (isDelimiter(c)) {\n            // end of token reached\n            token.type = TOKEN;\n            break;\n        } else if (eol) {\n            // end of record reached\n            token.type = EORECORD;\n            break;\n        } else if (isEndOfFile(c)) {\n            // end of file reached\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            break;\n        } else if (isEscape(c)) {\n            // escape character found\n            ch = readEscape();\n        } else if (isQuoteChar(c)) {\n            // quote character found\n            token.type = INVALID; // invalid token\n            break;\n        } else if (isCommentStart(c)) {\n            // comment character found\n            token.type = COMMENT;\n            break;\n        } else if (isWhitespace(c)) {\n            // ignore white spaces\n            continue;\n        } else {\n            // append char to token content\n            token.content.append((char) c);\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (!eol && !isDelimiter(ch) && !isEndOfFile(ch)) {\n        if (isEscape(ch)) {\n            ch = readEscape();\n        }\n        token.content.append((char) ch);\n        ch = reader.read();\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) \n    {\n        if (isDelimiter(ch)) \n        {\n            token.type = TOKEN;\n            break;\n        } \n        else if (eol) \n        {\n            token.type = EORECORD;\n            break;\n        } \n        else if (isEscape(ch)) \n        {\n            ch = readEscape();\n        } \n        else if (isEndOfFile(ch)) \n        {\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            break;\n        } \n        else \n        {\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (token.type == INVALID) {\n        // ignore whitespaces at beginning of a token\n        if (ignoreSurroundingSpaces) {\n            while (isWhitespace(c) && !eol) {\n                c = reader.read();\n                eol = readEndOfLine(c);\n            }\n        }\n\n        // ok, start of token reached: encapsulated, or token\n        if (isDelimiter(c)) {\n            // empty token return TOKEN(\"\")\n            token.type = TOKEN;\n        } else if (eol) {\n            // empty token return EORECORD(\"\")\n            // noop: token.content.append(\"\");\n            token.type = EORECORD;\n        } else if (isQuoteChar(c)) {\n            // consume encapsulated token\n            parseEncapsulatedToken(token);\n        } else if (isEndOfFile(c)) {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n        } else {\n            // next token must be a simple token\n            // add removed blanks when not ignoring whitespace chars...\n            while (!isDelimiter(c) && !eol && !isEndOfFile(c)) {\n                if (isEscape(c)) {\n                    c = readEscape();\n                }\n                token.content.append((char) c);\n                c = reader.read();\n            }\n            // end of token reached: return TOKEN\n            token.type = TOKEN;\n        }\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (!eol && !isDelimiter(ch) && !isEndOfFile(ch)) {\n        if (isEscape(ch)) {\n            ch = readEscape();\n        }\n        token.content.append((char) ch);\n        ch = reader.read();\n    }\n    if (isDelimiter(ch)) {\n        token.type = TOKEN;\n    } else if (eol) {\n        token.type = EORECORD;\n    } else if (isEndOfFile(ch)) {\n        token.type = EOF;\n        token.isReady = true; // there is data at EOF\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (true) \n    {\n        c = reader.read();\n        if (isDelimiter(c)) \n        {\n            // empty token return TOKEN(\"\")\n            token.type = TOKEN;\n            break;\n        } \n        else if (eol) \n        {\n            // empty token return EORECORD(\"\")\n            // noop: token.content.append(\"\");\n            token.type = EORECORD;\n            break;\n        } \n        else if (isEndOfFile(c)) \n        {\n            // end of file return EOF()\n            // noop: token.content.append(\"\");\n            token.type = EOF;\n            token.isReady = true; // there is data at EOF\n            break;\n        } \n        else if (isEscape(c)) \n        {\n            // escape character found\n            c = readEscape();\n        } \n        else if (isQuoteChar(c)) \n        {\n            // end of token reached\n            break;\n        } \n        else \n        {\n            // add char to token\n            token.content.append((char) c);\n        }\n    }\n    return token;\n}"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n\n    int[] counts = new int[dimension];\n    int tempIndex = index;\n\n    for (int i = 0; i < dimension; i++) \n    {\n        counts[i] = tempIndex / uniCounterOffset[i];\n        tempIndex %= uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n\n    int[] counts = new int[dimension];\n    int tempIndex = index;\n    for (int i = 0; i < dimension; i++) \n    {\n        counts[i] = tempIndex / uniCounterOffset[i];\n        tempIndex %= uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) \n    {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int tempIndex = index;\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = tempIndex / uniCounterOffset[i];\n        tempIndex %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) \n    {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) \n    {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) \n    {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int tempIndex = index;\n    for (int i = 0; i < dimension; i++) \n    {\n        counts[i] = tempIndex / uniCounterOffset[i];\n        tempIndex %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) \n    {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return counts;\n}"
    ],
    [
      "public JsonPointer last()  {\n    JsonPointer h = _head;\n    if (h == null) {\n        if (this != EMPTY) {\n            h = _constructHead();\n        }\n        _head = h;\n    }\n    return h;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = _nextSegment;\n    while (last != null && last._nextSegment != null) \n    {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = _nextSegment;\n    if (tail == null) {\n        return this;\n    }\n    while (tail._nextSegment != null) {\n        tail = tail._nextSegment;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer h = _head;\n    if (h == null) {\n        if (this != EMPTY) {\n            h = _constructHead();\n        }\n        _head = h;\n    }\n    return h;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = _nextSegment;\n    while (tail != null) {\n        tail = tail._nextSegment;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = _nextSegment;\n    if (last == null) {\n        return this;\n    }\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer h = _head;\n    if (h == null) {\n        if (this != EMPTY) {\n            h = _constructHead();\n        }\n        _head = h;\n    }\n    return h;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = _nextSegment;\n    while (tail != null) {\n        tail = tail._nextSegment;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer h = _head;\n    if (h == null) {\n        if (this != EMPTY) {\n            h = _constructHead();\n        }\n        _head = h;\n    }\n    return h;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = _nextSegment;\n    while (tail != null) {\n        tail = tail._nextSegment;\n    }\n    return tail;\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n    while ((read = data.read(buffer)) > -1) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n    while ((read = data.read(buffer)) > -1) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n    while ((read = data.read(buffer)) > 0) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n    while ((read = data.read(buffer)) > -1) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n    while ((read = data.read(buffer)) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  {\n    if (obj instanceof Cloneable) \n    {\n        try \n        {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\");\n            if (!cloneMethod.isAccessible()) \n            {\n                cloneMethod.setAccessible(true);\n            }\n            return (T) cloneMethod.invoke(obj);\n        } \n        catch (final NoSuchMethodException e) \n        {\n            // ignored\n        } \n        catch (final IllegalAccessException e) \n        {\n            // ignored\n        } \n        catch (final InvocationTargetException e) \n        {\n            // ignored\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) \n    {\n        return null;\n    }\n    try \n    {\n        return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n    } \n    catch (final NoSuchMethodException e) \n    {\n        throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \n                                      \" has no clone method\", e);\n    } \n    catch (final IllegalAccessException e) \n    {\n        throw new CloneFailedException(\"Cannot clone Cloneable type \" + obj.getClass().getName(), e);\n    } \n    catch (final InvocationTargetException e) \n    {\n        throw new CloneFailedException(\"Exception cloning Cloneable type \" + obj.getClass().getName(), e.getCause());\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj instanceof Cloneable) \n    {\n        try \n        {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\");\n            final Object result = cloneMethod.invoke(obj);\n            if (result != obj) \n            {\n                return (T) result;\n            }\n        } \n        catch (final NoSuchMethodException e) \n        {\n            // ignore, no valid clone method found\n        } \n        catch (final IllegalAccessException e) \n        {\n            // ignore, cannot access the clone method\n        } \n        catch (final InvocationTargetException e) \n        {\n            // ignore, cannot invoke the clone method\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) \n    {\n        return null;\n    }\n    if (obj instanceof Cloneable) \n    {\n        try \n        {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\", (Class[]) null);\n            return (T) cloneMethod.invoke(obj, (Object[]) null);\n        } \n        catch (NoSuchMethodException e) \n        {\n            throw new CloneFailedException(\"Cloneable class \" + obj.getClass().getName() + \" has no clone method\", e);\n        } \n        catch (IllegalAccessException e) \n        {\n            throw new CloneFailedException(\"Cannot clone Cloneable class \" + obj.getClass().getName(), e);\n        } \n        catch (InvocationTargetException e) \n        {\n            throw new CloneFailedException(\"Exception cloning Cloneable class \" + obj.getClass().getName(), e);\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    if (obj instanceof Cloneable) {\n        try {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\", (Class<?>[]) null);\n            final Object result = cloneMethod.invoke(obj, (Object[]) null);\n            if (result != null) {\n                return (T) result;\n            }\n        } catch (NoSuchMethodException ex) {\n            // ignored\n        } catch (IllegalAccessException ex) {\n            // ignored\n        } catch (InvocationTargetException ex) {\n            // ignored\n        }\n    }\n    throw new CloneFailedException(\"Object \" + obj.getClass().getName() + \" is cloneable but does not implement Cloneable\");\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) \n    {\n        return null;\n    }\n    if (obj instanceof Cloneable) \n    {\n        try \n        {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\", (Class<?>[]) null);\n            return (T) cloneMethod.invoke(obj, (Object[]) null);\n        } \n        catch (final NoSuchMethodException e) \n        {\n            // ignore, no clone method\n        } \n        catch (final IllegalAccessException e) \n        {\n            // ignore, cannot access\n        } \n        catch (final InvocationTargetException e) \n        {\n            // ignore, exception during method invocation\n        }\n    }\n    throw new CloneFailedException(\"The object \" + obj + \" is cloneable but the clone() method threw an exception\");\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) \n    {\n        return null;\n    }\n    try \n    {\n        if (obj instanceof Cloneable) \n        {\n            final Class<?> clazz = obj.getClass();\n            final Method cloneMethod = clazz.getMethod(\"clone\", (Class<?>[]) null);\n            final Object result = cloneMethod.invoke(obj, (Object[]) null);\n            if (result != null) \n            {\n                return (T) result;\n            }\n        }\n    } \n    catch (final NoSuchMethodException e) \n    {\n        // ignore\n    } \n    catch (final IllegalAccessException e) \n    {\n        // ignore\n    } \n    catch (final InvocationTargetException e) \n    {\n        // ignore\n    }\n    throw new CloneFailedException(\"Cloneable interface not implemented for: \" + obj.getClass().getName());\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj instanceof Cloneable) \n    {\n        try \n        {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\");\n            if (!Modifier.isPublic(cloneMethod.getModifiers())) \n            {\n                cloneMethod.setAccessible(true);\n            }\n            return (T) cloneMethod.invoke(obj);\n        } \n        catch (NoSuchMethodException e) \n        {\n            // ignored\n        } \n        catch (IllegalAccessException e) \n        {\n            // ignored\n        } \n        catch (InvocationTargetException e) \n        {\n            // ignored\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) \n    {\n        return null;\n    }\n    if (obj instanceof Cloneable) \n    {\n        try \n        {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\", (Class[]) null);\n            return (T) cloneMethod.invoke(obj, (Object[]) null);\n        } \n        catch (NoSuchMethodException e) \n        {\n            throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \n                                          \" has no clone method\", e);\n        } \n        catch (IllegalAccessException e) \n        {\n            throw new CloneFailedException(\"Cannot clone Cloneable type \" + obj.getClass().getName(), e);\n        } \n        catch (InvocationTargetException e) \n        {\n            throw new CloneFailedException(\"Exception cloning Cloneable type \" + obj.getClass().getName(), e.getCause());\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj instanceof Cloneable) \n    {\n        try \n        {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\");\n            final Object result = cloneMethod.invoke(obj);\n            if (result != null) \n            {\n                return (T) result;\n            }\n        } \n        catch (NoSuchMethodException e) \n        {\n            // ignore\n        } \n        catch (IllegalAccessException e) \n        {\n            // ignore\n        } \n        catch (InvocationTargetException e) \n        {\n            // ignore\n        }\n}\n}"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n    return type.getParameterType(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n      return null;\n    }\n    String qualifiedName = sym.getQualifiedName();\n    if (qualifiedName == null) {\n      return null;\n    }\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n      return null;\n    }\n    return scope.getOwnSlot(qualifiedName + \".\" + paramName);\n  }\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) \n    {\n        return null;\n    }\n    String[] parameters = type.getParameterNames();\n    for (int i = 0; i < parameters.length; i++) \n    {\n        if (parameters[i].equals(paramName)) \n        {\n            return getSymbolForName(sym.getDeclarationNode(), parameters[i]);\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n    return type.getParameter(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n    return type.getParameter(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  return type.getParameterType(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  return type.getParameterType(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n    return type.getParameter(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  return type.getParameterType(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) \n    {\n        return null;\n    }\n    return type.getParameterType(paramName);\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Check if the matrix has sufficient data\n    checkSufficientData(matrix);\n\n    // Get the number of rows and columns\n    int n = matrix.getRowDimension();\n    int m = matrix.getColumnDimension();\n\n    // Create a new matrix to store the covariance matrix\n    RealMatrix covMatrix = matrix.createMatrix(m, m);\n\n    // Compute the covariance matrix\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            double sum = 0.0;\n            for (int k = 0; k < n; k++) {\n                double x = matrix.getEntry(k, i);\n                double y = matrix.getEntry(k, j);\n                sum += (x - matrix.getColumn(i).getMean()) * (y - matrix.getColumn(j).getMean());\n            }\n            covMatrix.setEntry(i, j, sum / (n - biasCorrected));\n        }\n    }\n\n    return covMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int n = matrix.getRowDimension();\n    double[][] data = matrix.getData();\n    double[] mean = new double[n];\n    double[][] cov = new double[n][n];\n    \n    // Calculate mean of each column\n    for (int j = 0; j < n; j++) {\n        double sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += data[i][j];\n        }\n        mean[j] = sum / n;\n    }\n    \n    // Calculate covariance matrix\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            double sum = 0;\n            for (int k = 0; k < n; k++) {\n                sum += (data[k][i] - mean[i]) * (data[k][j] - mean[j]);\n            }\n            cov[i][j] = sum / (n - 1); // Unbiased estimate\n        }\n    }\n    \n    // Adjust for bias correction\n    if (biasCorrected) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                cov[i][j] *= n / (n - 1);\n            }\n        }\n    }\n    \n    return new BlockRealMatrix(cov);\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int rows = matrix.getRowDimension();\n    int cols = matrix.getColumnDimension();\n    double[][] data = matrix.getData();\n    double[] mean = new double[cols];\n    double[][] cov = new double[cols][cols];\n    for (int i = 0; i < cols; i++) {\n        mean[i] = 0;\n        for (int j = 0; j < rows; j++) {\n            mean[i] += data[j][i];\n        }\n        mean[i] /= rows;\n    }\n    for (int i = 0; i < cols; i++) {\n        for (int j = 0; j < cols; j++) {\n            cov[i][j] = 0;\n            for (int k = 0; k < rows; k++) {\n                cov[i][j] += (data[k][i] - mean[i]) * (data[k][j] - mean[j]);\n            }\n            cov[i][j] /= (rows - 1);\n            if (!biasCorrected) {\n                cov[i][j] += 1e-10;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(cov);\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int rows = matrix.getRowDimension();\n    int cols = matrix.getColumnDimension();\n    double[][] covData = new double[cols][cols];\n    for (int i = 0; i < cols; i++) {\n        for (int j = 0; j < cols; j++) {\n            double sum = 0;\n            for (int k = 0; k < rows; k++) {\n                double x = matrix.getEntry(k, i);\n                double y = matrix.getEntry(k, j);\n                sum += x * y;\n            }\n            double meanX = matrix.getColumn(i).getMean();\n            double meanY = matrix.getColumn(j).getMean();\n            double cov = sum / (rows - biasCorrected) - meanX * meanY;\n            covData[i][j] = cov;\n        }\n    }\n    return new Array2DRowRealMatrix(covData);\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int n = matrix.getRowDimension();\n    double[][] data = matrix.getData();\n    double[] mean = new double[n];\n    double[][] cov = new double[n][n];\n\n    // Calculate the mean of each column\n    for (int i = 0; i < n; i++) {\n        double sum = 0;\n        for (int j = 0; j < matrix.getColumnDimension(); j++) {\n            sum += data[j][i];\n        }\n        mean[i] = sum / matrix.getColumnDimension();\n    }\n\n    // Calculate the covariance matrix\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            double sum = 0;\n            for (int k = 0; k < matrix.getColumnDimension(); k++) {\n                sum += (data[k][i] - mean[i]) * (data[k][j] - mean[j]);\n            }\n            cov[i][j] = sum / (matrix.getColumnDimension() - biasCorrected);\n            cov[j][i] = cov[i][j];\n        }\n    }\n\n    return new Array2DRowRealMatrix(cov);\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Check if the matrix has sufficient data\n    checkSufficientData(matrix);\n\n    // Get the number of observations\n    n = matrix.getRowDimension();\n\n    // Compute the covariance matrix\n    RealMatrix covarianceMatrix = matrix.multiply(matrix.transpose());\n    if (biasCorrected) {\n        covarianceMatrix = covarianceMatrix.scalarDivide(n);\n    } else {\n        covarianceMatrix = covarianceMatrix.scalarDivide(n - 1);\n    }\n\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int n = matrix.getRowDimension();\n    double[][] data = matrix.getData();\n    double[] mean = new double[n];\n    double[][] cov = new double[n][n];\n\n    // Compute the mean of each column\n    for (int i = 0; i < n; i++) {\n        double sum = 0;\n        for (int j = 0; j < data.length; j++) {\n            sum += data[j][i];\n        }\n        mean[i] = sum / data.length;\n    }\n\n    // Compute the covariance matrix\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            double sum = 0;\n            for (int k = 0; k < data.length; k++) {\n                sum += (data[k][i] - mean[i]) * (data[k][j] - mean[j]);\n            }\n            cov[i][j] = sum / (data.length - (biasCorrected ? 1 : 0));\n        }\n    }\n\n    return new Array2DRowRealMatrix(cov);\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Check that the matrix has at least two rows and one column\n    if (matrix.getRowDimension() < 2 || matrix.getColumnDimension() < 1) {\n        throw new MathIllegalArgumentException(\"Input matrix must have at least two rows and one column\");\n    }\n\n    // Compute the mean of each column\n    double[] means = new double[matrix.getColumnDimension()];\n    for (int j = 0; j < matrix.getColumnDimension(); j++) {\n        double sum = 0;\n        for (int i = 0; i < matrix.getRowDimension(); i++) {\n            sum += matrix.getEntry(i, j);\n        }\n        means[j] = sum / matrix.getRowDimension();\n    }\n\n    // Compute the covariance matrix\n    RealMatrix covMatrix = new BlockRealMatrix(matrix.getRowDimension(), matrix.getColumnDimension());\n    for (int j = 0; j < matrix.getColumnDimension(); j++) {\n        for (int k = j; k < matrix.getColumnDimension(); k++) {\n            double sum = 0;\n            for (int i = 0; i < matrix.getRowDimension(); i++) {\n                sum += (matrix.getEntry(i, j) - means[j]) * (matrix.getEntry(i, k) - means[k]);\n            }\n            covMatrix.setEntry(j, k, sum / (matrix.getRowDimension() - biasCorrected));\n            covMatrix.setEntry(k, j, sum / (matrix.getRowDimension() - biasCorrected));\n        }\n    }\n    return covMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int n = matrix.getRowDimension();\n    double[][] data = matrix.getData();\n    double[] mean = new double[n];\n    double[][] cov = new double[n][n];\n\n    // Calculate the mean of each column\n    for (int i = 0; i < n; i++) {\n        double sum = 0;\n        for (int j = 0; j < data.length; j++) {\n            sum += data[j][i];\n        }\n        mean[i] = sum / data.length;\n    }\n\n    // Calculate the covariance matrix\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            double sum = 0;\n            for (int k = 0; k < data.length; k++) {\n                sum += (data[k][i] - mean[i]) * (data[k][j] - mean[j]);\n            }\n            cov[i][j] = sum / (data.length - (biasCorrected ? 1 : 0));\n        }\n    }\n\n    return new Array2DRowRealMatrix(cov);\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Check if the matrix has sufficient data\n    checkSufficientData(matrix);\n\n    // Get the number of observations\n    int n = matrix.getRowDimension();\n\n    // Compute the covariance matrix\n    RealMatrix covarianceMatrix = matrix.multiply(matrix.transpose()).scalarDivide(n - (biasCorrected ? 0 : 1));\n\n    return covarianceMatrix;\n}"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) \n    {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    if (bitsCachedSize < count) \n    {\n        if (!ensureCache(count)) \n        {\n            return -1;\n        }\n    }\n\n    final long bitsOut;\n    if (byteOrder == ByteOrder.BIG_ENDIAN) \n    {\n        bitsOut = bitsCached & MASKS[count];\n    } \n    else \n    {\n        bitsOut = (bitsCached >> (MAXIMUM_CACHE_SIZE - count)) & MASKS[count];\n    }\n\n    bitsCached <<= count;\n    bitsCachedSize -= count;\n\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) \n    {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    if (!ensureCache(count)) \n    {\n        return -1;\n    }\n\n    long bitsOut = bitsCached & MASKS[count];\n    bitsCached >>= count;\n    bitsCachedSize -= count;\n\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    if (count == 0) {\n        return 0;\n    }\n\n    if (count > bitsCachedSize) {\n        if (!ensureCache(count)) {\n            return -1;\n        }\n    }\n\n    final long bitsOut;\n    if (byteOrder == ByteOrder.BIG_ENDIAN) {\n        bitsOut = bitsCached & MASKS[count];\n        bitsCached >>= count;\n    } else {\n        bitsOut = (bitsCached & MASKS[count]) >>> (MAXIMUM_CACHE_SIZE - count);\n        bitsCached <<= count;\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (count == 0) {\n        return 0;\n    }\n    if (ensureCache(count)) {\n        return bitsCached & MASKS[count];\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    if (count == 0) {\n        return 0;\n    }\n\n    if (ensureCache(count)) {\n        return bitsCached & MASKS[count];\n    }\n\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    if (bitsCachedSize < count) {\n        if (!ensureCache(count)) {\n            return -1;\n        }\n    }\n\n    final long bitsOut = bitsCached & MASKS[count];\n    bitsCached >>= count;\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (ensureCache(count)) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n\n    if (count <= bitsCachedSize) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCached >>= count;\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n\n    if (count == bitsCachedSize) {\n        final long bitsOut = bitsCached;\n        clearBitCache();\n        return bitsOut;\n    }\n\n    if (count > bitsCachedSize + 57) {\n        return processBitsGreater57(count);\n    }\n\n    final int bytesToRead = (count + 7) / 8;\n    final int bitsToRead = bytesToRead * 8;\n    final int bitsToReadInCache = bitsToRead - bitsCachedSize;\n    final int bitsToReadInCacheInBytes = bitsToReadInCache / 8;\n    final int bitsToReadInCacheInBits = bitsToReadInCache % 8;\n\n    final int bytesToReadInCache = bitsCachedSize / 8;\n    final int bytesToReadInCacheInBits = bitsCachedSize % 8;\n\n    final long bitsOut = bitsCached;\n    bitsCached = 0;\n    bitsCachedSize = 0;\n\n    final byte[] buffer = new byte[bytesToRead];\n    final int bytesRead = in.read(buffer, 0, bytesToRead);\n    if (bytesRead == -1) {\n        return -1;\n    }\n\n    final int bytesReadInCache = bytesToReadInCacheInBits > 0 ? bytesToReadInCache + 1 : bytesToReadInCache;\n    final int bytesReadInCacheInBits = bytesToReadInCacheInBits > 0 ? 8 - bytesToReadInCacheInBits : 0;\n\n    final int bytesToReadInCacheInBytes = bytesToReadInCache - bytesToReadInCacheInBits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (count == 0) {\n        return 0;\n    }\n    if (ensureCache(count)) {\n        return bitsCached & MASKS[count];\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > MAXIMUM_CACHE_SIZE) \n    {\n        throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (bitsCachedSize < count) \n    {\n        if (!ensureCache(count)) \n        {\n            return -1;\n        }\n    }\n    final long result = bitsCached & MASKS[count];\n    bitsCached >>= count;\n    bitsCachedSize -= count;\n    return result;\n}"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    try \n    {\n        return outerProduct((SparseFieldVector<T>) v);\n    } \n    catch (ClassCastException cce) \n    {\n        final int m = data.length;\n        final int n = v.getDimension();\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) \n        {\n            for (int j = 0; j < n; j++) \n            {\n                out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n            }\n        }\n        return out;\n    }\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    try \n    {\n        return outerProduct((SparseFieldVector<T>)v);\n    } \n    catch (ClassCastException cce) \n    {\n        final int m = data.length;\n        final int n = v.getDimension();\n        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) \n        {\n            for (int j = 0; j < n; j++) \n            {\n                out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n            }\n        }\n        return out;\n    }\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.data[j]));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    Node labelNode = target;\n    while (labelNode != null && !labelNode.isLabel()) {\n      labelNode = labelNode.getParent();\n    }\n    return labelNode != null && labelNode.getFirstChild().getString().equals(label);\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.getType() == Token.LABEL) {\n        return target.getFirstChild().getString().equals(label);\n    }\n    if (target.getType() == Token.LABELNAME) {\n        return target.getParent().getFirstChild().getString().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    Node labelName = target.getFirstChild();\n    return labelName != null && labelName.getType() == Token.NAME &&\n        labelName.getString().equals(label);\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.isLabel()) {\n        return target.getFirstChild().getString().equals(label);\n    }\n    if (target.isSwitch()) {\n        return true;\n    }\n    if (target.isCase()) {\n        return target.getParent().getFirstChild().getString().equals(label);\n    }\n    if (target.isDefaultCase()) {\n        return target.getParent().getLastChild().getString().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) \n    {\n      return true;\n    }\n    Node labeledBlock = target;\n    if (labeledBlock.getType() == Token.LABEL) \n    {\n      labeledBlock = labeledBlock.getFirstChild();\n    }\n    return labeledBlock.getType() == Token.LABEL && labeledBlock.getFirstChild().getString().equals(label);\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.isLabel()) {\n      return label.equals(target.getFirstChild().getString());\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.getType() == Token.LABEL) {\n      return label.equals(target.getFirstChild().getString());\n    }\n    if (target.getType() == Token.CASE || target.getType() == Token.DEFAULT) {\n      return target.getParent().getFirstChild().getString().equals(label);\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node labelName = target.getFirstChild();\n    return labelName.isLabelName() && labelName.getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.getType() == Token.LABEL) {\n      return label.equals(target.getFirstChild().getString());\n    }\n    return false;\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    if (target.isLabelName()) {\n      return label.equals(target.getString());\n    } else if (target.isLabel()) {\n      return label.equals(target.getFirstChild().getString());\n    }\n    return false;\n  }"
    ],
    [
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        if (item >= 0 && item < urls.size()) {\n            result = (String) urls.get(item);\n        }\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) \n    {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null && urls.size() > item) \n    {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null) \n    {\n        if (item < urls.size()) \n        {\n            return (String) urls.get(item);\n        }\n    }\n    return null;\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    int i = 0;\n    int c = str.charAt(i++);\n    if (c < '0' || c > '9') {\n        _reportInvalidBase64(c, i-1, \"expected digit (0-9) to indicate value\\'s 3-digit octal representation\");\n    }\n    int digit1 = c - '0';\n    c = str.charAt(i++);\n    if (c < '0' || c > '9') {\n        _reportInvalidBase64(c, i-1, \"expected digit (0-9) to indicate value\\'s 3-digit octal representation\");\n    }\n    int digit2 = c - '0';\n    c = str.charAt(i++);\n    if (c < '0' || c > '9') {\n        _reportInvalidBase64(c, i-1, \"expected digit (0-9) to indicate value\\'s 3-digit octal representation\");\n    }\n    int digit3 = c - '0';\n    return (digit1 << 6) + (digit2 << 3) + digit3;\n}",
      "private final static int _parseIndex(String str)  {\n    int i = str.length() - 1;\n    if (i < 0) {\n        throw new IllegalArgumentException(\"Invalid index: empty string\");\n    }\n    if (i == 0) {\n        return str.charAt(0) - '0';\n    }\n    if (i == 1) {\n        return (str.charAt(0) - '0') * 10 + (str.charAt(1) - '0');\n    }\n    if (i == 2) {\n        return (str.charAt(0) - '0') * 100 + (str.charAt(1) - '0') * 10 + (str.charAt(2) - '0');\n    }\n    throw new IllegalArgumentException(\"Invalid index: too large\");\n}\n    protected static JsonPointer _parseTail(String input)\n    {\n        int i = input.length() - 1;\n        if (i < 0) {\n            return EMPTY;\n        }\n        if (input.charAt(i) == SEPARATOR) {\n            --i;\n        }\n        if (i < 0) {\n            return EMPTY;\n        }\n        if (input.charAt(i) == '\"') {\n            return _parseQuotedTail(input, i);\n        }\n        return new JsonPointer(input, input.substring(i), _parseIndex(input.substring(0, i)), null);\n    }\n    protected static JsonPointer _parseQuotedTail(String input, int i)\n    {\n        int end = i - 1;\n        if (end < 0 || input.charAt(end) != '\"') {\n            throw new IllegalArgumentException(\"Invalid index: missing closing quote\");\n        }\n        String segment = input.substring(1, end);\n        if (segment.indexOf('\\\\') >= 0) {\n            segment = input.substring(1, end);\n        }\n        return new JsonPointer(input, segment, segment, _parseTail(input.substring(end + 1)));\n    }\n    protected JsonPointer _constructHead()\n    {\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len < 3 || len > 4) {\n        throw new IllegalArgumentException(\"Invalid 3-digit index: \"+str);\n    }\n    int val = (str.charAt(0) - '0') * 100;\n    val += (str.charAt(1) - '0') * 10;\n    val += str.charAt(2) - '0';\n    return val;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len < 3) {\n        throw new IllegalArgumentException(\"Invalid 3-digit index: too short\");\n    }\n    if (len > 3) {\n        throw new IllegalArgumentException(\"Invalid 3-digit index: too long\");\n    }\n    int first = str.charAt(0) - '0';\n    int second = str.charAt(1) - '0';\n    int third = str.charAt(2) - '0';\n    if (first < 0 || first > 9) {\n        throw new IllegalArgumentException(\"Invalid 3-digit index: first digit not a number\");\n    }\n    if (second < 0 || second > 9) {\n        throw new IllegalArgumentException(\"Invalid 3-digit index: second digit not a number\");\n    }\n    if (third < 0 || third > 9) {\n        throw new IllegalArgumentException(\"Invalid 3-digit index: third digit not a number\");\n    }\n    return (first * 100) + (second * 10) + third;\n}\n\nprotected static JsonPointer _parseTail(String input)\n{\n    int i = input.indexOf('/');\n    if (i < 0) {\n        return _parseQuotedTail(input, input.length());\n    }\n    return _parseQuotedTail(input, i);\n}\n\nprotected static JsonPointer _parseQuotedTail(String input, int i)\n{\n    String segment = input.substring(0, i);\n    if (segment.length() == 0) {\n        return _parseTail(input.substring(i+1));\n    }\n    int matchIndex = -1;\n    if (segment.charAt(0) == '0') {\n        if (segment.length() > 1) {\n            throw new IllegalArgumentException(\"Invalid 3-digit index: leading zero\");\n        }\n        matchIndex = 0;\n    } else if (segment.charAt(0) == '-') {\n        if (segment.length() < 2) {\n}\n}\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len < 3) {\n        throw new IllegalArgumentException(\"Invalid index: \"+str);\n    }\n    int ix = 0;\n    char c = str.charAt(ix++);\n    if (c == '+') {\n        c = str.charAt(ix++);\n    }\n    if (c < '0' || c > '9') {\n        throw new IllegalArgumentException(\"Invalid index: \"+str);\n    }\n    int v = c - '0';\n    while (ix < len) {\n        c = str.charAt(ix++);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Invalid index: \"+str);\n        }\n        v = (v * 10) + (c - '0');\n    }\n    return v;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len < 3) {\n        throw new IllegalArgumentException(\"Invalid 3-digit index: shorter than 3 chars\");\n    }\n    if (len > 3) {\n        throw new IllegalArgumentException(\"Invalid 3-digit index: longer than 3 chars\");\n    }\n    int ix = (str.charAt(0) - '0') * 100\n            + (str.charAt(1) - '0') * 10\n            + (str.charAt(2) - '0');\n    if (ix < 0) {\n        throw new IllegalArgumentException(\"Invalid 3-digit index: negative value\");\n    }\n    return ix;\n}\n\nprotected static JsonPointer _parseTail(String input)\n{\n    int i = input.length() - 1;\n    if (i < 0) {\n        throw new IllegalArgumentException(\"Invalid JSON Pointer expression: empty\");\n    }\n    char c = input.charAt(i);\n    if (c == '/') {\n        return _parseTail(input.substring(0, i));\n    }\n    if (c == '0') {\n        return new JsonPointer(input, \"0\", 0, null);\n    }\n    if (c >= '1' && c <= '9') {\n        return new JsonPointer(input, input.substring(i), _parseIndex(input.substring(i)), null);\n    }\n    if (c == '-') {\n        return new JsonPointer(input, input.substring(i), -_parseIndex(input.substring(i + 1)), null);\n    }\n    if (c == '\"') {\n        return _parseQuotedTail(input, i);\n    }\n    throw new IllegalArgumentException(\"Invalid JSON Pointer expression: unexpected character '\"+c+\"'\");\n}\n\nprotected static JsonPointer _parseQuotedTail(String input, int i)\n{\n    int end = input.indexOf('\"', i + 1);\n    if (end < 0) {\n}\n}",
      "private final static int _parseIndex(String str)  {\n    int i = 0;\n    int len = str.length();\n    int value = 0;\n    while (i < len) {\n        char c = str.charAt(i++);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Invalid index: \" + str);\n        }\n        value = (value * 10) + (c - '0');\n    }\n    return value;\n}\n\nprotected static JsonPointer _parseTail(String input)\n{\n    int i = input.length() - 1;\n    if (i < 0) {\n        throw new IllegalArgumentException(\"Invalid JSON Pointer expression: empty string\");\n    }\n    if (input.charAt(i) == '/') {\n        throw new IllegalArgumentException(\"Invalid JSON Pointer expression: trailing slash\");\n    }\n    String segment = input.substring(i);\n    if (segment.charAt(0) == '0') {\n        if (segment.length() > 1) {\n            throw new IllegalArgumentException(\"Invalid JSON Pointer expression: leading zero\");\n        }\n        return new JsonPointer(input, segment, 0, null);\n    }\n    if (segment.charAt(0) == '-') {\n        int index = _parseIndex(segment);\n        if (index < 0) {\n            throw new IllegalArgumentException(\"Invalid JSON Pointer expression: negative index\");\n        }\n        return new JsonPointer(input, segment, index, null);\n    }\n    return new JsonPointer(input, segment, null, null);\n}\n\nprotected static JsonPointer _parseQuotedTail(String input, int i)\n{\n    int end = i;\n    int len = input.length();\n    while (++end < len) {\n        char c = input.charAt(end);\n        if (c == '\\\\') {\n            ++end;\n            continue;\n        }\n        if (c == '\"') {\n            break;\n        }\n    }\n    if (end == len) {\n        throw new IllegalArgumentException(\"Invalid JSON Pointer expression: missing closing quote\");\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len < 3) {\n        throw new IllegalArgumentException(\"Invalid index: \" + str);\n    }\n    int ix = 0;\n    int c = str.charAt(ix++);\n    if (c < '0' || c > '9') {\n        throw new IllegalArgumentException(\"Invalid index: \" + str);\n    }\n    int v = c - '0';\n    c = str.charAt(ix++);\n    if (c < '0' || c > '9') {\n        throw new IllegalArgumentException(\"Invalid index: \" + str);\n    }\n    v = (v * 10) + (c - '0');\n    c = str.charAt(ix++);\n    if (c < '0' || c > '9') {\n        throw new IllegalArgumentException(\"Invalid index: \" + str);\n    }\n    v = (v * 10) + (c - '0');\n    if (ix < len) {\n        throw new IllegalArgumentException(\"Invalid index: \" + str);\n    }\n    return v;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len < 3) {\n        throw new IllegalArgumentException(\"Invalid index value: \"+str);\n    }\n    int ix = 0;\n    char c = str.charAt(ix++);\n    if (c == '+') {\n        // fine, skip\n    } else if (c == '-') {\n        // negative index\n        ix++;\n    } else {\n        throw new IllegalArgumentException(\"Invalid index value: \"+str);\n    }\n    int v = 0;\n    while (ix < len) {\n        c = str.charAt(ix++);\n        if (c >= '0' && c <= '9') {\n            v = (v * 10) + (c - '0');\n        } else {\n            throw new IllegalArgumentException(\"Invalid index value: \"+str);\n        }\n    }\n    return v;\n}\n    protected static JsonPointer _parseTail(String input)\n    {\n        int i = input.length() - 1;\n        if (i < 0) {\n            throw new IllegalArgumentException(\"Empty input\");\n        }\n        if (input.charAt(i) == '/') {\n            return _parseTail(input.substring(0, i));\n        }\n        return _parseQuotedTail(input, i);\n    }\n    protected static JsonPointer _parseQuotedTail(String input, int i)\n    {\n        int len = input.length();\n        if (i < 2 || input.charAt(i-1) != '\\\\') {\n            throw new IllegalArgumentException(\"Missing escape character for quoted segment\");\n        }\n        String segment = input.substring(i-2, len);\n        input = input.substring(0, i-2);\n        return new JsonPointer(input, segment, _parseIndex(segment), _parseTail(input));\n    }\n    protected JsonPointer _constructHead()\n    {\n        if (_head != null) {\n            return _head;\n        }\n        return _head = new JsonPointer(_asString, _matchingPropertyName, _matchingElementIndex, null);\n    }",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len < 3) {\n        throw new IllegalArgumentException(\"Invalid index value: \"+str);\n    }\n    if (str.charAt(0) == '-') {\n        if (len < 4) {\n            throw new IllegalArgumentException(\"Invalid index value: \"+str);\n        }\n        return -1 * _parseInt(str, 1, len - 1);\n    }\n    return _parseInt(str, 0, len - 1);\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) \n    {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) \n    {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    Object[] out = new Object[k];\n    Iterator<?> iterator = c.iterator();\n    for (int i = 0; i < k; i++) \n    {\n        out[i] = iterator.next();\n    }\n    return out;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    final Object[] out = new Object[k];\n\n    final List<?> list = new ArrayList<>(c);\n    final RandomGenerator rng = getRandomGenerator();\n    for (int i = 0; i < k; i++) {\n        out[i] = list.remove(rng.nextInt(list.size()));\n    }\n\n    return out;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    final Object[] out = new Object[k];\n\n    for (int i = 0; i < k; i++) {\n        out[i] = nextSample(c);\n    }\n\n    return out;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) \n    {\n        throw new NumberIsTooLargeException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                k, c.size(), true);\n    }\n    if (k <= 0) \n    {\n        throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                k);\n    }\n\n    Object[] out = new Object[k];\n    int i = 0;\n    for (Object obj : c) \n    {\n        if (i < k) \n        {\n            out[i] = obj;\n            i++;\n        } \n        else \n        {\n            break;\n        }\n    }\n    return out;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    final Object[] out = new Object[k];\n\n    final List<?> list = new ArrayList<>(c);\n    for (int i = 0; i < k; i++) {\n        int index = nextInt(0, list.size() - 1);\n        out[i] = list.get(index);\n        list.remove(index);\n    }\n\n    return out;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    final Object[] out = new Object[k];\n\n    for (int i = 0; i < k; i++) {\n        out[i] = nextPermutation(c.size(), 1)[0];\n    }\n\n    return out;\n\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    final Object[] out = new Object[k];\n\n    for (int i = 0; i < k; i++) {\n        out[i] = nextSample(c);\n    }\n\n    return out;\n\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    Object[] out = new Object[k];\n    Iterator<?> iter = c.iterator();\n    for (int i = 0; i < k; i++) {\n        out[i] = iter.next();\n    }\n    return out;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) \n    {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE, k, c.size(), true);\n    }\n    if (k <= 0) \n    {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE, k);\n    }\n\n    Object[] out = new Object[k];\n\n    for (int i = 0; i < k; i++) \n    {\n        int index = nextInt(0, c.size() - 1);\n        out[i] = c.toArray()[index];\n        c.remove(index);\n    }\n\n    return out;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) \n    {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) \n    {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    Object[] out = new Object[k];\n    Iterator<?> it = c.iterator();\n    for (int i = 0; i < k; i++) \n    {\n        out[i] = it.next();\n    }\n    return out;\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = NodeUtil.newQualifiedNameNode(\n          compiler.getCodingConvention().getGlobalObject(), methodName);\n      callNode.addChildToFront(argumentNode);\n      callNode.useSourceInfoIfMissingFromForTree(srcref);\n      return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = NodeUtil.newQualifiedNameNode(\n          compiler.getCodingConvention().getGlobalObject(),\n          methodName);\n      callNode.addChildToFront(argumentNode);\n      callNode.useSourceInfoIfMissingFrom(srcref);\n      return callNode;\n    }\n  }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = NodeUtil.newQName(compiler, methodName);\n      callNode.addChildToFront(argumentNode);\n      callNode.useSourceInfoFrom(srcref);\n      return callNode;\n    }\n  }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = NodeUtil.newQualifiedNameNode(\n          compiler.getCodingConvention().getGlobalObject(),\n          methodName,\n          argumentNode.getSourceFileName(),\n          argumentNode.getLineno(),\n          argumentNode.getCharno());\n      callNode.addChildToBack(argumentNode);\n      callNode.useSourceInfoFrom(srcref);\n      return callNode;\n    }\n  }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = NodeUtil.newQualifiedNameNode(\n          compiler.getCodingConvention().getGlobalObject(),\n          methodName,\n          srcref.getLineno(),\n          srcref.getCharno());\n      callNode.addChildToFront(argumentNode);\n      callNode.setSourceInfo(srcref);\n      return callNode;\n    }\n  }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node call = new Node(Token.CALL,\n                           new Node(Token.NAME, methodName),\n                           argumentNode);\n      call.useSourceInfoFrom(srcref);\n      return call;\n    }\n  }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = NodeUtil.newQName(compiler, methodName);\n      callNode.addChildToFront(argumentNode);\n      callNode.useSourceInfoIfMissingFrom(srcref);\n      return callNode;\n    }\n  }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = NodeUtil.newQualifiedNameNode(\n        compiler.getCodingConvention().getGlobalObject(), methodName,\n        srcref.getLineno(), srcref.getCharno());\n    callNode.addChildToFront(argumentNode);\n    callNode.setSourceInfo(srcref);\n    return callNode;\n  }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = NodeUtil.newQName(compiler, methodName);\n      callNode.addChildToFront(argumentNode);\n      callNode.useSourceInfoIfMissingFromForTree(srcref);\n      return callNode;\n    }\n  }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n      Node callNode = NodeUtil.newQName(compiler, methodName);\n      callNode.addChildToFront(argumentNode);\n      callNode.useSourceInfoFrom(srcref);\n      return callNode;\n    }"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    final int[] sorted = new int[indoubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        sorted[i] = indices[i].index;\n    }\n    return sorted;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) \n    {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    final int[] sorted = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        sorted[i] = indices[i].index;\n    }\n    return sorted;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    final int[] sorted = new int[indices.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        sorted[i] = indices[i].index;\n    }\n    return sorted;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    final int[] sorted = new int[indices.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        sorted[i] = indices[i].index;\n    }\n    return sorted;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    final int[] sorted = new int[indices.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        sorted[i] = indices[i].index;\n    }\n    return sorted;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    final int[] sorted = new int[indices.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        sorted[i] = indices[i].index;\n    }\n    return sorted;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    final int[] sorted = new int[indoubles.length];\n    for (int i = 0; i < indices.length; i++) {\n        sorted[i] = indices[i].index;\n    }\n    return sorted;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    final int[] sorted = new int[indices.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        sorted[i] = indices[i].index;\n    }\n    return sorted;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) \n    {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    final int[] sorted = new int[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        sorted[i] = indices[i].index;\n    }\n    return sorted;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    final int[] sorted = new int[indices.length];\n    for (int i = 0; i < indices.length; i++) \n    {\n        sorted[i] = indices[i].index;\n    }\n    return sorted;\n}"
    ],
    [
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n        for (int i = 0; i < householderVectors.length; i++) \n        {\n            for (int j = 0; j < i; j++) \n            {\n                cachedQt.setEntry(i, j, 0);\n            }\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        final double[][] qt = new double[m][m];\n        for (int i = 0; i < m; ++i) \n        {\n            if (i > 0) \n            {\n                // copy the entry of the lower sub-diagonal\n                qt[i][i - 1] = householderVectors[i][i - 1];\n            }\n\n            // copy upper triangular part of the matrix\n            for (int j = i; j < m; ++j) \n            {\n                qt[i][j] = householderVectors[i][j];\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qt);\n    }\n\n    // return the cached matrix\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        final int m = householderVectors.length;\n        final double[][] qt = new double[m][m];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < m; ++j) {\n                double sum = 0.0;\n                for (int k = 0; k <= i; ++k) {\n                    sum += householderVectors[j][k] * householderVectors[i][k];\n                }\n                qt[j][i] = sum;\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qt);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        final double[][] qt = new double[m][m];\n        for (int i = 0; i < m; ++i) \n        {\n            for (int j = 0; j < m; ++j) \n            {\n                if (i == j) \n                {\n                    qt[i][j] = 1.0;\n                } \n                else \n                {\n                    qt[i][j] = householderVectors[j][i];\n                }\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qt);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n        for (int i = 0; i < householderVectors.length; i++) \n        {\n            for (int j = 0; j < i; j++) \n            {\n                cachedQt.setEntry(i, j, 0.0);\n            }\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        final double[][] qt = new double[m][m];\n        for (int i = 0; i < m; ++i) \n        {\n            for (int j = 0; j < m; ++j) \n            {\n                for (int k = 0; k < m; ++k) \n                {\n                    qt[i][j] += householderVectors[i][k] * householderVectors[k][j];\n                }\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qt);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        final double[][] qt = new double[m][m];\n        for (int i = 0; i < m; ++i) \n        {\n            for (int j = 0; j < m; ++j) \n            {\n                double sum = 0.0;\n                for (int k = 0; k <= i; ++k) \n                {\n                    sum += householderVectors[k][i] * householderVectors[k][j];\n                }\n                qt[j][i] = sum;\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qt);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        final double[][] qt = new double[m][m];\n        for (int i = 0; i < m; ++i) \n        {\n            if (i > 0) \n            {\n                // copy the entry of the lower sub-diagonal\n                qt[i][i - 1] = householderVectors[i][i - 1];\n            }\n\n            // copy upper triangular part of the matrix\n            for (int j = i; j < m; ++j) \n            {\n                qt[i][j] = householderVectors[i][j];\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qt);\n    }\n\n    // return the cached matrix\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        final double[][] qt = new double[m][m];\n        for (int i = 0; i < m; ++i) \n        {\n            for (int j = 0; j < m; ++j) \n            {\n                double sum = 0.0;\n                for (int k = 0; k < m; ++k) \n                {\n                    sum += householderVectors[k][i] * householderVectors[k][j];\n                }\n                qt[i][j] = sum;\n            }\n        }\n        cachedQt = MatrixUtils.createRealMatrix(qt);\n    }\n    return cachedQt;\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double total = 0.0;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) \n    {\n        int categoryCount = dataset.getCategoryCount();\n        for (int c = 0; c < categoryCount; c++) \n        {\n            double value = dataset.getValue(s, c);\n            if (!Double.isNaN(value)) \n            {\n                total = total + value;\n            }\n        }\n    }\n    return new Range(0.0, total);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) {\n        double seriesTotal = 0.0;\n        int categoryCount = dataset.getCategoryCount();\n        for (int c = 0; c < categoryCount; c++) {\n            double value = dataset.getValue(s, c).doubleValue();\n            seriesTotal += value;\n            min = Math.min(min, seriesTotal);\n            max = Math.max(max, seriesTotal);\n        }\n    }\n    return new Range(min, max);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) \n    {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    } \n    else \n    {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) \n    {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    } \n    else \n    {\n        result = iterateRangeBounds(dataset, true);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) \n    {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    } \n    else \n    {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) {\n        double seriesMin = Double.POSITIVE_INFINITY;\n        double seriesMax = Double.NEGATIVE_INFINITY;\n        int categoryCount = dataset.getCategoryCount();\n        for (int c = 0; c < categoryCount; c++) {\n            double value = dataset.getValue(s, c).doubleValue();\n            seriesMin = Math.min(seriesMin, value);\n            seriesMax = Math.max(seriesMax, value);\n        }\n        min = Math.min(min, seriesMin);\n        max = Math.max(max, seriesMax);\n    }\n    return new Range(min, max);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) \n    {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    } \n    else \n    {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) {\n        int categoryCount = dataset.getCategoryCount(s);\n        double runningTotal = 0.0;\n        for (int c = 0; c < categoryCount; c++) {\n            double value = dataset.getValue(s, c).doubleValue();\n            runningTotal += value;\n            min = Math.min(min, runningTotal);\n            max = Math.max(max, runningTotal);\n        }\n    }\n    return new Range(min, max);\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    return fixedOffsetZone(\"+\" + (hoursOffset < 0 ? \"-\" : \"\") + Math.abs(hoursOffset) + \":\" + (minutesOffset < 0 ? \"-\" : \"\") + Math.abs(minutesOffset), hoursOffset * 60 * 1000 + minutesOffset * 60 * 1000);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour value out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute value out of range: \" + minutesOffset);\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be positive when hours are negative\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    return fixedOffsetZone(\"+\" + (hoursOffset < 0 ? \"-\" : \"\") + Math.abs(hoursOffset) + \":\" + (minutesOffset < 0 ? \"-\" : \"\") + Math.abs(minutesOffset), hoursOffset * 60 * 1000 + minutesOffset * 60 * 1000);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be positive when hours are negative\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    int millisOffset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    return fixedOffsetZone(hoursOffset + \":\" + minutesOffset, millisOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute out of range: \" + minutesOffset);\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be positive when hours are negative\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    int millisOffset = hoursOffset * DateTimeConstants.MILLIS_PER_HOUR + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n    return fixedOffsetZone(\"+\" + printOffset(millisOffset), millisOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour value out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute value out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be zero or positive if hours is positive\");\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes must be zero or negative if hours is negative\");\n    }\n    int offset = (hoursOffset * 60) + minutesOffset;\n    if (offset == 0) {\n        return UTC;\n    }\n    return fixedOffsetZone(\"+\" + printOffset(offset), offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be positive when hours are negative\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    return fixedOffsetZone(\"+\" + (hoursOffset < 0 ? \"-\" : \"\") + Math.abs(hoursOffset) + \":\" + (minutesOffset < 0 ? \"-\" : \"\") + Math.abs(minutesOffset), hoursOffset * DateTimeConstants.MILLIS_PER_HOUR + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) \n    {\n        throw new IllegalArgumentException(\"Hour value must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) \n    {\n        throw new IllegalArgumentException(\"Minute value must be in the range -59 to +59\");\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) \n    {\n        throw new IllegalArgumentException(\"Minutes must be zero or positive when hours are negative\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) \n    {\n        throw new IllegalArgumentException(\"Minutes must be zero or positive when hours are positive\");\n    }\n    int offset = hoursOffset * DateTimeConstants.MILLIS_PER_HOUR + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n    return fixedOffsetZone(\"+\" + hoursOffset + (minutesOffset < 0 ? minutesOffset : \"+\" + minutesOffset), offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) \n    {\n        throw new IllegalArgumentException(\"Hour value out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) \n    {\n        throw new IllegalArgumentException(\"Minute value out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) \n    {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    int millisOffset = hoursOffset * 60 * 60 * 1000 + minutesOffset * 60 * 1000;\n    return forOffsetMillis(millisOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    return fixedOffsetZone(\"+\" + (hoursOffset < 0 ? \"-\" : \"\") + Math.abs(hoursOffset) + \":\" + (minutesOffset < 0 ? \"-\" : \"\") + Math.abs(minutesOffset), hoursOffset * 60 * 1000 + minutesOffset * 60 * 1000);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour value must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute value must be in the range -59 to +59\");\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes must be zero or negative when hours are negative\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be zero or positive when hours are positive\");\n    }\n    int millis = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n    return fixedOffsetZone(\"+\" + hoursOffset + \":\" + (minutesOffset < 10 ? \"0\" : \"\") + minutesOffset, millis);\n}"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int depth = 0;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (c == open) \n        {\n            depth++;\n        } \n        else if (c == close) \n        {\n            depth--;\n            if (depth == 0) \n            {\n                break;\n            }\n        } \n        else if (c == ESC) \n        {\n            consume(); // consume escape\n        }\n    }\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = StringUtil.borrowBuilder();\n    int depth = 0;\n    boolean escaped = false;\n    char last = 0;\n    for (char c : queue.toCharArray()) \n    {\n        if (c == ESC) \n        {\n            if (last != 0 && last == ESC)\n                out.append(c);\n            escaped = !escaped;\n        } \n        else \n        {\n            if (c == open && !escaped) \n            {\n                depth++;\n            } \n            else if (c == close && !escaped) \n            {\n                depth--;\n                if (depth == 0) \n                {\n                    break;\n                }\n            }\n            out.append(c);\n        }\n        last = c;\n    }\n    queue = queue.substring(pos);\n    pos = 0;\n    return StringUtil.releaseBuilder(out);\n}",
      "public String chompBalanced(char open, char close)  {\n    int balance = 1;\n    int start = pos;\n    char last = 0;\n    for (char c : queue.toCharArray()) \n    {\n        if (c == ESC) \n        {\n            if (last != 0 && last == ESC)\n                continue;\n        }\n        else if (c == open) \n        {\n            balance++;\n        }\n        else if (c == close) \n        {\n            balance--;\n            if (balance == 0) \n            {\n                String consumed = queue.substring(start, pos);\n                pos++;\n                return consumed;\n            }\n        }\n        last = c;\n    }\n    return remainder();\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = pos;\n    int depth = 1;\n    char last = 0;\n    for (char c : queue.toCharArray()) \n    {\n        if (c == ESC) \n        {\n            if (last != 0 && last == ESC)\n                out.append(c);\n        } \n        else \n        {\n            if (c == open) \n            {\n                depth++;\n            } \n            else if (c == close) \n            {\n                depth--;\n            }\n            if (depth == 0) \n            {\n                break;\n            }\n        }\n        last = c;\n    }\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = StringUtil.borrowBuilder();\n    char last = 0;\n    int balance = 0;\n    while (!isEmpty()) {\n        char c = consume();\n        if (c == ESC) {\n            if (last != 0 && last == ESC)\n                out.append(c);\n            else\n                c = consume(); // consume escaped char\n        }\n        if (c == open)\n            balance++;\n        else if (c == close)\n            balance--;\n        out.append(c);\n        if (balance == 0)\n            break;\n        last = c;\n    }\n    return StringUtil.releaseBuilder(out);\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = StringUtil.borrowBuilder();\n    char last = 0;\n    boolean escaped = false;\n    while (!isEmpty()) {\n        char c = consume();\n        if (escaped) {\n            out.append(c);\n            escaped = false;\n        }\n        else if (c == ESC)\n            escaped = true;\n        else if (c == open)\n            out.append(c);\n        else if (c == close) {\n            out.append(c);\n            break;\n        }\n    }\n    return StringUtil.releaseBuilder(out);\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = StringUtil.borrowBuilder();\n    int balance = 1;\n    char last = 0;\n    while (!isEmpty()) {\n        char c = consume();\n        if (c == ESC) {\n            if (last != 0 && last == ESC)\n                out.append(c);\n        } else if (c == open) {\n            balance++;\n        } else if (c == close) {\n            balance--;\n        }\n        if (balance == 0)\n            break;\n        out.append(c);\n        last = c;\n    }\n    return StringUtil.releaseBuilder(out);\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = StringUtil.borrowBuilder();\n    char last = 0;\n    int depth = 0;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (c == ESC) \n        {\n            if (last != 0 && last == ESC)\n                out.append(c);\n        } \n        else \n        {\n            if (c == open) \n            {\n                depth++;\n            } \n            else if (c == close) \n            {\n                depth--;\n            }\n\n            if (depth == 0) \n            {\n                break;\n            }\n            out.append(c);\n        }\n        last = c;\n    }\n    return StringUtil.releaseBuilder(out);\n}",
      "public String chompBalanced(char open, char close)  {\n    int balance = 0;\n    int start = pos;\n    char last = 0;\n    for (char c : queue.substring(pos).toCharArray()) \n    {\n        if (c == ESC) \n        {\n            if (last != 0 && last == ESC)\n                balance++;\n        } \n        else if (c == open) \n        {\n            balance++;\n        } \n        else if (c == close) \n        {\n            balance--;\n        }\n        last = c;\n        if (balance == 0) \n        {\n            String consumed = queue.substring(start, pos + 1);\n            pos++;\n            return consumed;\n        }\n    }\n    return remainder();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = StringUtil.borrowBuilder();\n    int balance = 0;\n    boolean escaped = false;\n    char last = 0;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (c == ESC) \n        {\n            if (last != 0 && last == ESC)\n                out.append(c);\n            escaped = !escaped;\n        } \n        else \n        {\n            if (c == open) \n            {\n                if (!escaped)\n                    balance++;\n            } \n            else if (c == close) \n            {\n                if (!escaped)\n                    balance--;\n                if (balance == 0)\n                    break;\n            }\n            out.append(c);\n            last = c;\n        }\n    }\n    return StringUtil.releaseBuilder(out);\n}"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix R = qr.getR();\n        RealMatrix Rinv = R.getInverse();\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTXinv = XT.multiply(Rinv).multiply(XT);\n        return XTXinv;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix r = qr.getR();\n        RealMatrix rInv = r.getSolver().getInverse();\n        RealMatrix xTrans = xMatrix.transpose();\n        RealMatrix xTransRInv = xTrans.multiply(rInv);\n        return xTransRInv.multiply(xTransRInv.transpose());\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix R = qr.getR();\n        RealMatrix Rinv = R.getSolver().getInverse();\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTX = XT.multiply(getX());\n        RealMatrix XTXinv = XTX.getSolver().getInverse();\n        return XTXinv.multiply(Rinv).multiply(Rinv.transpose()).multiply(XTX);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix R = qr.getR();\n        RealMatrix Q = qr.getQ();\n        RealMatrix QT = Q.transpose();\n        RealMatrix XT = xMatrix.transpose();\n        RealMatrix XTQ = XT.multiply(Q);\n        RealMatrix XTQT = XTQ.multiply(QT);\n        RealMatrix XTQTX = XTQT.multiply(xMatrix);\n        RealMatrix XTQTXXTQT = XTQTX.multiply(QT);\n        RealMatrix XTQTXXTQTXT = XTQTXXTQT.transpose();\n        RealMatrix XTQTXXTQTXTinv = XTQTXXTQTXT.getInverse();\n        RealMatrix betaVariance = XTQTXXTQTXTinv.multiply(XTQTXXTQTXTinv);\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix R = qr.getR();\n        RealMatrix Rinv = R.getInverse();\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTinv = XT.getInverse();\n        RealMatrix XTinvX = XTinv.multiply(getX());\n        RealMatrix XTinvXinvXT = XTinvX.multiply(XT);\n        RealMatrix betaVar = Rinv.multiply(XTinvXinvXT).multiply(Rinv);\n        return betaVar;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix r = qr.getR();\n        RealMatrix rInv = r.getSolver().getInverse();\n        RealMatrix xT = getX().transpose();\n        return xT.multiply(rInv).multiply(xT).getSolver().getInverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // No DME advertised - args valid if we get here\n        RealMatrix R = qr.getR();\n        RealMatrix Rinv = R.getInverse();\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTinvXT = XT.multiply(Rinv).multiply(XT);\n        return XTinvXT;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // No DME advertised - args valid if we get here\n        return qr.getR().getInverse().multiply(qr.getR().transpose()).multiply(qr.getR().getInverse());\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix R = qr.getR();\n        RealMatrix Rinv = R.getSolver().getInverse();\n        return Rinv.multiply(Rinv.transpose());\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // No try-catch or advertised NotStrictlyPositiveException - NPE above if n < 3\n        Array2DRowRealMatrix augI = new Array2DRowRealMatrix(n, n);\n        double[][] augIData = augI.getDataRef();\n        for (int i = 0; i < n; i++) {\n            for (int j =0; j < n; j++) {\n                if (i == j && i < p) {\n                    augIData[i][j] = 1d;\n                } else {\n                    augIData[i][j] = 0d;\n                }\n            }\n        }\n\n        // Compute and return Hat matrix\n        // No DME advertised - args valid if we get here\n        return qr.getSolver().solve(augI).multiply(qr.getSolver().solve(augI.transpose()));\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n    if (offset == 0) \n    {\n        return \"Z\";\n    }\n    StringBuilder sb = new StringBuilder();\n    if (offset < 0) \n    {\n        sb.append('-');\n        offset = -offset;\n    } \n    else \n    {\n        sb.append('+');\n    }\n    int hours = offset / 3600000;\n    int minutes = (offset % 3600000) / 60000;\n    sb.append(hours);\n    if (minutes != 0) \n    {\n        sb.append(':');\n        if (minutes < 10) \n        {\n            sb.append('0');\n        }\n        sb.append(minutes);\n    }\n    return sb.toString();\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / 3600000;\n    int minutes = (offset % 3600000) / 60000;\n    StringBuilder sb = new StringBuilder();\n    if (hours < 0) {\n        sb.append('-');\n        hours = -hours;\n    } else {\n        sb.append('+');\n    }\n    sb.append(hours);\n    sb.append(':');\n    if (minutes < 10) {\n        sb.append('0');\n    }\n    sb.append(minutes);\n    return sb.toString();\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / 3600000;\n    int minutes = (offset % 3600000) / 60000;\n    StringBuilder sb = new StringBuilder();\n    if (hours < 0) {\n        sb.append('-');\n        hours = -hours;\n    } else {\n        sb.append('+');\n    }\n    if (hours < 10) {\n        sb.append('0');\n    }\n    sb.append(hours);\n    sb.append(':');\n    if (minutes < 10) {\n        sb.append('0');\n    }\n    sb.append(minutes);\n    return sb.toString();\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / (60 * 60 * 1000);\n    int minutes = (offset / (60 * 1000)) % 60;\n    int seconds = (offset / 1000) % 60;\n    StringBuilder sb = new StringBuilder(7);\n    if (hours < 0) {\n        sb.append('-');\n        hours = -hours;\n    } else {\n        sb.append('+');\n    }\n    if (hours < 10) {\n        sb.append('0');\n    }\n    sb.append(hours);\n    sb.append(':');\n    if (minutes < 10) {\n        sb.append('0');\n    }\n    sb.append(minutes);\n    if (seconds > 0 || minutes == 0) {\n        sb.append(':');\n        if (seconds < 10) {\n            sb.append('0');\n        }\n        sb.append(seconds);\n    }\n    return sb.toString();\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / (60 * 60 * 1000);\n    int minutes = (offset % (60 * 60 * 1000)) / (60 * 1000);\n    int seconds = (offset % (60 * 1000)) / 1000;\n    StringBuilder sb = new StringBuilder();\n    if (hours < 0) {\n        sb.append('-');\n        hours = -hours;\n    } else {\n        sb.append('+');\n    }\n    if (hours < 10) {\n        sb.append('0');\n    }\n    sb.append(hours);\n    sb.append(':');\n    if (minutes < 10) {\n        sb.append('0');\n    }\n    sb.append(minutes);\n    if (seconds != 0 || seconds == 0 && offset % 1000 != 0) {\n        sb.append(':');\n        if (seconds < 10) {\n            sb.append('0');\n        }\n        sb.append(seconds);\n    }\n    return sb.toString();\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / (60 * 60 * 1000);\n    int minutes = (offset / (60 * 1000)) % 60;\n    int seconds = (offset / 1000) % 60;\n    StringBuilder sb = new StringBuilder();\n    if (hours < 0) {\n        sb.append('-');\n        hours = -hours;\n    } else {\n        sb.append('+');\n    }\n    sb.append(String.format(\"%02d\", hours));\n    sb.append(':');\n    sb.append(String.format(\"%02d\", minutes));\n    if (seconds > 0) {\n        sb.append(':');\n        sb.append(String.format(\"%02d\", seconds));\n    }\n    return sb.toString();\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / (60 * 60 * 1000);\n    int minutes = (offset % (60 * 60 * 1000)) / (60 * 1000);\n    StringBuilder sb = new StringBuilder(9);\n    if (hours < 0) {\n        sb.append('-');\n        hours = -hours;\n    } else {\n        sb.append('+');\n    }\n    if (hours < 10) {\n        sb.append('0');\n    }\n    sb.append(hours);\n    sb.append(':');\n    if (minutes < 10) {\n        sb.append('0');\n    }\n    sb.append(minutes);\n    return sb.toString();\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / 3600000;\n    int minutes = (offset % 3600000) / 60000;\n    StringBuilder sb = new StringBuilder(7);\n    if (hours < 0) {\n        sb.append('-');\n        hours = -hours;\n    } else {\n        sb.append('+');\n    }\n    if (hours < 10) {\n        sb.append('0');\n    }\n    sb.append(hours);\n    sb.append(':');\n    if (minutes < 10) {\n        sb.append('0');\n    }\n    sb.append(minutes);\n    return sb.toString();\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / (60 * 60 * 1000);\n    int minutes = (offset / (60 * 1000)) % 60;\n    StringBuilder sb = new StringBuilder();\n    if (hours < 0) {\n        sb.append('-');\n        hours = -hours;\n    } else {\n        sb.append('+');\n    }\n    sb.append(hours);\n    sb.append(':');\n    if (minutes < 10) {\n        sb.append('0');\n    }\n    sb.append(minutes);\n    return sb.toString();\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / 3600000;\n    int minutes = (offset % 3600000) / 60000;\n    StringBuilder sb = new StringBuilder(7);\n    if (hours < 0) {\n        sb.append('-');\n        hours = -hours;\n    } else {\n        sb.append('+');\n    }\n    if (hours < 10) {\n        sb.append('0');\n    }\n    sb.append(hours);\n    sb.append(':');\n    if (minutes < 10) {\n        sb.append('0');\n    }\n    sb.append(minutes);\n    return sb.toString();\n}"
    ],
    [
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null key not permitted.\");\n    }\n    return this.indexMap.get(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null key not permitted.\");\n    }\n    return this.indexMap.get(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null key not permitted.\");\n    }\n    return this.indexMap.get(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null key not permitted.\");\n    }\n    int index = -1;\n    for (int i = 0; i < keys.size(); i++) \n    {\n        if (keys.get(i).equals(key)) \n        {\n            index = i;\n            break;\n        }\n    }\n    return index;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null key not permitted.\");\n    }\n    return this.indexMap.get(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null key not permitted.\");\n    }\n    int index = -1;\n    for (int i = 0; i < this.keys.size(); i++) {\n        Comparable currentKey = (Comparable) this.keys.get(i);\n        if (currentKey.equals(key)) {\n            index = i;\n            break;\n        }\n    }\n    return index;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null key not permitted.\");\n    }\n    return this.indexMap.get(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null key not permitted.\");\n    }\n    return this.indexMap.get(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null key not permitted.\");\n    }\n    return this.indexMap.get(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null key not permitted.\");\n    }\n    return this.indexMap.get(key);\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) \n    {\n        if (!slots.containsKey(symbolEntry.getKey())) \n        {\n            slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n    }\n\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n    if (parent != null) {\n      slots.putAll(parent.allFlowSlots());\n    }\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n\n    // If we're at the bottom of the lattice, just return the symbols\n    // defined in this scope.\n    if (linkedEquivalent == null) {\n      for (Scope scope = functionScope; scope != null; scope = scope.getParentScope()) {\n        for (Var var : scope.getAllSymbols()) {\n          slots.put(var.getName(), new SimpleSlot(var.getName(), var.getType(), true));\n        }\n      }\n    } else {\n      // Otherwise, we need to merge all the symbols defined in this scope\n      // with all the symbols defined in the linked flow scope.\n      for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n          slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n      }\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) \n    {\n        if (!slots.containsKey(symbolEntry.getKey())) \n        {\n            slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n    }\n\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n\n    // First, add all the slots from the cache at the bottom of the lattice.\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) \n    {\n        if (!slots.containsKey(symbolEntry.getKey())) \n        {\n            slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n    }\n\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n  for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) \n  {\n    if (!slots.containsKey(symbolEntry.getKey())) \n    {\n      slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n    }\n  }\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n\n  for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) \n  {\n    if (!slots.containsKey(symbolEntry.getKey())) \n    {\n      slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n    }\n  }\n\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n\n    // The slots in the current scope.\n    for (Var var : scope.getAllSymbols()) {\n      if (var.isLocal()) {\n        slots.put(var.getName(), var.getScope().getSlot(var.getName()));\n      }\n    }\n\n    // The slots in the parent scope.\n    if (parent != null) {\n      for (Map.Entry<String, StaticSlot<JSType>> symbolEntry :\n          parent.cache.symbols.entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n          slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n      }\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n\n    for (Scope scope = this; scope != null; scope = scope.getParent()) {\n        for (Var var : scope.getAllSymbols()) {\n            if (var.isLocal()) {\n                String name = var.getName();\n                StaticSlot<JSType> slot = scope.getSlot(name);\n                if (slot != null) {\n                    slots.put(name, slot);\n                }\n            }\n        }\n    }\n\n    return slots;\n}"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
    ],
    [
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n    double absAtanh;\n    if (a > 0.167) {\n        absAtanh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    if (a == 1.0) {\n        return Double.POSITIVE_INFINITY;\n    }\n    else if (a == -1.0) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    else {\n        return FastMath.log((1 + a) / (1 - a)) / 2.0;\n    }\n}",
      "public static double atanh(double a)  {\n    if (a == 1.0) \n    {\n        return Double.POSITIVE_INFINITY;\n    } \n    else if (a == -1.0) \n    {\n        return Double.NEGATIVE_INFINITY;\n    } \n    else \n    {\n        return 0.5 * FastMath.log((1.0 + a) / (1.0 - a));\n    }\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    double absAtanh;\n    if (a > 0.167) {\n        absAtanh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a > 0.167) {\n        result = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            result = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.036) {\n            result = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n            result = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n            result = a * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2);\n        }\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a > 0.5) {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(2.0 * a, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    }\n    else {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(2.0 * a, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n\n    double result;\n    if (a < 0.5) {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 2.0 + ya;\n        double db = -(da - 2.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    }\n    else {\n        double hiPrec[] = new double[2];\n        // tanh(x) = expm1(2x) / (expm1(2x) + 2)\n        expm1(x*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n}\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    double absAtanh;\n    if (a > 0.167) {\n        absAtanh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n    double absAtanh;\n    if (a > 0.167) {\n        absAtanh = FastMath.log(FastMath.sqrt(a * a + 1) + a);\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n}\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n    double result;\n    if (a > 0.5) {\n        result = 0.5 * FastMath.log(2 + 2 * a / (1 - a));\n    } else {\n        result = a / (1 - a);\n    }\n    if (negate) {\n        result = -result;\n    }\n    return result;\n}"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = Double.NaN;\n    if (test(values, weights, begin, length, true)) {\n        sum = 0.0;\n        for (int i = begin; i < begin + length; i++) {\n            sum += values[i] * weights[i];\n        }\n    }\n    return sum;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            continue;\n        }\n        if (Double.isInfinite(values[i])) {\n            throw new MathArithmeticException(LocalizedFormats.INFINITE_ARRAY_ELEMENT);\n        }\n        sum += values[i];\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_ARRAY_ELEMENT);\n    }\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT);\n    }\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NaN_ARRAY_ELEMENT);\n    }\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i];\n        } else {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = Double.NaN;\n    if (test(values, weights, begin, length, true)) {\n        sum = 0.0;\n        for (int i = begin; i < begin + length; i++) {\n            sum += values[i] * weights[i];\n        }\n    }\n    return sum;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\n            LocalizedFormats.NORMALIZE_INFINITE_SUM, normalizedSum);\n    }\n    double sum = 0.0;\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isInfinite(values[i]) || Double.isNaN(values[i])) {\n            throw new MathArithmeticException(\n                LocalizedFormats.NORMALIZE_INFINITE_ELEMENT, values[i]);\n        }\n        sum += values[i];\n    }\n    if (sum == 0.0) {\n        throw new MathArithmeticException(\n            LocalizedFormats.NORMALIZE_ZERO_SUM);\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        result[i] = values[i] * normalizedSum / sum;\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\n            \"Cannot normalize to a \" + normalizedSum + \" value\");\n    }\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i]) && !Double.isInfinite(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\n            \"Cannot normalize an array with a sum of zero\");\n    }\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i]) && !Double.isInfinite(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = values[i];\n        }\n    }\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\n            LocalizedFormats.NORMALIZE_INFINITE_SUM, normalizedSum);\n    }\n    double sum = 0.0;\n    int count = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i]) && !Double.isInfinite(values[i])) {\n            sum += values[i];\n            count++;\n        }\n    }\n    if (count == 0) {\n        throw new MathArithmeticException(LocalizedFormats.NO_NON_ZERO_ELEMENTS_IN_ARRAY);\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i]) && !Double.isInfinite(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = Double.NaN;\n    if (test(values, weights, begin, length, true)) {\n        sum = 0.0;\n        for (int i = begin; i < begin + length; i++) {\n            sum += values[i] * weights[i];\n        }\n    }\n    return sum;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\n            \"Normalized sum must be a finite number\");\n    }\n    double sum = 0;\n    for (double value : values) {\n        if (!Double.isNaN(value) && !Double.isInfinite(value)) {\n            sum += value;\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\n            \"Array contains infinite or no non-NaN values\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i]) && !Double.isInfinite(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZATION_SUM_INFINITE_OR_NAN, normalizedSum);\n    }\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n    }\n    double[] normalized = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalized[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalized[i] = values[i];\n        }\n    }\n    return normalized;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Invalid target sum: \" + normalizedSum);\n    }\n    double sum = 0.0;\n    int len = values.length;\n    for (int i = 0; i < len; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (Double.isInfinite(sum) || sum == 0.0) {\n        throw new MathArithmeticException(\"Input array contains infinite or zero elements\");\n    }\n    double[] result = new double[len];\n    for (int i = 0; i < len; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toUpperCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                MutableDateTime dt = new MutableDateTime(millis, chrono);\n                if (iZone != null) {\n                    dt = dt.withZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                MutableDateTime dt = new MutableDateTime(millis, chrono);\n                if (iZone != null) {\n                    dt = dt.withZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXInverse = new LUDecomposition(XTOIX).getSolver().getInverse();\n        return XTOIXInverse.multiply(getX().transpose()).multiply(OI).operate(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealVector XTOIXInv = new LUDecomposition(XTOIX).getSolver().getInverse().operate(getX().transpose().operate(getY()));\n        return XTOIXInv;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXInverse = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealMatrix XTOIXXTOIXInverse = getX().transpose().multiply(OI).multiply(XTOIXInverse);\n        return XTOIXXTOIXInverse.operate(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealVector XTOIXI = new LUDecomposition(XTOIX).getSolver().getInverse().operate(getX().transpose().operate(getY()));\n        return XTOIXI;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        return new LUDecomposition(XTOIX).getSolver().solve(getX().transpose().multiply(OI).multiply(yVector));\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXInv = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealMatrix XTOIXInvX = XTOIXInv.multiply(getX().transpose());\n        return XTOIXInvX.operate(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        return new LUDecomposition(XTOIX).getSolver().solve(getX().transpose().multiply(OI).multiply(yVector));\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXinv = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealMatrix XTOIXinvX = XTOIXinv.multiply(getX());\n        RealVector XTOIXinvy = XTOIXinv.operate(getY());\n        return XTOIXinvX.operate(XTOIXinvy);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXInverse = new LUDecomposition(XTOIX).getSolver().getInverse();\n        return XTOIXInverse.multiply(getX().transpose()).multiply(OI).operate(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        return new LUDecomposition(XTOIX).getSolver().solve(getX().transpose().multiply(OI).multiply(yVector));\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return select(\"#\" + id).first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    Elements elementsById = select(\"#\" + id);\n    return elementsById.isEmpty() ? null : elementsById.first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    Elements elementsById = select(\"#\" + id);\n    return elementsById.isEmpty() ? null : elementsById.first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return select(\"#\" + id).first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    Elements elements = select(\"#\" + id);\n    return elements.size() > 0 ? elements.first() : null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    Elements elementsById = select(\"#\" + id);\n    return elementsById.isEmpty() ? null : elementsById.first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length());\n    int customIndex = 0;\n    int pos = 0;\n    while (pos < pattern.length()) {\n        if (pattern.charAt(pos) == START_FE) {\n            result.append(pattern, pos, pos + 1);\n            pos++;\n            int depth = 1;\n            while (depth > 0) {\n                if (pos >= pattern.length()) {\n                    throw new IllegalArgumentException(\"Unterminated format element\");\n                }\n                if (pattern.charAt(pos) == START_FE) {\n                    depth++;\n                } else if (pattern.charAt(pos) == END_FE) {\n                    depth--;\n                }\n                result.append(pattern.charAt(pos));\n                pos++;\n            }\n        } else if (pattern.charAt(pos) == QUOTE) {\n            result.append(appendQuotedString(pattern, new ParsePosition(pos), new StringBuilder(), true));\n        } else {\n            result.append(pattern.charAt(pos));\n            pos++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    int customIndex = 0;\n    int pos = 0;\n    final StringBuilder result = new StringBuilder(pattern.length());\n    while (pos < pattern.length()) \n    {\n        if (pattern.charAt(pos) == START_FE) \n        {\n            result.append(pattern, pos, pos + 1);\n            final String desc = customPatterns.get(customIndex++);\n            result.append(desc);\n            pos += desc.length() + 2;\n        } \n        else \n        {\n            result.append(pattern.charAt(pos++));\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length());\n    int customIndex = 0;\n    int pos = 0;\n    while (pos < pattern.length()) \n    {\n        if (pattern.charAt(pos) == START_FE) \n        {\n            if (customIndex < customPatterns.size()) \n            {\n                result.append(customPatterns.get(customIndex++));\n            } \n            else \n            {\n                result.append(pattern.charAt(pos));\n            }\n            pos++;\n        } \n        else \n        {\n            result.append(pattern.charAt(pos++));\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    int customIndex = 0;\n    int customSize = customPatterns == null ? 0 : customPatterns.size();\n    final StringBuilder result = new StringBuilder(pattern.length());\n    int pos = 0;\n    while (pos < pattern.length()) \n    {\n        char c = pattern.charAt(pos++);\n        if (c == START_FE) \n        {\n            if (customIndex < customSize) \n            {\n                result.append(customPatterns.get(customIndex++));\n            } \n            else \n            {\n                result.append(c);\n            }\n        } \n        else if (c == END_FE) \n        {\n            result.append(c);\n        } \n        else if (c == QUOTE) \n        {\n            result.append(c);\n            if (pos < pattern.length()) \n            {\n                c = pattern.charAt(pos++);\n                if (c == QUOTE) \n                {\n                    result.append(c);\n                } \n                else \n                {\n                    pos--;\n                }\n            }\n        } \n        else \n        {\n            result.append(c);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    int customIndex = 0;\n    int pos = 0;\n    StringBuilder result = new StringBuilder();\n    while (pos < pattern.length()) \n    {\n        if (pattern.charAt(pos) == START_FE) \n        {\n            result.append(pattern, pos, pos + 1);\n            int end = pattern.indexOf(END_FE, pos);\n            if (end == -1) \n            {\n                throw new IllegalArgumentException(\"Unterminated format element at position \" + pos);\n            }\n            result.append(customPatterns.get(customIndex++));\n            pos = end + 1;\n        } \n        else \n        {\n            result.append(pattern.charAt(pos++));\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length());\n    int customIndex = 0;\n    int pos = 0;\n    while (pos < pattern.length()) \n    {\n        if (pattern.charAt(pos) == START_FE) \n        {\n            result.append(pattern, pos, pos + 1);\n            pos++;\n            int depth = 1;\n            while (depth > 0) \n            {\n                if (pos >= pattern.length()) \n                {\n                    throw new IllegalArgumentException(\"Unterminated format element at position \" + (pos - 1));\n                }\n                if (pattern.charAt(pos) == START_FE) \n                {\n                    depth++;\n                } \n                else if (pattern.charAt(pos) == END_FE) \n                {\n                    depth--;\n                }\n                result.append(pattern.charAt(pos));\n                pos++;\n            }\n        } \n        else \n        {\n            result.append(pattern.charAt(pos));\n            pos++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length());\n    int customIndex = 0;\n    int pos = 0;\n    while (pos < pattern.length()) {\n        if (pattern.charAt(pos) == START_FE) {\n            if (customIndex < customPatterns.size()) {\n                result.append(customPatterns.get(customIndex++));\n            } else {\n                result.append(pattern.substring(pos));\n                break;\n            }\n        } else {\n            result.append(pattern.charAt(pos));\n        }\n        pos++;\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length());\n    int customIndex = 0;\n    int depth = 0;\n    for (int i = 0; i < pattern.length(); i++) {\n        char c = pattern.charAt(i);\n        if (c == START_FE) {\n            depth++;\n        } else if (c == END_FE) {\n            depth--;\n        } else if (c == QUOTE) {\n            result.append(appendQuotedString(pattern, new ParsePosition(i), result, false));\n            i = next(new ParsePosition(i)).getIndex() - 1;\n            continue;\n        }\n        if (depth == 0 && c == START_FMT) {\n            result.append(customPatterns.get(customIndex++));\n        } else {\n            result.append(c);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    int pos = 0;\n    final StringBuilder result = new StringBuilder();\n    while (pos < pattern.length()) \n    {\n        if (pattern.charAt(pos) == START_FE) \n        {\n            final int start = pos;\n            int depth = 1;\n            pos++;\n            while (depth > 0 && pos < pattern.length()) \n            {\n                if (pattern.charAt(pos) == START_FE) \n                {\n                    depth++;\n                } \n                else if (pattern.charAt(pos) == END_FE) \n                {\n                    depth--;\n                }\n                pos++;\n            }\n            final String customPattern = customPatterns.get(start / 2);\n            result.append(customPattern);\n        } \n        else \n        {\n            result.append(pattern.charAt(pos));\n            pos++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    int customIndex = 0;\n    final StringBuilder result = new StringBuilder(pattern.length());\n    final char[] chars = pattern.toCharArray();\n    int depth = 0;\n    for (int i = 0; i < chars.length; i++) {\n        char c = chars[i];\n        if (c == START_FE) {\n            depth++;\n            if (depth == 1) {\n                if (customIndex < customPatterns.size()) {\n                    result.append(customPatterns.get(customIndex++));\n                }\n            }\n        } else if (c == END_FE) {\n            depth--;\n        } else if (c == QUOTE) {\n            result.append(appendQuotedString(pattern, new ParsePosition(i), result, false));\n            i = next(new ParsePosition(i)).getIndex() - 1;\n        } else {\n            result.append(c);\n        }\n    }\n    return result.toString();\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n  for (int i = 0; i < fromArgs.length; i++) {\n    if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    return from.getRawType().equals(to.getRawType())\n        && $Gson$Types.canonicalize(from.getOwnerType())\n            .equals($Gson$Types.canonicalize(to.getOwnerType()))\n        && Arrays.equals(from.getActualTypeArguments(),\n            to.getActualTypeArguments(), typeVarMap);\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (from.getRawType() != to.getRawType()) {\n    return false;\n  }\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  for (int i = 0; i < fromArgs.length; i++) {\n    if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  if (from.getRawType() != to.getRawType()) {\n    return false;\n  }\n\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n\n  for (int i = 0; i < fromArgs.length; i++) {\n    if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n      return false;\n    }\n  }\n\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n  Type[] fromArgs = from.getActualTypeArguments();\n  Type[] toArgs = to.getActualTypeArguments();\n  if (fromArgs.length != toArgs.length) {\n    return false;\n  }\n  for (int i = 0; i < fromArgs.length; i++) {\n    if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n      return false;\n    }\n  }\n  return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return iPeriodConverters.add(converter, iPeriodConverters.getConverters());\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return iPeriodConverters.add(converter, null);\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        return iPeriodConverters.add(converter, null);\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return iPeriodConverters.add(converter, iPeriodConverters.iSelectEntries);\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return iPeriodConverters.add(converter, iPeriodConverters.getConverters());\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return iPeriodConverters.add(converter, iPeriodConverters.getConverters());\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        return iPeriodConverters.add(converter, iPeriodConverters.iConverters);\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        return iPeriodConverters.add(converter, null);\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return iPeriodConverters.add(converter, null);\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        return iPeriodConverters.add(converter, null);\n    }"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n    if (colorToNodeMap == null) {\n        color();\n    }\n    int color = ((Color) graph.getNode(node).getAnnotation()).value;\n    return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n  Preconditions.checkNotNull(colorToNodeMap);\n  int color = node.getAnnotation(Color.class).value;\n  return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n  if (colorToNodeMap == null) {\n    color();\n  }\n  return colorToNodeMap[getNode(node).getAnnotation().value];\n}",
      "public N getPartitionSuperNode(N node)  {\n  Preconditions.checkNotNull(node);\n  Preconditions.checkState(colorToNodeMap != null);\n  int color = node.getAnnotation().value;\n  return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n  int color = ((Color)graph.getNode(node).getAnnotation()).value;\n  if (colorToNodeMap[color] == null) \n  {\n    colorToNodeMap[color] = node;\n  }\n  return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n  int color = getNodeAnnotation(node).value;\n  if (colorToNodeMap[color] == null) \n  {\n    colorToNodeMap[color] = node;\n  }\n  return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n  // Check if the node has been colored\n  if (colorToNodeMap[node.hashCode()] != null) \n  {\n    return colorToNodeMap[node.hashCode()];\n  }\n  \n  // If the node has not been colored, find the color of the node\n  int color = graph.getNode(node).getAnnotation().value;\n  \n  // Find the node that has the same color\n  for (N n : graph.getNodes()) \n  {\n    if (graph.getNode(n).getAnnotation().value == color) \n    {\n      // Assign the node to the colorToNodeMap\n      colorToNodeMap[node.hashCode()] = n;\n      return n;\n    }\n  }\n  \n  // If no node with the same color is found, return null\n  return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    GraphNode<N, E> nodeGraphNode = graph.getNode(node);\n    Color color = nodeGraphNode.getAnnotation();\n    if (color == null) \n    {\n        throw new IllegalStateException(\"Node \" + node + \" is not colored.\");\n    }\n    return colorToNodeMap[color.value];\n}",
      "public N getPartitionSuperNode(N node)  {\n    int color = ((Color)graph.getNode(node).getAnnotation()).value;\n    if (colorToNodeMap[color] == null)\n    {\n        colorToNodeMap[color] = node;\n    }\n    return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n  int color = ((Color) graph.getNode(node).getAnnotation()).value;\n  return colorToNodeMap[color];\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < points.length; i++) \n    {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < points.length; i++) \n    {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < points.length; i++) \n    {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < points.length; i++) \n    {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return (map2 == null);\n    }\n    if (map2 == null) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator = keys1.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!SerialUtilities.equal(paint1, paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) \n    {\n        return (map2 == null);\n    }\n    if (map2 == null) \n    {\n        return false;\n    }\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!SerialUtilities.equal(paint1, paint2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) \n    {\n        return (map2 == null);\n    }\n    if (map2 == null) \n    {\n        return false;\n    }\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!SerialUtilities.equal(paint1, paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) \n    {\n        return (map2 == null);\n    }\n    if (map2 == null) \n    {\n        return false;\n    }\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!SerialUtilities.equal(paint1, paint2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) \n    {\n        return true;\n    }\n    if (map1 == null || map2 == null) \n    {\n        return false;\n    }\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!SerialUtilities.equal(paint1, paint2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) \n    {\n        return (map2 == null);\n    }\n    if (map2 == null) \n    {\n        return false;\n    }\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!SerialUtilities.equal(paint1, paint2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return (map2 == null);\n    }\n    if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return (map2 == null);\n    }\n    if (map2 == null) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator = keys1.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String key = expr.getString();\n        String replacement = getReplacement(key);\n        recordReplacement(expr, key);\n        return IR.string(replacement);\n    } else {\n        return expr;\n    }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.getType() == Token.CALL) \n    {\n        Node callee = expr.getFirstChild();\n        Node firstArg = callee.getNext();\n        if (firstArg != null && firstArg.getType() == Token.STRING) \n        {\n            String key = firstArg.getString();\n            String replacement = getReplacement(key);\n            if (replacement != null) \n            {\n                recordReplacement(expr, key);\n                Node newExpr = IR.string(replacement);\n                newExpr.copyInformationFrom(expr);\n                parent.replaceChild(expr, newExpr);\n                return newExpr;\n            }\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String key = expr.getString();\n        String replacement = getReplacement(key);\n        recordReplacement(expr, key);\n        return IR.string(replacement);\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // TODO(user): This code is a mess. Refactor it.\n    if (expr.isAdd()) {\n      Node left = expr.getFirstChild();\n      Node right = left.getNext();\n      Node newLeft = replaceExpression(t, left, expr);\n      Node newRight = replaceExpression(t, right, expr);\n      if (newLeft != left || newRight != right) {\n        return IR.add(newLeft, newRight).srcref(expr);\n      }\n    } else if (expr.isString()) {\n      String key = expr.getString();\n      String replacement = getReplacement(key);\n      recordReplacement(expr, key);\n      return IR.string(replacement).srcref(expr);\n    } else if (expr.isName() || expr.isGetProp()) {\n      // TODO(user): This is a hack.\n      // We need to figure out a way to handle properties that are not\n      // constants.\n      if (isConstantName(expr, t.getCompiler().getKnownConstants())) {\n        String key = expr.getQualifiedName();\n        String replacement = getReplacement(key);\n        recordReplacement(expr, key);\n        return IR.string(replacement).srcref(expr);\n      }\n    } else if (expr.isCall() || expr.isNew()) {\n      // TODO(user): This is a hack.\n      // We need to figure out a way to handle properties that are not\n      // constants.\n      if (isConstantName(expr.getFirstChild(), t.getCompiler().getKnownConstants())) {\n        String key = expr.getFirstChild().getQualifiedName();\n        String replacement = getReplacement(key);\n        recordReplacement(expr, key);\n        return IR.string(replacement).srcref(expr);\n      }\n    }\n\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String key = expr.getString();\n        String replacement = getReplacement(key);\n        recordReplacement(expr, key);\n        return IR.string(replacement).srcref(expr);\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String key = expr.getString();\n        String replacement = getReplacement(key);\n        recordReplacement(expr, key);\n        return IR.string(replacement);\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // TODO(johnlenz): This should be a more general mechanism.\n    if (expr.getType() == Token.NAME) {\n      // TODO(johnlenz): This should be a more general mechanism.\n      if (expr.getString().equals(\"arguments\")) {\n        return expr;\n      }\n    }\n    String key = getKey(expr);\n    if (key == null) {\n      return expr;\n    }\n\n    String replacement = getReplacement(key);\n    recordReplacement(expr, key);\n\n    // Build the replacement tree.\n    Node prefix = IR.string(replacement);\n    StringBuilder keyBuilder = new StringBuilder();\n    Node replacementTree = buildReplacement(expr, prefix, keyBuilder);\n\n    // Replace the expression with the replacement tree.\n    parent.replaceChild(expr, replacementTree);\n\n    // Update the replacement key with the concatenated values.\n    results.get(key).replacement = keyBuilder.toString();\n\n    return replacementTree;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // TODO(user): This method is too long. Break it up.\n    if (expr.isName() || expr.isGetProp() || expr.isGetElem()) {\n      // Replace the name with a short string.\n      String name = getName(expr);\n      if (name != null) {\n        String replacement = getReplacement(name);\n        recordReplacement(expr, name);\n        return IR.string(replacement);\n      }\n    } else if (expr.isCall() || expr.isNew()) {\n      // Replace the call with a short string.\n      Config config = findMatching(getName(expr));\n      if (config != null) {\n        doSubstitutions(t, config, expr);\n        String replacement = getReplacement(getName(expr));\n        recordReplacement(expr, getName(expr));\n        return IR.string(replacement);\n      }\n    } else if (expr.isAdd()) {\n      // Replace the addition with a short string.\n      Node left = expr.getFirstChild();\n      Node right = left.getNext();\n      Node leftReplacement = replaceExpression(t, left, expr);\n      Node rightReplacement = replaceExpression(t, right, expr);\n      if (leftReplacement != left || rightReplacement != right) {\n        StringBuilder keyBuilder = new StringBuilder();\n        Node replacement = buildReplacement(\n            expr, IR.string(\"\"), keyBuilder);\n        recordReplacement(expr, keyBuilder.toString());\n        return replacement;\n      }\n    }\n\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.getType() == Token.STRING) {\n        String key = expr.getString();\n        String replacement = getReplacement(key);\n        recordReplacement(expr, key);\n        return IR.string(replacement);\n    } else {\n        return expr;\n    }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // Only conditionals that are the direct child of an expression statement\n    // don't need results, for those simply replace the expression statement.\n    Preconditions.checkArgument(parent.isExprResult());\n    Node gramps = parent.getParent();\n    gramps.replaceChild(parent, ifNode);\n    return ifNode;\n}"
    ],
    [
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo == null) {\n      return false;\n    }\n    String desc = docInfo.getDescription();\n    if (desc != null) {\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n    return false;\n  }\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo == null) {\n      return false;\n    }\n\n    String desc = docInfo.getDescription();\n    if (desc == null) {\n      return false;\n    }\n\n    if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n      builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n      builder.setIsHidden(true);\n    } else {\n      builder.setDesc(desc);\n    }\n    return true;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  JSDocInfo docInfo = node.getJSDocInfo();\n  if (docInfo != null) {\n    String desc = docInfo.getDescription();\n    if (desc != null) {\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo == null) {\n      return false;\n    }\n\n    String desc = docInfo.getDescription();\n    if (desc == null) {\n      return false;\n    }\n\n    if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n      builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n      builder.setIsHidden(true);\n    } else {\n      builder.setDesc(desc);\n    }\n    return true;\n  }\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo == null) {\n      return false;\n    }\n    String desc = docInfo.getDescription();\n    if (desc == null) {\n      return false;\n    }\n    if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n      builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n      builder.setIsHidden(true);\n    } else {\n      builder.setDesc(desc);\n    }\n    return true;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    String desc = info.getDescription();\n    if (desc != null) {\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo != null) {\n      String desc = docInfo.getDescription();\n      if (desc != null) {\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo == null) {\n      return false;\n    }\n    String desc = docInfo.getDescription();\n    if (desc != null) {\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n    return false;\n  }\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo == null) {\n      return false;\n    }\n\n    String desc = docInfo.getDescription();\n    if (desc != null) {\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n\n    return false;\n  }\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n  JSDocInfo docInfo = node.getJSDocInfo();\n  if (docInfo != null) {\n    String desc = docInfo.getDescription();\n    if (desc != null) {\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, 2);\n    } else {\n        double sumX = 0.0;\n        double sumY = 0.0;\n        double sumXY = 0.0;\n        double sumX2 = 0.0;\n        double sumY2 = 0.0;\n\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n            sumX2 += xArray[i] * xArray[i];\n            sumY2 += yArray[i] * yArray[i];\n        }\n\n        double n = xArray.length;\n        double cov = (sumXY - (sumX * sumY) / n) / (n - 1);\n        if (biasCorrected) {\n            cov = (sumXY - (sumX * sumY) / n) / (n);\n        }\n\n        return cov;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, 2);\n    } else {\n        double meanX = 0;\n        double meanY = 0;\n        for(int i=0; i<xArray.length; i++) {\n            meanX += xArray[i];\n            meanY += yArray[i];\n        }\n        meanX /= xArray.length;\n        meanY /= yArray.length;\n\n        double sum = 0;\n        for(int i=0; i<xArray.length; i++) {\n            sum += (xArray[i] - meanX) * (yArray[i] - meanY);\n        }\n\n        return sum / (xArray.length - (biasCorrected ? 1 : 0));\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, 2);\n    } else {\n        double sumX = 0.0;\n        double sumY = 0.0;\n        double sumXX = 0.0;\n        double sumYY = 0.0;\n        double sumXY = 0.0;\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXX += xArray[i] * xArray[i];\n            sumYY += yArray[i] * yArray[i];\n            sumXY += xArray[i] * yArray[i];\n        }\n        double n = xArray.length;\n        double cov = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);\n        if (biasCorrected) {\n            cov = cov * n / (n - 1);\n        }\n        return cov;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, 2);\n    } else {\n        double meanX = 0.0;\n        double meanY = 0.0;\n        double cov = 0.0;\n        for (int i = 0; i < xArray.length; i++) {\n            meanX += xArray[i];\n            meanY += yArray[i];\n        }\n        meanX /= xArray.length;\n        meanY /= yArray.length;\n        for (int i = 0; i < xArray.length; i++) {\n            cov += (xArray[i] - meanX) * (yArray[i] - meanY);\n        }\n        if (biasCorrected) {\n            cov /= (xArray.length - 1);\n        } else {\n            cov /= xArray.length;\n        }\n        return cov;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH, xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION, xArray.length, 2);\n    } else {\n        double sumX = 0;\n        double sumY = 0;\n        double sumXX = 0;\n        double sumYY = 0;\n        double sumXY = 0;\n        for(int i=0; i<xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXX += xArray[i] * xArray[i];\n            sumYY += yArray[i] * yArray[i];\n            sumXY += xArray[i] * yArray[i];\n        }\n        double n = xArray.length;\n        double cov = (sumXY - (sumX * sumY) / n) / (n - 1);\n        if (biasCorrected) {\n            cov = (sumXY - (sumX * sumY) / n) / (n);\n        }\n        return cov;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, 2);\n    } else {\n        double sumX = 0.0;\n        double sumY = 0.0;\n        double sumXY = 0.0;\n        double sumXX = 0.0;\n        double sumYY = 0.0;\n\n        for(int i=0; i<xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n            sumXX += xArray[i] * xArray[i];\n            sumYY += yArray[i] * yArray[i];\n        }\n\n        double n = xArray.length;\n        double meanX = sumX / n;\n        double meanY = sumY / n;\n\n        double cov = (sumXY - meanX * meanY * n) / (biasCorrected ? n : n - 1);\n\n        return cov;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, 2);\n    } else {\n        double sumX = 0.0;\n        double sumY = 0.0;\n        double sumXY = 0.0;\n        double sumX2 = 0.0;\n        double sumY2 = 0.0;\n        for(int i=0; i<xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n            sumX2 += xArray[i] * xArray[i];\n            sumY2 += yArray[i] * yArray[i];\n        }\n        double n = xArray.length;\n        double cov = (sumXY - sumX * sumY / n) / (n - 1);\n        if (biasCorrected) {\n            cov /= n;\n        }\n        return cov;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH, xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION, xArray.length, 2);\n    } else {\n        double sumX = 0;\n        double sumY = 0;\n        double sumXY = 0;\n        double sumXSq = 0;\n        double sumYSq = 0;\n\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n            sumXSq += xArray[i] * xArray[i];\n            sumYSq += yArray[i] * yArray[i];\n        }\n\n        double n = xArray.length;\n        double cov = (sumXY - (sumX * sumY) / n) / (n - 1);\n\n        if (biasCorrected) {\n            cov = (sumXY - (sumX * sumY) / n) / (n);\n        }\n\n        return cov;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new DimensionMismatchException(xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, 2);\n    } else {\n        double meanX = 0.0;\n        double meanY = 0.0;\n        double sum = 0.0;\n        for (int i = 0; i < xArray.length; i++) {\n            meanX += xArray[i];\n            meanY += yArray[i];\n        }\n        meanX /= xArray.length;\n        meanY /= yArray.length;\n        for (int i = 0; i < xArray.length; i++) {\n            sum += (xArray[i] - meanX) * (yArray[i] - meanY);\n        }\n        if (biasCorrected) {\n            return sum / (xArray.length - 1);\n        } else {\n            return sum / xArray.length;\n        }\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH, xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION, xArray.length, 2);\n    } else {\n        double sumX = 0.0;\n        double sumY = 0.0;\n        double sumXY = 0.0;\n        double sumX2 = 0.0;\n        double sumY2 = 0.0;\n\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n            sumX2 += xArray[i] * xArray[i];\n            sumY2 += yArray[i] * yArray[i];\n        }\n\n        double n = xArray.length;\n        double meanX = sumX / n;\n        double meanY = sumY / n;\n\n        double cov = (sumXY - n * meanX * meanY) / (biasCorrected ? n : n - 1);\n\n        return cov;\n    }\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) \n        {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) \n        {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) \n        {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) \n        {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) \n        {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) \n        {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) \n        {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) \n        {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) \n        {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) \n        {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(\n        MessageId.generateId(tcValue, tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                    CaseFormat.UPPER_UNDERSCORE,\n                    ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(\n            MessageId.generateId(tcValue, tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n\n    return String.valueOf(\n        MessageId.generateId(tcValue, tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                    CaseFormat.UPPER_UNDERSCORE,\n                    ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(\n            MessageId.generateId(tcValue, tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(\n        MessageId.generateId(tcValue, tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(\n        MessageId.generateId(tcValue, tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                    CaseFormat.UPPER_UNDERSCORE,\n                    ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(\n            MessageId.generateId(tcValue, tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(\n        MessageId.generateId(tcValue, tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                    CaseFormat.UPPER_UNDERSCORE,\n                    ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(\n            MessageId.generateId(tcValue, tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(\n        MessageId.generateId(tcValue, tcValue));\n}"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long minPos = Math.max(minDistanceFromEnd, archive.size() - maxDistanceFromEnd);\n    long maxPos = Math.min(maxDistanceFromEnd, archive.size() - minDistanceFromEnd);\n    long pos = maxPos;\n    final byte[] b = new byte[sig.length];\n    while (pos >= minPos) {\n        archive.position(pos);\n        if (archive.read(b) == sig.length && Arrays.equals(sig, b)) {\n            archive.position(pos);\n            return true;\n        }\n        pos--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long minPosition = Math.max(minDistanceFromEnd, currentPosition - maxDistanceFromEnd);\n    long maxPosition = Math.min(maxDistanceFromEnd, currentPosition - minDistanceFromEnd);\n    if (maxPosition < minPosition) {\n        return false;\n    }\n    archive.position(maxPosition);\n    wordBbuf.rewind();\n    IOUtils.readFully(archive, wordBbuf);\n    boolean found = Arrays.equals(sig, wordBuf);\n    if (!found) {\n        archive.position(minPosition);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        found = Arrays.equals(sig, wordBuf);\n    }\n    if (found) {\n        archive.position(archive.position() - WORD);\n    }\n    return found;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long minPos = archive.size() - maxDistanceFromEnd;\n    final long maxPos = archive.size() - minDistanceFromEnd;\n    archive.position(maxPos);\n    wordBbuf.rewind();\n    IOUtils.readFully(archive, wordBuf);\n    boolean found = Arrays.equals(sig, wordBuf);\n    if (!found) {\n        archive.position(minPos);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBuf);\n        found = Arrays.equals(sig, wordBuf);\n    }\n    if (found) {\n        archive.position(archive.position() - WORD);\n    }\n    return found;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long minPos = archive.size() - maxDistanceFromEnd;\n    long maxPos = Math.max(minPos, archive.size() - minDistanceFromEnd);\n    archive.position(maxPos);\n    byte[] tmp = new byte[sig.length];\n    while (archive.position() > minPos) {\n        archive.position(archive.position() - 1);\n        if (archive.read(tmp) != sig.length) {\n            return false;\n        }\n        if (Arrays.equals(tmp, sig)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long minDistance = minDistanceFromEnd;\n    long maxDistance = maxDistanceFromEnd;\n    if (minDistance > maxDistance) {\n        long tmp = minDistance;\n        minDistance = maxDistance;\n        maxDistance = tmp;\n    }\n    if (maxDistance > archive.size()) {\n        maxDistance = archive.size();\n    }\n    if (minDistance > archive.size()) {\n        minDistance = archive.size();\n    }\n    if (minDistance > maxDistance) {\n        return false;\n    }\n    final long maxPos = archive.size() - minDistance;\n    archive.position(maxPos);\n    final byte[] buf = new byte[(int) (maxDistance - maxPos)];\n    IOUtils.readFully(archive, buf);\n    final int idx = ArrayUtils.indexOf(buf, sig);\n    if (idx == -1) {\n        return false;\n    }\n    archive.position(maxPos + idx);\n    return true;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long minPosition = Math.max(currentPosition - maxDistanceFromEnd, 0);\n    long maxPosition = Math.min(currentPosition - minDistanceFromEnd,\n                                archive.size() - sig.length);\n    if (maxPosition < minPosition) {\n        return false;\n    }\n    archive.position(maxPosition);\n    wordBbuf.rewind();\n    IOUtils.readFully(archive, wordBbuf);\n    boolean found = Arrays.equals(sig, wordBuf);\n    if (!found) {\n        archive.position(minPosition);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        found = Arrays.equals(sig, wordBuf);\n    }\n    if (found) {\n        archive.position(archive.position() - sig.length);\n    }\n    return found;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long archiveSize = archive.size();\n    long minDistance = Math.min(minDistanceFromEnd, archiveSize);\n    long maxDistance = Math.min(maxDistanceFromEnd, archiveSize);\n    long maxPosition = archiveSize - maxDistance;\n    long minPosition = Math.max(0, maxPosition - minDistance);\n    archive.position(maxPosition);\n    final ByteBuffer bb = ByteBuffer.wrap(sig);\n    while (archive.position() > minPosition) {\n        archive.position(archive.position() - 1);\n        if (archive.read(bb) == sig.length) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long archiveSize = archive.size();\n    long maxDistance = Math.min(maxDistanceFromEnd, archiveSize);\n    long minDistance = Math.min(minDistanceFromEnd, maxDistance);\n    long currentPosition = archiveSize - maxDistance;\n    long endPosition = archiveSize - minDistance;\n    final byte[] buffer = new byte[sig.length];\n    while (currentPosition >= endPosition) {\n        archive.position(currentPosition);\n        IOUtils.readFully(archive, buffer);\n        if (Arrays.equals(sig, buffer)) {\n            return true;\n        }\n        currentPosition--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long maxPosition = Math.max(currentPosition - minDistanceFromEnd, 0);\n    long minPosition = Math.max(currentPosition - maxDistanceFromEnd, 0);\n    archive.position(maxPosition);\n    final byte[] buffer = new byte[sig.length];\n    while (archive.position() > minPosition) {\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(sig, wordBuf)) {\n            archive.position(archive.position() - sig.length);\n            return true;\n        }\n        archive.position(archive.position() - 1);\n    }\n    archive.position(currentPosition);\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long minDistance = minDistanceFromEnd;\n    long maxDistance = maxDistanceFromEnd;\n    long currentPosition = archive.position();\n    if (currentPosition < minDistance) {\n        minDistance = currentPosition;\n    }\n    if (currentPosition > maxDistance) {\n        maxDistance = currentPosition;\n    }\n    long distanceToTry = minDistance;\n    while (distanceToTry <= maxDistance) {\n        archive.position(currentPosition - distanceToTry);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(sig, wordBuf)) {\n            return true;\n        }\n        distanceToTry <<= 1;\n        if (distanceToTry < minDistance) {\n            distanceToTry = minDistance;\n        }\n        if (distanceToTry > maxDistance) {\n            distanceToTry = maxDistance;\n        }\n    }\n    return false;\n}"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) \n    {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) \n    {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n}",
      "public InputStream getDataStream()  {\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) \n    {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    } \n    else \n    {\n        return _originalStream;\n    }\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) \n    {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return _originalStream;\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.values.getColumnKey(section);\n    if (key == null) {\n        key = \"Series \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (this.dataset != null) \n    {\n        key = this.dataset.getKey(section);\n    }\n    if (key == null) \n    {\n        key = \"Series \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.values.getColumnKey(section);\n    if (key == null) {\n        key = \"Series \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (this.dataset != null) {\n        int seriesCount = this.dataset.getSeriesCount();\n        if (section < seriesCount) {\n            return this.dataset.getSeriesKey(section);\n        }\n    }\n    return new Integer(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.values.getColumnKey(section);\n    if (key == null) {\n        key = \"Series \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section >= 0 && section < this.values.getColumnCount()) \n    {\n        key = this.values.getColumnKey(section);\n    }\n    else \n    {\n        key = \"Series \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section >= 0 && section < getDataset().getItemCount()) \n    {\n        return getDataset().getKey(section);\n    } \n    else \n    {\n        return Integer.toString(section);\n    }\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.values.getColumnKey(section);\n    if (key == null) {\n        key = new Integer(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (this.dataset == null) {\n        throw new IllegalStateException(\"PiePlot.getSectionKey(): no dataset.\");\n    }\n    Comparable key = this.dataset.getKey(section);\n    if (key == null) {\n        key = \"Series \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.values.getColumnKey(section);\n    if (key == null) {\n        key = \"Series \" + section;\n    }\n    return key;\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = getNumberValue();\n                if (n instanceof Double) {\n                    return Double.isNaN((Double) n);\n                } else if (n instanceof Float) {\n                    return Float.isNaN((Float) n);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = getNumberValue();\n                return n.isNaN();\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = getNumberValue();\n                return Double.isNaN(n.doubleValue());\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = getNumberValue();\n                return n.isNaN();\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = _currentObject();\n                if (n instanceof Double) {\n                    return Double.isNaN((Double) n);\n                }\n                if (n instanceof Float) {\n                    return Float.isNaN((Float) n);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = getNumberValue();\n                if (n instanceof Double) {\n                    return Double.isNaN((Double) n);\n                }\n                if (n instanceof Float) {\n                    return Float.isNaN((Float) n);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = getNumberValue();\n                if (n instanceof Double) {\n                    return Double.isNaN((Double) n);\n                }\n                if (n instanceof Float) {\n                    return Float.isNaN((Float) n);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = getNumberValue();\n                if (n instanceof Double) {\n                    return Double.isNaN((Double) n);\n                } else if (n instanceof Float) {\n                    return Float.isNaN((Float) n);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = _currentObject();\n                if (n instanceof Double) {\n                    return Double.isNaN((Double) n);\n                }\n                if (n instanceof Float) {\n                    return Float.isNaN((Float) n);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = getNumberValue();\n                if (n instanceof Double) {\n                    return Double.isNaN((Double) n);\n                } else if (n instanceof Float) {\n                    return Float.isNaN((Float) n);\n                }\n            }\n            return false;\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}"
    ],
    [
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n\n  String result;\n  if (p == PEEKED_UNQUOTED) \n  {\n    result = nextUnquotedValue();\n  } \n  else if (p == PEEKED_SINGLE_QUOTED) \n  {\n    result = nextQuotedValue('\\'');\n  } \n  else if (p == PEEKED_DOUBLE_QUOTED) \n  {\n    result = nextQuotedValue('\"');\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathNames[stackSize - 1] = result;\n  return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED) \n  {\n    result = nextUnquotedValue();\n  } \n  else if (p == PEEKED_SINGLE_QUOTED) \n  {\n    result = nextQuotedValue('\\'');\n  } \n  else if (p == PEEKED_DOUBLE_QUOTED) \n  {\n    result = nextQuotedValue('\"');\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathNames[stackSize - 1] = result;\n  return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED) \n  {\n    result = nextUnquotedValue();\n  } \n  else if (p == PEEKED_SINGLE_QUOTED) \n  {\n    result = nextQuotedValue('\\'');\n  } \n  else if (p == PEEKED_DOUBLE_QUOTED) \n  {\n    result = nextQuotedValue('\"');\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathNames[stackSize - 1] = result;\n  return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth - 3 <= 4) {\n        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n    }\n    return \"...\" + str.substring(offset, maxWidth - 3) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth - 3 <= 4) {\n        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n    }\n    return \"...\" + str.substring(offset, maxWidth - 3) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth - 3 <= 4) {\n        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n    }\n    return \"...\" + str.substring(offset, maxWidth - 3) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + (maxWidth - 3) < str.length()) {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth - 3 <= 4) {\n        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n    }\n    return \"...\" + str.substring(offset, maxWidth - 3) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth - 3 <= 4) {\n        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n    }\n    return \"...\" + str.substring(offset, maxWidth - 3) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth - 3 <= 4) {\n        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n    }\n    return \"...\" + str.substring(offset, maxWidth - 3) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth - 3 <= 4) {\n        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n    }\n    return \"...\" + str.substring(offset, maxWidth - 3) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth - 3 <= 4) {\n        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n    }\n    return \"...\" + str.substring(offset, maxWidth - 3) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset < 7) {\n        return \"...\" + str.substring(maxWidth - 3);\n    }\n    return \"...\" + str.substring(offset - 3, maxWidth - 3) + \"...\";\n}"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;  // already know 's1' isn't null\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;  // already know 's1' isn't null\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;  // already know 's1' isn't null\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;  // already know 's1' isn't null\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;  // already know 's1' isn't null\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;  // already know 's1' isn't null\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n  if (symbolName != null) \n  {\n    Integer index = originalNameMap.get(symbolName);\n    if (index != null) \n    {\n      return index;\n    } \n    else \n    {\n      index = originalNameMap.size();\n      originalNameMap.put(symbolName, index);\n      return index;\n    }\n  } \n  else \n  {\n    return UNMAPPED;\n  }\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) {\n            return index;\n        } else {\n            int index = originalNameMap.size();\n            originalNameMap.put(symbolName, index);\n            return index;\n        }\n    }\n    return UNMAPPED;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != null) \n  {\n    Integer index = originalNameMap.get(symbolName);\n    if (index != null) \n    {\n      return index;\n    } \n    else \n    {\n      index = originalNameMap.size();\n      originalNameMap.put(symbolName, index);\n      return index;\n    }\n  } \n  else \n  {\n    return UNMAPPED;\n  }\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != null) \n  {\n    Integer index = originalNameMap.get(symbolName);\n    if (index != null) \n    {\n      return index;\n    } \n    else \n    {\n      index = originalNameMap.size();\n      originalNameMap.put(symbolName, index);\n      return index;\n    }\n  } \n  else \n  {\n    return UNMAPPED;\n  }\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != null) \n  {\n    Integer index = originalNameMap.get(symbolName);\n    if (index != null) \n    {\n      return index;\n    } \n    else \n    {\n      index = originalNameMap.size();\n      originalNameMap.put(symbolName, index);\n      return index;\n    }\n  } \n  else \n  {\n    return UNMAPPED;\n  }\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) {\n            return index;\n        } else {\n            int index = originalNameMap.size();\n            originalNameMap.put(symbolName, index);\n            return index;\n        }\n    } else {\n        return UNMAPPED;\n    }\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) \n    {\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) \n        {\n            return index;\n        } \n        else \n        {\n            index = originalNameMap.size();\n            originalNameMap.put(symbolName, index);\n            return index;\n        }\n    } \n    else \n    {\n        return UNMAPPED;\n    }\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != null) \n  {\n    Integer index = originalNameMap.get(symbolName);\n    if (index != null) \n    {\n      return index;\n    } else \n    {\n      index = originalNameMap.size();\n      originalNameMap.put(symbolName, index);\n      return index;\n    }\n  }\n  return UNMAPPED;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) {\n            return index;\n        } else {\n            int id = originalNameMap.size();\n            originalNameMap.put(symbolName, id);\n            return id;\n        }\n    }\n    return UNMAPPED;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != null) \n  {\n    Integer index = originalNameMap.get(symbolName);\n    if (index != null) \n    {\n      return index;\n    } \n    else \n    {\n      index = originalNameMap.size();\n      originalNameMap.put(symbolName, index);\n      return index;\n    }\n  } \n  else \n  {\n    return UNMAPPED;\n  }\n}"
    ],
    [
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_LONG) \n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return (double) peekedLong;\n  }\n  if (p == PEEKED_NUMBER) \n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    String number = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n    return Double.parseDouble(number);\n  }\n  throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n\n  if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return (double) peekedLong;\n  }\n  if (p == PEEKED_NUMBER) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n  }\n  if (p == PEEKED_DOUBLE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(peekedString);\n  }\n  throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return (double) peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n        String number = new String(buffer, pos, peekedNumberLength);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return Double.parseDouble(number);\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n\n  if (p == PEEKED_LONG) \n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return (double) peekedLong;\n  }\n  else if (p == PEEKED_NUMBER) \n  {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n  }\n  else \n  {\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n  }\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return (double) peekedLong;\n    }\n    if (p == PEEKED_NUMBER) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        String numStr = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n        return Double.parseDouble(numStr);\n    }\n    if (p == PEEKED_UNQUOTED) \n    {\n        String numStr = nextUnquotedValue();\n        return Double.parseDouble(numStr);\n    }\n    if (p == PEEKED_SINGLE_QUOTED) \n    {\n        String numStr = nextQuotedValue('\\'');\n        return Double.parseDouble(numStr);\n    }\n    if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        String numStr = nextQuotedValue('\"');\n        return Double.parseDouble(numStr);\n    }\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return (double) peekedLong;\n    }\n    else if (p == PEEKED_NUMBER) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        String value = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n        return Double.parseDouble(value);\n    }\n    else if (p == PEEKED_STRING) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        String value = peekedString;\n        peekedString = null;\n        return Double.parseDouble(value);\n    }\n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n\n  if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return (double) peekedLong;\n  } else if (p == PEEKED_NUMBER) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n  } else if (p == PEEKED_STRING) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(peekedString);\n  } else {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return (double) peekedLong;\n    }\n    else if (p == PEEKED_NUMBER) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        String str = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n        return Double.parseDouble(str);\n    }\n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return (double) peekedLong;\n    }\n    else if (p == PEEKED_NUMBER) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        String number = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n        return Double.parseDouble(number);\n    }\n    else \n    {\n        throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return (double) peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    } else if (p == PEEKED_UNQUOTED) {\n        String value = nextUnquotedValue();\n        try {\n            return Double.parseDouble(value);\n        } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(\"Cannot parse double value from unquoted literal: \" + value, e);\n        }\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        String value = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        try {\n            return Double.parseDouble(value);\n        } catch (NumberFormatException e) {\n            throw new JsonSyntaxException(\"Cannot parse double value from quoted literal: \" + value, e);\n        }\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n}"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLen = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLen);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLen = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLen);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (repeat <= 0) \n    {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLen = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLen);\n    for (int i = 0; i < repeat; i++) \n    {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) \n    {\n        return null;\n    }\n    // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it\n    final String result = repeat(str + \" \", repeat);\n    return removeEnd(result, \" \");\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (repeat <= 0) \n    {\n        return EMPTY;\n    }\n    final StringBuilder buf = new StringBuilder(repeat * str.length());\n    for (int i = 0; i < repeat; i++) \n    {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) \n    {\n        return null;\n    }\n    // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it\n    final String result = repeat(str + \" \", repeat);\n    return removeEnd(result, \" \");\n}\n    // Substring",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (repeat <= 0) \n    {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLen = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLen);\n    for (int i = 0; i < repeat; i++) \n    {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (repeat <= 0) \n    {\n        return EMPTY;\n    }\n    final StringBuilder buf = new StringBuilder(repeat * str.length());\n    for (int i = 0; i < repeat; i++) \n    {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLen = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLen);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLen = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLen);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        clazz = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        clazz = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        clazz = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        clazz = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        clazz = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        clazz = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        clazz = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        clazz = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        clazz = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) clazz.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> clazz = implementations.get(headerId);\n    if (clazz == null) {\n        clazz = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) clazz.newInstance();\n}"
    ],
    [
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Marker marker = (Marker) entry.getValue();\n        clone.put(key, (Marker) marker.clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Object key = entry.getKey();\n        Object value = entry.getValue();\n        if (value instanceof Marker) {\n            Marker marker = (Marker) value;\n            clone.put(key, (Marker) marker.clone());\n        }\n        else {\n            clone.put(key, value);\n        }\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Marker marker = (Marker) entry.getKey();\n        Marker clone = (Marker) marker.clone();\n        result.put(clone, entry.getValue());\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = new HashMap();\n    for (Iterator iterator = map.keySet().iterator(); iterator.hasNext();) {\n        Object key = iterator.next();\n        Object value = map.get(key);\n        if (value instanceof Marker) {\n            Marker marker = (Marker) value;\n            Marker clone = (Marker) marker.clone();\n            result.put(key, clone);\n        }\n        else {\n            result.put(key, value);\n        }\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Marker marker = (Marker) entry.getKey();\n        Marker clone = (Marker) marker.clone();\n        result.put(clone, entry.getValue());\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Marker marker = (Marker) entry.getKey();\n        Marker clone = (Marker) marker.clone();\n        result.put(clone, entry.getValue());\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = new HashMap();\n    for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n        Map.Entry entry = (Map.Entry) it.next();\n        Marker marker = (Marker) entry.getKey();\n        Marker clone = (Marker) marker.clone();\n        result.put(clone, entry.getValue());\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Marker marker = (Marker) entry.getKey();\n        Marker clone = (Marker) marker.clone();\n        result.put(clone, entry.getValue());\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Marker marker = (Marker) entry.getKey();\n        clone.put(marker.clone(), entry.getValue());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Object key = entry.getKey();\n        Object value = entry.getValue();\n        if (value instanceof Marker) {\n            Marker marker = (Marker) value;\n            Marker clone = (Marker) marker.clone();\n            result.put(key, clone);\n        }\n        else {\n            result.put(key, value);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) \n        {\n            if (contains(e)) \n            {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        super.addAll(index, toAdd);\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // Adds elements to the list if they are not already present\n        for (final E element : coll) \n        {\n            add(index, element);\n        }\n        return true;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) \n        {\n            if (contains(e)) \n            {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        // add all elements to the list at the specified index\n        super.addAll(index, toAdd);\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) \n        {\n            if (contains(e)) \n            {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        // adds elements if they are not contained already\n        if (toAdd.isEmpty() == false) \n        {\n            super.addAll(index, toAdd);\n            set.addAll(toAdd);\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) \n        {\n            if (contains(e)) \n            {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        super.addAll(index, toAdd);\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) \n        {\n            if (contains(e)) \n            {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        // adds all elements to the list at the specified index\n        super.addAll(index, toAdd);\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) \n        {\n            if (contains(e)) \n            {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        // add all elements at once\n        super.addAll(index, toAdd);\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) \n        {\n            if (contains(e)) \n            {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        super.addAll(index, toAdd);\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // Create a new list to store the elements to be added\n        List<E> newElements = new ArrayList<E>();\n\n        // Iterate over the collection and add non-duplicate elements to the new list\n        for (E element : coll) \n        {\n            if (!set.contains(element)) \n            {\n                newElements.add(element);\n            }\n        }\n\n        // Add the new elements to the list at the specified index\n        super.addAll(index, newElements);\n\n        // Add the new elements to the set\n        set.addAll(newElements);\n\n        // Return true if the list changed\n        return !newElements.isEmpty();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) \n        {\n            if (contains(e)) \n            {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        super.addAll(index, toAdd);\n        return changed;\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    incrementEvaluationCount();\n    return function.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    incrementEvaluationCount();\n    return function.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    incrementEvaluationCount();\n    return function.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    incrementEvaluationCount();\n    return f.value(x);\n}"
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return !(bin.getUpperBound() < this.lowerBound\n            || bin.getLowerBound() > this.upperBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return (this.lowerBound < bin.upperBound && this.upperBound > bin.lowerBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return (this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return (this.lowerBound < bin.upperBound && this.upperBound > bin.lowerBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return !(bin.getUpperBound() < this.lowerBound\n            || bin.getLowerBound() > this.upperBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound) \n    {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return (this.lowerBound < bin.upperBound && this.upperBound > bin.lowerBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound;\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final ArrayList<String> buffer = new ArrayList<String>();\n    char ch = 0;\n    char lastChar = 0;\n    int tokenStart = 0;\n    int type = 0;\n    int lastType = 0;\n    for (int i = 0; i < strLen; i++) {\n        ch = str.charAt(i);\n        type = Character.getType(ch);\n        if (camelCase && lastType == Character.UPPERCASE_LETTER && type == Character.LOWERCASE_LETTER) {\n            if (i > tokenStart) {\n                buffer.add(str.substring(tokenStart, i));\n                tokenStart = i;\n            }\n        } else if (type == Character.UNASSIGNED) {\n            continue;\n        } else if (type != lastType) {\n            if (lastType != 0) {\n                buffer.add(str.substring(tokenStart, i));\n                tokenStart = i;\n            }\n        }\n        lastType = type;\n    }\n    if (lastType != 0) {\n        buffer.add(str.substring(tokenStart, strLen));\n    }\n    return buffer.toArray(new String[buffer.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final List<String> buffer = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(tokenStart));\n    for (int i = tokenStart + 1; i < strLen; i++) {\n        int newType = Character.getType(str.charAt(i));\n        if (newType != currentType) {\n            if (camelCase && currentType == Character.UPPERCASE_LETTER && newType == Character.LOWERCASE_LETTER) {\n                if (tokenStart != i - 1) {\n                    buffer.add(str.substring(tokenStart, i - 1));\n                    tokenStart = i - 1;\n                }\n            } else {\n                buffer.add(str.substring(tokenStart, i));\n                tokenStart = i;\n            }\n            currentType = newType;\n        }\n    }\n    buffer.add(str.substring(tokenStart, strLen));\n    return buffer.toArray(new String[buffer.size()]);\n}\n    // Joining",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final List<String> buffer = new ArrayList<>();\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(tokenStart));\n    for (int i = tokenStart + 1; i < strLen; i++) {\n        int ct = Character.getType(str.charAt(i));\n        if (ct == currentType) {\n            continue;\n        }\n        if (camelCase && ct == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            if (tokenStart != i - 1) {\n                buffer.add(str.substring(tokenStart, i));\n                tokenStart = i;\n            }\n        } else {\n            buffer.add(str.substring(tokenStart, i));\n            tokenStart = i;\n        }\n        currentType = ct;\n    }\n    buffer.add(str.substring(tokenStart, strLen));\n    return buffer.toArray(new String[0]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final ArrayList<String> buf = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(tokenStart));\n    for (int i = tokenStart + 1; i < strLen; i++) {\n        int newType = Character.getType(str.charAt(i));\n        if (newType == currentType) {\n            continue;\n        }\n        if (camelCase && currentType == Character.LOWERCASE_LETTER && newType == Character.UPPERCASE_LETTER) {\n            if (i > tokenStart + 1) {\n                buf.add(str.substring(tokenStart, i - 1));\n            }\n            buf.add(str.substring(i - 1, i));\n            tokenStart = i;\n        } else {\n            buf.add(str.substring(tokenStart, i));\n            tokenStart = i;\n        }\n        currentType = newType;\n    }\n    buf.add(str.substring(tokenStart, strLen));\n    return buf.toArray(new String[buf.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final List<String> buffer = new ArrayList<String>();\n    char ch = 0;\n    char lastChar = 0;\n    int tokenStart = 0;\n    int type = 0;\n    int lastType = 0;\n    for (int i = 0; i < strLen; i++) {\n        ch = str.charAt(i);\n        type = Character.getType(ch);\n        if (camelCase && lastType == Character.UPPERCASE_LETTER && type == Character.LOWERCASE_LETTER) {\n            if (i > tokenStart) {\n                buffer.add(str.substring(tokenStart, i));\n                tokenStart = i;\n            }\n        } else {\n            if (type == Character.UNASSIGNED) {\n                continue;\n            }\n            if (type != lastType) {\n                if (lastType != 0) {\n                    buffer.add(str.substring(tokenStart, i));\n                    tokenStart = i;\n                }\n                lastType = type;\n            }\n        }\n        lastChar = ch;\n    }\n    if (lastType != 0) {\n        buffer.add(str.substring(tokenStart, strLen));\n    }\n    return buffer.toArray(new String[buffer.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final List<String> buf = new ArrayList<>();\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(tokenStart));\n    for (int i = tokenStart + 1; i < strLen; i++) {\n        final int ct = Character.getType(str.charAt(i));\n        if (ct == currentType) {\n            continue;\n        }\n        if (camelCase && ct == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            if (tokenStart != i - 1) {\n                buf.add(str.substring(tokenStart, i));\n                tokenStart = i;\n            }\n        } else {\n            buf.add(str.substring(tokenStart, i));\n            tokenStart = i;\n        }\n        currentType = ct;\n    }\n    buf.add(str.substring(tokenStart, strLen));\n    return buf.toArray(new String[0]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final List<String> buf = new ArrayList<>();\n    char ch = 0;\n    char lastChar = 0;\n    int tokenStart = 0;\n    int type = 0;\n    int lastType = 0;\n    for (int i = 0; i < strLen; i++) {\n        ch = str.charAt(i);\n        type = Character.getType(ch);\n        if (camelCase && lastType == Character.UPPERCASE_LETTER && type == Character.LOWERCASE_LETTER) {\n            if (tokenStart > 0) {\n                buf.add(str.substring(tokenStart, i));\n                tokenStart = i;\n            }\n        } else if (type == Character.SPACE_SEPARATOR || type == Character.LINE_SEPARATOR || type == Character.PARAGRAPH_SEPARATOR) {\n            if (lastType != Character.SPACE_SEPARATOR) {\n                buf.add(str.substring(tokenStart, i));\n                tokenStart = i + 1;\n            }\n        } else {\n            lastType = type;\n        }\n    }\n    if (tokenStart != strLen) {\n        buf.add(str.substring(tokenStart, strLen));\n    }\n    return buf.toArray(new String[0]);\n}\n\n// Joining",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final List<String> buffer = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(tokenStart));\n    for (int i = tokenStart + 1; i < strLen; i++) {\n        int ct = Character.getType(str.charAt(i));\n        if (ct == currentType) {\n            continue;\n        }\n        if (camelCase && \n            ct == Character.LOWERCASE_LETTER && \n            currentType == Character.UPPERCASE_LETTER) {\n            // we've found camel case!\n            if (tokenStart != i - 1) {\n                // we've got an upper char followed by lower chars\n                buffer.add(str.substring(tokenStart, i - 1));\n                tokenStart = i - 1;\n            }\n        } else {\n            buffer.add(str.substring(tokenStart, i));\n            tokenStart = i;\n        }\n        currentType = ct;\n    }\n    buffer.add(str.substring(tokenStart, strLen));\n    return buffer.toArray(new String[buffer.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final List<String> buffer = new ArrayList<String>();\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(tokenStart));\n    for (int i = tokenStart + 1; i < strLen; i++) {\n        int newType = Character.getType(str.charAt(i));\n        if (newType != currentType) {\n            if (camelCase && currentType == Character.LOWERCASE_LETTER && newType == Character.UPPERCASE_LETTER) {\n                if (tokenStart != i - 1) {\n                    buffer.add(str.substring(tokenStart, i - 1));\n                    tokenStart = i - 1;\n                }\n            } else {\n                buffer.add(str.substring(tokenStart, i));\n                tokenStart = i;\n            }\n            currentType = newType;\n        }\n    }\n    buffer.add(str.substring(tokenStart, strLen));\n    return buffer.toArray(new String[buffer.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int strLen = str.length();\n    final List<String> buffer = new ArrayList<>();\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(tokenStart));\n    for (int i = tokenStart + 1; i < strLen; i++) {\n        int newType = Character.getType(str.charAt(i));\n        if (newType == currentType) {\n            continue;\n        }\n        if (camelCase && currentType == Character.UPPERCASE_LETTER && newType == Character.LOWERCASE_LETTER) {\n            if (tokenStart != i - 1) {\n                buffer.add(str.substring(tokenStart, i - 1));\n                tokenStart = i - 1;\n            }\n        } else {\n            buffer.add(str.substring(tokenStart, i));\n            tokenStart = i;\n        }\n        currentType = newType;\n    }\n    buffer.add(str.substring(tokenStart, strLen));\n    return buffer.toArray(new String[0]);\n}"
    ],
    [
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        throw new IllegalArgumentException(\"Text cannot be parsed to a date-time\");\n    }\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(\"Text '\" + text + \"' could not be parsed at index \" + newPos);\n    }\n    throw new IllegalArgumentException(\"Text '\" + text + \"' could not be parsed\");\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        throw new IllegalArgumentException(\"Text cannot be parsed to a date-time: \" + text);\n    }\n    throw new IllegalArgumentException(\"Text cannot be parsed to a date-time: \" + text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        throw new IllegalArgumentException(\"Text cannot be parsed to a date/time\");\n    }\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        throw new IllegalArgumentException(\"Text cannot be parsed to a date-time: \" + text);\n    }\n    throw new IllegalArgumentException(\"Text cannot be parsed to a date-time: \" + text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        throw new IllegalArgumentException(\"Illegal instant format: \" + text);\n    }\n    throw new IllegalArgumentException(\"Illegal instant format: \" + text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        throw new IllegalArgumentException(\"Text cannot be parsed to a date/time: \" + text);\n    }\n    throw new IllegalArgumentException(\"Text cannot be parsed to a date/time: \" + text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        throw new IllegalArgumentException(\"Text cannot be parsed to a date-time: \" + text);\n    }\n    throw new IllegalArgumentException(\"Text cannot be parsed to a date-time: \" + text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(\"Text cannot be parsed to a date-time: \" + text);\n    }\n    throw new IllegalArgumentException(\"Text cannot be parsed to a date-time: \" + text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(\"Text '\" + text + \"' could not be parsed at index \" + newPos);\n    }\n    throw new IllegalArgumentException(\"Text '\" + text + \"' could not be parsed\");\n}"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    Node placeholder = swapWithPlaceholderNode(n);\n    return new MinimizedCondition(\n        new MeasuredNode(n, estimateCostOneLevel(n), false),\n        new MeasuredNode(new Node(Token.SCRIPT).srcref(n), Integer.MAX_VALUE, false))\n        .setPlaceholder(placeholder);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode positive = new MeasuredNode(n, estimateCostOneLevel(n), false);\n    MeasuredNode negative = new MeasuredNode(\n        new Node(Token.SCRIPT).srcref(n), Integer.MAX_VALUE, false);\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  MeasuredNode positive = new MeasuredNode(n, 1, false);\n  MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false);\n  return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  MeasuredNode negative = new MeasuredNode(\n      new Node(Token.SCRIPT).srcref(n), Integer.MAX_VALUE, false);\n  return new MinimizedCondition(new MeasuredNode(n, n.getLength(), false), negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    Node placeholder = swapWithPlaceholderNode(n);\n    return new MinimizedCondition(\n        new MeasuredNode(n, estimateCostOneLevel(n), false),\n        new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false))\n        .setPlaceholder(placeholder);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    Node placeholder = swapWithPlaceholderNode(n);\n    return new MinimizedCondition(\n        new MeasuredNode(n, estimateCostOneLevel(n), false),\n        new MeasuredNode(\n            new Node(Token.SCRIPT).setLength(Integer.MAX_VALUE),\n            Integer.MAX_VALUE,\n            false))\n        .setPlaceholder(placeholder);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  Node placeholder = swapWithPlaceholderNode(n);\n  return new MinimizedCondition(\n      new MeasuredNode(n, estimateCostOneLevel(n), false),\n      new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false))\n      .setPlaceholder(placeholder);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  MeasuredNode positive = new MeasuredNode(n, 1, false);\n  MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT), 1000000, false);\n  return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    Node placeholder = swapWithPlaceholderNode(n);\n    return new MinimizedCondition(\n        new MeasuredNode(n, estimateCostOneLevel(n), false),\n        new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false))\n        .setPlaceholder(placeholder);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    Node placeholder = swapWithPlaceholderNode(n);\n    return new MinimizedCondition(\n        new MeasuredNode(n, estimateCostOneLevel(n), false),\n        new MeasuredNode(new Node(Token.SCRIPT).srcref(n), Integer.MAX_VALUE, false))\n        .setPlaceholder(placeholder);\n}"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[0];\n    int size = 0;\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        size = Math.max(size, constant.ordinal() + 1);\n    }\n    result = new long[size / Long.SIZE + 1];\n    for (final E constant : values) \n    {\n        result[constant.ordinal() / Long.SIZE] |= 1 << (constant.ordinal() % Long.SIZE);\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[0];\n    int size = 0;\n    for (final E constant : values) \n    {\n        if (constant != null) \n        {\n            size++;\n        }\n    }\n    result = new long[(size - 1) / Long.SIZE + 1];\n    int index = 0;\n    for (final E constant : values) \n    {\n        if (constant != null) \n        {\n            result[index / Long.SIZE] |= 1 << (index % Long.SIZE);\n            index++;\n        }\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[0];\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[constant.ordinal() / Long.SIZE] |= 1 << (constant.ordinal() % Long.SIZE);\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[constant.ordinal() / Long.SIZE] |= 1 << (constant.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[0];\n    int count = 0;\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        count++;\n        if (count > Long.SIZE) \n        {\n            result = Arrays.copyOf(result, result.length + 1);\n            result[result.length - 1] = 0;\n        }\n        result[result.length - 1] |= 1 << constant.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[constant.ordinal() / Long.SIZE] |= 1 << (constant.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[constant.ordinal() / Long.SIZE] |= 1 << (constant.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[0];\n    int count = 0;\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        count++;\n    }\n    result = new long[(count - 1) / Long.SIZE + 1];\n    int index = 0;\n    for (final E constant : values) \n    {\n        result[index / Long.SIZE] |= 1 << (index % Long.SIZE);\n        index++;\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[0];\n    int count = 0;\n    for (final E constant : values) \n    {\n        if (constant != null) \n        {\n            count++;\n        }\n    }\n    result = new long[(count - 1) / Long.SIZE + 1];\n    int index = 0;\n    for (final E constant : values) \n    {\n        if (constant != null) \n        {\n            result[index / Long.SIZE] |= 1 << (index % Long.SIZE);\n            index++;\n        }\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result[constant.ordinal() / Long.SIZE] |= 1 << (constant.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    return iPartialConverters.add(converter, null);\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    return iPartialConverters.add(converter, null);\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        return iPartialConverters.add(converter, null);\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    return iPartialConverters.add(converter, null);\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    return iPartialConverters.add(converter, null);\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        return iPartialConverters.add(converter, null);\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    return iPartialConverters.add(converter, null);\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    return iPartialConverters.add(converter, null);\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        return iPartialConverters.add(converter, null);\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    return iPartialConverters.add(converter, null);\n}"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    int depth = 0;\n    while (!scope.isLexicalScope()) {\n      scope = scope.getParentScope();\n      depth++;\n    }\n    return depth + scope.getScopeDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isDocScope()) {\n    return 0;\n  } else {\n    int depth = 0;\n    for (SymbolScope parent = scope.getParentScope();\n         parent != null;\n         parent = parent.getParentScope()) {\n      if (parent.isLexicalScope()) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isDocScope()) {\n    return 0;\n  } else {\n    int depth = 0;\n    for (SymbolScope s = scope; s != null; s = s.getParentScope()) {\n      if (s.isLexicalScope()) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    int depth = 0;\n    for (SymbolScope currentScope = scope;\n         !currentScope.isLexicalScope();\n         currentScope = currentScope.getParentScope()) {\n      depth++;\n    }\n    return depth + scope.getScopeDepth();\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isDocScope()) {\n    return 0;\n  } else {\n    int depth = 0;\n    for (SymbolScope s = scope; s != null; s = s.getParentScope()) {\n      if (s.isLexicalScope()) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n}"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // create blocks layout data array\n    final double[][] blocksLayout = new double[blockRows * blockColumns][];\n    for (int i = 0; i < blockRows; ++i) {\n        for (int j = 0; j < blockColumns; ++j) {\n            final int blockStartRow = i * BLOCK_SIZE;\n            final int blockStartColumn = j * BLOCK_SIZE;\n            final int blockEndRow = Math.min(blockStartRow + BLOCK_SIZE, rows);\n            final int blockEndColumn = Math.min(blockStartColumn + BLOCK_SIZE, columns);\n            blocksLayout[i * blockColumns + j] = new double[\n                (blockEndRow - blockStartRow) * (blockEndColumn - blockStartColumn)\n            ];\n            for (int k = blockStartRow; k < blockEndRow; ++k) {\n                System.arraycopy(rawData[k], blockStartColumn,\n                                 blocksLayout[i * blockColumns + j],\n                                 (k - blockStartRow) * (blockEndColumn - blockStartColumn),\n                                 blockEndColumn - blockStartColumn);\n            }\n        }\n    }\n\n    return blocksLayout;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // create blocks layout data array\n    final double[][] blocksLayout = new double[blockRows * blockColumns][BLOCK_SIZE * BLOCK_SIZE];\n\n    // fill blocks layout data array\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iStartRow = iBlock * BLOCK_SIZE;\n        final int iEndRow   = Math.min(iStartRow + BLOCK_SIZE, rows);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int jStartColumn = jBlock * BLOCK_SIZE;\n            final int jEndColumn   = Math.min(jStartColumn + BLOCK_SIZE, columns);\n            final int index = iBlock * blockColumns + jBlock;\n            for (int i = iStartRow; i < iEndRow; ++i) {\n                for (int j = jStartColumn; j < jEndColumn; ++j) {\n                    blocksLayout[index][(i - iStartRow) * BLOCK_SIZE + (j - jStartColumn)] = rawData[i][j];\n                }\n            }\n        }\n    }\n\n    return blocksLayout;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // create blocks layout array\n    final double[][] blocksLayout = new double[blockRows][blockColumns * BLOCK_SIZE];\n\n    // fill blocks layout array\n    for (int iBlockRow = 0; iBlockRow < blockRows; ++iBlockRow) {\n        final int rowStart = iBlockRow * BLOCK_SIZE;\n        final int rowEnd   = Math.min(rowStart + BLOCK_SIZE, rows);\n        for (int iBlockColumn = 0; iBlockColumn < blockColumns; ++iBlockColumn) {\n            final int colStart = iBlockColumn * BLOCK_SIZE;\n            final int colEnd   = Math.min(colStart + BLOCK_SIZE, columns);\n            for (int i = rowStart; i < rowEnd; ++i) {\n                System.arraycopy(rawData[i], colStart, blocksLayout[iBlockRow], iBlockColumn * BLOCK_SIZE, colEnd - colStart);\n            }\n        }\n    }\n\n    return blocksLayout;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // create the blocks layout array\n    final double[][] blocksLayout = new double[blockRows * blockColumns][BLOCK_SIZE * BLOCK_SIZE];\n\n    // fill the blocks layout array\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int iStartRow = iBlock * BLOCK_SIZE;\n        final int iEndRow   = Math.min(iStartRow + BLOCK_SIZE, rows);\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int jStartColumn = jBlock * BLOCK_SIZE;\n            final int jEndColumn   = Math.min(jStartColumn + BLOCK_SIZE, columns);\n            final int kBlock = iBlock * blockColumns + jBlock;\n            for (int i = iStartRow; i < iEndRow; ++i) {\n                System.arraycopy(rawData[i], jStartColumn, blocksLayout[kBlock], (i - iStartRow) * BLOCK_SIZE + (jStartColumn - jBlock * BLOCK_SIZE), jEndColumn - jStartColumn);\n            }\n        }\n    }\n\n    return blocksLayout;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // create the blocks layout array\n    final double[][] blocksLayout = new double[blockRows * blockColumns][];\n    for (int i = 0; i < blockRows; ++i) {\n        for (int j = 0; j < blockColumns; ++j) {\n            final int startRow = i * BLOCK_SIZE;\n            final int startColumn = j * BLOCK_SIZE;\n            final int endRow = Math.min(startRow + BLOCK_SIZE, rows);\n            final int endColumn = Math.min(startColumn + BLOCK_SIZE, columns);\n            blocksLayout[i * blockColumns + j] = new double[\n                (endRow - startRow) * (endColumn - startColumn)\n            ];\n            for (int k = startRow; k < endRow; ++k) {\n                System.arraycopy(rawData[k], startColumn,\n                                 blocksLayout[i * blockColumns + j],\n                                 (k - startRow) * (endColumn - startColumn),\n                                 endColumn - startColumn);\n            }\n        }\n    }\n\n    return blocksLayout;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // create the blocks layout array\n    final double[][] blocksLayout = new double[blockRows][blockColumns * BLOCK_SIZE * BLOCK_SIZE];\n\n    // copy the data to the blocks layout array\n    for (int iBlockRow = 0; iBlockRow < blockRows; ++iBlockRow) {\n        final int iRow = iBlockRow * BLOCK_SIZE;\n        final int iRowEnd = Math.min(iRow + BLOCK_SIZE, rows);\n        for (int iBlockColumn = 0; iBlockColumn < blockColumns; ++iBlockColumn) {\n            final int iCol = iBlockColumn * BLOCK_SIZE;\n            final int iColEnd = Math.min(iCol + BLOCK_SIZE, columns);\n            final int iBlock = iBlockRow * blockColumns + iBlockColumn;\n            for (int i = iRow; i < iRowEnd; ++i) {\n                System.arraycopy(rawData[i], iCol, blocksLayout[iBlock], (i - iRow) * BLOCK_SIZE + (iCol - iCol), iColEnd - iCol);\n            }\n        }\n    }\n\n    return blocksLayout;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // create the blocks layout array\n        final double[][] blocksLayout = new double[blockRows * blockColumns][];\n        for (int i = 0; i < blockRows; ++i) {\n            for (int j = 0; j < blockColumns; ++j) {\n                final int startRow = i * BLOCK_SIZE;\n                final int startCol = j * BLOCK_SIZE;\n                final int endRow   = Math.min(startRow + BLOCK_SIZE, rows);\n                final int endCol   = Math.min(startCol + BLOCK_SIZE, columns);\n                blocksLayout[i * blockColumns + j] = Arrays.copyOfRange(rawData[startRow], startCol, endCol);\n            }\n        }\n\n        return blocksLayout;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // create the blocks layout array\n    final double[][] blocksLayout = new double[blockRows * blockColumns][BLOCK_SIZE * BLOCK_SIZE];\n\n    // copy the data to the blocks layout array\n    for (int iBlockRow = 0; iBlockRow < blockRows; ++iBlockRow) {\n        for (int iBlockColumn = 0; iBlockColumn < blockColumns; ++iBlockColumn) {\n            final int iBlock = iBlockRow * blockColumns + iBlockColumn;\n            final int iRowStart = iBlockRow * BLOCK_SIZE;\n            final int iRowEnd = Math.min(iRowStart + BLOCK_SIZE, rows);\n            final int iColStart = iBlockColumn * BLOCK_SIZE;\n            final int iColEnd = Math.min(iColStart + BLOCK_SIZE, columns);\n            for (int iRow = iRowStart; iRow < iRowEnd; ++iRow) {\n                final int i = (iRow - iRowStart) * BLOCK_SIZE + (iCol - iColStart);\n                System.arraycopy(rawData[iRow], iColStart, blocksLayout[iBlock], i, iColEnd - iColStart);\n            }\n        }\n    }\n\n    return blocksLayout;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // create blocks layout array\n        final double[][] blocksLayout = new double[blockRows * blockColumns][BLOCK_SIZE * BLOCK_SIZE];\n\n        // copy data to blocks layout\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iStartRow = iBlock * BLOCK_SIZE;\n            final int iEndRow   = Math.min(iStartRow + BLOCK_SIZE, rows);\n            final int iRowSpan  = iEndRow - iStartRow;\n\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int jStartColumn = jBlock * BLOCK_SIZE;\n                final int jEndColumn   = Math.min(jStartColumn + BLOCK_SIZE, columns);\n                final int jColumnSpan  = jEndColumn - jStartColumn;\n\n                final int index = iBlock * blockColumns + jBlock;\n                for (int i = 0; i < iRowSpan; ++i) {\n                    System.arraycopy(rawData[iStartRow + i], jStartColumn,\n                                     blocksLayout[index], i * BLOCK_SIZE,\n                                     jColumnSpan);\n                }\n            }\n        }\n\n        return blocksLayout;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // create the blocks layout array\n        final double[][] blocksLayout = new double[blockRows * blockColumns][];\n        for (int iBlockRow = 0; iBlockRow < blockRows; ++iBlockRow) {\n            final int rowStart = iBlockRow * BLOCK_SIZE;\n            final int rowEnd   = Math.min(rowStart + BLOCK_SIZE, rows);\n            final int height   = rowEnd - rowStart;\n\n            for (int iBlockColumn = 0; iBlockColumn < blockColumns; ++iBlockColumn) {\n                final int colStart = iBlockColumn * BLOCK_SIZE;\n                final int colEnd   = Math.min(colStart + BLOCK_SIZE, columns);\n                final int width   = colEnd - colStart;\n\n                // create the block\n                final double[] block = new double[height * width];\n\n                // copy the block data from the raw layout array\n                for (int iRow = 0; iRow < height; ++iRow) {\n                    System.arraycopy(rawData[rowStart + iRow], colStart,\n                                     block, iRow * width, width);\n                }\n\n                // store the block in the blocks layout array\n                blocksLayout[iBlockRow * blockColumns + iBlockColumn] = block;\n            }\n        }\n\n        return blocksLayout;\n    }"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n    final Dfp two = a.getTwo();\n    final Dfp zero = a.getZero();\n    final Dfp ln2 = a.getField().getLn2();\n\n    if (a.isInfinite()) {\n        // return +Infinity\n        return a.newInstance((byte)1, Dfp.INFINITE);\n    }\n\n    if (a.isNaN()) {\n        return a.newInstance((byte)1, Dfp.QNAN);\n    }\n\n    Dfp y = a;\n    boolean negate = false;\n    int cmp0 = compare(a, zero);\n    if (cmp0 == 0) {\n        return one;\n    } else if (cmp0 < 0) {\n        y = negate();\n        negate = true;\n    }\n\n    /* Find the exponent, first estimate by integer log10, then adjust.\n     Should be faster than doing a natural logarithm.  */\n    int exponent = (int)(y.intLog10() * 3.32);\n    if (exponent < 0) {\n        exponent--;\n    }\n\n    Dfp tempDfp = DfpMath.pow(two, exponent);\n    while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n        tempDfp = tempDfp.multiply(2);\n        exponent++;\n    }\n    exponent--;\n\n    /* We have the exponent, now work on the mantissa */\n\n    y = y.divide(DfpMath.pow(two, exponent));\n    if (exponent > -1023) {\n        y = y.subtract(one);\n    }\n\n    if (exponent < -1074) {\n        return zero;\n    }\n\n    if (exponent > 1023) {\n        return negate ? DfpMath.pow(two, 1023) : DfpMath.pow(two, 1024);\n    }\n\n\n    y = y.multiply(newInstance(4503599627370496l)).rint();\n    String str = y.toString();\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n        final Dfp inta = a.rint();\n        final Dfp fraca = a.subtract(inta);\n\n        final int ia = inta.intValue();\n        if (ia > 2147483646) {\n            // return +Infinity\n            return a.newInstance((byte)1, Dfp.INFINITE);\n        }\n\n        if (ia < -2147483646) {\n            // return 0;\n            return a.newInstance();\n        }\n\n        final Dfp einta = splitPow(a.getField().getESplit(), ia);\n        final Dfp efraca = expInternal(fraca);\n\n        return einta.multiply(efraca);\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n        Dfp result = a.getOne();\n        Dfp x = a;\n        Dfp fact = a.getOne();\n\n        for (int i = 2; i < 90; i++) {\n            fact = fact.divide(i);  // 1 over fact\n            x = x.multiply(a);\n            result = result.add(x.multiply(fact));\n        }\n\n        return result;\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getOne();\n    Dfp y = a;\n    Dfp fact = a.getOne();\n    Dfp py = new Dfp(y);\n\n    for (int i = 2; i < 90; i++) {\n        y = y.multiply(a);\n        fact = fact.divide(i);  // 1 over fact\n        y = y.divide(fact);\n        result = result.add(y);\n        if (result.equals(py)) {\n            break;\n        }\n        py = new Dfp(result);\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n    final Dfp two = a.getTwo();\n\n    Dfp y = a;\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 1; i < 90; i++) {\n        y = y.multiply(a);\n        fact = fact.divide(i);  // 1 over fact\n        y = y.add(fact);\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp inta = a.rint();\n    final Dfp fraca = a.subtract(inta);\n\n    final int ia = inta.intValue();\n    if (ia > 2147483646) {\n        // return +Infinity\n        return a.newInstance((byte)1, Dfp.INFINITE);\n    }\n\n    if (ia < -2147483646) {\n        // return 0;\n        return a.newInstance();\n    }\n\n    final Dfp einta = splitPow(a.getField().getESplit(), ia);\n    final Dfp efraca = expInternal(fraca);\n\n    return einta.multiply(efraca);\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    if (a.isNaN()) {\n        return a.newInstance((byte)1, Dfp.QNAN);\n    }\n\n    if (a.isInfinite()) {\n        if (a.lessThan(getZero())) {\n            return a.newInstance((byte)1, Dfp.INFINITE);\n        } else {\n            return a.newInstance((byte)1, Dfp.INFINITE);\n        }\n    }\n\n    if (a.isZero()) {\n        return a.newInstance(getOne());\n    }\n\n    final Dfp one = a.getOne();\n    final Dfp two = a.getTwo();\n    final Dfp zero = a.getZero();\n    final Dfp ln2 = a.getField().getLn2();\n\n    final Dfp c = a.subtract(ln2);\n    final Dfp r = pow(two, a.intValue());\n    final Dfp y = exp(c);\n\n    return r.multiply(y);\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getOne();\n    Dfp tempDfp = a;\n    Dfp fact = a.getOne();\n\n    for (int i = 2; i < 90; i++) {\n        fact = fact.divide((i - 1) * i);  // 1 over fact\n        tempDfp = tempDfp.multiply(a);\n        result = result.add(tempDfp.multiply(fact));\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n        Dfp y = a;\n        Dfp fact = a.getOne();\n        Dfp py = new Dfp(y);\n\n        for (int i = 2; i < 90; i++) {\n            y = y.multiply(a);\n            fact = fact.divide(i);  // 1 over fact\n            y = y.add(fact);\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n        final Dfp one = a.getOne();\n        final Dfp two = a.getTwo();\n\n        /* If the exponent is less than zero then we can certainly\n         * return zero */\n        if (a.exp < 0) {\n            return a.getZero();\n        }\n\n        /* If the exponent is greater than or equal to digits, then it\n         * must already be an integer since there is no precision left\n         * for any fractional part */\n\n        if (a.exp >= a.mant.length) {\n            return a;\n        }\n\n        /* General case:  create another dfp, result, that contains the\n         * a with the fractional part lopped off.  */\n\n        Dfp result = newInstance(a);\n        for (int i = 0; i < a.mant.length-result.exp; i++) {\n            result.mant[i] = 0;\n        }\n\n        /* We have the exponent, now work on the mantissa */\n\n        result = result.add(one);\n\n        Dfp y = result;\n        Dfp fact = one;\n        Dfp py = new Dfp(y);\n\n        for (int i = 1; i < 90; i++) {\n            y = y.multiply(a);\n            y = y.divide(fact);\n            fact = fact.multiply(i);  // i over fact\n            result = result.add(y);\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return result;\n\n    }"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } \n    else if (FastMath.abs(y) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(0, z.multiply(-inverse), y.multiply(-inverse));\n    } \n    else if (FastMath.abs(y) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(x.multiply(-inverse), 0, z.multiply(-inverse));\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(y.multiply(-inverse), x.multiply(-inverse), 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } \n    else if (FastMath.abs(y) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(0, z.negate(), y.negate());\n    } \n    else if (FastMath.abs(y) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(x.negate(), 0, z.negate());\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(y.negate(), x.negate(), 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getReal() * y.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(0, z.multiply(-inverse), y.multiply(-inverse));\n    } else if (FastMath.abs(y.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(x.multiply(-inverse), 0, z.multiply(-inverse));\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal());\n    return new FieldVector3D<T>(y.multiply(inverse), x.multiply(inverse), 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(0, z.multiply(-inverse), y.multiply(-inverse));\n    } \n    else if (FastMath.abs(y) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(x.multiply(-inverse), 0, z.multiply(-inverse));\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(y.multiply(-inverse), x.multiply(-inverse), 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } \n    else if (FastMath.abs(y) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) \n    {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } \n    else if (FastMath.abs(y) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(0, z.multiply(-inverse), y.multiply(-inverse));\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(z.multiply(-inverse), 0, x.multiply(-inverse));\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(y.multiply(-inverse), x.multiply(-inverse), 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n}"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"The Range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"The Range \" + this + \" does not overlap \" + other);\n    }\n    final T min = getComparator().compare(minimum, other.minimum) < 0 ? other.minimum : minimum;\n    final T max = getComparator().compare(maximum, other.maximum) > 0 ? other.maximum : maximum;\n    return new Range<T>(min, max, getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) \n    {\n        throw new IllegalArgumentException(\"The range must not be null\");\n    }\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"The ranges do not overlap\");\n    }\n    T newMin = comparator.compare(minimum, other.minimum) < 0 ? other.minimum : minimum;\n    T newMax = comparator.compare(maximum, other.maximum) > 0 ? other.maximum : maximum;\n    return new Range<T>(newMin, newMax, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) \n    {\n        throw new IllegalArgumentException(\"The range must not be null\");\n    }\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"The ranges do not overlap\");\n    }\n    T min = getComparator().compare(minimum, other.minimum) < 0 ? other.minimum : minimum;\n    T max = getComparator().compare(maximum, other.maximum) > 0 ? other.maximum : maximum;\n    return new Range<>(min, max, getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) \n    {\n        throw new IllegalArgumentException(\"The range must not be null\");\n    }\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"The ranges do not overlap\");\n    }\n    final T min = (T) comparator.compare(minimum, other.minimum) < 0 ? other.minimum : minimum;\n    final T max = (T) comparator.compare(maximum, other.maximum) > 0 ? other.maximum : maximum;\n    return new Range<T>(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"The range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"The ranges do not overlap\");\n    }\n    final T min = getComparator().compare(minimum, other.minimum) < 0 ? other.minimum : minimum;\n    final T max = getComparator().compare(maximum, other.maximum) > 0 ? other.maximum : maximum;\n    return new Range<>(min, max, getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"The Range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"The Ranges do not overlap\");\n    }\n    return new Range<T>(\n        comparator.max(minimum, other.minimum),\n        comparator.min(maximum, other.maximum),\n        comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"The range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"The range must overlap this range\");\n    }\n    T min = getComparator().compare(other.minimum, minimum) < 0 ? other.minimum : minimum;\n    T max = getComparator().compare(other.maximum, maximum) > 0 ? other.maximum : maximum;\n    return new Range<>(min, max, getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"The Range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"The Ranges do not overlap\");\n    }\n    T newMin = getComparator().compare(other.minimum, minimum) > 0 ? other.minimum : minimum;\n    T newMax = getComparator().compare(maximum, other.maximum) < 0 ? maximum : other.maximum;\n    return new Range<T>(newMin, newMax, getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) \n    {\n        throw new IllegalArgumentException(\"The range must not be null\");\n    }\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"The ranges do not overlap\");\n    }\n    final T min = getComparator().compare(minimum, other.minimum) > 0 ? other.minimum : minimum;\n    final T max = getComparator().compare(maximum, other.maximum) < 0 ? other.maximum : maximum;\n    return new Range<>(min, max, getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"The Range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"The Range \" + this + \" does not overlap \" + other);\n    }\n    T min = comparator.compare(this.minimum, other.minimum) > 0 ? other.minimum : this.minimum;\n    T max = comparator.compare(this.maximum, other.maximum) < 0 ? other.maximum : this.maximum;\n    return new Range<>(min, max, comparator);\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    // As per [JACKSON-259], may want to fully disable canonicalization:\n    return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out,\n            _rootCharSymbols.makeChild(_factoryFeatures));\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, out, _rootCharSymbols.makeChild(_factoryFeatures));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, _generatorFeatures,\n            _objectCodec, out, _rootCharSymbols.makeChild(_factoryFeatures));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, out,\n            _rootCharSymbols.makeChild(_factoryFeatures));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    // As per [JACKSON-259], may want to fully disable canonicalization:\n    UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, _generatorFeatures,\n            _objectCodec, out, _rootCharSymbols.makeChild(_factoryFeatures));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n    //   non-JSON input.\n    _requireJSONFactory(\"OutputStream source not (yet?) supported for this format (%s)\");\n    // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n    // at least handle possible UTF-8 BOM\n    int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(out);\n    ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n    return new UTF8OutputJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out,\n            can, firstByte);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, _generatorFeatures,\n            _objectCodec, out, _rootCharSymbols.makeChild(_factoryFeatures));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    // 13-May-2016, tatu: Need to take care not to accidentally create JSON parser for\n    //   non-JSON input.\n    _requireJSONFactory(\"OutputStream source not (yet?) supported for this format (%s)\");\n    // Also: while we can't do full bootstrapping (due to read-ahead limitations), should\n    // at least handle possible UTF-8 BOM\n    int firstByte = ByteSourceJsonBootstrapper.skipUTF8BOM(out);\n    ByteQuadsCanonicalizer can = _byteSymbolCanonicalizer.makeChild(_factoryFeatures);\n    return new UTF8OutputJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out,\n            can, firstByte);\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type.getNativeType(JSTypeNative.NO_TYPE);\n    }\n    return type;\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n    return type;\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type == null) {\n        return null;\n    }\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    if (type.isUnknownType()) {\n        return type.getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n    }\n    return type.getNativeType(JSTypeNative.NO_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n    return type;\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type.getNativeType(JSTypeNative.NO_TYPE);\n    }\n    return type;\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type == null) \n    {\n        return null;\n    }\n\n    if (type.isNoResolvedType()) \n    {\n        return type;\n    }\n\n    if (type.isUnknownType()) \n    {\n        return type.getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n    }\n\n    return type.getNativeType(JSTypeNative.NO_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type == null) \n    {\n        return null;\n    }\n    if (type.isNoResolvedType()) \n    {\n        return type;\n    }\n    if (type.isUnknownType()) \n    {\n        return type;\n    }\n    if (type.isNoType()) \n    {\n        return type;\n    }\n    if (type.isAllType()) \n    {\n        return type;\n    }\n    if (type.isCheckedUnknownType()) \n    {\n        return type;\n    }\n    if (type.isUnionType()) \n    {\n        UnionType unionType = type.toMaybeUnionType();\n        if (unionType != null) \n        {\n            JSType[] alternates = unionType.getAlternates();\n            JSType[] filteredAlternates = new JSType[alternates.length];\n            int index = 0;\n            for (JSType alternate : alternates) \n            {\n                if (alternate.isNoResolvedType() || alternate.isUnknownType() || alternate.isNoType() || alternate.isAllType() || alternate.isCheckedUnknownType()) \n                {\n                    filteredAlternates[index++] = alternate;\n                }\n            }\n            if (index == alternates.length) \n            {\n                return type;\n            }\n            if (index == 0) \n            {\n                return getNativeType(JSTypeNative.NO_TYPE);\n            }\n            if (index == 1) \n            {\n                return filteredAlternates[0];\n            }\n            return createUnionType(filteredAlternates);\n        }\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n    return type;\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type.getNativeType(JSTypeNative.NO_TYPE);\n    }\n    return type;\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n      return type;\n    }\n    return type.isUnknownType() ? getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE) : null;\n  }"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n  if (restrictedType != null && restrictedType != originalType) {\n    FlowScope informed = blindScope.createChildFlowScope();\n    declareNameInScope(informed, node, restrictedType);\n    return informed;\n  }\n  return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n  if (restrictedType != null && restrictedType != originalType) {\n    FlowScope informed = blindScope.createChildFlowScope();\n    declareNameInScope(informed, node, restrictedType);\n    return informed;\n  }\n  return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n  if (restrictedType != null && restrictedType != originalType) {\n    FlowScope informed = blindScope.createChildFlowScope();\n    declareNameInScope(informed, node, restrictedType);\n    return informed;\n  }\n  return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n  if (restrictedType != null && restrictedType != originalType) {\n    FlowScope informed = blindScope.createChildFlowScope();\n    declareNameInScope(informed, node, restrictedType);\n    return informed;\n  }\n  return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n  if (restrictedType != null && restrictedType != originalType) {\n    FlowScope informed = blindScope.createChildFlowScope();\n    declareNameInScope(informed, node, restrictedType);\n    return informed;\n  }\n  return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n  if (restrictedType != null && restrictedType != originalType) {\n    FlowScope informed = blindScope.createChildFlowScope();\n    declareNameInScope(informed, node, restrictedType);\n    return informed;\n  }\n  return blindScope;\n}"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  skipEOLs();\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.THIS)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.COLON)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n  next();\n  skipEOLs();\n  Node thisType = parseTypeExpression(next());\n  if (thisType == null) {\n    return null;\n  }\n  functionType.addChildToBack(thisType);\n  skipEOLs();\n  if (!match(JsDocToken.COMMA)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n  }\n  next();\n  skipEOLs();\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) {\n    return null;\n  }\n  functionType.addChildToBack(parametersType);\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return null;\n  }\n  functionType.addChildToBack(resultType);\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParameters = null;\n    Node thisType = null;\n    Node parametersType = null;\n    Node resultType = null;\n    if (match(JsDocToken.LT)) \n    {\n        next();\n        skipEOLs();\n        typeParameters = parseTypeExpressionList(next());\n        if (typeParameters == null) \n        {\n            return null;\n        }\n        skipEOLs();\n        if (!match(JsDocToken.GT)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n        next();\n    }\n    skipEOLs();\n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    if (match(JsDocToken.THIS)) \n    {\n        next();\n        skipEOLs();\n        if (!match(JsDocToken.COLON)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n        }\n        next();\n        skipEOLs();\n        thisType = parseTypeExpression(next());\n        if (thisType == null) \n        {\n            return null;\n        }\n        skipEOLs();\n    }\n    if (!match(JsDocToken.RP)) \n    {\n        parametersType = parseParametersType(next());\n        if (parametersType == null) \n        {\n            return null;\n        }\n        skipEOLs();\n    }\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    resultType = parseResultType(next());\n    if (resultType == null) \n    {\n        return null;\n    }\n    skipEOLs();\n    functionType.addChildToFront(resultType);\n    if (parametersType != null) \n    {\n}\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node typeParameters = parseTypeParameters(token);\n  if (typeParameters != null) {\n    functionType.addChildToFront(typeParameters);\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n\n  skipEOLs();\n  if (!match(JsDocToken.THIS)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n  next();\n\n  skipEOLs();\n  if (!match(JsDocToken.COLON)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n  next();\n\n  skipEOLs();\n  Node thisType = parseTypeExpression(next());\n  if (thisType == null) {\n    return null;\n  }\n  functionType.addChildToBack(thisType);\n\n  skipEOLs();\n  if (!match(JsDocToken.COMMA)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n  }\n  next();\n\n  skipEOLs();\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) {\n    return null;\n  }\n  functionType.addChildToBack(parametersType);\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return null;\n  }\n  functionType.addChildToBack(resultType);\n\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node typeParameters = parseTypeParameters(token);\n  if (typeParameters != null) \n  {\n    functionType.addChildToFront(typeParameters);\n  }\n  skipEOLs();\n  if (!match(JsDocToken.LP)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.THIS)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.COLON)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n  next();\n  skipEOLs();\n  Node typeName = parseTypeName(next());\n  if (typeName == null) \n  {\n    return null;\n  }\n  functionType.addChildToBack(typeName);\n  skipEOLs();\n  if (!match(JsDocToken.COMMA)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n  }\n  next();\n  skipEOLs();\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) \n  {\n    return null;\n  }\n  functionType.addChildToBack(parametersType);\n  skipEOLs();\n  if (!match(JsDocToken.RP)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) \n  {\n    return null;\n  }\n  functionType.addChildToBack(resultType);\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node typeParameters = null;\n  Node thisType = null;\n  Node parametersType = null;\n  Node resultType = null;\n\n  if (match(JsDocToken.LT)) \n  {\n    typeParameters = parseTypeParameters(next());\n    if (typeParameters == null) \n    {\n      return null;\n    }\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.LP)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n\n  skipEOLs();\n  if (match(JsDocToken.THIS)) \n  {\n    thisType = parseTypeNameAnnotation(next());\n    if (thisType == null) \n    {\n      return null;\n    }\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) \n    {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n  }\n\n  parametersType = parseParametersType(next());\n  if (parametersType == null) \n  {\n    return null;\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n\n  skipEOLs();\n  resultType = parseResultType(next());\n  if (resultType == null) \n  {\n    return null;\n  }\n\n  functionType.addChildToFront(resultType);\n  functionType.addChildToFront(parametersType);\n  if (thisType != null) \n  {\n    functionType.addChildToFront(thisType);\n  }\n  if (typeParameters != null) \n  {\n    functionType.addChildToFront(typeParameters);\n  }\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node typeParameters = null;\n  Node parametersType = null;\n  Node resultType = null;\n\n  if (match(JsDocToken.LT)) {\n    typeParameters = parseTypeParameters(next());\n    if (typeParameters == null) {\n      return null;\n    }\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n\n  skipEOLs();\n  if (match(JsDocToken.THIS)) {\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    Node thisType = parseTypeExpression(next());\n    if (thisType == null) {\n      return null;\n    }\n    functionType.addChildToFront(thisType);\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    parametersType = parseParametersType(next());\n    if (parametersType == null) {\n      return null;\n    }\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n\n  skipEOLs();\n  if (match(JsDocToken.COLON)) {\n    next();\n    skipEOLs();\n    resultType = parseTypeExpression(next());\n    if (resultType == null) {\n      return null;\n    }\n  }\n\n  if (typeParameters != null) {\n    functionType.addChildToFront(typeParameters);\n  }\n  if (parametersType != null) {\n    functionType.addChildToFront(parametersType);\n  }\n  if (resultType != null) {\n    functionType.addChildToFront(resultType);\n  }\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParameters = null;\n    if (match(JsDocToken.LT)) \n    {\n        typeParameters = parseTypeParameters(next());\n        if (typeParameters == null) \n        {\n            return null;\n        }\n        functionType.addChildToFront(typeParameters);\n    }\n    skipEOLs();\n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    Node thisType = newStringNode(\"this\", lineno, charno);\n    if (!match(JsDocToken.COLON)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    Node typeName = parseTypeName(next());\n    if (typeName == null) \n    {\n        return null;\n    }\n    thisType.addChildToFront(typeName);\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n    }\n    next();\n    skipEOLs();\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) \n    {\n        return null;\n    }\n    skipEOLs();\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) \n    {\n        return null;\n    }\n    functionType.addChildToBack(thisType);\n    functionType.addChildToBack(parametersType);\n    functionType.addChildToBack(resultType);\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.THIS)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    Node typeName = parseTypeName(next());\n    if (typeName == null) {\n      return null;\n    }\n    functionType.addChildToBack(typeName);\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n    }\n    next();\n    skipEOLs();\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n      return null;\n    }\n    functionType.addChildToBack(parametersType);\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    }\n    functionType.addChildToBack(resultType);\n    return functionType;\n  }\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  skipEOLs();\n  if (!match(JsDocToken.LP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.THIS)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n  }\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.COLON)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n  }\n  next();\n  skipEOLs();\n  Node typeName = parseTypeName(next());\n  if (typeName == null) {\n    return null;\n  }\n  functionType.addChildToBack(typeName);\n  skipEOLs();\n  if (!match(JsDocToken.COMMA)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n  }\n  next();\n  skipEOLs();\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) {\n    return null;\n  }\n  functionType.addChildToBack(parametersType);\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return null;\n  }\n  functionType.addChildToBack(resultType);\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    skipEOLs();\n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.THIS)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    Node typeName = parseTypeName(next());\n    if (typeName == null) \n    {\n        return null;\n    }\n    functionType.addChildToBack(typeName);\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n    }\n    next();\n    skipEOLs();\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) \n    {\n        return null;\n    }\n    functionType.addChildToBack(parametersType);\n    skipEOLs();\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) \n    {\n        return null;\n    }\n    functionType.addChildToBack(resultType);\n    return functionType;\n}"
    ],
    [
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    return count == sz ? str : new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    return count == sz ? str : new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    return count == sz ? str : new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    if (sz == 0) {\n        return str;\n    }\n    char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    return count == sz ? str : new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    if (sz == 0) {\n        return str;\n    }\n    StringBuilder buffer = new StringBuilder(sz);\n    for (int i = 0; i < sz; i++) {\n        char ch = str.charAt(i);\n        if (!Character.isWhitespace(ch)) {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    int sz = str.length();\n    char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    \n    SummaryStatistics combinedStats = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        combinedStats.addValue(stat.getMean());\n        combinedStats.addValue(stat.getVariance());\n        combinedStats.addValue(stat.getN());\n        combinedStats.addValue(stat.getMax());\n        combinedStats.addValue(stat.getMin());\n        combinedStats.addValue(stat.getSum());\n    }\n    \n    return new StatisticalSummaryValues(combinedStats.getMean(), combinedStats.getVariance(), combinedStats.getN(), combinedStats.getMax(), combinedStats.getMin(), combinedStats.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    SummaryStatistics aggregateStatistics = new SummaryStatistics();\n    for (SummaryStatistics s : statistics) {\n        if (s != null) {\n            aggregateStatistics.addValue(s.getSum());\n            aggregateStatistics.addValue(s.getSumsq());\n            aggregateStatistics.addValue(s.getMin());\n            aggregateStatistics.addValue(s.getMax());\n            aggregateStatistics.addValue(s.getSumOfLogs());\n            aggregateStatistics.addValue(s.getGeometricMean());\n            aggregateStatistics.addValue(s.getSecondMoment());\n        }\n    }\n    return aggregateStatistics.getSummary();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    \n    SummaryStatistics aggregate = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregate.addValues(stat.getValues());\n    }\n    \n    return aggregate.getSummaryValues();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    SummaryStatistics aggregate = new SummaryStatistics();\n    for (SummaryStatistics s : statistics) {\n        aggregate.addValues(s.getValues());\n    }\n    return aggregate.getSummary();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    SummaryStatistics combined = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        combined.addValue(stat.getSum());\n        combined.addValue(stat.getSumsq());\n        combined.addValue(stat.getMin());\n        combined.addValue(stat.getMax());\n        combined.addValue(stat.getSumOfLogs());\n        combined.addValue(stat.getGeometricMean());\n        combined.addValue(stat.getSecondMoment());\n    }\n    return combined.getSummary();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics aggregateStatistics = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregateStatistics.addValues(stat);\n    }\n    return aggregateStatistics.getSummaryValues();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    SummaryStatistics combinedStatistics = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) \n    {\n        combinedStatistics.addValue(stat.getMean());\n        combinedStatistics.addValue(stat.getVariance());\n        combinedStatistics.addValue(stat.getN());\n        combinedStatistics.addValue(stat.getMax());\n        combinedStatistics.addValue(stat.getMin());\n        combinedStatistics.addValue(stat.getSum());\n    }\n\n    return new StatisticalSummaryValues(\n        combinedStatistics.getMean(),\n        combinedStatistics.getVariance(),\n        combinedStatistics.getN(),\n        combinedStatistics.getMax(),\n        combinedStatistics.getMin(),\n        combinedStatistics.getSum()\n    );\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    \n    SummaryStatistics combined = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        combined.addValue(stat.getMean());\n        combined.addValue(stat.getVariance());\n        combined.addValue(stat.getN());\n        combined.addValue(stat.getMax());\n        combined.addValue(stat.getMin());\n        combined.addValue(stat.getSum());\n    }\n    \n    return new StatisticalSummaryValues(combined.getMean(), combined.getVariance(), combined.getN(), combined.getMax(), combined.getMin(), combined.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n    SummaryStatistics aggregate = new SummaryStatistics();\n    for (SummaryStatistics s : statistics) \n    {\n        aggregate.addValue(s.getMean());\n        aggregate.addValue(s.getVariance());\n        aggregate.addValue(s.getN());\n        aggregate.addValue(s.getMax());\n        aggregate.addValue(s.getMin());\n        aggregate.addValue(s.getSum());\n    }\n    return new StatisticalSummaryValues(aggregate.getMean(), aggregate.getVariance(), aggregate.getN(), aggregate.getMax(), aggregate.getMin(), aggregate.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n    SummaryStatistics combinedStats = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) \n    {\n        combinedStats.addValues(stat.getValues());\n    }\n    return combinedStats.getSummaryValues();\n}"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i];\n        result += diff * diff;\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n <= 1) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i];\n        result += diff * diff;\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i];\n        result += diff * diff;\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n <= 1) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i];\n        result += diff * diff;\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n <= 1) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i];\n        result += diff * diff;\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n <= 1) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i];\n        result += diff * diff;\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n <= 1) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    double sumSq = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i];\n        sumSq += diff * diff;\n    }\n    return sumSq / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i];\n        result += diff * diff;\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i];\n        result += diff * diff;\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n <= 1) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i];\n        result += diff * diff;\n    }\n    return result / (n - 1);\n}"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int seriesCount = dataset.getItemCount();\n    for (int series = 0; series < seriesCount; series++) {\n        Number value = dataset.getValue(series);\n        if (value != null) {\n            double v = value.doubleValue();\n            if (v > 0.0) {\n                total = total + v;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int seriesCount = dataset.getItemCount();\n    for (int series = 0; series < seriesCount; series++) {\n        Number value = dataset.getValue(series);\n        if (value != null) {\n            double v = value.doubleValue();\n            if (v > 0.0) {\n                total = total + v;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null && !Double.isNaN(value.doubleValue())) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int seriesCount = dataset.getItemCount();\n    for (int series = 0; series < seriesCount; series++) \n    {\n        Number value = dataset.getValue(series);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    int seriesCount = dataset.getItemCount();\n    for (int series = 0; series < seriesCount; series++) \n    {\n        Number value = dataset.getValue(series);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int seriesCount = dataset.getItemCount();\n    for (int series = 0; series < seriesCount; series++) \n    {\n        Number value = dataset.getValue(series);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_BUFFERED) \n    {\n        result = peekedString;\n        peekedString = null;\n    } \n    else if (p == PEEKED_LONG) \n    {\n        result = Long.toString(peekedLong);\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_BUFFERED) \n    {\n        result = peekedString;\n        peekedString = null;\n    } \n    else if (p == PEEKED_LONG) \n    {\n        result = Long.toString(peekedLong);\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  String result;\n  if (p == PEEKED_UNQUOTED) {\n    result = nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED) {\n    result = nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED) {\n    result = nextQuotedValue('\"');\n  } else if (p == PEEKED_BUFFERED) {\n    result = peekedString;\n    peekedString = null;\n  } else if (p == PEEKED_LONG) {\n    result = Long.toString(peekedLong);\n  } else if (p == PEEKED_NUMBER) {\n    result = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  } else {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_BUFFERED) \n    {\n        result = peekedString;\n        peekedString = null;\n    } \n    else if (p == PEEKED_LONG) \n    {\n        result = Long.toString(peekedLong);\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_BUFFERED) \n    {\n        result = peekedString;\n        peekedString = null;\n    } \n    else if (p == PEEKED_LONG) \n    {\n        result = Long.toString(peekedLong);\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_BUFFERED) \n    {\n        result = peekedString;\n        peekedString = null;\n    } \n    else if (p == PEEKED_LONG) \n    {\n        result = Long.toString(peekedLong);\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n        result = peekedString;\n        peekedString = null;\n    } else if (p == PEEKED_LONG) {\n        result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n        result = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED_NAME) \n  {\n    result = nextUnquotedValue();\n  } \n  else if (p == PEEKED_SINGLE_QUOTED_NAME) \n  {\n    result = nextQuotedValue('\\'');\n  } \n  else if (p == PEEKED_DOUBLE_QUOTED_NAME) \n  {\n    result = nextQuotedValue('\"');\n  } \n  else if (p == PEEKED_BUFFERED) \n  {\n    result = peekedString;\n    peekedString = null;\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED) \n  {\n    result = nextUnquotedValue();\n  } \n  else if (p == PEEKED_SINGLE_QUOTED) \n  {\n    result = nextQuotedValue('\\'');\n  } \n  else if (p == PEEKED_DOUBLE_QUOTED) \n  {\n    result = nextQuotedValue('\"');\n  } \n  else if (p == PEEKED_BUFFERED) \n  {\n    result = peekedString;\n    peekedString = null;\n  } \n  else if (p == PEEKED_LONG) \n  {\n    result = Long.toString(peekedLong);\n  } \n  else if (p == PEEKED_NUMBER) \n  {\n    result = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) {\n        return nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n        return nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n        return nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n        return peekedString;\n    } else if (p == PEEKED_LONG) {\n        return Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n        return new String(buffer, pos, peekedNumberLength);\n    } else {\n        throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) \n    {\n        int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        if (read > 0) \n        {\n            uncompressedBytesRemaining -= read;\n        }\n        return read;\n    } \n    else if (currentCompressedChunk != null) \n    {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        if (read > 0) {\n            uncompressedBytesRemaining -= read;\n            if (uncompressedBytesRemaining == 0) {\n                inUncompressedChunk = false;\n            }\n        }\n        return read;\n    } else if (currentCompressedChunk != null) {\n        int read = currentCompressedChunk.read(b, off, len);\n        if (read > 0) {\n            expectedChecksum = checksum.getValue();\n        } else if (read == -1) {\n            verifyLastChecksumAndReset();\n            currentCompressedChunk = null;\n        }\n        return read;\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    int read = -1;\n    if (currentCompressedChunk != null) {\n        read = currentCompressedChunk.read(b, off, len);\n        if (read == -1) {\n            currentCompressedChunk.close();\n            currentCompressedChunk = null;\n        }\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    int read = -1;\n    if (inUncompressedChunk) {\n        read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        if (read != -1) {\n            uncompressedBytesRemaining -= read;\n        }\n    } else if (currentCompressedChunk != null) {\n        read = currentCompressedChunk.read(b, off, len);\n    }\n    if (read != -1) {\n        size += read;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    int read = 0;\n    if (inUncompressedChunk) {\n        read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        if (read != -1) {\n            uncompressedBytesRemaining -= read;\n        }\n    } else if (currentCompressedChunk != null) {\n        read = currentCompressedChunk.read(b, off, len);\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    int read = -1;\n    if (inUncompressedChunk) {\n        read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        if (read != -1) {\n            uncompressedBytesRemaining -= read;\n        }\n    } else if (currentCompressedChunk != null) {\n        read = currentCompressedChunk.read(b, off, len);\n        if (read != -1) {\n            expectedChecksum ^= read;\n        }\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    int read = 0;\n    if (inUncompressedChunk) {\n        read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        if (read != -1) {\n            uncompressedBytesRemaining -= read;\n        }\n    } else if (currentCompressedChunk != null) {\n        read = currentCompressedChunk.read(b, off, len);\n        if (read != -1) {\n            expectedChecksum ^= ByteUtils.toLong(b, off, read);\n        }\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) {\n        if (uncompressedBytesRemaining == 0) {\n            inUncompressedChunk = false;\n            currentCompressedChunk = null;\n        } else {\n            final int read = Math.min(len, uncompressedBytesRemaining);\n            in.read(b, off, read);\n            uncompressedBytesRemaining -= read;\n            return read;\n        }\n    } else if (currentCompressedChunk != null) {\n        final int read = currentCompressedChunk.read(b, off, len);\n        if (read == -1) {\n            currentCompressedChunk = null;\n        }\n        return read;\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    int read = -1;\n    if (inUncompressedChunk) {\n        read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n        if (read != -1) {\n            uncompressedBytesRemaining -= read;\n        }\n    } else if (currentCompressedChunk != null) {\n        read = currentCompressedChunk.read(b, off, len);\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk != null) {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site.node.isCall() || site.node.isNew()) {\n        return getArgumentForCallOrNew(site.node, argIndex);\n    } else if (site.node.isGetElem() || site.node.isGetProp()) {\n        Node parent = site.node.getParent();\n        if (parent != null && parent.isCall()) {\n            return getArgumentForCallOrNew(parent, argIndex);\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node call = site.node;\n      if (call.isCall() || call.isNew()) {\n        return getArgumentForCallOrNew(call, argIndex);\n      } else if (call.isGetElem() && argIndex == 1) {\n        return call.getFirstChild().getNext();\n      } else if (call.isGetProp() && argIndex == 1) {\n        return call.getFirstChild().getNext();\n      } else if (call.isDotCall()) {\n        return getArgumentForCallOrNew(call.getFirstChild(), argIndex);\n      } else if (call.isString() && argIndex == 1) {\n        return call.getFirstChild().getNext();\n      } else if (call.isArrayLit() && argIndex == 0) {\n        return call.getFirstChild();\n      } else if (call.isObjectLit() && argIndex == 0) {\n        return call.getFirstChild();\n      } else if (call.isFunction() && argIndex == 0) {\n        return call.getFirstChild();\n      } else if (call.isName() && argIndex == 0) {\n        return call.getFirstChild();\n      } else if (call.isThis() && argIndex == 0) {\n        return call.getFirstChild();\n      } else if (call.isRegExp() && argIndex == 0) {\n        return call.getFirstChild();\n      } else if (call.isNumber() && argIndex == 0) {\n        return call.getFirstChild();\n      } else if (call.isString() && argIndex == 0) {\n        return call.getFirstChild();\n      } else if (call.isArrayLit() && argIndex == 1) {\n        return call.getFirstChild().getNext();\n      } else if (call.isObjectLit() && argIndex == 1) {\n        return call.getFirstChild().getNext();\n      } else if (call.isFunction() && argIndex == 1) {\n}\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.node;\n    if (isFunctionObjectCall(call)) {\n      call = call.getFirstChild();\n    }\n    if (isFunctionObjectApply(call)) {\n      call = call.getFirstChild();\n    }\n    if (isToStringMethodCall(call)) {\n      return call.getFirstChild();\n    }\n    return getArgumentForCallOrNew(call, argIndex);\n  }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (node.isCall() || node.isNew()) {\n        return getArgumentForCallOrNew(node, argIndex);\n    } else if (node.isGetElem() || node.isGetProp()) {\n        // If the call is of the form A.B.C(...) then the call is the\n        // last child of the rightmost node.\n        Node parent = node.getParent();\n        while (parent != null && !parent.isCall() && !parent.isNew()) {\n            node = parent;\n            parent = node.getParent();\n        }\n        if (parent != null) {\n            return getArgumentForCallOrNew(parent, argIndex);\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n      Node call = site.node;\n      if (call.isCall() || call.isNew()) {\n        return getArgumentForCallOrNew(call, argIndex);\n      } else if (isGet(call)) {\n        Node obj = call.getFirstChild();\n        Node prop = call.getLastChild();\n        if (prop.isString() && \"call\".equals(prop.getString())) {\n          Node arg = getArgumentForCallOrNew(obj, argIndex + 1);\n          if (arg != null) {\n            return arg;\n          }\n        }\n      }\n      return null;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (node.isCall() || node.isNew()) {\n      return getArgumentForCallOrNew(node, argIndex);\n    } else if (node.isGetElem()) {\n      Node parent = node.getParent();\n      if (parent != null && parent.isCall()) {\n        return getArgumentForCallOrNew(parent, argIndex);\n      }\n    } else if (node.isGetProp()) {\n      Node parent = node.getParent();\n      if (parent != null && parent.isCall() && isToStringMethodCall(parent)) {\n        return getArgumentForCallOrNew(parent, argIndex);\n      }\n    }\n    return null;\n  }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.node;\n    if (call.isCall()) {\n        return getArgumentForCallOrNew(call, argIndex);\n    } else if (call.isNew()) {\n        return getArgumentForCallOrNew(call, argIndex);\n    } else if (call.isGetElem()) {\n        Node parent = call.getParent();\n        if (parent != null && parent.isCall()) {\n            return getArgumentForCallOrNew(parent, argIndex);\n        }\n    } else if (call.isGetProp()) {\n        if (isToStringMethodCall(call)) {\n            return getArgumentForCallOrNew(call.getParent(), argIndex);\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.node;\n    if (isFunctionObjectCall(call)) {\n      return getArgumentForCallOrNew(call.getFirstChild(), argIndex);\n    } else if (isFunctionObjectApply(call)) {\n      Node arg = getArgumentForCallOrNew(call.getFirstChild(), 0);\n      if (arg != null && arg.isArrayLit()) {\n        return NodeUtil.getArgumentForCallOrNew(arg, argIndex);\n      }\n    } else if (isToStringMethodCall(call)) {\n      Node arg = getArgumentForCallOrNew(call.getFirstChild(), 0);\n      if (arg != null && arg.isString()) {\n        return null;\n      }\n    }\n    return null;\n  }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site.node.isCall()) {\n        return getArgumentForCallOrNew(site.node, argIndex);\n    } else if (site.node.isNew()) {\n        return getArgumentForCallOrNew(site.node.getFirstChild(), argIndex);\n    } else if (site.node.isGetProp() || site.node.isGetElem()) {\n        return getArgumentForCallOrNew(site.node.getParent(), argIndex);\n    } else {\n        return null;\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.node;\n    if (isFunctionObjectCall(call)) {\n      call = call.getFirstChild();\n    }\n    return getArgumentForCallOrNew(call, argIndex);\n  }"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n\n    return \"\";\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) \n  {\n    return null;\n  }\n  JSType normalizedType = type.dereference();\n  if (normalizedType == null) \n  {\n    return null;\n  }\n  if (normalizedType.isFunctionType()) \n  {\n    FunctionType fn = normalizedType.toMaybeFunctionType();\n    if (fn.isConstructor()) \n    {\n      return getTypeDeprecationInfo(fn.getInstanceType());\n    }\n    if (fn.isInterface()) \n    {\n      return getTypeDeprecationInfo(fn.getPrototype());\n    }\n  }\n  JSDocInfo info = normalizedType.getJSDocInfo();\n  if (info != null && info.isDeprecated()) \n  {\n    if (info.getDeprecationReason() != null) \n    {\n      return info.getDeprecationReason();\n    }\n    return \"\";\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) \n  {\n    if (info.getDeprecationReason() != null) \n    {\n      return info.getDeprecationReason();\n    }\n    return \"\";\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type.isFunctionType()) \n  {\n    JSDocInfo info = type.toMaybeFunctionType().getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n      if (info.getDeprecationReason() != null) \n      {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n  } \n  else if (type.isObjectType()) \n  {\n    JSDocInfo info = type.toObjectType().getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n      if (info.getDeprecationReason() != null) \n      {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type != null) {\n    JSTypeNative nativeType = type.toMaybeNativeType();\n    if (nativeType != null) {\n      return getTypeDeprecationInfo(nativeType);\n    }\n\n    JSTypeRegistry registry = type.getJSTypeRegistry();\n    if (registry != null) {\n      JSDocInfo info = registry.getTypeDeclaration(type).getJSDocInfo();\n      if (info != null && info.isDeprecated()) {\n        if (info.getDeprecationReason() != null) {\n          return info.getDeprecationReason();\n        }\n\n        return \"\";\n      }\n    }\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type.isFunctionType()) \n  {\n    JSDocInfo info = type.toMaybeFunctionType().getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n      if (info.getDeprecationReason() != null) \n      {\n        return info.getDeprecationReason();\n      }\n      return \"\";\n    }\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type.isFunctionType()) \n  {\n    JSDocInfo info = type.toMaybeFunctionType().getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n      if (info.getDeprecationReason() != null) \n      {\n        return info.getDeprecationReason();\n      }\n      return \"\";\n    }\n  } \n  else if (type.isObjectType()) \n  {\n    JSDocInfo info = type.toObjectType().getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n      if (info.getDeprecationReason() != null) \n      {\n        return info.getDeprecationReason();\n      }\n      return \"\";\n    }\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSTypeNative nativeType = type.toMaybeNativeType();\n  if (nativeType != null) {\n    switch (nativeType) {\n      case ARRAY_TYPE:\n        return \"Array\";\n      case BOOLEAN_TYPE:\n        return \"boolean\";\n      case FUNCTION_TYPE:\n        return \"Function\";\n      case NUMBER_TYPE:\n        return \"number\";\n      case OBJECT_TYPE:\n        return \"Object\";\n      case REGEXP_TYPE:\n        return \"RegExp\";\n      case STRING_TYPE:\n        return \"string\";\n      case VOID_TYPE:\n        return \"void\";\n      default:\n        return null;\n    }\n  }\n\n  JSTypeObjectType objectType = type.toMaybeObjectType();\n  if (objectType != null) {\n    JSDocInfo info = objectType.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type.isFunctionType()) \n  {\n    JSDocInfo info = type.toMaybeFunctionType().getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n      if (info.getDeprecationReason() != null) \n      {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  JSDocInfo info = type.getJSDocInfo();\n  if (info != null && info.isDeprecated()) {\n    if (info.getDeprecationReason() != null) {\n      return info.getDeprecationReason();\n    }\n\n    return \"\";\n  }\n  return null;\n}"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String prior = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (prior != null) {\n            value = prior;\n        }\n    }\n    return value;\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = -1;\n    if (key != null) \n    {\n        columnIndex = this.columnKeys.indexOf(key);\n    }\n    return columnIndex;\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int index = -1;\n    if (this.underlying != null) \n    {\n        index = this.underlying.getColumnIndex(key);\n        if (index >= this.firstCategoryIndex && index < this.firstCategoryIndex + this.maximumCategoryCount) \n        {\n            index = index - this.firstCategoryIndex;\n        } \n        else \n        {\n            index = -1;\n        }\n    }\n    return index;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = -1;\n    if (key != null) \n    {\n        int columnCount = getColumnCount();\n        for (int i = 0; i < columnCount; i++) \n        {\n            if (getColumnKey(i).equals(key)) \n            {\n                columnIndex = i;\n                break;\n            }\n        }\n    }\n    return columnIndex;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = -1;\n    if (key != null) \n    {\n        int columnCount = getColumnCount();\n        for (int i = 0; i < columnCount; i++) \n        {\n            Comparable columnKey = getColumnKey(i);\n            if (key.equals(columnKey)) \n            {\n                columnIndex = i;\n                break;\n            }\n        }\n    }\n    return columnIndex;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int index = -1;\n    if (key != null) \n    {\n        int columnCount = getColumnCount();\n        for (int i = 0; i < columnCount; i++) \n        {\n            if (getColumnKey(i).equals(key)) \n            {\n                index = i;\n                break;\n            }\n        }\n    }\n    return index;\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int columnIndex = -1;\n    int columnCount = getColumnCount();\n    for (int i = 0; i < columnCount; i++) \n    {\n        Comparable columnKey = getColumnKey(i);\n        if (columnKey.equals(key)) \n        {\n            columnIndex = i;\n            break;\n        }\n    }\n    return columnIndex;\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.data.getIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = -1;\n    if (key != null) \n    {\n        int firstCategoryIndex = getFirstCategoryIndex();\n        int maximumCategoryCount = getMaximumCategoryCount();\n        int lastCategoryIndex = lastCategoryIndex();\n        if (firstCategoryIndex <= key && key <= lastCategoryIndex) \n        {\n            columnIndex = key - firstCategoryIndex;\n            if (columnIndex >= maximumCategoryCount) \n            {\n                columnIndex = maximumCategoryCount - 1;\n            }\n        }\n    }\n    return columnIndex;\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.data.getIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    int columnIndex = -1;\n    if (key != null) \n    {\n        int columnCount = getColumnCount();\n        for (int i = 0; i < columnCount; i++) \n        {\n            if (getColumnKey(i).equals(key)) \n            {\n                columnIndex = i;\n                break;\n            }\n        }\n    }\n    return columnIndex;\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point > upper + tolerance) \n    {\n        return Location.OUTSIDE;\n    } \n    else \n    {\n        return (point == lower || point == upper) ? Location.BOUNDARY : Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point <= lower - tolerance) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point >= upper + tolerance) \n    {\n        return Location.OUTSIDE;\n    } \n    else \n    {\n        return (point < lower + tolerance || point > upper - tolerance) ? Location.BOUNDARY : Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance)\n    {\n        return Location.OUTSIDE;\n    }\n    if (point > upper + tolerance)\n    {\n        return Location.OUTSIDE;\n    }\n    if (point < lower + tolerance || point > upper - tolerance)\n    {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point > upper + tolerance) \n    {\n        return Location.OUTSIDE;\n    } \n    else \n    {\n        if (point <= lower + tolerance || point >= upper - tolerance) \n        {\n            return Location.BOUNDARY;\n        } \n        else \n        {\n            return Location.INSIDE;\n        }\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point > upper + tolerance) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point <= lower + tolerance || point >= upper - tolerance) \n    {\n        return Location.BOUNDARY;\n    } \n    else \n    {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance)\n    {\n        return Location.OUTSIDE;\n    }\n    else if (point > upper + tolerance)\n    {\n        return Location.OUTSIDE;\n    }\n    else if (Math.abs(point - lower) <= tolerance || Math.abs(point - upper) <= tolerance)\n    {\n        return Location.BOUNDARY;\n    }\n    else\n    {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance)\n    {\n        return Location.OUTSIDE;\n    }\n    if (point > upper + tolerance)\n    {\n        return Location.OUTSIDE;\n    }\n    if (Math.abs(point - lower) <= tolerance || Math.abs(point - upper) <= tolerance)\n    {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point > upper + tolerance) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (Math.abs(point - lower) < tolerance || Math.abs(point - upper) < tolerance) \n    {\n        return Location.BOUNDARY;\n    } \n    else \n    {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point <= lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point >= upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (Math.abs(point - lower) <= tolerance) {\n        return Location.BOUNDARY;\n    } else if (Math.abs(point - upper) <= tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point <= lower - tolerance)\n    {\n        return Location.OUTSIDE;\n    }\n    if (point >= upper + tolerance)\n    {\n        return Location.OUTSIDE;\n    }\n    if (point >= lower + tolerance && point <= upper - tolerance)\n    {\n        return Location.INSIDE;\n    }\n    return Location.BOUNDARY;\n}\n    }"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double maxCoefficient = Double.MIN_VALUE;\n    int pivotColumn = -1;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) {\n        double coefficient = tableau.getEntry(0, i);\n        if (coefficient < maxCoefficient) {\n            maxCoefficient = coefficient;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the objective function row\n    List<Integer> minObjectiveFunctionPositions = new ArrayList<Integer>();\n    double minObjectiveFunction = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) {\n        final double entry = tableau.getEntry(0, i);\n\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) {\n            final double objectiveFunction = entry;\n            // check if the entry is strictly equal to the current min objective function\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(objectiveFunction, minObjectiveFunction);\n            if (cmp == 0) {\n                minObjectiveFunctionPositions.add(i);\n            } else if (cmp > 0) {\n                minObjectiveFunction = objectiveFunction;\n                minObjectiveFunctionPositions = new ArrayList<Integer>();\n                minObjectiveFunctionPositions.add(i);\n            }\n        }\n    }\n\n    if (minObjectiveFunctionPositions.size() == 0) {\n        return null;\n    } else if (minObjectiveFunctionPositions.size() > 1) {\n        // there's a degeneracy as indicated by a tie in the objective function row\n        throw new IllegalStateException(\"Degeneracy in objective function row\");\n    } else {\n        return minObjectiveFunctionPositions.get(0);\n    }\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) {\n        final double entry = tableau.getEntry(0, i);\n\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) {\n            final double ratio = entry / tableau.getEntry(1, i);\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) {\n                minRatioPositions.add(i);\n            } else if (cmp < 0) {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) {\n        return null;\n    } else if (minRatioPositions.size() > 1) {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // pick the first column in the list\n        return minRatioPositions.get(0);\n    } else {\n        return minRatioPositions.get(0);\n    }\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = -1;\n    double minCoefficient = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) \n    {\n        double coefficient = tableau.getEntry(0, i);\n        if (Precision.compareTo(coefficient, minCoefficient, maxUlps) < 0) \n        {\n            minCoefficient = coefficient;\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int minCoeffCol = -1;\n    double minCoeff = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) \n    {\n        double coeff = tableau.getEntry(0, i);\n        if (Precision.compareTo(coeff, minCoeff, maxUlps) < 0) \n        {\n            minCoeff = coeff;\n            minCoeffCol = i;\n        }\n    }\n    return minCoeffCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = -1;\n    double minCoefficient = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getNumObjectiveFunctions(); i++) \n    {\n        double coefficient = tableau.getEntry(i, tableau.getWidth() - 1);\n        if (coefficient < minCoefficient) \n        {\n            minCoefficient = coefficient;\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the objective function\n    List<Integer> minObjFunctionPositions = new ArrayList<Integer>();\n    double minObjFunction = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, minObjFunction, maxUlps) < 0) {\n            minObjFunction = entry;\n            minObjFunctionPositions = new ArrayList<Integer>();\n            minObjFunctionPositions.add(i);\n        } else if (Precision.compareTo(entry, minObjFunction, maxUlps) == 0) {\n            minObjFunctionPositions.add(i);\n        }\n    }\n\n    if (minObjFunctionPositions.size() == 0) {\n        return null;\n    } else if (minObjFunctionPositions.size() > 1) {\n        // there's a degeneracy as indicated by a tie in the objective function\n        // return the column with the most negative coefficient in the objective function row\n        return minObjFunctionPositions.get(0);\n    } else {\n        return minObjFunctionPositions.get(0);\n    }\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = -1;\n    double minCoefficient = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) {\n        double coefficient = tableau.getEntry(0, i);\n        if (coefficient < minCoefficient) {\n            minCoefficient = coefficient;\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = -1;\n    double minCoeff = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getNumObjectiveFunctions(); i++) \n    {\n        double coeff = tableau.getEntry(i, tableau.getWidth() - 1);\n        if (coeff < minCoeff) \n        {\n            minCoeff = coeff;\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) {\n        final double entry = tableau.getEntry(0, i);\n\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) {\n            final double ratio = entry;\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) {\n                minRatioPositions.add(i);\n            } else if (cmp < 0) {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) {\n        return null;\n    } else if (minRatioPositions.size() > 1) {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        // TODO: handle degeneracy\n    }\n\n    return minRatioPositions.get(0);\n}"
    ]
  ]
}