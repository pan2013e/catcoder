{
  "benchmark": "javaeval_xc",
  "lastest_eval": {
    "compile@1": 0.680904522613065,
    "pass@1": 0.3964824120603014,
    "compile@3": 0.8033500837520934,
    "pass@3": 0.47437185929648223,
    "compile@5": 0.8407114939778257,
    "pass@5": 0.5048057749062773
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }\n\n     /*\n     /**********************************************************\n     /* Configuration methods, adding deserializers\n     /**********************************************************",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }"
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            TimePeriod planned = task.getPlanned();\n            if (planned != null) {\n                double plannedDuration = planned.getDuration();\n                double actualDuration = duration.getDuration();\n                result = new Double(actualDuration / plannedDuration);\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Long(duration.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            TimePeriod start = duration.getStart();\n            TimePeriod end = duration.getEnd();\n            if (end != null) {\n                long diff = end.getTime() - start.getTime();\n                if (diff > 0) {\n                    long now = System.currentTimeMillis();\n                    long diffNow = now - start.getTime();\n                    if (diffNow > 0) {\n                        result = new Double(diffNow / diff);\n                    }\n                }\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(task.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Long(duration.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = new Double(task.getPercentComplete());\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            TimePeriod planned = task.getPlannedDuration();\n            if (planned != null) {\n                double fraction = (double) duration.getDuration()\n                        / planned.getDuration();\n                result = new Double(fraction);\n            }\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            result = new Double(task.getPercentComplete());\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        TimePeriod duration = task.getDuration();\n        if (duration != null) {\n            long start = duration.getStart().getTime();\n            long end = duration.getEnd().getTime();\n            long now = System.currentTimeMillis();\n            if (now < end) {\n                result = new Double(\n                    (now - start) / (double) (end - start));\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        for (int i = 0; i < size; i++) \n        {\n            if (str.equals(new String(buffer, i, len))) \n            {\n                deleteImpl(i, i + len, len);\n                break;\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        for (int i = 0; i < size; i++) \n        {\n            if (str.equals(new String(buffer, i, len))) \n            {\n                deleteImpl(i, i + len, len);\n                break;\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        for (int i = 0; i < size; i++) \n        {\n            if (str.equals(new String(buffer, i, len))) \n            {\n                deleteImpl(i, i + len, len);\n                break;\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        for (int i = 0; i < size; i++) \n        {\n            if (str.equals(new String(buffer, i, len))) \n            {\n                deleteImpl(i, i + len, len);\n                break;\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        for (int i = 0; i < size; i++) \n        {\n            if (str.equals(new String(buffer, i, len))) \n            {\n                deleteImpl(i, i + len, len);\n                break;\n            }\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, true);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, true);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, true);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return new Array2DRowRealMatrix(m.getData(), false);\n    }\n    if (m.getRowDimension() == 1) {\n        return new Array2DRowRealMatrix(m.getColumnDimension(), 1, false);\n    }\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int i = 0; i < m.getRowDimension(); i++) {\n        for (int j = 0; j < m.getColumnDimension(); j++) {\n            d[i][j] = i == j ? m.getEntry(i, j) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int n = m.getRowDimension();\n    final int m2 = m.getColumnDimension();\n    if (n == m2) {\n        return new DiagonalMatrix(m.getData());\n    }\n    final double[][] d = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            d[i][j] = i == j ? m.getEntry(i, j) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getRowDimension() == m.getColumnDimension()) {\n        return new Array2DRowRealMatrix(m.getData(), false);\n    } else if (m.getRowDimension() == 1) {\n        final double[][] d = new double[m.getColumnDimension()][m.getColumnDimension()];\n        for (int i = 0; i < m.getColumnDimension(); i++) {\n            d[i][i] = m.getEntry(0, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            d[i][i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return new Array2DRowRealMatrix(m.getData(), false);\n    }\n    final double[][] d = new double[m.getColumnDimension()][m.getColumnDimension()];\n    for (int i = 0; i < m.getColumnDimension(); i++) {\n        d[i][i] = m.getEntry(i, i);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int rd = m.getRowDimension();\n    final int cd = m.getColumnDimension();\n    final double[][] d = new double[rd][cd];\n    for (int r = 0; r < rd; r++) \n    {\n        for (int c = 0; c < cd; c++) \n        {\n            d[r][c] = r == c ? m.getEntry(r, c) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getRowDimension() == m.getColumnDimension()) {\n        return m.transpose();\n    } else {\n        return m.getColumnMatrix(0);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int rd = m.getRowDimension();\n    final int cd = m.getColumnDimension();\n    final double[][] d = new double[rd][cd];\n    for (int r = 0; r < rd; r++) {\n        for (int c = 0; c < cd; c++) {\n            d[r][c] = r == c ? m.getEntry(r, c) : 0;\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getRowDimension() == m.getColumnDimension()) {\n        return m.getColumnMatrix(0);\n    } else {\n        return m.getSubMatrix(0, m.getRowDimension() - 1, 0, m.getColumnDimension() - 1);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return new Array2DRowRealMatrix(m.getData(), false);\n    } else {\n        return new Array2DRowRealMatrix(m.getRowDimension(), m.getColumnDimension(),\n                                        new DiagonalMatrix(m.getColumnDimension()).getData(), false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return new Array2DRowRealMatrix(m.getData(), false);\n    }\n    final int n = m.getRowDimension();\n    final double[][] d = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        d[i][i] = m.getEntry(i, 0);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws NotStrictlyPositiveException {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws NotStrictlyPositiveException {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws NotStrictlyPositiveException {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws NotStrictlyPositiveException {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws NotStrictlyPositiveException {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws NotStrictlyPositiveException {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws NotStrictlyPositiveException {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws NotStrictlyPositiveException {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws NotStrictlyPositiveException {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  throws NotStrictlyPositiveException {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, (Object) null, forceAccess);\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int millis = parseOffset(id);\n            return fixedOffsetZone(id, millis);\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz == null) {\n            throw new IllegalArgumentException(\"Invalid time zone ID: \" + id);\n        }\n        return dtz;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz == null) {\n            dtz = cProvider.getZone(getConvertedId(id));\n        }\n        if (dtz == null) {\n            throw new IllegalArgumentException(\"Invalid time zone ID: \" + id);\n        }\n        return dtz;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.length() >= 5 && id.charAt(2) == ':') {\n            int millis = parseOffset(id);\n            return fixedOffsetZone(id, millis);\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) {\n            return dtz;\n        }\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            throw new IllegalArgumentException(\"Invalid time zone ID: \" + id);\n        }\n        return dtz;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        // Convert from JDK TimeZone\n        TimeZone jdkZone = TimeZone.getTimeZone(id);\n        if (jdkZone.getID().equals(id)) {\n            return forTimeZone(jdkZone);\n        }\n        // Convert from fixed offset\n        if (id.length() >= 5 && id.charAt(0) == '+' || id.charAt(0) == '-') {\n            int millis = parseOffset(id);\n            return forOffsetMillis(millis);\n        }\n        throw new IllegalArgumentException(\"Invalid ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"Invalid time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"No DateTimeZone found for ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone == null) {\n            zone = cProvider.getZone(getConvertedId(id));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"Invalid time zone ID: \" + id);\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        // convert from java.util.TimeZone\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.length() >= 3 && id.charAt(0) == '+' || id.charAt(0) == '-') {\n            int millis = parseOffset(id);\n            return fixedOffsetZone(id, millis);\n        }\n        throw new IllegalArgumentException(\"Invalid id: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        if (id.length() >= 3) {\n            int millisOffset = parseOffset(id);\n            if (millisOffset != Integer.MIN_VALUE) {\n                return fixedOffsetZone(id, millisOffset);\n            }\n        }\n        throw new IllegalArgumentException(\"Invalid ID for DateTimeZone: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.length() > 3 && id.charAt(0) == '+' || id.charAt(0) == '-') {\n            int millis = parseOffset(id);\n            return fixedOffsetZone(id, millis);\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone == null) {\n            zone = cProvider.getZone(getConvertedId(id));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"No DateTimeZone found for ID: \" + id);\n        }\n        return zone;\n    }"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n        if (x == 0) {\n            return getZero();\n        }\n\n        if (x == 1) {\n            return this;\n        }\n\n        if (x == RADIX) {\n            return newInstance(this);\n        }\n\n        if (x == 10) {\n            return multiply(getTen());\n        }\n\n        if (x == RADIX/10) {\n            return multiply(getTen().reciprocal());\n        }\n\n        if (x == RADIX/100) {\n            return multiply(getOneHundred().reciprocal());\n        }\n\n        if (x == RADIX/1000) {\n            return multiply(getOneThousand().reciprocal());\n        }\n\n        if (x == RADIX/10000) {\n            return multiply(getTenThousand().reciprocal());\n        }\n\n        if (x == RADIX/100000) {\n            return multiply(getHundredThousand().reciprocal());\n        }\n\n        if (x == RADIX/1000000) {\n            return multiply(getMillion().reciprocal());\n        }\n\n        if (x == RADIX/10000000) {\n            return multiply(getTenMillion().reciprocal());\n        }\n\n        if (x == RADIX/100000000) {\n            return multiply(getHundredMillion().reciprocal());\n        }\n\n        if (x == RADIX/1000000000) {\n            return multiply(getBillion().reciprocal());\n        }\n\n        if (x == RADIX/10000000000) {\n            return multiply(getTenBillion().reciprocal());\n        }\n\n        if (x == RADIX/100000000000) {\n            return multiply(getHundredBillion().reciprocal());\n        }\n\n}",
      "private Dfp multiplyFast(final int x)  {\n        if (x == 0) {\n            return getZero();\n        }\n\n        if (x == 1) {\n            return this;\n        }\n\n        if (x == RADIX) {\n            return newInstance(this);\n        }\n\n        Dfp result = newInstance(this);\n\n        int carry = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int product = mant[i] * x + carry;\n            result.mant[i] = (byte) (product % RADIX);\n            carry = product / RADIX;\n        }\n\n        if (carry != 0) {\n            result.mant[mant.length] = (byte) carry;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        if (x == 0) {\n            return result;\n        }\n\n        if (x == 1) {\n            result = newInstance(this);\n            return result;\n        }\n\n        if (x == RADIX-1) {\n            result = newInstance(this);\n            result.exp++;\n            return result;\n        }\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / x;\n            rl = r - rh * x;\n            result.mant[i] = rh;\n        }\n\n        if (rl != 0) {\n            result.exp++;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        if (x == 0) {\n            return getZero();\n        }\n\n        if (x == 1) {\n            return newInstance(this);\n        }\n\n        if (x == RADIX) {\n            return newInstance(this).shiftLeft();\n        }\n\n        if (x == 10) {\n            return newInstance(this).multiply(RADIX);\n        }\n\n        if (x == RADIX/10) {\n            return newInstance(this).multiply(RADIX).shiftRight();\n        }\n\n        if (x == RADIX/100) {\n            return newInstance(this).multiply(RADIX).multiply(RADIX).shiftRight();\n        }\n\n        if (x == RADIX/1000) {\n            return newInstance(this).multiply(RADIX).multiply(RADIX).multiply(RADIX).shiftRight();\n        }\n\n        if (x == RADIX/10000) {\n            return newInstance(this).multiply(RADIX).multiply(RADIX).multiply(RADIX).multiply(RADIX).shiftRight();\n        }\n\n        if (x == RADIX/100000) {\n            return newInstance(this).multiply(RADIX).multiply(RADIX).multiply(RADIX).multiply(RADIX).multiply(RADIX).shiftRight();\n        }\n\n        if (x == RADIX/1000000) {\n            return newInstance(this).multiply(RADIX).multiply(RADIX).multiply(RADIX).multiply(RADIX).multiply(RADIX).multiply(RADIX).shiftRight();\n        }\n\n        if (x == RADIX/10000000) {\n}\n}",
      "private Dfp multiplyFast(final int x)  {\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE && divisor.mant[divisor.mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(divisor);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n        }\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + mant[i];\n            final int rh = r / x;\n            rl = r - rh * x;\n            result.mant[i] = rh;\n        }\n\n        if (rl != 0) {\n}\n}",
      "private Dfp multiplyFast(final int x)  {\n        if (x == 0) {\n            return getZero();\n        }\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE && divisor.mant[divisor.mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(divisor);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n        }\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + mant[i];\n            final int rh = r / x;\n            rl = r - rh * x;\n}\n}",
      "private Dfp multiplyFast(final int x)  {\n        if (x == 0) {\n            return getZero();\n        }\n\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != x) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, newInstance(x), result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r / x;\n            rl = r - rh * x;\n            result.mant[i] = rh;\n        }\n\n        if (rl != 0) {\n            result.mant[result.mant.length-1] = rl;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        // make sure we don't mix number with different precision\n        if (field.getRadixDigits() != divisor.field.getRadixDigits()) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            final Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, x, result);\n        }\n\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE || divisor.nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (divisor.isNaN()) {\n                return divisor;\n            }\n\n            if (nans == INFINITE && divisor.nans == FINITE && divisor.mant[divisor.mant.length-1] != 0) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == FINITE && mant[mant.length-1] != 0) {\n                result = newInstance(divisor);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n\n            if (divisor.nans == INFINITE && nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * divisor.sign);\n                return result;\n            }\n        }\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + mant[i];\n            final int rh = r / x;\n            rl = r - rh * x;\n            result.mant[i] = rh;\n        }\n\n        if (rl != 0) {\n}\n}",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(getZero());\n\n        /* handle special cases */\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                result = newInstance(this);\n                result.sign = (byte) (sign * x);\n                return result;\n            }\n        }\n\n        if (x == 0) {\n            return result;\n        }\n\n        if (x == 1) {\n            result = newInstance(this);\n            return result;\n        }\n\n        if (x == -1) {\n            result = newInstance(this);\n            result.sign = (byte) -sign;\n            return result;\n        }\n\n        if (x == RADIX) {\n            result = newInstance(this);\n            result.exp++;\n            return result;\n        }\n\n        if (x == -RADIX) {\n            result = newInstance(this);\n            result.exp--;\n            return result;\n        }\n\n        int carry = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int product = mant[i] * x + carry;\n            result.mant[i] = (byte) (product % RADIX);\n            carry = product / RADIX;\n        }\n\n        if (carry != 0) {\n            result.mant[mant.length] = (byte) carry;\n        }\n\n        if (result.mant[mant.length-1] == 0) { // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        if (x == 0) {\n            return getZero();\n        }\n\n        if (x == 1) {\n            return this;\n        }\n\n        if (x == 2) {\n            return multiplyFast(this);\n        }\n\n        if (x == 3) {\n            return multiplyFast(this).add(this);\n        }\n\n        if (x == 4) {\n            return multiplyFast(this).add(this).add(this);\n        }\n\n        if (x == 5) {\n            return multiplyFast(this).add(this).add(this).add(this);\n        }\n\n        if (x == 6) {\n            return multiplyFast(this).add(this).add(this).add(this).add(this);\n        }\n\n        if (x == 7) {\n            return multiplyFast(this).add(this).add(this).add(this).add(this).add(this);\n        }\n\n        if (x == 8) {\n            return multiplyFast(this).add(this).add(this).add(this).add(this).add(this).add(this);\n        }\n\n        if (x == 9) {\n            return multiplyFast(this).add(this).add(this).add(this).add(this).add(this).add(this).add(this);\n        }\n\n        if (x == 10) {\n            return multiplyFast(this).add(this).add(this).add(this).add(this).add(this).add(this).add(this).add(this);\n        }\n\n        if (x == 11) {\n            return multiplyFast(this).add(this).add(this).add(this).add(this).add(this).add(this).add(this).add(this).add(this);\n        }\n\n        if (x == 12) {\n            return multiplyFast(this).add(this).add(this).add(this).add(this).add(this).add(this).add(this).add(this).add(this).add(this);\n}\n}"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = NodeUtil.newFunctionNode(\n      exportedFunction.getFirstChild().getString(),\n      ImmutableList.<Node>of(),\n      ImmutableList.<Node>of(),\n      ImmutableList.<Node>of(),\n      ImmutableList.<Node>of(),\n      null);\n  function.setJSType(exportedFunction.getJSType());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(IR.name(\"\"), IR.paramList());\n  function.setJSType(exportedFunction.getJSType());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  JSDocInfo info = NodeUtil.getBestJSDocInfo(exportedFunction);\n  if (info != null) {\n    // We don't care about the return type, but we do care about the\n    // parameter names.\n    List<String> paramNames = new ArrayList<>();\n    for (Node param : exportedFunction.getSecondChild().children()) {\n      if (param.isName()) {\n        paramNames.add(param.getString());\n      }\n    }\n\n    // Create a new JSDocInfo that contains the parameter names.\n    JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n    builder.recordParameterNames(paramNames);\n    function.setJSDocInfo(builder.build());\n  }\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  JSDocInfo info = exportedFunction.getJSDocInfo();\n  if (info == null) {\n    compiler.report(\n        JSError.make(exportedFunction,\n            RhinoErrorReporter.BAD_JSDOC_ANNOTATION));\n    return null;\n  }\n\n  Node function = IR.function(IR.name(\"\"), IR.paramList());\n  function.setJSType(exportedFunction.getJSType());\n  function.setJSDocInfo(info);\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  JSDocInfo info = exportedFunction.getJSDocInfo();\n  if (info == null) {\n    compiler.report(\n        JSError.make(exportedFunction, EXTERNS_MISSING_PARAMETER_OR_RETURN));\n    return null;\n  }\n\n  Node function = IR.function(\n      IR.name(exportedFunction.getFirstChild().getString()),\n      IR.paramList(),\n      IR.block());\n  function.setJSDocInfo(info);\n  function.setJSType(exportedFunction.getJSType());\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  JSDocInfo info = exportedFunction.getJSDocInfo();\n  FunctionType functionType =\n      new FunctionType(\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n          null,\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = IR.function(\n      IR.name(exportedFunction.getFirstChild().getString()),\n      IR.paramList(),\n      IR.block());\n  function.setJSType(exportedFunction.getJSType());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  function.setJSDocInfo(new JSDocInfo());\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node function = NodeUtil.newFunctionNode(\n      exportedFunction.getFirstChild().getString(),\n      exportedFunction.getSecondChild(),\n      exportedFunction.getJSDocInfo());\n\n  // TODO(user): this is a hack to get around the fact that we don't\n  // have a way to create a function type without a body.\n  function.setJSType(exportedFunction.getJSType());\n\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  FunctionType functionType = null;\n\n  // Global ctor aliases should be registered with the type registry.\n  if (exportedFunction.isQualifiedName() && scope.isGlobal()) {\n    Var var = scope.getVar(exportedFunction.getQualifiedName());\n    if (var != null && var.getType() != null &&\n        var.getType().isFunctionType()) {\n      functionType = var.getType().toMaybeFunctionType();\n      if (functionType.isConstructor() || functionType.isInterface()) {\n        functionType = functionType.toMaybeFunctionType();\n      } else {\n        functionType = null;\n      }\n    }\n  }\n\n  if (functionType == null) {\n    functionType = FunctionType.builder(registry)\n        .forFunction(exportedFunction, null, null, null, null)\n        .withName(exportedFunction.getQualifiedName())\n        .build();\n  }\n\n  Node function = IR.function(\n      IR.name(exportedFunction.getQualifiedName()),\n      IR.paramList(),\n      IR.block());\n  function.setJSType(functionType);\n  function.setJSDocInfo(new JSDocInfo());\n  return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  Node functionNode = NodeUtil.newFunctionNode(\n      exportedFunction.getFirstChild().getString(),\n      ImmutableList.<Node>of(),\n      ImmutableList.<Node>of(),\n      ImmutableList.<Node>of(),\n      ImmutableList.<Node>of(),\n      null,\n      null,\n      null,\n      null,\n      null);\n  functionNode.setJSType(exportedFunction.getJSType());\n\n  // This is an indirect way of telling the typed code generator\n  // \"print the type of this\"\n  functionNode.setJSDocInfo(new JSDocInfo());\n\n  return functionNode;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n  FunctionType functionType = null;\n  JSDocInfo info = exportedFunction.getJSDocInfo();\n  if (info != null) {\n    functionType = info.getType();\n  }\n\n  if (functionType == null) {\n    compiler.report(\n        JSError.make(\n            exportedFunction,\n            EXTERNS_MISSING_RETURN_OR_TYPED_DEFINITION));\n  }\n\n  Node function = NodeUtil.newFunctionNode(\n      exportedFunction.getFirstChild().getString(),\n      functionType.getParameters(),\n      functionType.getReturnType());\n\n  return function;\n}"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covar = computeCovariances(params,\n                                          covarianceSingularityThreshold);\n    double[] sigma = new double[covar.length];\n    for (int i = 0; i < covar.length; ++i) {\n        sigma[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[] errors = new double[params.length];\n    double[][] covar = computeCovariances(params,\n                                          covarianceSingularityThreshold);\n    for (int i = 0; i < errors.length; ++i) {\n        errors[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return errors;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[] sigma = new double[params.length];\n    double[][] covar = computeCovariances(params,\n                                          covarianceSingularityThreshold);\n    for (int i = 0; i < sigma.length; ++i) {\n        sigma[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[] sigma = new double[params.length];\n    final double[][] covar = computeCovariances(params,\n                                                covarianceSingularityThreshold);\n    for (int i = 0; i < sigma.length; ++i) {\n        sigma[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covar = computeCovariances(params,\n                                          covarianceSingularityThreshold);\n    double[] sigma = new double[covar.length];\n    for (int i = 0; i < sigma.length; ++i) {\n        sigma[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    final double[][] covar = computeCovariances(params,\n                                                covarianceSingularityThreshold);\n    final double[] sigma = new double[covar.length];\n    for (int i = 0; i < sigma.length; ++i) {\n        sigma[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[] sigma = new double[params.length];\n    final double[][] covar = computeCovariances(params,\n                                                covarianceSingularityThreshold);\n    for (int i = 0; i < sigma.length; ++i) {\n        sigma[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    final double[][] covar = computeCovariances(params,\n                                                covarianceSingularityThreshold);\n    final double[] sigma = new double[covar.length];\n    for (int i = 0; i < covar.length; ++i) {\n        sigma[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[] errors = new double[params.length];\n    double[][] covar = computeCovariances(params,\n                                          covarianceSingularityThreshold);\n    for (int i = 0; i < errors.length; ++i) {\n        errors[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return errors;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    final double[] sigma = new double[params.length];\n    final double[][] covar = computeCovariances(params,\n                                                covarianceSingularityThreshold);\n    for (int i = 0; i < sigma.length; ++i) {\n        sigma[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return sigma;\n}"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution of \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution of \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution of \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution of \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution of \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution of \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution of \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution of \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution of \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution of \" + varName);\n    }\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  List<INPUT> inputs = Lists.newArrayList();\n  for (INPUT root : roots) {\n    inputs.addAll(getDependenciesOf(root, sorted));\n  }\n  return inputs;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = Lists.newArrayList();\n    Set<INPUT> seen = Sets.newHashSet();\n    for (INPUT root : roots) {\n        seen.add(root);\n        result.add(root);\n    }\n    while (!seen.isEmpty()) {\n        INPUT next = null;\n        for (INPUT input : inputs) {\n            if (seen.contains(input) && !result.contains(input)) {\n                next = input;\n                break;\n            }\n        }\n        if (next == null) {\n            break;\n        }\n        seen.remove(next);\n        result.add(next);\n    }\n    if (sorted) {\n        result = topologicalStableSort(result, deps);\n    }\n    return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // We'll build up a set of all the nodes in the graph.\n    Set<INPUT> subGraph = new LinkedHashSet<INPUT>();\n    for (INPUT root : roots) {\n        subGraph.add(root);\n    }\n\n    // We'll use a queue to keep track of the nodes we need to visit.\n    Queue<INPUT> queue = new LinkedList<INPUT>();\n    queue.addAll(roots);\n\n    // We'll use a set to keep track of the nodes we've already visited.\n    Set<INPUT> visited = new HashSet<INPUT>();\n\n    // We'll keep visiting nodes until the queue is empty.\n    while (!queue.isEmpty()) {\n        INPUT current = queue.remove();\n\n        // If we've already visited this node, we don't need to do it again.\n        if (visited.contains(current)) {\n            continue;\n        }\n\n        // Mark the node as visited.\n        visited.add(current);\n\n        // Add all of the node's dependencies to the queue.\n        for (INPUT dependency : current.getDependencies()) {\n            if (subGraph.contains(dependency)) {\n                queue.add(dependency);\n            }\n        }\n    }\n\n    // If we're supposed to return them in topological order, we'll do that now.\n    if (sorted) {\n        List<INPUT> sortedList = new ArrayList<INPUT>();\n        for (INPUT input : subGraph) {\n            sortedList.add(input);\n        }\n        return sortedList;\n    } else {\n        return new ArrayList<INPUT>(subGraph);\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = Lists.newArrayList();\n    Set<INPUT> seen = Sets.newHashSet();\n    for (INPUT root : roots) {\n        getDependenciesOfHelper(root, seen, result);\n    }\n    if (sorted) {\n        try {\n            result = (new SortedDependencies<INPUT>(result)).getSortedList();\n        } catch (CircularDependencyException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n    return Collections.unmodifiableList(result);\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  // Make sure the roots are all in the graph.\n  for (INPUT root : roots) \n  {\n    if (!inputs.contains(root)) \n    {\n      throw new IllegalArgumentException(\"Root is not in the graph: \" + root);\n    }\n  }\n\n  // Make sure the roots don't have any provides.\n  for (INPUT root : roots) \n  {\n    if (root.getProvides().size() > 0) \n    {\n      throw new IllegalArgumentException(\"Root has provides: \" + root);\n    }\n  }\n\n  // Find the transitive closure of the dependencies of the roots.\n  Set<INPUT> closure = new HashSet<>();\n  for (INPUT root : roots) \n  {\n    closure.add(root);\n    findCycle(root, closure, deps);\n  }\n\n  // Make sure there are no cycles.\n  if (closure.size() != inputs.size()) \n  {\n    List<INPUT> cycle = findCycle(closure, deps);\n    throw new CircularDependencyException(cycleToString(cycle));\n  }\n\n  // Get the sorted list of inputs.\n  List<INPUT> sortedList = new ArrayList<>();\n  if (sorted) \n  {\n    sortedList = topologicalStableSort(inputs, deps);\n  } \n  else \n  {\n    sortedList = new ArrayList<>(inputs);\n  }\n\n  return sortedList;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // Step 1: Find the transitive closure of all the dependencies of the roots.\n    Set<INPUT> allDeps = Sets.newHashSet();\n    for (INPUT root : roots) {\n        allDeps.add(root);\n        allDeps.addAll(getInputsThatDependOn(root));\n    }\n\n    // Step 2: Find the subset of the transitive closure that is not provided.\n    Set<INPUT> subset = Sets.newHashSet();\n    for (INPUT input : allDeps) {\n        if (input.getProvides().isEmpty()) {\n            subset.add(input);\n        }\n    }\n\n    // Step 3: If we want the inputs sorted, sort them.\n    if (sorted) {\n        List<INPUT> sortedList = Lists.newArrayList(subset);\n        Collections.sort(sortedList, new Comparator<INPUT>() {\n}\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    // Find the set of inputs that are reachable from the roots.\n    Set<INPUT> reachable = new HashSet<INPUT>();\n    for (INPUT root : roots) {\n        reachable.add(root);\n    }\n    Set<INPUT> visited = new HashSet<INPUT>();\n    Queue<INPUT> toVisit = new LinkedList<INPUT>(reachable);\n    while (!toVisit.isEmpty()) {\n        INPUT input = toVisit.remove();\n        if (visited.contains(input)) {\n            continue;\n        }\n        visited.add(input);\n        for (INPUT child : inputs) {\n            if (reachable.contains(child)) {\n                continue;\n            }\n            if (child.getRequires().contains(input.getProvides().iterator().next())) {\n                reachable.add(child);\n                toVisit.add(child);\n            }\n        }\n    }\n\n    // If we want to get them in topological order, then sort them.\n    if (sorted) {\n        List<INPUT> sortedList = new ArrayList<INPUT>(reachable);\n}\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  // Find the subgraph of nodes reachable from the roots.\n  Set<INPUT> subGraph = new HashSet<>();\n  for (INPUT root : roots) {\n    subGraph.add(root);\n  }\n  for (INPUT root : roots) {\n    subGraph.addAll(findCycle(root, subGraph, deps, new HashSet<>()));\n  }\n\n  // If we're not sorting, just return the subgraph.\n  if (!sorted) {\n    return new ArrayList<>(subGraph);\n  }\n\n  // Topologically sort the subgraph.\n  return topologicalStableSort(new ArrayList<>(subGraph), deps);\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n  // The subgraph of the graph that we're interested in.\n  Set<INPUT> subGraph = Sets.newHashSet();\n\n  // The queue of nodes to visit.\n  Queue<INPUT> queue = Lists.newLinkedList();\n\n  // Add all the roots to the queue.\n  queue.addAll(roots);\n\n  // While there are still nodes to visit, visit them.\n  while (!queue.isEmpty()) \n  {\n    // Get the next node to visit.\n    INPUT current = queue.remove();\n\n    // If we've already visited this node, skip it.\n    if (subGraph.contains(current)) \n    {\n      continue;\n    }\n\n    // Mark this node as visited.\n    subGraph.add(current);\n\n    // Add all of this node's dependencies to the queue.\n    for (INPUT dependency : deps.get(current)) \n    {\n      queue.add(dependency);\n    }\n  }\n\n  // If we're supposed to sort the inputs, sort them.\n  if (sorted) \n  {\n    return topologicalStableSort(inputs, deps);\n  }\n\n  // Otherwise, return the unsorted list.\n  return Lists.newArrayList(subGraph);\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = Lists.newArrayList();\n    Set<INPUT> subGraph = Sets.newHashSet();\n    for (INPUT root : roots) {\n        subGraph.add(root);\n    }\n    while (!subGraph.isEmpty()) {\n        INPUT current = subGraph.iterator().next();\n        subGraph.remove(current);\n        for (INPUT dependency : findCycle(current, subGraph, deps, Sets.newHashSet())) {\n            result.add(dependency);\n        }\n    }\n    if (sorted) {\n        return topologicalStableSort(result, deps);\n    } else {\n        return result;\n    }\n}"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n        return split(a.getField(), a.toString());\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp result[] = new Dfp[2];\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        char[] buf = new char[a.getField().getRadixDigits()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = a.getField().newDfp(new String(buf));\n\n        return result;\n\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    result[0] = a.getField().newDfp(a.getMantissa(), a.getExponent());\n    result[1] = a.getField().newDfp(a.getMantissa(), a.getExponent());\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp[] result = new Dfp[2];\n        boolean leading = true;\n        int sp = 0;\n        int sig = 0;\n\n        char[] buf = new char[a.getField().getRadixDigits()];\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.charAt(i);\n\n            if (buf[i] >= '1' && buf[i] <= '9') {\n                leading = false;\n            }\n\n            if (buf[i] == '.') {\n                sig += (400 - sig) % 4;\n                leading = false;\n            }\n\n            if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n                sp = i;\n                break;\n            }\n\n            if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n                sig ++;\n            }\n        }\n\n        result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n        for (int i = 0; i < buf.length; i++) {\n            buf[i] = a.charAt(i);\n            if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n                buf[i] = '0';\n            }\n        }\n\n        result[1] = a.getField().newDfp(new String(buf));\n\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) \n    {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') \n        {\n            leading = false;\n        }\n\n        if (buf[i] == '.') \n        {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) \n        {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) \n        {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) \n    {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) \n        {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n\n}"
    ],
    [
      "public String cssSelector()  {\n    if (id() != null) \n    {\n        return \"#\" + id();\n    }\n    else \n    {\n        Element parent = parent();\n        if (parent == null) \n        {\n            return tagName();\n        }\n        else \n        {\n            String parentSelector = parent.cssSelector();\n            if (parentSelector.equals(tagName())) \n            {\n                return parentSelector + \":nth-child(\" + (siblingIndex() + 1) + \")\";\n            }\n            else \n            {\n                return parentSelector + \" > \" + tagName();\n            }\n        }\n    }\n}",
      "public String cssSelector()  {\n    StringBuilder sb = new StringBuilder();\n    cssSelector(sb);\n    return sb.toString();\n}",
      "public String cssSelector()  {\n    if (id() != null) \n    {\n        return \"#\" + id();\n    }\n    else \n    {\n        Element parent = parent();\n        if (parent == null) \n        {\n            return tagName();\n        }\n        else \n        {\n            String parentSelector = parent.cssSelector();\n            if (parentSelector.equals(tagName())) \n            {\n                return parentSelector + \":nth-child(\" + (elementSiblingIndex() + 1) + \")\";\n            }\n            else \n            {\n                return parentSelector + \" > \" + tagName();\n            }\n        }\n    }\n}",
      "public String cssSelector()  {\n    // if we have an id, return that\n    String id = id();\n    if (id != null)\n        return \"#\" + id;\n\n    // no id, so build a selector off the tag and classes\n    StringBuilder sb = new StringBuilder();\n    if (parent() != null)\n        sb.append(parent().cssSelector()).append(\" > \");\n    sb.append(tagName());\n    for (String className : classNames())\n        sb.append('.').append(className);\n    if (elementSiblingIndex() > 0)\n        sb.append(\":nth-child(\").append(elementSiblingIndex() + 1).append(\")\");\n    return sb.toString();\n}",
      "public String cssSelector()  {\n    // if the element has an id, use that\n    String id = id();\n    if (id != null) \n    {\n        return \"#\" + id;\n    }\n\n    // build the css selector for the element\n    StringBuilder builder = new StringBuilder();\n    if (parent() != null) \n    {\n        builder.append(parent().cssSelector());\n        builder.append(\" > \");\n    }\n\n    builder.append(tagName());\n\n    // add the classes\n    String[] classes = classNames();\n    if (classes.length > 0) \n    {\n        builder.append(\".\");\n        builder.append(String.join(\".\", classes));\n    }\n\n    // add the pseudo-class :nth-child(n) if this element is not the first child\n    if (parent() != null && siblingIndex() > 0) \n    {\n        builder.append(\":nth-child(\");\n        builder.append(siblingIndex() + 1);\n        builder.append(\")\");\n    }\n\n    return builder.toString();\n}",
      "public String cssSelector()  {\n    // ID selector\n    String id = this.id();\n    if (id != null) \n    {\n        return \"#\" + id;\n    }\n\n    // Class selectors\n    StringBuilder css = new StringBuilder();\n    if (this.parent() != null) \n    {\n        css.append(this.parent().cssSelector());\n        css.append(\" > \");\n    }\n\n    css.append(this.tagName());\n\n    // Classes\n    Set<String> classes = this.classNames();\n    if (classes.size() > 0) \n    {\n        for (String className : classes) \n        {\n            css.append(\".\");\n            css.append(className);\n        }\n    }\n\n    // Unique element selector\n    if (this.parent() != null) \n    {\n        int count = 0;\n        for (Element sibling : this.parent().children()) \n        {\n            if (sibling.tagName().equals(this.tagName())) \n            {\n                count++;\n                if (count == 2) \n                {\n                    break;\n                }\n            }\n        }\n\n        if (count > 1) \n        {\n            css.append(\":nth-child(\");\n            css.append(count);\n            css.append(\")\");\n        }\n    }\n\n    return css.toString();\n}",
      "public String cssSelector()  {\n    StringBuilder sb = new StringBuilder();\n    cssSelector(sb);\n    return sb.toString();\n}",
      "public String cssSelector()  {\n    if (id() != null) \n    {\n        return \"#\" + id();\n    }\n    else \n    {\n        StringBuilder path = new StringBuilder();\n        Element parent = parent();\n        if (parent != null) \n        {\n            path.append(parent.cssSelector());\n            path.append(\" > \");\n        }\n        path.append(tagName());\n        if (hasClass()) \n        {\n            for (String className : classNames()) \n            {\n                path.append(\".\");\n                path.append(className);\n            }\n        }\n        if (parent != null && siblingIndex() > 0) \n        {\n            path.append(\":nth-child(\");\n            path.append(siblingIndex() + 1);\n            path.append(\")\");\n        }\n        return path.toString();\n    }\n}",
      "public String cssSelector()  {\n    if (hasId()) \n    {\n        return \"#\" + id();\n    }\n    else \n    {\n        StringBuilder sb = new StringBuilder();\n        if (parent() != null) \n        {\n            sb.append(parent().cssSelector());\n            sb.append(\" > \");\n        }\n        sb.append(tagName());\n        if (hasClass()) \n        {\n            sb.append(\".\");\n            sb.append(classNames().stream().collect(Collectors.joining(\".\")));\n        }\n        if (parent() != null && parent().children().size() > 1) \n        {\n            sb.append(\":nth-child(\");\n            sb.append(parent().children().indexOf(this) + 1);\n            sb.append(\")\");\n        }\n        return sb.toString();\n    }\n}",
      "public String cssSelector()  {\n    // if we have an id, return that\n    String id = this.id();\n    if (id != null) \n    {\n        return \"#\" + id;\n    }\n\n    // otherwise, work backwards through our ancestors and generate a path\n    StringBuilder path = new StringBuilder();\n    Element parent = this.parent();\n    while (parent != null) \n    {\n        // if the parent has an id, use that\n        String parentId = parent.id();\n        if (parentId != null) \n        {\n            path.insert(0, \"#\" + parentId + \" > \");\n            break;\n        }\n\n        // otherwise, use the parent tag name\n        path.insert(0, parent.tagName() + \" > \");\n\n        // move up to the next parent\n        parent = parent.parent();\n    }\n\n    // add our own tag name and any classes to the path\n    path.insert(0, this.tagName());\n    String className = this.className();\n    if (className != null) \n    {\n        String[] classes = className.split(\" \");\n        for (String c : classes) \n        {\n            path.insert(0, \".\" + c);\n        }\n    }\n\n    // add the pseudo-class \":nth-child(n)\" if we are not the first child\n    if (this.parent() != null) \n    {\n        Elements siblings = this.parent().children();\n        int index = 0;\n        for (Element sibling : siblings) \n        {\n            if (sibling == this) \n            {\n                break;\n            }\n            index++;\n        }\n        path.insert(0, \":nth-child(\" + index + \")\");\n    }\n\n    return path.toString();\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost = 1;\n      break;\n    case Token.NE:\n    case Token.SHEQ:\n    case Token.EQ:\n    case Token.SHNE:\n      cost = 2;\n      break;\n    case Token.OR:\n    case Token.AND:\n      cost = 3;\n      break;\n    case Token.HOOK:\n      cost = 4;\n      break;\n    case Token.INC:\n    case Token.DEC:\n      cost = 5;\n      break;\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.DELPROP:\n      cost = 6;\n      break;\n    case Token.NAME:\n      cost = 7;\n      break;\n    case Token.GETPROP:\n    case Token.GETELEM:\n      cost = 8;\n      break;\n    case Token.CALL:\n    case Token.NEW:\n      cost = 9;\n      break;\n    case Token.POS:\n    case Token.NEG:\n    case Token.BITNOT:\n      cost = 10;\n      break;\n    case Token.ADD:\n    case Token.SUB:\n    case Token.MUL:\n    case Token.DIV:\n    case Token.MOD:\n    case Token.LSH:\n    case Token.RSH:\n    case Token.URSH:\n    case Token.BITAND:\n    case Token.BITXOR:\n    case Token.BITOR:\n    case Token.ASSIGN:\n    case Token.ASSIGN_BITAND:\n    case Token.ASSIGN_BITOR:\n    case Token.ASSIGN_BITXOR:\n    case Token.ASSIGN_LSH:\n    case Token.ASSIGN_RSH:\n    case Token.ASSIGN_URSH:\n    case Token.ASSIGN_ADD:\n    case Token.ASSIGN_SUB:\n    case Token.ASSIGN_MUL:\n    case Token.ASSIGN_DIV:\n}\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost = 1;\n      break;\n    case Token.AND:\n    case Token.OR:\n      cost = 2;\n      break;\n    case Token.HOOK:\n      cost = 3;\n      break;\n    case Token.PAREN:\n      cost = 2;\n      break;\n    default:\n      break;\n  }\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost += 1;\n      break;\n    case Token.NEG:\n      cost += 1;\n      break;\n    case Token.HOOK:\n      cost += 3;\n      break;\n    case Token.AND:\n    case Token.OR:\n      cost += 2;\n      break;\n    case Token.COMMA:\n      cost += 1;\n      break;\n    case Token.CALL:\n      cost += 2;\n      break;\n    case Token.NEW:\n      cost += 2;\n      break;\n    case Token.TYPEOF:\n      cost += 2;\n      break;\n    case Token.VOID:\n      cost += 2;\n      break;\n    case Token.ADD:\n    case Token.SUB:\n    case Token.MUL:\n    case Token.DIV:\n    case Token.MOD:\n    case Token.BITAND:\n    case Token.BITOR:\n    case Token.BITXOR:\n    case Token.SHL:\n    case Token.SHR:\n    case Token.USHR:\n    case Token.EQ:\n    case Token.NE:\n    case Token.SHEQ:\n    case Token.SHNE:\n    case Token.LT:\n    case Token.GT:\n    case Token.LE:\n    case Token.GE:\n    case Token.INSTANCEOF:\n    case Token.IN:\n      cost += 2;\n      break;\n    case Token.NAME:\n      cost += 2;\n      break;\n    case Token.GETPROP:\n      cost += 2;\n      break;\n    case Token.GETELEM:\n      cost += 2;\n      break;\n    case Token.ASSIGN:\n      cost += 2;\n      break;\n    case Token.ASSIGN_ADD:\n      cost += 2;\n      break;\n    case Token.ASSIGN_SUB:\n      cost += 2;\n      break;\n    case Token.ASSIGN_MUL:\n      cost += 2;\n      break;\n}\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost += 2; // NOT\n      break;\n    case Token.NE:\n      cost += 2; // NE\n      break;\n    case Token.SHEQ:\n      cost += 2; // SHEQ\n      break;\n    case Token.SHNE:\n      cost += 2; // SHNE\n      break;\n    case Token.AND:\n    case Token.OR:\n      cost += 1; // parens\n      break;\n    case Token.HOOK:\n      cost += 3; // ? :\n      break;\n    case Token.ASSIGN_BITOR:\n    case Token.ASSIGN_BITXOR:\n    case Token.ASSIGN_BITAND:\n    case Token.ASSIGN_LSH:\n    case Token.ASSIGN_RSH:\n    case Token.ASSIGN_URSH:\n    case Token.ASSIGN_ADD:\n    case Token.ASSIGN_SUB:\n    case Token.ASSIGN_MUL:\n    case Token.ASSIGN_DIV:\n    case Token.ASSIGN_MOD:\n    case Token.ASSIGN_EXPONENT:\n      cost += 2; // =\n      break;\n    case Token.COMMA:\n      cost += 1; // ,\n      break;\n    case Token.OR:\n    case Token.AND:\n    case Token.HOOK:\n      cost += 2; // parens\n      break;\n    case Token.NAME:\n      cost += 2; // parens\n      break;\n    case Token.CALL:\n      cost += 2; // parens\n      break;\n    case Token.NEW:\n      cost += 2; // parens\n      break;\n    case Token.GETPROP:\n      cost += 2; // .\n      break;\n    case Token.GETELEM:\n      cost += 2; // [\n      break;\n    case Token.TYPEOF:\n      cost += 2; // parens\n      break;\n    case Token.VOID:\n      cost += 2; // parens\n      break;\n}\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost += 1;\n      break;\n    case Token.OR:\n    case Token.AND:\n      cost += 2;\n      break;\n    case Token.HOOK:\n      cost += 3;\n      break;\n    case Token.PAREN:\n      cost += 2;\n      break;\n    case Token.CALL:\n      cost += 2;\n      break;\n    case Token.NEW:\n      cost += 2;\n      break;\n    case Token.GETPROP:\n      cost += 2;\n      break;\n    case Token.GETELEM:\n      cost += 2;\n      break;\n    case Token.TYPEOF:\n      cost += 2;\n      break;\n    case Token.INSTANCEOF:\n      cost += 2;\n      break;\n    case Token.IN:\n      cost += 2;\n      break;\n    case Token.DELPROP:\n      cost += 2;\n      break;\n    case Token.VOID:\n      cost += 2;\n      break;\n    case Token.REGEXP:\n      cost += 2;\n      break;\n    case Token.ADD:\n    case Token.SUB:\n    case Token.MUL:\n    case Token.DIV:\n    case Token.MOD:\n    case Token.SHL:\n    case Token.SHR:\n    case Token.USHR:\n    case Token.BITAND:\n    case Token.BITXOR:\n    case Token.BITOR:\n      cost += 2;\n      break;\n    case Token.EQ:\n    case Token.NE:\n    case Token.SHEQ:\n    case Token.SHNE:\n      cost += 2;\n      break;\n    case Token.LT:\n    case Token.GT:\n    case Token.LE:\n    case Token.GE:\n      cost += 2;\n      break;\n    case Token.INSTANCEOF:\n      cost += 2;\n      break;\n    case Token.IN:\n      cost += 2;\n      break;\n}\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost = 1;\n      break;\n    case Token.OR:\n    case Token.AND:\n      cost = 2;\n      break;\n    case Token.HOOK:\n      cost = 3;\n      break;\n    case Token.CALL:\n      cost = 2;\n      break;\n    case Token.NEW:\n      cost = 2;\n      break;\n    case Token.GETPROP:\n      cost = 2;\n      break;\n    case Token.GETELEM:\n      cost = 2;\n      break;\n    case Token.NAME:\n      cost = 2;\n      break;\n    case Token.STRING:\n      cost = 2;\n      break;\n    case Token.NUMBER:\n      cost = 2;\n      break;\n    case Token.REGEXP:\n      cost = 2;\n      break;\n    case Token.TRUE:\n      cost = 2;\n      break;\n    case Token.FALSE:\n      cost = 2;\n      break;\n    case Token.NULL:\n      cost = 2;\n      break;\n    case Token.THIS:\n      cost = 2;\n      break;\n    case Token.FUNCTION:\n      cost = 2;\n      break;\n    case Token.ASSIGN:\n      cost = 2;\n      break;\n    case Token.ASSIGN_BITOR:\n      cost = 2;\n      break;\n    case Token.ASSIGN_BITXOR:\n      cost = 2;\n      break;\n    case Token.ASSIGN_BITAND:\n      cost = 2;\n      break;\n    case Token.ASSIGN_LSH:\n      cost = 2;\n      break;\n    case Token.ASSIGN_RSH:\n      cost = 2;\n      break;\n    case Token.ASSIGN_URSH:\n      cost = 2;\n      break;\n    case Token.ASSIGN_ADD:\n      cost = 2;\n      break;\n    case Token.ASSIGN_SUB:\n}\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost += 1;\n      break;\n    case Token.AND:\n    case Token.OR:\n      cost += 2;\n      break;\n    case Token.HOOK:\n      cost += 3;\n      break;\n    case Token.PAREN:\n      cost += 2;\n      break;\n    default:\n      break;\n  }\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost = 1;\n      break;\n    case Token.AND:\n    case Token.OR:\n      cost = 2;\n      break;\n    case Token.HOOK:\n      cost = 3;\n      break;\n    case Token.CALL:\n      cost = 2 + estimateCostOneLevel(n.getFirstChild()) +\n          estimateCostOneLevel(n.getLastChild());\n      break;\n    case Token.NEW:\n      cost = 2 + estimateCostOneLevel(n.getFirstChild());\n      break;\n    case Token.GETPROP:\n    case Token.GETELEM:\n      cost = 2 + estimateCostOneLevel(n.getFirstChild()) +\n          estimateCostOneLevel(n.getLastChild());\n      break;\n    case Token.INC:\n    case Token.DEC:\n      cost = 1 + estimateCostOneLevel(n.getFirstChild());\n      break;\n    case Token.POS:\n    case Token.NEG:\n      cost = 1 + estimateCostOneLevel(n.getFirstChild());\n      break;\n    case Token.ADD:\n    case Token.SUB:\n    case Token.MUL:\n    case Token.DIV:\n    case Token.MOD:\n    case Token.SHL:\n    case Token.SHR:\n    case Token.SHR_U:\n    case Token.BITAND:\n    case Token.BITXOR:\n    case Token.BITOR:\n    case Token.LSH:\n    case Token.URSH:\n      cost = 2 + estimateCostOneLevel(n.getFirstChild()) +\n          estimateCostOneLevel(n.getLastChild());\n      break;\n    case Token.ASSIGN:\n    case Token.ASSIGN_BITOR:\n    case Token.ASSIGN_BITXOR:\n    case Token.ASSIGN_BITAND:\n    case Token.ASSIGN_LSH:\n    case Token.ASSIGN_RSH:\n    case Token.ASSIGN_URSH:\n}\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost += 1;\n      break;\n    case Token.AND:\n    case Token.OR:\n      cost += estimateCostOneLevel(n.getFirstChild()) +\n          estimateCostOneLevel(n.getLastChild());\n      break;\n    case Token.HOOK:\n      cost += estimateCostOneLevel(n.getFirstChild()) +\n          estimateCostOneLevel(n.getLastChild()) +\n          estimateCostOneLevel(n.getLastChild().getNext());\n      break;\n    case Token.PAREN:\n      cost += estimateCostOneLevel(n.getFirstChild());\n      break;\n    default:\n      break;\n  }\n  return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n  int cost = 0;\n  switch (n.getType()) {\n    case Token.NOT:\n      cost = 1;\n      break;\n    case Token.NEG:\n    case Token.POS:\n      cost = 2;\n      break;\n    case Token.OR:\n    case Token.AND:\n      cost = 1;\n      break;\n    case Token.HOOK:\n      cost = 3;\n      break;\n    case Token.OR2:\n    case Token.AND2:\n      cost = 2;\n      break;\n    case Token.BITOR:\n    case Token.BITXOR:\n    case Token.BITAND:\n      cost = 1;\n      break;\n    case Token.EQ:\n    case Token.NE:\n    case Token.SHEQ:\n    case Token.SHNE:\n      cost = 2;\n      break;\n    case Token.LT:\n    case Token.GT:\n    case Token.LE:\n    case Token.GE:\n    case Token.INSTANCEOF:\n    case Token.IN:\n      cost = 3;\n      break;\n    case Token.ADD:\n    case Token.SUB:\n    case Token.MUL:\n    case Token.DIV:\n    case Token.MOD:\n    case Token.BITLSHIFT:\n    case Token.BITRSHIFT:\n    case Token.BITURSHIFT:\n    case Token.BITNOT:\n      cost = 2;\n      break;\n    case Token.TYPEOF:\n    case Token.VOID:\n    case Token.DELPROP:\n    case Token.GETPROP:\n    case Token.GETELEM:\n    case Token.SETPROP:\n    case Token.SETELEM:\n    case Token.CALL:\n    case Token.NEW:\n    case Token.THIS:\n    case Token.NAME:\n    case Token.NUMBER:\n    case Token.STRING:\n    case Token.NULL:\n    case Token.TRUE:\n    case Token.FALSE:\n      cost = 0;\n      break;\n    case Token.FUNCTION:\n      cost = 2;\n}\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    int i = 0;\n    int j = size - 1;\n    while (i < j) \n    {\n        char temp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = temp;\n        i++;\n        j--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int i = 0;\n    int j = size - 1;\n    char tmp;\n    while (i < j) {\n        tmp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = tmp;\n        i++;\n        j--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int j = size - 1;\n    for (int i = 0; i < j; i++, j--) \n    {\n        char temp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int i = 0;\n    int j = size - 1;\n    while (i < j) \n    {\n        char tmp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = tmp;\n        i++;\n        j--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size > 1) {\n        final char[] buf = buffer;\n        for (int i = 0, j = size - 1; i < j; i++, j--) {\n            char c = buf[i];\n            buf[i] = buf[j];\n            buf[j] = c;\n        }\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    // Reverse the string builder in place\n    for (int i = 0, j = size - 1; i < j; i++, j--) \n    {\n        char tmp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = tmp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    // Validate the index\n    if (size == 0) {\n        return this;\n    }\n    int mid = size / 2;\n    for (int i = 0; i < mid; i++) {\n        char tmp = buffer[i];\n        buffer[i] = buffer[size - i - 1];\n        buffer[size - i - 1] = tmp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size > 1) \n    {\n        for (int i = 0, j = size - 1; i < j; i++, j--) \n        {\n            char tmp = buffer[i];\n            buffer[i] = buffer[j];\n            buffer[j] = tmp;\n        }\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size > 1) \n    {\n        final char[] buf = buffer;\n        for (int i = 0, j = size - 1; i < j; i++, j--) \n        {\n            char c = buf[i];\n            buf[i] = buf[j];\n            buf[j] = c;\n        }\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    // Find the middle point\n    int middle = size / 2;\n\n    // Reverse the first half\n    for (int i = 0; i < middle; i++) \n    {\n        // Swap the characters\n        char temp = buffer[i];\n        buffer[i] = buffer[size - i - 1];\n        buffer[size - i - 1] = temp;\n    }\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    if (offset < 0 || offset > text.length())\n        throw new IndexOutOfBoundsException(\"split offset \" + offset + \" but length is \" + text.length());\n    if (offset == text.length())\n        return new TextNode(text);\n    String head = text.substring(0, offset);\n    String tail = text.substring(offset);\n    TextNode newNode = new TextNode(tail);\n    if (parent() != null)\n        parent().addChildren(siblingIndex() + 1, newNode);\n    coreValue(head);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n        if (offset > coreValue().length())\n            throw new IndexOutOfBoundsException(\"Offset: \" + offset + \", length: \" + coreValue().length());\n        TextNode newNode = new TextNode(coreValue().substring(offset));\n        coreValue(coreValue().substring(0, offset));\n        parentNode.addChildren(siblingIndex + 1, new Node[]{newNode});\n        return newNode;\n    }",
      "public TextNode splitText(int offset)  {\n    // Validate.notNull(text);\n    // Validate.isTrue(offset >= 0 && offset <= value.length(), \"split offset \" + offset + \" must be in range 0..\" + value.length());\n    String newData = value.substring(offset);\n    value = value.substring(0, offset);\n    TextNode newNode = new TextNode(newData);\n    if (parent() != null) parent().addChildren(siblingIndex(), newNode);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    // your code goes here\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    if (offset == 0) return new TextNode(text, baseUri);\n    if (offset >= text.length()) return null;\n    String newText = text.substring(offset);\n    String oldText = text.substring(0, offset);\n    TextNode newNode = new TextNode(newText, baseUri);\n    parentNode.addChildren(siblingIndex + 1, newNode);\n    this.text(oldText);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    if (offset > text.length())\n        throw new IndexOutOfBoundsException(\"Offset: \" + offset + \", length: \" + text.length());\n    String newText = text.substring(offset);\n    String oldText = text.substring(0, offset);\n    TextNode newNode = new TextNode(newText);\n    parentNode.addChildren(siblingIndex() + 1, newNode);\n    text(oldText);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset > value.length())\n        throw new IndexOutOfBoundsException(\"Offset: \" + offset + \", length: \" + value.length());\n    if (offset == value.length())\n        return new TextNode(\"\");\n    String head = value.substring(0, offset);\n    String tail = value.substring(offset);\n    value = head;\n    TextNode tailNode = new TextNode(tail);\n    parentNode.addChildren(siblingIndex() + 1, Collections.singletonList(tailNode));\n    return tailNode;\n}",
      "public TextNode splitText(int offset)  {\n    // validate\n    if (offset < 0 || offset > text().length())\n        throw new IndexOutOfBoundsException(\"split offset \" + offset + \" but length is \" + text().length());\n    if (offset == 0)\n        return this; // nothing to split. would return 'this' in Java\n\n    // split the node\n    String leftText = text().substring(0, offset);\n    String rightText = text().substring(offset);\n    text(leftText);\n    TextNode rightNode = new TextNode(rightText);\n    Element parent = parent();\n    parent.insertChildren(siblingIndex() + 1, rightNode);\n\n    return rightNode;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset > value.length())\n        throw new IndexOutOfBoundsException(\"offset can not be longer than current text\");\n    if (offset == value.length())\n        return new TextNode(\"\");\n    String newData = value.substring(offset);\n    value = value.substring(0, offset);\n    TextNode newNode = new TextNode(newData);\n    parentNode.insertChildren(siblingIndex()+1, newNode);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    // check offset is in range\n    String text = getWholeText();\n    if (offset < 0 || offset > text.length())\n        throw new IndexOutOfBoundsException(\"Offset: \" + offset + \", length: \" + text.length());\n\n    // split the node\n    String newText = text.substring(offset);\n    TextNode newNode = new TextNode(newText);\n    insertAfter(newNode);\n    String oldText = text.substring(0, offset);\n    TextNode oldNode = new TextNode(oldText);\n    replaceWith(oldNode);\n\n    return newNode;\n}"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    final byte[] bytes = value.toByteArray();\n    final int length = bytes.length;\n    if (length > 8) {\n        throw new IllegalArgumentException(\"Input too large to encode into a ZipEightByteInteger\");\n    }\n    final int start = length - 1;\n    for (int i = 0; i < length; i++) {\n        result[i] = bytes[start - i];\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[8];\n        final byte[] bytes = value.toByteArray();\n        for (int i = 0; i < 8; i++) {\n            result[i] = (i < bytes.length) ? bytes[i] : (i % 2 == 0) ? (byte) 0 : (byte) 0xFF;\n        }\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    final byte[] bytes = value.toByteArray();\n    for (int i = 0; i < bytes.length; i++) {\n        result[i] = bytes[bytes.length - i - 1];\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[8];\n        final byte[] bytes = value.toByteArray();\n        if (bytes.length == 0) {\n            throw new IllegalArgumentException(\"Empty byte array\");\n        }\n        final int start = bytes[0] == 0 ? 1 : 0;\n        final int length = bytes.length - start;\n        if (length > 8) {\n            throw new IllegalArgumentException(\"Too many bytes\");\n        }\n        System.arraycopy(bytes, start, result, 8 - length, length);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    final byte[] bytes = value.toByteArray();\n    for (int i = 0; i < bytes.length; i++) {\n        result[i] = bytes[i];\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[8];\n        final byte[] bytes = value.toByteArray();\n        final int length = bytes.length;\n        if (length > 8) {\n            throw new RuntimeException(\"value too large to fit in eight bytes\");\n        }\n        for (int i = 0; i < length; i++) {\n            result[i] = bytes[i];\n        }\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    ByteUtils.toLittleEndian(result, value, 0, 8);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[8];\n        ByteUtils.toLittleEndian(result, value, 0, 8);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    final byte[] bytes = value.toByteArray();\n    final int length = bytes.length;\n    if (length > 8) {\n        throw new IllegalArgumentException(\"Too large for eight bytes\");\n    }\n    for (int i = 0; i < length; i++) {\n        result[i] = bytes[i];\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    final byte[] bytes = value.toByteArray();\n    for (int i = 0; i < bytes.length; i++) {\n        result[i] = bytes[i];\n    }\n    return result;\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}\n\n//-----------------------------------------------------------------------",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}\n//-----------------------------------------------------------------------",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}\n//-----------------------------------------------------------------------",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}\n\n//-----------------------------------------------------------------------",
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        return modify(str, set, true);\n    }",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}\n//-----------------------------------------------------------------------",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}\n//-----------------------------------------------------------------------",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}\n// Delete",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    return modify(str, set, true);\n}\n//-----------------------------------------------------------------------"
    ],
    [
      "public RealMatrix getSquareRoot()  {\n    if (cachedSquareRoot != null) {\n        return cachedSquareRoot;\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    final int dim = getRowDimension();\n    final RealMatrix sqrtM = new Array2DRowRealMatrix(dim, dim);\n    final double[][] data = sqrtM.getData();\n    for (int i = 0; i < dim; i++) {\n        final double[] dataI = data[i];\n        for (int j = i; j < dim; j++) {\n            dataI[j] = FastMath.sqrt(getEntry(i, i) * getEntry(j, j));\n        }\n    }\n    for (int i = 0; i < dim; i++) {\n        final double[] dataI = data[i];\n        for (int j = 0; j < i; j++) {\n            dataI[j] = data[j][i];\n        }\n    }\n    cachedSquareRoot = sqrtM;\n    return sqrtM;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (isSymmetric()) {\n        return new CholeskyDecomposition(this).getL();\n    } else {\n        throw new MathUnsupportedOperationException();\n    }\n}",
      "public RealMatrix getSquareRoot()  {\n    if (isSymmetric()) {\n        return new CholeskyDecomposition(this).getL();\n    } else {\n        throw new MathUnsupportedOperationException();\n    }\n}",
      "public RealMatrix getSquareRoot()  {\n    if (isSymmetric()) {\n        return squareRoot(this);\n    } else {\n        throw new MathUnsupportedOperationException();\n    }\n}",
      "public RealMatrix getSquareRoot()  {\n    if (isSymmetric()) {\n        return squareRoot(this);\n    } else {\n        throw new MathUnsupportedOperationException();\n    }\n}",
      "public RealMatrix getSquareRoot()  {\n    if (cachedSquareRoot != null) {\n        return cachedSquareRoot;\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    final int dim = getRowDimension();\n    final EigenDecomposition eigen = new EigenDecomposition(this);\n    final RealMatrix squareRoot = eigen.getV().multiply(eigen.getD().scalarMultiply(eigen.getV().transpose()));\n    cachedSquareRoot = squareRoot;\n    return squareRoot;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (isSymmetric()) \n    {\n        return new CholeskyDecomposition(this).getL();\n    }\n    else \n    {\n        throw new MathUnsupportedOperationException();\n    }\n}",
      "public RealMatrix getSquareRoot()  {\n    if (isSymmetric()) {\n        return squareRoot(this);\n    } else {\n        throw new MathUnsupportedOperationException();\n    }\n}",
      "public RealMatrix getSquareRoot()  {\n    if (isSymmetric()) {\n        return new CholeskyDecomposition(this).getSquareRoot();\n    } else {\n        throw new MathUnsupportedOperationException();\n    }\n}",
      "public RealMatrix getSquareRoot()  {\n    if (isSymmetric()) {\n        return squareRoot(this);\n    } else {\n        throw new MathUnsupportedOperationException();\n    }\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\t// [databind#631]: Assign current value, to be accessible by custom deserializers\n    \t\tp.setCurrentValue(result);\n    \t\t\n    \t\t// Ok: must point to START_OBJECT or FIELD_NAME\n    \t\tif (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n    \t\t\treturn ctxt.handleUnexpectedToken(getMapClass(), p);\n    \t\t}\n    \t\t// 21-Apr-2017, tatu: Need separate methods to do proper merging\n    \t\tif (_standardStringKey) {\n    \t\t\t_readAndUpdateStringKeyMap(p, ctxt, result);\n    \t\t\treturn result;\n    \t\t}\n    \t\t_readAndUpdate(p, ctxt, result);\n    \t\treturn result;\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tif (t == JsonToken.VALUE_STRING) {\n    \t\t\treturn p.getText();\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\t\treturn p.getIntValue();\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_FLOAT) {\n    \t\t\treturn p.getDecimalValue();\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_TRUE) {\n    \t\t\treturn Boolean.TRUE;\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_FALSE) {\n    \t\t\treturn Boolean.FALSE;\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NULL) {\n    \t\t\treturn null;\n    \t\t}\n    \t\tif (t == JsonToken.START_ARRAY) {\n    \t\t\treturn deserializeFromArray(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.START_OBJECT) {\n    \t\t\treturn deserializeFromObject(p, ctxt);\n    \t\t}\n    \t\treturn ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n    \t}\n    /*\n    /**********************************************************\n    /* Helper methods, non-standard creation\n    /**********************************************************",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // [databind#631]: Assign current value, to be accessible by custom deserializers\n        p.setCurrentValue(result);\n        // 21-Apr-2017, tatu: Need separate methods to do proper merging\n        if (_standardStringKey) {\n            _readAndUpdateStringKeyMap(p, ctxt, result);\n            return result;\n        }\n        _readAndUpdate(p, ctxt, result);\n        return result;\n    }\n\n    /*\n    /**********************************************************\n    /* Concrete deserialization methods\n    /**********************************************************",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\t// 21-Apr-2017, tatu: Need separate methods to do proper merging\n    \t\tif (_standardStringKey) {\n    \t\t\treturn _readAndUpdateStringKeyMap(p, ctxt, new LinkedHashMap<Object,Object>());\n    \t\t}\n    \t\treturn _readAndUpdate(p, ctxt, new LinkedHashMap<Object,Object>());\n    \t}\n    \n    /*\n    /**********************************************************\n    /* Helper methods, non-standard creation\n    /**********************************************************\n     */",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tif (t == JsonToken.VALUE_STRING) {\n    \t\t\treturn p.getText();\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\t\treturn p.getIntValue();\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_FLOAT) {\n    \t\t\treturn p.getDecimalValue();\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_TRUE) {\n    \t\t\treturn Boolean.TRUE;\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_FALSE) {\n    \t\t\treturn Boolean.FALSE;\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NULL) {\n    \t\t\treturn getNullValue(ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.START_ARRAY) {\n    \t\t\treturn _deserializeFromArray(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.START_OBJECT) {\n    \t\t\treturn _deserializeFromObject(p, ctxt);\n    \t\t}\n    \t\t// [databind#631]: Assign current value, to be accessible by custom deserializers\n    \t\tp.setCurrentValue(this);\n    \t\tObject value = ctxt.handleUnexpectedToken(getValueType(ctxt), p);\n    \t\treturn wrapAndThrow(ctxt, JsonMappingException.fromUnexpectedToken(p, value),\n    \t\t\t\t\"Unexpected token (%s), expected VALUE_STRING\",\n    \t\t\t\tt);\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // 21-Apr-2017, tatu: Need separate methods to do proper merging\n        if (_standardStringKey) {\n            return _readAndUpdateStringKeyMap(p, ctxt, null);\n        }\n        return _readAndUpdate(p, ctxt, null);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tif (t == JsonToken.VALUE_NULL) {\n    \t\t\treturn getNullValue(ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.START_ARRAY) {\n    \t\t\treturn _deserializeFromArray(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.FIELD_NAME) {\n    \t\t\treturn _deserializeFromObject(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.START_OBJECT) {\n    \t\t\treturn _deserializeFromObject(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_STRING) {\n    \t\t\treturn _deserializeFromString(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_INT) {\n    \t\t\treturn _deserializeFromNumber(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_NUMBER_FLOAT) {\n    \t\t\treturn _deserializeFromNumber(p, ctxt);\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_TRUE) {\n    \t\t\treturn Boolean.TRUE;\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_FALSE) {\n    \t\t\treturn Boolean.FALSE;\n    \t\t}\n    \t\tif (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n    \t\t\treturn getEmbeddedObject(p, ctxt);\n    \t\t}\n    \t\treturn _handleUnexpectedToken(p, ctxt);\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\t// [databind#631]: Assign current value, to be accessible by custom deserializers\n    \t\tp.setCurrentValue(result);\n    \t\t\n    \t\t// Ok: must point to START_OBJECT or FIELD_NAME\n    \t\tif (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n    \t\t\treturn ctxt.handleUnexpectedToken(getMapClass(), p);\n    \t\t}\n    \t\t// 21-Apr-2017, tatu: Need separate methods to do proper merging\n    \t\tif (_standardStringKey) {\n    \t\t\t_readAndUpdateStringKeyMap(p, ctxt, result);\n    \t\t\treturn result;\n    \t\t}\n    \t\t_readAndUpdate(p, ctxt, result);\n    \t\treturn result;\n    \t}\n    \t\n    \t/*\n    /**********************************************************",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_STRING) {\n            return p.getText();\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return p.getIntValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return p.getDecimalValue();\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return Boolean.TRUE;\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return Boolean.FALSE;\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return getNullValue(ctxt);\n        }\n        if (t == JsonToken.START_ARRAY) {\n            return deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.START_OBJECT) {\n            return deserializeFromObject(p, ctxt);\n        }\n        return _handleUnexpectedToken(p, ctxt);\n    \t}\n    /*\n    /**********************************************************\n    /* Helper methods, non-standard creation\n    /**********************************************************",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tswitch (t) {\n    \t\tcase VALUE_STRING:\n    \t\t\treturn p.getText();\n    \t\tcase VALUE_NUMBER_INT:\n    \t\t\treturn p.getIntValue();\n    \t\tcase VALUE_NUMBER_FLOAT:\n    \t\t\treturn p.getDecimalValue();\n    \t\tcase VALUE_TRUE:\n    \t\t\treturn Boolean.TRUE;\n    \t\tcase VALUE_FALSE:\n    \t\t\treturn Boolean.FALSE;\n    \t\tcase VALUE_NULL:\n    \t\t\treturn null;\n    \t\tcase START_ARRAY:\n    \t\t\treturn deserializeFromArray(p, ctxt);\n    \t\tcase START_OBJECT:\n    \t\t\treturn deserializeFromObject(p, ctxt);\n    \t\tdefault:\n    \t\t\treturn ctxt.handleUnexpectedToken(getValueType(), p);\n    \t\t}\n    \t}"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        checkSampleData(sample1);\n        checkSampleData(sample2);\n        double sum = 0d;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0d;\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length < 2) {\n            throw new NoDataException(sample1.length);\n        }\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        checkSampleData(sample1);\n        checkSampleData(sample2);\n        double sum = 0d;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        checkSampleData(sample1);\n        checkSampleData(sample2);\n        double sum = 0d;\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        for (int i = 0; i < n; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        checkSampleData(sample1);\n        checkSampleData(sample2);\n        double sum = 0d;\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NoDataException(n);\n        }\n        for (int i = 0; i < n; i++) {\n            sum += (sample1[i] - sample2[i]);\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        checkSampleData(sample1);\n        checkSampleData(sample2);\n        double sum = 0d;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0d;\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 1) {\n            throw new NoDataException(n);\n        }\n        for (int i = 0; i < n; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        checkSampleData(sample1);\n        checkSampleData(sample2);\n        double sum = 0d;\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        for (int i = 0; i < n; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        checkSampleData(sample1);\n        checkSampleData(sample2);\n        double sum = 0d;\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NoDataException(n);\n        }\n        for (int i = 0; i < n; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        double sum = 0d;\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NoDataException(n);\n        }\n        for (int i = 0; i < n; i++) {\n            sum += (sample1[i] - sample2[i]);\n        }\n        return sum;\n    }"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int fullChunkLen = fullChunk.length;\n         if (_freeBuffer == null) {\n             _freeBuffer = new Object[Math.max(12, fullChunkLen)];\n         }\n         if (_freeBuffer.length < fullChunkLen) {\n             Object[] tmp = new Object[fullChunkLen];\n             System.arraycopy(fullChunk, 0, tmp, 0, fullChunkLen);\n             _freeBuffer = tmp;\n         } else {\n             System.arraycopy(fullChunk, 0, _freeBuffer, 0, fullChunkLen);\n         }\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // add the chunk to the buffer\n         LinkedNode<Object[]> node = new LinkedNode<Object[]>(fullChunk);\n         if (_tail == null) {\n             _head = node;\n         } else {\n             _tail.next = node;\n         }\n         _tail = node;\n         _size += fullChunk.length;\n         return fullChunk;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // TODO: implement this method\n         return null;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int fullChunkLen = fullChunk.length;\n        if (_freeBuffer == null) {\n            _freeBuffer = new Object[Math.max(SMALL_CHUNK, fullChunkLen)];\n        } else if (_freeBuffer.length < fullChunkLen) {\n            _freeBuffer = new Object[fullChunkLen];\n        }\n        System.arraycopy(fullChunk, 0, _freeBuffer, 0, fullChunkLen);\n        return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         _size += fullChunk.length;\n         if (_freeBuffer == null) {\n             _freeBuffer = fullChunk;\n         } else {\n             _freeBuffer = Arrays.copyOf(fullChunk, fullChunk.length + _freeBuffer.length);\n         }\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int newSize = _size + fullChunk.length;\n         if ((_freeBuffer == null) || (_freeBuffer.length < newSize)) {\n             _freeBuffer = new Object[Math.max(12, newSize)];\n         }\n         System.arraycopy(fullChunk, 0, _freeBuffer, _size, fullChunk.length);\n         _size = newSize;\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         _size += fullChunk.length;\n         if (_freeBuffer == null) {\n             _freeBuffer = fullChunk;\n         } else {\n             // append to end of existing buffer\n             Object[] tmp = _freeBuffer;\n             _freeBuffer = new Object[tmp.length + fullChunk.length];\n             System.arraycopy(tmp, 0, _freeBuffer, 0, tmp.length);\n             System.arraycopy(fullChunk, 0, _freeBuffer, tmp.length, fullChunk.length);\n         }\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int newSize = _size + fullChunk.length;\n        if ((_freeBuffer == null) || (_freeBuffer.length < newSize)) {\n            _freeBuffer = new Object[Math.max(12, newSize)];\n        }\n        System.arraycopy(fullChunk, 0, _freeBuffer, _size, fullChunk.length);\n        _size = newSize;\n        return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int chunkLen = fullChunk.length;\n         if ((_freeBuffer == null) || (_freeBuffer.length < chunkLen)) {\n             _freeBuffer = new Object[Math.max(12, chunkLen)];\n         }\n         System.arraycopy(fullChunk, 0, _freeBuffer, 0, chunkLen);\n         _size += chunkLen;\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         _size += fullChunk.length;\n         if ((_freeBuffer == null) || (_freeBuffer.length < _size)) {\n             _freeBuffer = new Object[_size];\n         }\n         System.arraycopy(fullChunk, 0, _freeBuffer, 0, fullChunk.length);\n         return _freeBuffer;\n     }"
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        appendPatternTo(builder, pattern);\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.VOID) {\n        return newNode(Token.VOID);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.LC) {\n        return parseUnionType(token);\n    } else if (token == JsDocToken.LP) {\n        return parseFunctionType(token);\n    } else if (token == JsDocToken.LB) {\n        return parseArrayType(token);\n    } else if (token == JsDocToken.STRING) {\n        return parseTypeName(token);\n    } else {\n        return reportGenericTypeSyntaxWarning();\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) \n    {\n        return newNode(Token.STAR);\n    } \n    else if (token == JsDocToken.NULL) \n    {\n        return newNode(Token.NULL);\n    } \n    else if (token == JsDocToken.UNDEFINED) \n    {\n        return newNode(Token.VOID);\n    } \n    else if (token == JsDocToken.LC) \n    {\n        return parseRecordType(token);\n    } \n    else if (token == JsDocToken.LB) \n    {\n        return parseArrayType(token);\n    } \n    else if (token == JsDocToken.LP) \n    {\n        return parseFunctionType(token);\n    } \n    else if (token == JsDocToken.STRING) \n    {\n        return parseTypeName(token);\n    } \n    else \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.type\");\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) \n    {\n        return newNode(Token.STAR);\n    }\n    else if (token == JsDocToken.NULL) \n    {\n        return newNode(Token.NULL);\n    }\n    else if (token == JsDocToken.UNDEFINED) \n    {\n        return newNode(Token.VOID);\n    }\n    else if (token == JsDocToken.STRING) \n    {\n        return parseTypeName(token);\n    }\n    else if (token == JsDocToken.LP) \n    {\n        return parseFunctionType(token);\n    }\n    else if (token == JsDocToken.LC) \n    {\n        return parseUnionType(token);\n    }\n    else if (token == JsDocToken.LB) \n    {\n        return parseArrayType(token);\n    }\n    else if (token == JsDocToken.DOT) \n    {\n        return parseRecordType(token);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) \n  {\n    return newNode(Token.STAR);\n  } \n  else if (token == JsDocToken.NULL) \n  {\n    return newNode(Token.NULL);\n  } \n  else if (token == JsDocToken.VOID) \n  {\n    return newNode(Token.VOID);\n  } \n  else if (token == JsDocToken.UNDEFINED) \n  {\n    return newNode(Token.UNDEFINED);\n  } \n  else \n  {\n    return parseTypeName(token);\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else if (token == JsDocToken.LP) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else {\n    return reportGenericTypeSyntaxWarning();\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n        return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.VOID) {\n        return newNode(Token.VOID);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.LC) {\n        return parseRecordType(token);\n    } else if (token == JsDocToken.LP) {\n        return parseFunctionType(token);\n    } else if (token == JsDocToken.LB) {\n        return parseArrayType(token);\n    } else {\n        return parseTypeName(token);\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.VOID);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.LP) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseUnionType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else if (token == JsDocToken.DOT) {\n    return parseRecordType(token);\n  } else {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) \n  {\n    return newNode(Token.STAR);\n  } \n  else if (token == JsDocToken.NULL) \n  {\n    return newNode(Token.NULL);\n  } \n  else if (token == JsDocToken.UNDEFINED) \n  {\n    return newNode(Token.UNDEFINED);\n  } \n  else if (token == JsDocToken.LC) \n  {\n    return parseTypeName(next());\n  } \n  else if (token == JsDocToken.LP) \n  {\n    return parseFunctionType(next());\n  } \n  else if (token == JsDocToken.LB) \n  {\n    return parseArrayType(next());\n  } \n  else if (token == JsDocToken.PIPE) \n  {\n    return parseUnionType(next());\n  } \n  else if (token == JsDocToken.SLASH) \n  {\n    return parseRecordType(next());\n  } \n  else \n  {\n    return null;\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) \n  {\n    return newNode(Token.STAR);\n  } \n  else if (token == JsDocToken.NULL) \n  {\n    return newNode(Token.NULL);\n  } \n  else if (token == JsDocToken.UNDEFINED) \n  {\n    return newNode(Token.VOID);\n  } \n  else \n  {\n    return parseTypeName(token);\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) {\n    return newNode(Token.STAR);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else if (token == JsDocToken.LP) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else {\n    return null;\n  }\n}"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    beforeName();\n    string(name);\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    beforeName();\n    string(name);\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    beforeName();\n    string(name);\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    beforeName();\n    string(name);\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) \n  {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) \n  {\n    throw new IllegalStateException(\"Dangling name: \" + deferredName);\n  }\n  deferredName = name;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) {\n    throw new NullPointerException(\"name == null\");\n  }\n  writeDeferredName();\n  beforeName();\n  string(name);\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) \n  {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) \n  {\n    throw new IllegalStateException(\"Dangling name: \" + deferredName);\n  }\n  beforeName();\n  string(name);\n  deferredName = name;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) \n  {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) \n  {\n    throw new IllegalStateException(\"Dangling name: \" + deferredName);\n  }\n  deferredName = name;\n  return this;\n}"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // work out the minimum value...\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        return new Double(info.getRangeLowerBound(true));\n    }\n\n    // hasn't implemented RangeInfo, so we'll have to iterate...\n    else {\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        boolean hasValidData = false;\n        double minimum = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                                 // '+', remember value is negative\n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum = Math.min(minimum, negative[g]);\n                maximum = Math.max(maximum, positive[g]);\n            }\n        }\n        if (hasValidData) {\n            return new Double(minimum);\n        }\n        return null;\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // work out the minimum value...\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        return new Double(info.getRangeLowerBound(true));\n    }\n\n    // hasn't implemented RangeInfo, so we'll have to iterate...\n    else {\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                                 // '+', remember value is negative\n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum[g] = Math.min(minimum[g], negative[g]);\n                maximum[g] = Math.max(maximimum[g], positive[g]);\n            }\n        }\n        if (hasValidData) {\n            for (int j = 0; j < groupCount; j++) {\n                result = Range.combine(result, new Range(minimum[j],\n                        maximum[j]));\n            }\n        }\n        return result;\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[groupIndex[series]]\n                             = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) {\n                    negative[groupIndex[series]]\n                             = negative[groupIndex[series]] + value;\n                                 // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum = Math.min(minimum, negative[g]);\n            maximum = Math.max(maximum, positive[g]);\n        }\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // work out the minimum value...\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        return new Double(info.getRangeLowerBound(true));\n    }\n\n    // hasn't implemented RangeInfo, so we'll have to iterate...\n    else {\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                                 // '+', remember value is negative\n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum[g] = Math.min(minimum[g], negative[g]);\n                maximum[g] = Math.max(maximimum[g], positive[g]);\n            }\n        }\n        if (hasValidData) {\n            for (int j = 0; j < groupCount; j++) {\n                result = Range.combine(result, new Range(minimum[j],\n                        maximum[j]));\n            }\n        }\n        return result;\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // work out the minimum value...\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        return new Double(info.getRangeLowerBound(true));\n    }\n\n    // hasn't implemented RangeInfo, so we'll have to iterate...\n    else {\n        // hasn't implemented RangeInfo, so we'll have to iterate...\n        boolean hasValidData = false;\n        double minimum = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                                 // '+', remember value is negative\n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum = Math.min(minimum, negative[g]);\n            }\n        }\n        if (hasValidData) {\n            return new Double(minimum);\n        }\n        else {\n            return null;\n        }\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[groupIndex[series]]\n                             = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) {\n                    negative[groupIndex[series]]\n                             = negative[groupIndex[series]] + value;\n                                 // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum = Math.min(minimum, negative[g]);\n            maximum = Math.max(maximum, positive[g]);\n        }\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[groupIndex[series]]\n                             = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) {\n                    negative[groupIndex[series]]\n                             = negative[groupIndex[series]] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum = Math.min(minimum, negative[g]);\n            maximum = Math.max(maximum, positive[g]);\n        }\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // work out the minimum value...\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        return new Double(info.getRangeLowerBound(true));\n    }\n\n    // hasn't implemented RangeInfo, so we'll have to iterate...\n    else {\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double[] positive = new double[groupCount];\n            double[] negative = new double[groupCount];\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    hasValidData = true;\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                    }\n                    if (value < 0.0) {\n                        negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                                 // '+', remember value is negative\n                    }\n                }\n            }\n            for (int g = 0; g < groupCount; g++) {\n                minimum[g] = Math.min(minimum[g], negative[g]);\n                maximum[g] = Math.max(maximum[g], positive[g]);\n            }\n        }\n        if (hasValidData) {\n            for (int j = 0; j < groupCount; j++) {\n                result = Range.combine(result, new Range(minimum[j],\n                        maximum[j]));\n            }\n        }\n        return result;\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) {\n                    negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                                 // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum = Math.min(minimum, negative[g]);\n            maximum = Math.max(maximum, positive[g]);\n        }\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[groupIndex[series]]\n                                 = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) {\n                    negative[groupIndex[series]]\n                                 = negative[groupIndex[series]] + value;\n                                 // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum = Math.min(minimum, negative[g]);\n            maximum = Math.max(maximum, positive[g]);\n        }\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (delimiters == null || delimiters.length == 0) \n    {\n        return str.substring(0, 1);\n    }\n    final Set<Character> delimiterSet = new HashSet<>();\n    for (final char delimiter : delimiters) \n    {\n        delimiterSet.add(delimiter);\n    }\n    final StringTokenizer st = new StringTokenizer(str, String.valueOf(delimiterSet));\n    final StringBuilder buffer = new StringBuilder();\n    while (st.hasMoreTokens()) \n    {\n        buffer.append(st.nextToken().substring(0, 1));\n    }\n    return buffer.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) \n    {\n        return \"\";\n    }\n    final Set<Character> delimSet = new HashSet<Character>(delimLen);\n    for (final char delimiter : delimiters) \n    {\n        delimSet.add(delimiter);\n    }\n    final char[] buf = new char[delimLen];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < str.length(); i++) \n    {\n        final char ch = str.charAt(i);\n        if (delimSet.contains(ch)) \n        {\n            if (!lastWasGap) \n            {\n                buf[count++] = ch;\n            }\n            lastWasGap = true;\n        } \n        else \n        {\n            if (lastWasGap) \n            {\n                buf[count++] = Character.toUpperCase(ch);\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    int wordStart = -1;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n            wordStart = -1;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toUpperCase(ch);\n            capitalizeNext = false;\n            wordStart = i;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toUpperCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    int count = 0;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n            count++;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[count++] = Character.toUpperCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) \n    {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) \n    {\n        return \"\";\n    }\n    final Set<Character> delimiterSet = new HashSet<Character>();\n    for (final char delimiter : delimiters) \n    {\n        delimiterSet.add(delimiter);\n    }\n    final StringTokenizer tokens = new StringTokenizer(str);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    while (tokens.hasMoreTokens()) \n    {\n        final String token = tokens.nextToken();\n        if (token.length() > 0) \n        {\n            buffer.append(Character.toUpperCase(token.charAt(0)));\n        }\n        if (tokens.hasMoreTokens()) \n        {\n            buffer.append(\".\");\n        }\n    }\n    return buffer.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toUpperCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    final char[] array = str.toCharArray();\n    final int arrayLength = array.length;\n    final StringBuilder builder = new StringBuilder((int)(arrayLength * 1.5));\n    boolean capitalizeNext = true;\n    for (int i = 0; i < arrayLength; i++) \n    {\n        final char ch = array[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n            builder.append(ch);\n        } \n        else if (capitalizeNext) \n        {\n            builder.append(Character.toUpperCase(ch));\n            capitalizeNext = false;\n        } \n        else \n        {\n            builder.append(ch);\n        }\n    }\n    return builder.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    int count = 0;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        if (isDelimiter(buffer[i], delimiters)) \n        {\n            if (i == 0 || count == 0) \n            {\n                continue;\n            }\n            buffer[count++] = Character.toUpperCase(buffer[i]);\n        } \n        else \n        {\n            buffer[count++] = Character.toLowerCase(buffer[i]);\n        }\n    }\n    return new String(buffer, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    final int sz = buffer.length;\n    final StringBuilder initials = new StringBuilder(sz);\n    for (int i = 0; i < sz; i++) \n    {\n        if (isDelimiter(buffer[i], delimiters)) \n        {\n            capitalizeNext = true;\n            continue;\n        }\n        if (capitalizeNext) \n        {\n            initials.append(Character.toUpperCase(buffer[i]));\n            capitalizeNext = false;\n        }\n        else \n        {\n            initials.append(Character.toLowerCase(buffer[i]));\n        }\n    }\n    return initials.toString();\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    return calculateColumnTotal(data, column, null);\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    return calculateColumnTotal(data, column, null);\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    return calculateColumnTotal(data, column, null);\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null)\n    {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null)\n    {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = screenPoint.getX() - insets.left;\n    double y = screenPoint.getY() - insets.top;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    // perform argument checking\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n\n    // get the insets\n    Insets insets = getInsets();\n\n    // translate the screen point to the Java2D space\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    return new Point2D.Double(screenPoint.x, screenPoint.y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    return new Point2D.Double(screenPoint.x, screenPoint.y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    return new Point2D.Double(screenPoint.x, screenPoint.y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = screenPoint.getX() - insets.left;\n    double y = screenPoint.getY() - insets.top;\n    return new Point2D.Double(x / this.scaleX, y / this.scaleY);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    return new Point2D.Double(screenPoint.x, screenPoint.y);\n}"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        ParsePosition parsePosition = new ParsePosition(0);\n        BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final int initialIndex = 0;\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, initialIndex);\n\n        // parse numerator\n        final BigInteger num = parseNextBigInteger(source, initialIndex);\n        if (num == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            return null;\n        }\n\n        // parse '/'\n        final int startIndex = initialIndex;\n        final char c = parseNextCharacter(source, initialIndex);\n        switch (c) {\n        case 0 :\n            // no '/'\n            // return num as a BigFraction\n            return new BigFraction(num);\n        case '/' :\n            // found '/', continue parsing denominator\n            break;\n        default :\n            // invalid '/'\n            // set index back to initial, error index should be the last\n            // character examined.\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, initialIndex);\n\n        // parse denominator\n        final BigInteger den = parseNextBigInteger(source, initialIndex);\n        if (den == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            return null;\n        }\n\n        // create and return the BigFraction\n        return new BigFraction(num, den);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        ParsePosition parsePosition = new ParsePosition(0);\n        BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        ParsePosition parsePosition = new ParsePosition(0);\n        BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final int initialIndex = 0;\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, initialIndex);\n\n        // parse numerator\n        final BigInteger num = parseNextBigInteger(source, initialIndex);\n        if (num == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            throw new MathParseException(source, initialIndex, BigFraction.class);\n        }\n\n        // parse '/'\n        final int startIndex = initialIndex;\n        final char c = parseNextCharacter(source, initialIndex);\n        switch (c) {\n            case 0 :\n                // no '/'\n                // return num as a BigFraction\n                return new BigFraction(num);\n            case '/' :\n                // found '/', continue parsing denominator\n                break;\n            default :\n                // invalid '/'\n                // set index back to initial, error index should be the last\n                // character examined.\n                throw new MathParseException(source, initialIndex, BigFraction.class);\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, initialIndex);\n\n        // parse denominator\n        final BigInteger den = parseNextBigInteger(source, initialIndex);\n        if (den == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            throw new MathParseException(source, initialIndex, BigFraction.class);\n        }\n\n        // create and return the BigFraction\n        return new BigFraction(num, den);\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        ParsePosition parsePosition = new ParsePosition(0);\n        BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source,\n                                         parsePosition.getErrorIndex(),\n                                         BigFraction.class);\n        }\n        return result;\n    }"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(new HashSet<E>(), list);\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(new HashSet<E>(), list);\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range range = plot.getDataRange(axis);\n            if (result == null) \n            {\n                result = range;\n            }\n            else \n            {\n                result = Range.combine(result, range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (this.subplots == null) {\n        return null;\n    }\n    Range result = null;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext()) {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        Range range = plot.getDataRange(axis);\n        if (range != null) {\n            if (result == null) {\n                result = range;\n            }\n            else {\n                result = Range.combine(result, range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == this) {\n        return getRange();\n    }\n    else {\n        Range result = null;\n        if (this.subplots != null) {\n            Iterator iterator = this.subplots.iterator();\n            while (iterator.hasNext()) {\n                CategoryPlot plot = (CategoryPlot) iterator.next();\n                Range range = plot.getDataRange(axis);\n                if (result == null) {\n                    result = range;\n                }\n                else {\n                    result = Range.combine(result, range);\n                }\n            }\n        }\n        return result;\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range range = plot.getDataRange(axis);\n            if (result == null) {\n                result = range;\n            }\n            else {\n                result = Range.combine(result, range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (this.subplots != null) \n    {\n        Range result = null;\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range range = plot.getDataRange(axis);\n            if (result == null) \n            {\n                result = range;\n            }\n            else \n            {\n                result = Range.combine(result, range);\n            }\n        }\n        return result;\n    }\n    return null;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range range = plot.getDataRange(axis);\n            if (result == null) \n            {\n                result = range;\n            }\n            else \n            {\n                result = Range.combine(result, range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == this)\n    {\n        return getRange();\n    }\n    else\n    {\n        Range result = null;\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext())\n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range r = plot.getDataRange(axis);\n            if (r != null)\n            {\n                if (result == null)\n                {\n                    result = r;\n                }\n                else\n                {\n                    result = Range.combine(result, r);\n                }\n            }\n        }\n        return result;\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == this) \n    {\n        return getRange();\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range range = plot.getDataRange(axis);\n            if (result == null) \n            {\n                result = range;\n            }\n            else \n            {\n                result = Range.combine(result, range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (this.subplots == null)  {\n        return null;\n    }\n    Range result = null;\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext())  {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        Range range = plot.getDataRange(axis);\n        if (result == null)  {\n            result = range;\n        }\n        else  {\n            result = Range.combine(result, range);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) + SMALL_LOG_VALUE; //invert adjustLog10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = (Math.log(val) / LOG10_VALUE) + SMALL_LOG_VALUE; //invert adjustLog10\n    }\n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) + 1.0; //invert adjustLog10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) + SMALL_LOG_VALUE; //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) - SMALL_LOG_VALUE; //invert adjustLog10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = (Math.log(val) / LOG10_VALUE) + 1.0; //invert adjustLog10\n    }\n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) - SMALL_LOG_VALUE; //invert adjustLog10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) - SMALL_LOG_VALUE; //invert adjustLog10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = (Math.log(val) / LOG10_VALUE) - 1.0; //invert adjustedLog10\n    }\n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = (Math.log(val) / LOG10_VALUE) + 1.0; //invert adjustedPow10\n    }\n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  if (cfg.getImplicitReturn() == null) {\n    return true;\n  }\n\n  if (cfg.getEntry() == null) {\n    return false;\n  }\n\n  // If there is a return statement, then we know that all paths must\n  // contain a return.\n  if (cfg.getImplicitReturn().getInEdges().size() > 0) {\n    return true;\n  }\n\n  // If there are no edges to the entry node, then we know that there\n  // is no path from the entry node to the exit node.\n  if (cfg.getEntry().getOutEdges().size() == 0) {\n    return false;\n  }\n\n  // If there are no edges to the exit node, then we know that there\n  // is no path from the entry node to the exit node.\n  if (cfg.getImplicitReturn().getOutEdges().size() == 0) {\n    return false;\n  }\n\n  // If there are no edges between the entry and exit nodes, then we know\n  // that there is no path from the entry node to the exit node.\n  if (cfg.getEntry().getOutEdges().size() == 0) {\n    return false;\n  }\n\n  // If there are no edges between the entry and exit nodes, then we know\n  // that there is no path from the entry node to the exit node.\n  if (cfg.getImplicitReturn().getInEdges().size() == 0) {\n    return false;\n  }\n\n  // If there are no edges between the entry and exit nodes, then we know\n  // that there is no path from the entry node to the exit node.\n  if (cfg.getEntry().getOutEdges().size() == 0) {\n    return false;\n  }\n\n  // If there are no edges between the entry and exit nodes, then we know\n  // that there is no path from the entry node to the exit node.\n  if (cfg.getImplicitReturn().getInEdges().size() == 0) {\n    return false;\n  }\n\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // If the function is empty, then it always returns.\n  if (cfg.isEmpty()) {\n    return true;\n  }\n\n  // If the function is a single return, then it always returns.\n  if (cfg.getImplicitReturn().getInEdges().isEmpty()) {\n    return true;\n  }\n\n  // If the function is a single block with a single return, then it always returns.\n  if (cfg.getImplicitReturn().getInEdges().size() == 1) {\n    Node block = cfg.getImplicitReturn().getInEdges().get(0).getSource();\n    if (block.isBlock() && block.getFirstChild() != null &&\n        block.getFirstChild().isReturn()) {\n      return true;\n    }\n  }\n\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  if (cfg.getImplicitReturn().getInEdges().isEmpty()) {\n    return true;\n  }\n\n  // Find the first node that is not a return.\n  for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge :\n      cfg.getImplicitReturn().getInEdges()) {\n    Node source = edge.getSource();\n    if (!source.isReturn()) {\n      return false;\n    }\n  }\n\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  if (cfg.getImplicitReturn().getInEdges().isEmpty()) {\n    return true;\n  }\n\n  for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge :\n      cfg.getImplicitReturn().getInEdges()) {\n    if (!edge.getType().isReturn()) {\n      return false;\n    }\n  }\n\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // TODO(user): This is a fast heuristic, but it's not guaranteed to be\n  // correct.  We should fix this.\n  if (cfg.getImplicitReturn().getInEdges().isEmpty()) {\n    return true;\n  }\n\n  // If there are no edges between the entry and the implicit return,\n  // then all paths must go through the implicit return.\n  if (cfg.getEntry().getOutEdges().isEmpty()) {\n    return false;\n  }\n\n  // If there are no back edges, then all paths must go through the\n  // implicit return.\n  if (cfg.getBackEdges().isEmpty()) {\n    return false;\n  }\n\n  // If there are no forward edges to the implicit return, then all\n  // paths must go through the implicit return.\n  if (cfg.getImplicitReturn().getInEdges().isEmpty()) {\n    return false;\n  }\n\n  return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  // Check for the simple case where the function is empty.\n  if (cfg.isEmpty()) {\n    return true;\n  }\n\n  // Check for the simple case where the function has a single return.\n  if (cfg.getImplicitReturn().getInEdges().size() == 1) {\n    return true;\n  }\n\n  // Check for the simple case where the function has no returns.\n  if (cfg.getImplicitReturn().getInEdges().isEmpty()) {\n    return false;\n  }\n\n  // Check for the simple case where the function has a single conditional\n  // return.\n  if (cfg.getImplicitReturn().getInEdges().size() == 2) {\n    // Find the condition node.\n    Node conditionNode = null;\n    for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge :\n        cfg.getImplicitReturn().getInEdges()) {\n      if (edge.getValue() == ControlFlowGraph.Branch.ON_TRUE) {\n        conditionNode = edge.getSource();\n        break;\n      }\n    }\n\n    // If the condition node is a boolean literal, we know that the function\n    // always returns.\n    if (conditionNode.isBooleanLiteral()) {\n      return true;\n    }\n\n    // If the condition node is a constant, we know that the function always\n    // returns.\n    if (conditionNode.isConstant()) {\n      return true;\n    }\n\n    // If the condition node is a name, we know that the function always\n    // returns.\n    if (conditionNode.isName()) {\n      return true;\n    }\n  }\n\n  // Check for the simple case where the function has a single conditional\n  // return with a constant condition.\n  if (cfg.getImplicitReturn().getInEdges().size() == 2) {\n    // Find the condition node.\n    Node conditionNode = null;\n    for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge :\n        cfg.getImplicitReturn().getInEdges()) {\n}\n}\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  if (cfg.getImplicitReturn() == null) {\n    return false;\n  }\n\n  // If the function has a return statement, then there is at least one path\n  // that returns.\n  if (cfg.getImplicitReturn().getInEdges().size() > 0) {\n    return true;\n  }\n\n  // If the function does not have a return statement, then there is at least\n  // one path that does not return.\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  if (cfg.getImplicitReturn().getInEdges().isEmpty()) {\n    return true;\n  }\n\n  // We can't use the fast path if there are any back edges.\n  for (DiGraphEdge<Node, ControlFlowGraph.Branch> edge :\n      cfg.getImplicitReturn().getInEdges()) {\n    if (edge.getType() == ControlFlowGraph.Branch.FALSE_BRANCH) {\n      return false;\n    }\n  }\n\n  // If there are no back edges, then all paths from the entry node to the\n  // implicit return must contain a return statement.\n  return cfg.getEntry().getOutEdges().size() == 1;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  if (cfg.getImplicitReturn().getInEdges().isEmpty()) {\n    return true;\n  }\n\n  // If there are no back edges, then all paths must go through the implicit\n  // return.\n  if (cfg.getBackEdges().isEmpty()) {\n    return true;\n  }\n\n  // If there are back edges, then there is a path from the entry to the\n  // implicit return that doesn't go through the implicit return.\n  return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n  if (cfg.getImplicitReturn() == null) {\n    return false;\n  }\n\n  if (cfg.getImplicitReturn().getInEdges().isEmpty()) {\n    return false;\n  }\n\n  // If there are no out edges from the implicit return, then there are no\n  // paths from the entry node to the implicit return.\n  if (cfg.getImplicitReturn().getOutEdges().isEmpty()) {\n    return false;\n  }\n\n  // If there is only one path from the entry node to the implicit return,\n  // then it must contain a return statement.\n  if (cfg.getImplicitReturn().getInEdges().size() == 1) {\n    return true;\n  }\n\n  // If there are multiple paths from the entry node to the implicit return,\n  // then there must be at least one path that contains a return statement.\n  return !cfg.getImplicitReturn().getInEdges().stream()\n      .allMatch(edge -> edge.getSource().getType() != Token.RETURN);\n}"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] x = new Dfp[2];\n    final Dfp[] y = new Dfp[2];\n    final Dfp[] z = new Dfp[2];\n    final Dfp[] a2 = new Dfp[2];\n    final Dfp[] a3 = new Dfp[2];\n    final Dfp[] a4 = new Dfp[2];\n    final Dfp[] a5 = new Dfp[2];\n    final Dfp[] a6 = new Dfp[2];\n    final Dfp[] a7 = new Dfp[2];\n    final Dfp[] a8 = new Dfp[2];\n    final Dfp[] a9 = new Dfp[2];\n    final Dfp[] a10 = new Dfp[2];\n    final Dfp[] a11 = new Dfp[2];\n    final Dfp[] a12 = new Dfp[2];\n    final Dfp[] a13 = new Dfp[2];\n    final Dfp[] a14 = new Dfp[2];\n    final Dfp[] a15 = new Dfp[2];\n    final Dfp[] a16 = new Dfp[2];\n    final Dfp[] a17 = new Dfp[2];\n    final Dfp[] a18 = new Dfp[2];\n    final Dfp[] a19 = new Dfp[2];\n    final Dfp[] a20 = new Dfp[2];\n    final Dfp[] a21 = new Dfp[2];\n    final Dfp[] a22 = new Dfp[2];\n    final Dfp[] a23 = new Dfp[2];\n    final Dfp[] a24 = new Dfp[2];\n    final Dfp[] a25 = new Dfp[2];\n    final Dfp[] a26 = new Dfp[2];\n    final Dfp[] a27 = new Dfp[2];\n    final Dfp[] a28 = new Dfp[2];\n    final Dfp[] a29 = new Dfp[2];\n    final Dfp[] a30 = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp x[] = new Dfp[2];\n    final Dfp y[] = new Dfp[2];\n    final Dfp z[] = new Dfp[2];\n    final Dfp a1[] = new Dfp[2];\n    final Dfp a2[] = new Dfp[2];\n    final Dfp a3[] = new Dfp[2];\n    final Dfp a4[] = new Dfp[2];\n    final Dfp a5[] = new Dfp[2];\n    final Dfp a6[] = new Dfp[2];\n    final Dfp a7[] = new Dfp[2];\n    final Dfp a8[] = new Dfp[2];\n    final Dfp a9[] = new Dfp[2];\n    final Dfp a10[] = new Dfp[2];\n    final Dfp a11[] = new Dfp[2];\n    final Dfp a12[] = new Dfp[2];\n    final Dfp a13[] = new Dfp[2];\n    final Dfp a14[] = new Dfp[2];\n    final Dfp a15[] = new Dfp[2];\n    final Dfp a16[] = new Dfp[2];\n    final Dfp a17[] = new Dfp[2];\n    final Dfp a18[] = new Dfp[2];\n    final Dfp a19[] = new Dfp[2];\n    final Dfp a20[] = new Dfp[2];\n    final Dfp a21[] = new Dfp[2];\n    final Dfp a22[] = new Dfp[2];\n    final Dfp a23[] = new Dfp[2];\n    final Dfp a24[] = new Dfp[2];\n    final Dfp a25[] = new Dfp[2];\n    final Dfp a26[] = new Dfp[2];\n    final Dfp a27[] = new Dfp[2];\n    final Dfp a28[] = new Dfp[2];\n    final Dfp a29[] = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] x = new Dfp[2];\n    final Dfp[] y = new Dfp[2];\n    final Dfp[] z = new Dfp[2];\n    final Dfp[] w = new Dfp[2];\n    final Dfp[] u = new Dfp[2];\n    final Dfp[] v = new Dfp[2];\n    final Dfp[] r = new Dfp[2];\n    final Dfp[] s = new Dfp[2];\n    final Dfp[] t = new Dfp[2];\n    final Dfp[] m = new Dfp[2];\n    final Dfp[] n = new Dfp[2];\n    final Dfp[] p = new Dfp[2];\n    final Dfp[] q = new Dfp[2];\n    final Dfp[] o = new Dfp[2];\n    final Dfp[] l = new Dfp[2];\n    final Dfp[] k = new Dfp[2];\n    final Dfp[] j = new Dfp[2];\n    final Dfp[] i = new Dfp[2];\n    final Dfp[] h = new Dfp[2];\n    final Dfp[] g = new Dfp[2];\n    final Dfp[] f = new Dfp[2];\n    final Dfp[] e = new Dfp[2];\n    final Dfp[] d = new Dfp[2];\n    final Dfp[] c = new Dfp[2];\n    final Dfp[] b = new Dfp[2];\n    final Dfp[] a1 = new Dfp[2];\n    final Dfp[] a2 = new Dfp[2];\n    final Dfp[] a3 = new Dfp[2];\n    final Dfp[] a4 = new Dfp[2];\n    final Dfp[] a5 = new Dfp[2];\n    final Dfp[] a6 = new Dfp[2];\n    final Dfp[] a7 = new Dfp[2];\n    final Dfp[] a8 = new Dfp[2];\n    final Dfp[] a9 = new Dfp[2];\n    final Dfp[] a10 = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp x[] = new Dfp[2];\n    final Dfp y[] = new Dfp[2];\n    final Dfp z[] = new Dfp[2];\n    final Dfp a1[] = new Dfp[2];\n    final Dfp a2[] = new Dfp[2];\n    final Dfp a3[] = new Dfp[2];\n    final Dfp a4[] = new Dfp[2];\n    final Dfp a5[] = new Dfp[2];\n    final Dfp a6[] = new Dfp[2];\n    final Dfp a7[] = new Dfp[2];\n    final Dfp a8[] = new Dfp[2];\n    final Dfp a9[] = new Dfp[2];\n    final Dfp a10[] = new Dfp[2];\n    final Dfp a11[] = new Dfp[2];\n    final Dfp a12[] = new Dfp[2];\n    final Dfp a13[] = new Dfp[2];\n    final Dfp a14[] = new Dfp[2];\n    final Dfp a15[] = new Dfp[2];\n    final Dfp a16[] = new Dfp[2];\n    final Dfp a17[] = new Dfp[2];\n    final Dfp a18[] = new Dfp[2];\n    final Dfp a19[] = new Dfp[2];\n    final Dfp a20[] = new Dfp[2];\n    final Dfp a21[] = new Dfp[2];\n    final Dfp a22[] = new Dfp[2];\n    final Dfp a23[] = new Dfp[2];\n    final Dfp a24[] = new Dfp[2];\n    final Dfp a25[] = new Dfp[2];\n    final Dfp a26[] = new Dfp[2];\n    final Dfp a27[] = new Dfp[2];\n    final Dfp a28[] = new Dfp[2];\n    final Dfp a29[] = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp x[] = new Dfp[2];\n    final Dfp y[] = new Dfp[2];\n    final Dfp a2[] = new Dfp[2];\n    final Dfp a3[] = new Dfp[2];\n    final Dfp a4[] = new Dfp[2];\n    final Dfp a5[] = new Dfp[2];\n    final Dfp a6[] = new Dfp[2];\n    final Dfp a7[] = new Dfp[2];\n    final Dfp a8[] = new Dfp[2];\n    final Dfp a9[] = new Dfp[2];\n    final Dfp a10[] = new Dfp[2];\n    final Dfp a11[] = new Dfp[2];\n    final Dfp a12[] = new Dfp[2];\n    final Dfp a13[] = new Dfp[2];\n    final Dfp a14[] = new Dfp[2];\n    final Dfp a15[] = new Dfp[2];\n    final Dfp a16[] = new Dfp[2];\n    final Dfp a17[] = new Dfp[2];\n    final Dfp a18[] = new Dfp[2];\n    final Dfp a19[] = new Dfp[2];\n    final Dfp a20[] = new Dfp[2];\n    final Dfp a21[] = new Dfp[2];\n    final Dfp a22[] = new Dfp[2];\n    final Dfp a23[] = new Dfp[2];\n    final Dfp a24[] = new Dfp[2];\n    final Dfp a25[] = new Dfp[2];\n    final Dfp a26[] = new Dfp[2];\n    final Dfp a27[] = new Dfp[2];\n    final Dfp a28[] = new Dfp[2];\n    final Dfp a29[] = new Dfp[2];\n    final Dfp a30[] = new Dfp[2];\n    final Dfp a31[] = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] x = new Dfp[2];\n    Dfp[] y = new Dfp[2];\n    Dfp[] a2 = new Dfp[2];\n    Dfp[] a3 = new Dfp[2];\n    Dfp[] a4 = new Dfp[2];\n    Dfp[] a5 = new Dfp[2];\n    Dfp[] a6 = new Dfp[2];\n    Dfp[] a7 = new Dfp[2];\n    Dfp[] a8 = new Dfp[2];\n    Dfp[] a9 = new Dfp[2];\n    Dfp[] a10 = new Dfp[2];\n    Dfp[] a11 = new Dfp[2];\n    Dfp[] a12 = new Dfp[2];\n    Dfp[] a13 = new Dfp[2];\n    Dfp[] a14 = new Dfp[2];\n    Dfp[] a15 = new Dfp[2];\n    Dfp[] a16 = new Dfp[2];\n    Dfp[] a17 = new Dfp[2];\n    Dfp[] a18 = new Dfp[2];\n    Dfp[] a19 = new Dfp[2];\n    Dfp[] a20 = new Dfp[2];\n    Dfp[] a21 = new Dfp[2];\n    Dfp[] a22 = new Dfp[2];\n    Dfp[] a23 = new Dfp[2];\n    Dfp[] a24 = new Dfp[2];\n    Dfp[] a25 = new Dfp[2];\n    Dfp[] a26 = new Dfp[2];\n    Dfp[] a27 = new Dfp[2];\n    Dfp[] a28 = new Dfp[2];\n    Dfp[] a29 = new Dfp[2];\n    Dfp[] a30 = new Dfp[2];\n    Dfp[] a31 = new Dfp[2];\n    Dfp[] a32 = new Dfp[2];\n    Dfp[] a33 = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    // We know that f'(x) = 1/x, thus from Taylor's theorum we have:\n    //\n    //           -----          n+1         n\n    //  f(x) =   \\           (-1)    (x - 1)\n    //           /          ----------------    for 1 <= n <= infinity\n    //           -----             n\n    //\n    // or\n    //                       2        3       4\n    //                   (x-1)   (x-1)    (x-1)\n    //  ln(x) =  (x-1) - ----- + ------ - ------ + ...\n    //                     2       3        4\n    //\n    // alternatively,\n    //\n    //                  2    3   4\n    //                 x    x   x\n    //  ln(x+1) =  x - -  + - - - + ...\n    //                 2    3   4\n    //\n    // This series can be used to compute ln(x), but it converges too slowly.\n    //\n    // If we substitute -x for x above, we get\n    //\n    //                   2    3    4\n    //                  x    x    x\n    //  ln(1-x) =  -x - -  - -  - - + ...\n    //                  2    3    4\n    //\n    // Note that all terms are now negative.  Because the even powered ones\n    // absorbed the sign.  Now, subtract the series above from the previous\n    // one to get ln(x+1) - ln(1-x).  Note the even terms cancel out leaving\n    // only the odd ones\n    //\n    //                             3     5      7\n    //                           2x    2x     2x\n    //  ln(x+1) - ln(x-1) = 2x + --- + --- + ---- + ...\n    //                            3     5      7\n    //\n    // By the property of logarithms that ln(a) - ln(b) = ln (a/b) we have:\n    //\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x[] = new Dfp[2];\n    Dfp x2[] = new Dfp[2];\n    Dfp y[] = new Dfp[2];\n    Dfp a2[] = new Dfp[2];\n\n    split(a, x);\n\n    /* Set X = (x-1)/(x+1) */\n    x[0] += 1.0;\n    resplit(x);\n    splitReciprocal(x, a2);\n    x[0] -= 2.0;\n    resplit(x);\n    splitMult(x, a2, y);\n    x[0] = y[0];\n    x[1] = y[1];\n\n    /* Square X -> X2*/\n    splitMult(x, x, x2);\n\n    //x[0] -= 1.0;\n    //resplit(x);\n\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n    for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n        splitMult(y, x2, a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n        splitAdd(y, LN_SPLIT_COEF[i], a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n    }\n\n    splitMult(y, x, a2);\n    y[0] = a2[0];\n    y[1] = a2[1];\n\n    return y;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] x = new Dfp[2];\n    Dfp[] y = new Dfp[2];\n    Dfp[] a2 = new Dfp[2];\n    Dfp[] a3 = new Dfp[2];\n    Dfp[] a4 = new Dfp[2];\n    Dfp[] a5 = new Dfp[2];\n    Dfp[] a6 = new Dfp[2];\n    Dfp[] a7 = new Dfp[2];\n    Dfp[] a8 = new Dfp[2];\n    Dfp[] a9 = new Dfp[2];\n    Dfp[] a10 = new Dfp[2];\n    Dfp[] a11 = new Dfp[2];\n    Dfp[] a12 = new Dfp[2];\n    Dfp[] a13 = new Dfp[2];\n    Dfp[] a14 = new Dfp[2];\n    Dfp[] a15 = new Dfp[2];\n    Dfp[] a16 = new Dfp[2];\n    Dfp[] a17 = new Dfp[2];\n    Dfp[] a18 = new Dfp[2];\n    Dfp[] a19 = new Dfp[2];\n    Dfp[] a20 = new Dfp[2];\n    Dfp[] a21 = new Dfp[2];\n    Dfp[] a22 = new Dfp[2];\n    Dfp[] a23 = new Dfp[2];\n    Dfp[] a24 = new Dfp[2];\n    Dfp[] a25 = new Dfp[2];\n    Dfp[] a26 = new Dfp[2];\n    Dfp[] a27 = new Dfp[2];\n    Dfp[] a28 = new Dfp[2];\n    Dfp[] a29 = new Dfp[2];\n    Dfp[] a30 = new Dfp[2];\n    Dfp[] a31 = new Dfp[2];\n    Dfp[] a32 = new Dfp[2];\n    Dfp[] a33 = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x[] = new Dfp[2];\n    Dfp x2[] = new Dfp[2];\n    Dfp y[] = new Dfp[2];\n    Dfp a2[] = new Dfp[2];\n\n    // Set X = (a-1)/(a+1)\n    splitAdd(a, a, x);\n    splitReciprocal(x, a2);\n    splitMult(a2, a2, x2);\n    splitAdd(x2, a, x);\n\n    // Square X -> X2\n    splitMult(x, x, x2);\n\n    // Now compute ln(x)\n    y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n    y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n    for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n        splitMult(y, x2, a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n        splitAdd(y, LN_SPLIT_COEF[i], a2);\n        y[0] = a2[0];\n        y[1] = a2[1];\n    }\n\n    splitMult(y, x, a2);\n    y[0] = a2[0];\n    y[1] = a2[1];\n\n    return y;\n}"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll != null) {\n            return coll.remove(value);\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"key/value must not be null\");\n        }\n        final Collection<V> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = decorated().getCollection(key);\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"key must not be null\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"value must not be null\");\n        }\n        final Collection<V> coll = decorated().getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        return coll != null && coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<V> coll = getCollection(key);\n        if (coll != null) {\n            return coll.remove(value);\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"key/value must not be null\");\n        }\n        final Collection<V> coll = getCollection(key);\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<Object> coll = getCollection(key);\n        if (coll == null) {\n            return false;\n        }\n        return coll.remove(value);\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        final Collection<Object> coll = decorated().getCollection(key);\n        return coll.remove(value);\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setQuotedString();\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setQuotedString();\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setQuotedString();\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setType(Token.STRING);\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setQuotedString();\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setQuotedString();\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setQuotedString();\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setQuotedString();\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n  Node node = transform(n);\n  if (node.getType() == Token.NAME) {\n    node.setType(Token.STRING);\n  } else if (node.getType() == Token.STRING) {\n    node.setQuotedString();\n  }\n  return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n    } else if (node.getType() == Token.STRING) {\n        node.setQuotedString();\n    }\n    return node;\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n        int column = dataset.getColumnIndex(category);\n        int rowCount = dataset.getRowCount();\n        List result = new ArrayList();\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, column);\n        }\n        for (int i = 0; i < rowCount; i++) {\n            if (includedRows == null || ArrayUtils.contains(includedRows, i)) {\n                Number n = dataset.getValue(i, column);\n                if (n != null) {\n                    double v = n.doubleValue();\n                    if (asPercentages) {\n                        v = v / total;\n                    }\n                    result.add(new Double(v + base));\n                }\n                else {\n                    result.add(new Double(base));\n                }\n            }\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List values = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        Number n = dataset.getValue(includedRows[i], category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            values.add(new Double(v + base));\n        }\n        else {\n            values.add(new Double(base));\n        }\n    }\n    return values;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n        int column = dataset.getColumnIndex(category);\n        int rowCount = dataset.getRowCount();\n        List values = new ArrayList();\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, column);\n        }\n        for (int row = 0; row < rowCount; row++) {\n            if (includedRows == null || ArrayUtils.contains(includedRows, row)) {\n                Number number = dataset.getValue(row, column);\n                double value = number.doubleValue();\n                if (asPercentages) {\n                    value = value / total;\n                }\n                values.add(value + base);\n            }\n        }\n        return values;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n        int column = dataset.getColumnIndex(category);\n        int rowCount = dataset.getRowCount();\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, column);\n        }\n        List values = new ArrayList();\n        for (int i = 0; i < rowCount; i++) {\n            if (Arrays.binarySearch(includedRows, i) >= 0) {\n                Number n = dataset.getValue(i, column);\n                if (n != null) {\n                    double v = n.doubleValue();\n                    if (asPercentages) {\n                        v = v / total;\n                    }\n                    values.add(new Double(v + base));\n                }\n                else {\n                    values.add(new Double(base));\n                }\n            }\n            else {\n                values.add(new Double(base));\n            }\n        }\n        return values;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // perform some checks\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Null 'category' argument.\");\n    }\n    if (includedRows == null) {\n        throw new IllegalArgumentException(\"Null 'includedRows' argument.\");\n    }\n\n    // create the list...\n    List list = new ArrayList();\n    list.add(new Double(base));\n\n    // get the total value for the category...\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n\n    // add the values for each series...\n    int seriesCount = dataset.getRowCount();\n    for (int i = 0; i < seriesCount; i++) {\n        if (Arrays.binarySearch(includedRows, i) >= 0) {\n            Number n = dataset.getValue(i, category);\n            if (n != null) {\n                double v = n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n                list.add(new Double(v));\n            }\n            else {\n                list.add(new Double(0.0));\n            }\n        }\n    }\n\n    return list;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        // create a list to return\n        List values = new ArrayList();\n\n        // add the base value\n        values.add(new Double(base));\n\n        // get the total value for the category\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n\n        // add the values for each series\n        for (int i = 0; i < includedRows.length; i++) {\n            Number n = dataset.getValue(includedRows[i], category);\n            if (n != null) {\n                double v = n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n                values.add(new Double(v));\n            }\n            else {\n                values.add(new Double(0.0));\n            }\n        }\n\n        // return the list\n        return values;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        int column = dataset.getColumnIndex(category);\n        int rowCount = dataset.getRowCount();\n        List values = new ArrayList();\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, column);\n        }\n        for (int i = 0; i < rowCount; i++) {\n            if (includedRows != null && !Arrays.contains(includedRows, i)) {\n                continue;\n            }\n            Number n = dataset.getValue(i, column);\n            if (n != null) {\n                double v = n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n                values.add(new Double(base + v));\n            }\n            else {\n                values.add(new Double(base));\n            }\n        }\n        return values;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n        int column = dataset.getColumnIndex(category);\n        int rowCount = dataset.getRowCount();\n        List result = new ArrayList();\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, column);\n        }\n        for (int row = 0; row < rowCount; row++) {\n            if (includedRows == null || ArrayUtils.contains(includedRows, row)) {\n                Number n = dataset.getValue(row, column);\n                if (n != null) {\n                    double v = n.doubleValue();\n                    if (asPercentages) {\n                        v = v / total;\n                    }\n                    result.add(new Double(v + base));\n                }\n                else {\n                    result.add(new Double(base));\n                }\n            }\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    // perform argument checks\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Null 'category' argument.\");\n    }\n    if (includedRows == null) {\n        throw new IllegalArgumentException(\"Null 'includedRows' argument.\");\n    }\n\n    // create the list\n    List list = new ArrayList();\n\n    // get the total value for the category\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n\n    // add the base value\n    list.add(new Double(base));\n\n    // add the values for each series\n    int seriesCount = dataset.getRowCount();\n    for (int i = 0; i < seriesCount; i++) {\n        if (Arrays.binarySearch(includedRows, i) >= 0) {\n            Number n = dataset.getValue(i, category);\n            if (n != null) {\n                double v = n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n                list.add(new Double(v));\n            }\n            else {\n                list.add(new Double(0.0));\n            }\n        }\n    }\n\n    // return the list\n    return list;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    int column = dataset.getColumnIndex(category);\n    int rowCount = dataset.getRowCount();\n    List values = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, column);\n    }\n    for (int row = 0; row < rowCount; row++) {\n        if (includedRows != null && !Arrays.contains(includedRows, row)) {\n            continue;\n        }\n        Number n = dataset.getValue(row, column);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            values.add(new Double(v + base));\n        }\n        else {\n            values.add(new Double(base));\n        }\n    }\n    return values;\n}"
    ],
    [
      "private List<Element> childElementsList()  {\n    List<Element> elements = shadowChildrenRef == null ? null : shadowChildrenRef.get();\n    if (elements == null) {\n        elements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(elements);\n    }\n    return elements;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> elements = shadowChildrenRef != null ? shadowChildrenRef.get() : null;\n    if (elements == null) {\n        elements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(elements);\n    }\n    return elements;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> elements = shadowChildrenRef == null ? null : shadowChildrenRef.get();\n    if (elements == null) {\n        elements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(elements);\n    }\n    return elements;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> elements = shadowChildrenRef != null ? shadowChildrenRef.get() : null;\n    if (elements == null) {\n        elements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(elements);\n    }\n    return elements;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> elements = shadowChildrenRef == null ? null : shadowChildrenRef.get();\n    if (elements == null) {\n        elements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(elements);\n    }\n    return elements;\n}",
      "private List<Element> childElementsList()  {\n    List<Element> elements = shadowChildrenRef != null ? shadowChildrenRef.get() : null;\n    if (elements == null) {\n        elements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(elements);\n    }\n    return elements;\n}",
      "private List<Element> childElementsList()  {\n        List<Element> elements = shadowChildrenRef != null ? shadowChildrenRef.get() : null;\n        if (elements == null) {\n            elements = new ArrayList<>();\n            for (Node node : childNodes) {\n                if (node instanceof Element)\n                    elements.add((Element) node);\n            }\n            shadowChildrenRef = new WeakReference<>(elements);\n        }\n        return elements;\n    }",
      "private List<Element> childElementsList()  {\n        List<Element> elements = shadowChildrenRef != null ? shadowChildrenRef.get() : null;\n        if (elements == null) {\n            elements = new ArrayList<>();\n            for (Node node : childNodes) {\n                if (node instanceof Element)\n                    elements.add((Element) node);\n            }\n            shadowChildrenRef = new WeakReference<>(elements);\n        }\n        return elements;\n    }",
      "private List<Element> childElementsList()  {\n    List<Element> children = shadowChildrenRef != null ? shadowChildrenRef.get() : null;\n    if (children == null) {\n        children = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                children.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(children);\n    }\n    return children;\n}",
      "private List<Element> childElementsList()  {\n        List<Element> elements = shadowChildrenRef != null ? shadowChildrenRef.get() : null;\n        if (elements == null) {\n            elements = new ArrayList<>();\n            for (Node node : childNodes) {\n                if (node instanceof Element)\n                    elements.add((Element) node);\n            }\n            shadowChildrenRef = new WeakReference<>(elements);\n        }\n        return elements;\n    }"
    ],
    [
      "private int getHash(final Object key)  {\n    final int hash = key.hashCode();\n    final int size = buckets.length;\n\n    // Ensure that hash is non-negative and within bounds\n    return Math.abs(hash) % size;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash ^= (hash >>> 20) ^ (hash >>> 12);\n    hash ^= (hash >>> 7) ^ (hash >>> 4);\n    return hash % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash ^= (hash >>> 20) ^ (hash >>> 12);\n    hash ^= (hash >>> 7) ^ (hash >>> 4);\n    return hash & (buckets.length - 1);\n}",
      "private int getHash(final Object key)  {\n    final int hash = key.hashCode();\n    return Math.abs(hash % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    final int hash = key.hashCode();\n    final int size = buckets.length;\n    return Math.abs(hash % size);\n}",
      "private int getHash(final Object key)  {\n    final int hash = key.hashCode();\n    return Math.abs(hash % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return hash % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return hash % buckets.length;\n}"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r > c + k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (c > r + k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (c >= r + k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (c >= r + k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r > c + k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r > c) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (c >= r - k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (c >= r + k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r > c) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r > c + k) {\n                d[r][c] = m.getEntry(r, c);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n    switch(skew)\n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if(right.skew == Skew.RIGHT_HIGH)\n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            }\n            else if(right.skew == Skew.BALANCED)\n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            }\n            else\n            {\n                Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch(s)\n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew)\n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH)\n            {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            }\n            else if (right.skew == Skew.BALANCED)\n            {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            }\n            else\n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s)\n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch(skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if(right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if(right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch(s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch(skew)\n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if(right.skew == Skew.RIGHT_HIGH)\n            {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            }\n            else if(right.skew == Skew.BALANCED)\n            {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            }\n            else\n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch(s)\n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch(skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if(right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if(right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch(s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch(skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if(right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if(right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch(s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // look for the first small sub-diagonal element\n    for (int i = startIdx; i < matrixT.length; i++) {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            if (FastMath.abs(matrixT[i][j]) <= epsilon * norm) {\n                return i;\n            }\n        }\n    }\n\n    // no small sub-diagonal element found\n    return matrixT.length;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx > 0) {\n        final double x = matrixT[idx][idx];\n        final double y = matrixT[idx - 1][idx - 1];\n        final double z = matrixT[idx][idx - 1];\n        final double absX = FastMath.abs(x);\n        final double absY = FastMath.abs(y);\n        final double absZ = FastMath.abs(z);\n        final double absXPlusY = absX + absY;\n        final double absXPlusZ = absX + absZ;\n        final double absYPlusZ = absY + absZ;\n        final double absXMinusY = absX - absY;\n        final double absXMinusZ = absX - absZ;\n        final double absYMinusZ = absY - absZ;\n\n        // check for convergence\n        if (absXPlusY * absXMinusY <= norm * absX * absXMinusY * absXMinusY ||\n            absXPlusZ * absXMinusZ <= norm * absX * absXMinusZ * absXMinusZ ||\n            absYPlusZ * absYMinusZ <= norm * absY * absYMinusZ * absYMinusZ) {\n            break;\n        }\n\n        idx--;\n    }\n\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx > 0) {\n        final double z = matrixT[idx][idx];\n        final double r = shift.x - z;\n        double s = shift.y - z;\n        final double lhs = FastMath.abs(matrixT[idx][idx - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[idx - 1][idx - 1]) +\n                                                    FastMath.abs(z) +\n                                                    FastMath.abs(matrixT[idx + 1][idx + 1]));\n\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        idx--;\n    }\n\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int i = startIdx;\n    while (i < matrixT.length) \n    {\n        if (FastMath.abs(matrixT[i][i - 1]) <= epsilon * norm) \n        {\n            break;\n        }\n        i++;\n    }\n    return i;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // the sub-diagonal element is considered small if its absolute value is less than\n    // the product of the norm of the matrix and a small factor\n    final double epsilon = norm * 1e-15;\n\n    // Outer loop over eigenvalue index\n    for (int i = startIdx; i < matrixT.length; i++) {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            if (FastMath.abs(matrixT[i][j]) < epsilon) {\n                return i;\n            }\n        }\n    }\n\n    // no small sub-diagonal element found\n    return matrixT.length;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    // look for small sub-diagonal element\n    for (int i = startIdx; i < matrixT.length; i++) \n    {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) \n        {\n            if (FastMath.abs(matrixT[i][j]) <= epsilon * norm) \n            {\n                return i;\n            }\n        }\n    }\n\n    // no small sub-diagonal element found\n    return matrixT.length;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++) {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            if (FastMath.abs(matrixT[i][j]) <= epsilon * norm) {\n                return i;\n            }\n        }\n    }\n    return matrixT.length;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int i = startIdx;\n    while (i < matrixT.length) {\n        if (FastMath.abs(matrixT[i][i]) <= epsilon * norm) {\n            return i;\n        }\n        i++;\n    }\n    return i;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int il = startIdx;\n    while (il < matrixT.length - 1) {\n        if (FastMath.abs(matrixT[il][il]) + FastMath.abs(matrixT[il + 1][il]) == norm) {\n            break;\n        }\n        il++;\n    }\n    return il;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    for (int i = startIdx; i < matrixT.length; i++) {\n        // as matrix T is (quasi-)triangular, also take the sub-diagonal element into account\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            if (FastMath.abs(matrixT[i][j]) <= epsilon * norm) {\n                return i;\n            }\n        }\n    }\n    return matrixT.length - 1;\n}"
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = getNotLarger(reference); node != null; node = node.getNext()) {\n        // loop over all elements neither larger nor larger\n        // than the specified one\n        if (node.element == reference) {\n            return candidate;\n        } else if (node.element.compareTo(reference) < 0) {\n            // all the remaining elements are known to be smaller,\n            // the element is not in the tree\n            return null;\n        }\n        candidate = node;\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = getNotLarger(reference); node != null; node = node.getNext()) {\n        // loop over all elements neither smaller nor larger\n        // than the specified one\n        if (node.element == reference) {\n            return candidate;\n        } else if (node.element.compareTo(reference) < 0) {\n            // all the remaining elements are known to be smaller,\n            // the element is not in the tree\n            return null;\n        }\n        candidate = node;\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = getNotLarger(reference); node != null; node = node.getNext()) \n    {\n        // loop over all elements neither smaller nor larger\n        // than the specified one\n        if (node.element == reference) \n        {\n            return candidate;\n        } \n        else if (node.element.compareTo(reference) < 0) \n        {\n            // all the remaining elements are known to be smaller,\n            // the element is not in the tree\n            return null;\n        }\n        else \n        {\n            candidate = node;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = getNotLarger(reference); node != null; node = node.getNext()) \n    {\n        // loop over all elements neither smaller nor larger\n        // than the specified one\n        if (node.element == reference) \n        {\n            return candidate;\n        } \n        else if (node.element.compareTo(reference) > 0) \n        {\n            // all the remaining elements are known to be larger,\n            // the element is not in the tree\n            return null;\n        }\n        else \n        {\n            candidate = node;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = getNotLarger(reference); node != null; node = node.getNext()) {\n        // loop over all elements neither larger nor larger\n        // than the specified one\n        if (node.element == reference) {\n            return candidate;\n        } else if (node.element.compareTo(reference) < 0) {\n            // all the remaining elements are known to be smaller,\n            // the element is not in the tree\n            return null;\n        }\n        candidate = node;\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = getNotLarger(reference); node != null; node = node.getNext()) {\n        // loop over all elements neither larger nor smaller\n        // than the specified one\n        if (node.element == reference) {\n            return candidate;\n        } else if (node.element.compareTo(reference) < 0) {\n            // all the remaining elements are known to be smaller,\n            // the element is not in the tree\n            return null;\n        }\n        candidate = node;\n    }\n    return null;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int matchIndex = 0;\n        while ((matchIndex = indexOf(str, matchIndex)) >= 0) \n        {\n            deleteImpl(matchIndex, matchIndex + len, len);\n            matchIndex += len;\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int start = 0;\n        while (start < size) \n        {\n            int found = indexOf(str, start);\n            if (found < 0) \n            {\n                break;\n            }\n            deleteImpl(found, found + len, len);\n            start = found + len;\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int startIndex = 0;\n        while (startIndex < size) \n        {\n            int foundIndex = indexOf(str, startIndex);\n            if (foundIndex < 0) \n            {\n                break;\n            }\n            deleteImpl(foundIndex, foundIndex + len, len);\n            startIndex = foundIndex + len;\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo jsDocInfo = handleJsDoc(node, null);\n  if (jsDocInfo != null) \n  {\n    return newNode(Token.CAST, transform(node), jsDocInfo);\n  }\n  return transform(node);\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo jsDocInfo = handleJsDoc(node, null);\n  if (jsDocInfo != null) {\n    node = maybeInjectCastNode(node, jsDocInfo, node);\n    node.setJSDocInfo(jsDocInfo);\n  }\n  return node;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo jsDocInfo = handleJsDoc(node, null);\n  if (jsDocInfo != null) \n  {\n    Node irNode = newNode(Token.CAST, null);\n    irNode.setJSDocInfo(jsDocInfo);\n    setSourceInfo(irNode, node);\n    return irNode;\n  }\n  return null;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo jsDocInfo = handleJsDoc(node, null);\n  if (jsDocInfo != null) {\n    Node irNode = newNode(Token.NAME, node.getString());\n    irNode.setJSDocInfo(jsDocInfo);\n    setSourceInfo(irNode, node);\n    return irNode;\n  }\n  return transformNameAsString(node);\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo jsDocInfo = handleJsDoc(node, null);\n  if (jsDocInfo != null) {\n    node.setJSDocInfo(jsDocInfo);\n  }\n  return node;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = justTransform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  JSDocInfo jsDocInfo = handleJsDoc(node, null);\n  if (jsDocInfo != null) \n  {\n    return newNode(Token.CAST, transform(node), jsDocInfo);\n  }\n  return transform(node);\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n  Node irNode = transform(node);\n  JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n  if (jsDocInfo != null) {\n    irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    irNode.setJSDocInfo(jsDocInfo);\n  }\n  setSourceInfo(irNode, node);\n  return irNode;\n}"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>());\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>(list));\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>());\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>(list));\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>());\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>(list));\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>());\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>(list));\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    return new SetUniqueList<E>(list, new HashSet<E>(list));\n}"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.BRACKET);\n  if (match(JsDocToken.RB)) {\n    next();\n    return arrayType;\n  }\n\n  Node elementType = parseTypeExpression(next());\n  if (elementType == null) {\n    return null;\n  }\n\n  arrayType.addChildToBack(elementType);\n  while (match(JsDocToken.COMMA)) {\n    next();\n    skipEOLs();\n    elementType = parseTypeExpression(next());\n    if (elementType == null) {\n      return null;\n    }\n\n    arrayType.addChildToBack(elementType);\n  }\n\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n\n  next();\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  if (token != JsDocToken.LB) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n  }\n\n  next();\n\n  Node elementTypeList = parseElementTypeList(next());\n\n  if (elementTypeList == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n\n  skipEOLs();\n\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n\n  next();\n\n  return elementTypeList;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  // Parse the '['\n  skipEOLs();\n  if (!match(JsDocToken.LB)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n  }\n  next();\n\n  // Parse the ElementTypeList\n  Node elementTypeList = parseElementTypeList(next());\n  if (elementTypeList == null) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.element.type\");\n  }\n\n  // Parse the ']'\n  skipEOLs();\n  if (!match(JsDocToken.RB)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n  next();\n\n  return elementTypeList;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.BRACKET);\n  Node elementTypeList = parseElementTypeList(token);\n  if (elementTypeList == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n  }\n  arrayType.addChildToBack(elementTypeList);\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.BRACKET);\n  if (match(JsDocToken.ELLIPSIS)) {\n    next();\n    skipEOLs();\n    Node typeExpression = parseTypeExpression(next());\n    if (typeExpression == null) {\n      return null;\n    }\n    arrayType.addChildToBack(typeExpression);\n    skipEOLs();\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n  }\n  Node typeExpression = parseTypeExpression(token);\n  if (typeExpression == null) {\n    return null;\n  }\n  arrayType.addChildToBack(typeExpression);\n  skipEOLs();\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n  next();\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.BRACKET);\n  Node elementTypeList = parseElementTypeList(token);\n\n  if (elementTypeList == null) \n  {\n    return null;\n  }\n\n  arrayType.addChildToBack(elementTypeList);\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.BRACKET);\n  Node elementTypeList = parseElementTypeList(token);\n  if (elementTypeList == null)\n  {\n    return null;\n  }\n  arrayType.addChildToBack(elementTypeList);\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.BRACKET);\n    if (match(JsDocToken.RB)) \n    {\n        return arrayType;\n    }\n\n    Node elementType = parseTypeExpression(next());\n    if (elementType == null) \n    {\n        return null;\n    }\n\n    arrayType.addChildToBack(elementType);\n    while (match(JsDocToken.COMMA)) \n    {\n        next();\n        skipEOLs();\n        elementType = parseTypeExpression(next());\n        if (elementType == null) \n        {\n            return null;\n        }\n\n        arrayType.addChildToBack(elementType);\n    }\n\n    if (!match(JsDocToken.RB)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n\n    next();\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.BRACKET);\n  Node elementTypeList = parseElementTypeList(token);\n  if (elementTypeList == null) {\n    return null;\n  }\n  arrayType.addChildToBack(elementTypeList);\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Node arrayType = newNode(Token.BRACKET);\n  Node elementTypeList = parseElementTypeList(token);\n  if (elementTypeList == null) {\n    return null;\n  }\n  arrayType.addChildToBack(elementTypeList);\n  return arrayType;\n}"
    ],
    [
      "public Vector3D getAxis()  {\n    // normalization preprocessing\n    double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n    q0 *= inv;\n    q1 *= inv;\n    q2 *= inv;\n    q3 *= inv;\n\n    return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    return axis.normalize();\n}",
      "public Vector3D getAxis()  {\n    return axis.normalize();\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n    }\n\n    double halfAngle = -0.5 * FastMath.asin(norm);\n    double coeff = FastMath.sin(halfAngle) / norm;\n    return new Vector3D(q1 * coeff, q2 * coeff, q3 * coeff);\n}",
      "public Vector3D getAxis()  {\n    return axis.normalize();\n}",
      "public Vector3D getAxis()  {\n    return axis.normalize();\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    double inv = 1.0 / norm;\n    return new Vector3D(q1 * inv, q2 * inv, q3 * inv);\n}",
      "public Vector3D getAxis()  {\n    // normalization preprocessing\n    double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n    q0 *= inv;\n    q1 *= inv;\n    q2 *= inv;\n    q3 *= inv;\n\n    return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n    return axis.normalize();\n}",
      "public Vector3D getAxis()  {\n    return axis.normalize();\n}"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        final int pos = 0;\n        final int len = bytes.length;\n        for (int b; pos < len; ) {\n            b = bytes[pos++];\n            if (b == ESCAPE_CHAR) {\n                if (pos >= len) {\n                    throw new DecoderException(\"Invalid URL encoding: single '%' found at end of string\");\n                }\n                b = bytes[pos++];\n                if (b == ESCAPE_CHAR) {\n                    buffer.write(ESCAPE_CHAR);\n                } else if (b >= '0' && b <= '9') {\n                    b = (b - '0') << 4;\n                    if (pos >= len) {\n                        throw new DecoderException(\"Invalid URL encoding: hex digit expected after '%'\");\n                    }\n                    b += (bytes[pos++] - '0');\n                } else if (b >= 'a' && b <= 'f') {\n                    b = (b - 'a') << 4;\n                    if (pos >= len) {\n                        throw new DecoderException(\"Invalid URL encoding: hex digit expected after '%'\");\n                    }\n                    b += (bytes[pos++] - '0');\n                } else if (b >= 'A' && b <= 'F') {\n                    b = (b - 'A') << 4;\n                    if (pos >= len) {\n                        throw new DecoderException(\"Invalid URL encoding: hex digit expected after '%'\");\n                    }\n                    b += (bytes[pos++] - '0');\n                } else {\n                    throw new DecoderException(\"Invalid URL encoding: invalid hex digit after '%'\");\n                }\n            } else {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Character.digit((char) bytes[++i], RADIX);\n                final int l = Character.digit((char) bytes[++i], RADIX);\n                if (u == -1 || l == -1) {\n                    throw new DecoderException(\"Invalid URL encoding: \");\n                }\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: \", e);\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Character.digit((char) bytes[++i], RADIX);\n                final int l = Character.digit((char) bytes[++i], RADIX);\n                if (u == -1 || l == -1) {\n                    throw new DecoderException(\"Invalid URL encoding: single escape character without a following byte.\");\n                }\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: single escape character without a following byte.\");\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            final int hi = Character.digit((char) bytes[++i], RADIX);\n            final int lo = Character.digit((char) bytes[++i], RADIX);\n            if (hi == -1 || lo == -1) {\n                throw new DecoderException(\"Invalid URL encoding: \");\n            }\n            buffer.write((char) ((hi << 4) + lo));\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte b : bytes) {\n        if (b == ESCAPE_CHAR) {\n            final int u = decodeUnsignedByte(bytes, buffer.size());\n            buffer.write(u);\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte b : bytes) {\n        if (b == ESCAPE_CHAR) {\n            final byte[] d = decodeEscapeSequence(bytes, buffer.size());\n            if (d == null) {\n                throw new DecoderException(\"Invalid escape sequence\");\n            }\n            buffer.write(d);\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Character.digit((char) bytes[++i], RADIX);\n                final int l = Character.digit((char) bytes[++i], RADIX);\n                if (u == -1 || l == -1) {\n                    throw new DecoderException(\"Invalid URL encoding: single escape character without a following byte.\");\n                }\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: single escape character without a following byte.\");\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    b = Character.digit((char) bytes[++i], RADIX);\n                    b = (b << 4) + Character.digit((char) bytes[++i], RADIX);\n                } catch (final Exception e) {\n                    throw new DecoderException(e.getMessage(), e);\n                }\n            }\n            buffer.write(b);\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n        if (bytes == null) {\n            return null;\n        }\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for (int i = 0; i < bytes.length; i++) {\n            int b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                try {\n                    final int u = Character.digit((char) bytes[++i], RADIX);\n                    final int l = Character.digit((char) bytes[++i], RADIX);\n                    if (u == -1 || l == -1) {\n                        throw new DecoderException(\"Invalid URL encoding: \");\n                    }\n                    buffer.write((char) ((u << 4) + l));\n                } catch (final ArrayIndexOutOfBoundsException e) {\n                    throw new DecoderException(\"Invalid URL encoding: \", e);\n                }\n            } else {\n                buffer.write(b);\n            }\n        }\n        return buffer.toByteArray();\n    }",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        int b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                final int u = Character.digit((char) bytes[++i], RADIX);\n                final int l = Character.digit((char) bytes[++i], RADIX);\n                if (u == -1 || l == -1) {\n                    throw new DecoderException(\"Invalid URL encoding: single escape character without a following byte\");\n                }\n                buffer.write((char) ((u << 4) + l));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL encoding: single escape character without a following byte\");\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial cannot be null\");\n        }\n        if (partial.size() < 2) {\n            return true;\n        }\n        int size = partial.size();\n        DateTimeFieldType[] types = new DateTimeFieldType[size];\n        for (int i = 0; i < size; i++) {\n            types[i] = partial.getFieldType(i);\n        }\n        for (int i = 0; i < size - 1; i++) {\n            if (types[i].getDurationType() != types[i + 1].getDurationType()) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  throws IllegalArgumentException {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    // check each field is contiguous\n    int[] fields = partial.getValues();\n    for (int i = 0; i < fields.length - 1; i++) {\n        DateTimeField field = partial.getFieldType(i).getField(partial.getChronology());\n        DateTimeField nextField = partial.getFieldType(i + 1).getField(partial.getChronology());\n        if (!field.isContiguous() || !nextField.isContiguous()) {\n            return false;\n        }\n        if (!field.getRangeUnit().equals(nextField.getRangeUnit())) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    if (size == 0) {\n        return true;\n    }\n    int[] values = new int[size];\n    partial.getValues(values);\n    DateTimeFieldType[] types = new DateTimeFieldType[size];\n    for (int i = 0; i < size; i++) {\n        types[i] = partial.getFieldType(i);\n    }\n    DateTimeField[] fields = new DateTimeField[size];\n    for (int i = 0; i < size; i++) {\n        fields[i] = types[i].getField(values[i]);\n    }\n    for (int i = 0; i < size - 1; i++) {\n        if (fields[i].getRangeDurationField().getUnitMillis() !=\n            fields[i + 1].getDurationField().getUnitMillis()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    if (size == 0) {\n        return true;\n    }\n    DateTimeFieldType[] types = new DateTimeFieldType[size];\n    for (int i = 0; i < size; i++) {\n        types[i] = partial.getFieldType(i);\n    }\n    for (int i = 0; i < size - 1; i++) {\n        if (!types[i].equals(types[i + 1].getRangeUnit())) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size; i++) {\n        DateTimeFieldType fieldType = partial.getFieldType(i);\n        if (i + 1 < size) {\n            DateTimeFieldType nextFieldType = partial.getFieldType(i + 1);\n            if (fieldType.getDurationType() != nextFieldType.getDurationType()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial cannot be null\");\n        }\n        int size = partial.size();\n        if (size == 0) {\n            return true;\n        }\n        int[] values = new int[size];\n        partial.getValues(values);\n        DateTimeFieldType[] types = new DateTimeFieldType[size];\n        for (int i = 0; i < size; i++) {\n            types[i] = partial.getFieldType(i);\n        }\n        DateTimeField[] fields = new DateTimeField[size];\n        for (int i = 0; i < size; i++) {\n            fields[i] = types[i].getField(values[i]);\n        }\n        for (int i = 0; i < size - 1; i++) {\n            if (fields[i].getRangeDurationField().getUnitMillis() !=\n                    fields[i + 1].getDurationField().getUnitMillis()) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) {\n        DateTimeFieldType field = partial.getFieldType(i);\n        DateTimeFieldType nextField = partial.getFieldType(i + 1);\n        if (field.getDurationType() != nextField.getDurationType()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial cannot be null\");\n        }\n        if (partial.size() < 2) {\n            return true;\n        }\n        int size = partial.size();\n        for (int i = 0; i < size - 1; i++) {\n            if (partial.getFieldType(i).getDurationType() != partial.getFieldType(i + 1).getDurationType()) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    // check each field\n    for (int i = 0; i < partial.size(); i++) {\n        DateTimeFieldType type = partial.getFieldType(i);\n        DateTimeField field = partial.getField(i);\n        if (i > 0) {\n            DateTimeFieldType previousType = partial.getFieldType(i - 1);\n            DateTimeField previousField = partial.getField(i - 1);\n            if (previousType.getDurationType() != type.getDurationType()) {\n                return false;\n            }\n            if (previousField.getRangeDurationField().getUnitMillis() != type.getDurationType().getUnitMillis()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    // check each field\n    for (int i = 0; i < partial.size() - 1; i++) {\n        DateTimeFieldType fieldType = partial.getFieldType(i);\n        DateTimeField field = partial.getField(i);\n        DateTimeFieldType nextFieldType = partial.getFieldType(i + 1);\n        DateTimeField nextField = partial.getField(i + 1);\n        if (fieldType.equals(nextFieldType)) {\n            // same field type, check ranges\n            if (!fieldType.getDurationType().equals(nextFieldType.getDurationType())) {\n                // different duration types, not contiguous\n                return false;\n            }\n            if (!field.getRange().equals(nextField.getRange())) {\n                // different ranges, not contiguous\n                return false;\n            }\n        } else {\n            // different field types, not contiguous\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = new ArrayList<>();\n  for (Node child = params.getFirstChild(); child != null;\n       child = child.getNext()) {\n    if (child.isString()) {\n      result.add(child);\n    }\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = new ArrayList<>();\n  for (Node param = params.getFirstChild(); param != null;\n       param = param.getNext()) {\n    result.add(param.cloneTree());\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = Lists.newArrayList();\n  for (Node child = params.getFirstChild(); child != null;\n       child = child.getNext()) {\n    result.add(child);\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = new ArrayList<>();\n  for (Node param = params.getFirstChild(); param != null;\n       param = param.getNext()) {\n    result.add(new StringNode(Token.NAME, param.getString()));\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> stringNodes = new ArrayList<>();\n  for (Node param = params.getFirstChild(); param != null;\n       param = param.getNext()) {\n    stringNodes.add(new StringNode(Token.NAME, param.getString()));\n  }\n  return stringNodes;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = Lists.newArrayList();\n  for (Node param : params.children()) {\n    strings.add(new StringNode(Token.STRING, param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = Lists.newArrayList();\n  for (Node child = params.getFirstChild(); child != null;\n       child = child.getNext()) {\n    result.add(new StringNode(Token.NAME, child.getString()));\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = Lists.newArrayList();\n  for (Node param = params.getFirstChild(); param != null;\n       param = param.getNext()) {\n    strings.add(new StringNode(Token.NAME, param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = Lists.newArrayList();\n  for (Node param : params.children()) {\n    result.add(new StringNode(Token.STRING, param.getString()));\n  }\n  return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> result = new ArrayList<>();\n  for (Node param : params.children()) {\n    if (param.isString()) {\n      result.add(param);\n    }\n  }\n  return result;\n}"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    return appendFixedWidthPadRight(String.valueOf(obj), width, padChar);\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    return appendFixedWidthPadRight(obj == null ? getNullText() : obj.toString(), width, padChar);\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    return appendFixedWidthPadRight(String.valueOf(obj), width, padChar);\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    return appendFixedWidthPadRight(String.valueOf(obj), width, padChar);\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    return appendFixedWidthPadRight(String.valueOf(obj), width, padChar);\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    return appendFixedWidthPadRight(obj == null ? getNullText() : obj.toString(), width, padChar);\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    return appendFixedWidthPadRight(String.valueOf(obj), width, padChar);\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    return appendFixedWidthPadRight(String.valueOf(obj), width, padChar);\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    return appendFixedWidthPadRight(obj == null ? getNullText() : obj.toString(), width, padChar);\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    return appendFixedWidthPadRight(String.valueOf(obj), width, padChar);\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    str = WordUtils.uncapitalize(str, delimiters);\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    str = uncapitalize(str, delimiters);\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    str = uncapitalize(str, delimiters);\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    // used by capitalizeFully and uncapitalize\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    // used by capitalizeFully and uncapitalize\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    str = uncapitalize(str, delimiters);\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    str = capitalize(str, delimiters);\n    str = uncapitalize(str, delimiters);\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    // convert the first character to lowercase, unless it is already lowercase\n    if (str != null && str.length() > 0) \n    {\n        char firstLetter = str.charAt(0);\n        if (Character.isUpperCase(firstLetter)) \n        {\n            str = Character.toLowerCase(firstLetter) + str.substring(1);\n        }\n    }\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    // handle any delimiters at start\n    str = capitalize(str, delimiters);\n    // split the string into an array of words\n    String[] words = StringUtils.split(str);\n    // loop through words\n    for (int i = 0; i < words.length; i++) \n    {\n        // handle any delimiters before this word\n        str = capitalize(words[i], delimiters);\n        // capitalize this word\n        words[i] = capitalize(str, delimiters);\n    }\n    // handle any delimiters at end\n    str = capitalize(StringUtils.join(words), delimiters);\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    str = capitalize(str, delimiters);\n    str = uncapitalize(str, delimiters);\n    return str;\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n    String convertedId = cZoneIdConversion.get(id);\n    if (convertedId == null)\n    {\n        convertedId = id;\n        if (convertedId.startsWith(\"Etc/GMT\"))\n        {\n            convertedId = \"Etc/UTC\";\n        }\n        else if (convertedId.startsWith(\"Etc/GMT+\") || convertedId.startsWith(\"Etc/GMT-\"))\n        {\n            convertedId = \"Etc/UTC\" + convertedId.substring(convertedId.indexOf('+') + 1);\n        }\n        else if (convertedId.startsWith(\"Etc/GMT0\"))\n        {\n            convertedId = \"Etc/UTC\";\n        }\n        cZoneIdConversion.put(id, convertedId);\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion.containsKey(id)) \n    {\n        return cZoneIdConversion.get(id);\n    }\n    return null;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion.containsKey(id)) \n    {\n        return cZoneIdConversion.get(id);\n    }\n    return id;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    String convertedId = cZoneIdConversion.get(id);\n    if (convertedId == null) \n    {\n        convertedId = convertId(id);\n        if (convertedId == null) \n        {\n            return null;\n        }\n        cZoneIdConversion.put(id, convertedId);\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null)\n    {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"Africa/Abidjan\", \"Africa/Accra\");\n        cZoneIdConversion.put(\"Africa/Accra\", \"Africa/Abidjan\");\n        cZoneIdConversion.put(\"Africa/Bamako\", \"Africa/Abidjan\");\n        cZoneIdConversion.put(\"Africa/Abidjan\", \"Africa/Bamako\");\n        cZoneIdConversion.put(\"Africa/Nairobi\", \"Africa/Nairobi\");\n        cZoneIdConversion.put(\"Africa/Lagos\", \"Africa/Lagos\");\n        cZoneIdConversion.put(\"Africa/Cairo\", \"Africa/Cairo\");\n        cZoneIdConversion.put(\"Africa/Johannesburg\", \"Africa/Johannesburg\");\n        cZoneIdConversion.put(\"Africa/Tripoli\", \"Africa/Tripoli\");\n        cZoneIdConversion.put(\"Africa/Casablanca\", \"Africa/Casablanca\");\n        cZoneIdConversion.put(\"Africa/Monrovia\", \"Africa/Monrovia\");\n        cZoneIdConversion.put(\"Africa/El_Aaiun\", \"Africa/El_Aaiun\");\n        cZoneIdConversion.put(\"Africa/Kinshasa\", \"Africa/Kinshasa\");\n        cZoneIdConversion.put(\"Africa/Dakar\", \"Africa/Dakar\");\n        cZoneIdConversion.put(\"Africa/Ouagadougou\", \"Africa/Ouagadougou\");\n        cZoneIdConversion.put(\"Africa/Bangui\", \"Africa/Bangui\");\n        cZoneIdConversion.put(\"Africa/Brazzaville\", \"Africa/Brazzaville\");\n        cZoneIdConversion.put(\"Africa/Bujumbura\", \"Africa/Bujumbura\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"Africa/Abidjan\", \"Africa/Accra\");\n        cZoneIdConversion.put(\"Africa/Accra\", \"Africa/Abidjan\");\n        cZoneIdConversion.put(\"Africa/Bamako\", \"Africa/Sao_Tome\");\n        cZoneIdConversion.put(\"Africa/Sao_Tome\", \"Africa/Bamako\");\n        cZoneIdConversion.put(\"Africa/Bangui\", \"Africa/Lagos\");\n        cZoneIdConversion.put(\"Africa/Lagos\", \"Africa/Bangui\");\n        cZoneIdConversion.put(\"Africa/Brazzaville\", \"Africa/Douala\");\n        cZoneIdConversion.put(\"Africa/Douala\", \"Africa/Brazzaville\");\n        cZoneIdConversion.put(\"Africa/Cairo\", \"Africa/Gaborone\");\n        cZoneIdConversion.put(\"Africa/Gaborone\", \"Africa/Cairo\");\n        cZoneIdConversion.put(\"Africa/Harare\", \"Africa/Johannesburg\");\n        cZoneIdConversion.put(\"Africa/Johannesburg\", \"Africa/Harare\");\n        cZoneIdConversion.put(\"Africa/Juba\", \"Africa/Mogadishu\");\n        cZoneIdConversion.put(\"Africa/Mogadishu\", \"Africa/Juba\");\n        cZoneIdConversion.put(\"Africa/Khartoum\", \"Africa/Nairobi\");\n        cZoneIdConversion.put(\"Africa/Nairobi\", \"Africa/Khartoum\");\n        cZoneIdConversion.put(\"Africa/Tripoli\", \"Africa/Tunis\");\n        cZoneIdConversion.put(\"Africa/Tunis\", \"Africa/Tripoli\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    String convertedId = cZoneIdConversion.get(id);\n    if (convertedId == null) \n    {\n        convertedId = convertOldId(id);\n        if (convertedId == null) \n        {\n            convertedId = id;\n        }\n        cZoneIdConversion.put(id, convertedId);\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    String convertedId = cZoneIdConversion.get(id);\n    if (convertedId == null) \n    {\n        convertedId = id;\n        if (convertedId.startsWith(\"UTC+\") || convertedId.startsWith(\"UTC-\")) \n        {\n            int offset = parseOffset(convertedId);\n            convertedId = \"UTC\" + printOffset(offset);\n        }\n        cZoneIdConversion.put(id, convertedId);\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    String convertedId = cZoneIdConversion.get(id);\n    if (convertedId == null) \n    {\n        convertedId = convertZoneId(id);\n        cZoneIdConversion.put(id, convertedId);\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    String convertedId = cZoneIdConversion.get(id);\n    if (convertedId == null) \n    {\n        int offset = parseOffset(id);\n        if (offset == Integer.MIN_VALUE) \n        {\n            return null;\n        }\n        convertedId = fixedOffsetZone(id, offset).getID();\n    }\n    return convertedId;\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix weightMatrix = getWeight();\n    if (weightMatrix.getRowDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n    }\n    if (weightMatrix.getColumnDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n    }\n\n    // Diagonal of the weight matrix.\n    final double[] residualsWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n\n    final double[] currentPoint = getStart();\n    final int nC = currentPoint.length;\n\n    // iterate until convergence is reached\n    PointVectorValuePair current = null;\n    for (boolean converged = false; !converged;) {\n        incrementIterationCount();\n\n        // evaluate the objective function and its jacobian\n        PointVectorValuePair previous = current;\n        // Value of the objective function at \"currentPoint\".\n        final double[] currentObjective = computeObjectiveValue(currentPoint);\n        final double[] currentResiduals = computeResiduals(currentObjective);\n        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n        current = new PointVectorValuePair(currentPoint, currentObjective);\n\n        // build the linear problem\n        final double[]   b = new double[nC];\n        final double[][] a = new double[nC][nC];\n        for (int i = 0; i < nR; ++i) {\n\n            final double[] grad   = weightedJacobian.getRow(i);\n            final double weight   = residualsWeights[i];\n            final double residual = currentResiduals[i];\n\n            // compute the normal equation\n            final double wr = weight * residual;\n            for (int j = 0; j < nC; ++j) {\n                b[j] += wr * grad[j];\n            }\n}\n}\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix weightMatrix = getWeight();\n    if (weightMatrix.getRowDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n    }\n    if (weightMatrix.getColumnDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n    }\n\n    // Diagonal of the weight matrix.\n    final double[] residualsWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n\n    final double[] currentPoint = getStart();\n    final int nC = currentPoint.length;\n\n    // iterate until convergence is reached\n    PointVectorValuePair current = null;\n    for (boolean converged = false; !converged;) {\n        incrementIterationCount();\n\n        // evaluate the objective function and its jacobian\n        PointVectorValuePair previous = current;\n        // Value of the objective function at \"currentPoint\".\n        final double[] currentObjective = computeObjectiveValue(currentPoint);\n        final double[] currentResiduals = computeResiduals(currentObjective);\n        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n        current = new PointVectorValuePair(currentPoint, currentObjective);\n\n        // build the linear problem\n        final double[]   b = new double[nC];\n        final double[][] a = new double[nC][nC];\n        for (int i = 0; i < nR; ++i) {\n\n            final double[] grad   = weightedJacobian.getRow(i);\n            final double weight   = residualsWeights[i];\n            final double residual = currentResiduals[i];\n\n            // compute the normal equation\n            final double wr = weight * residual;\n            for (int j = 0; j < nC; ++j) {\n                b[j] += wr * grad[j];\n            }\n\n}\n}\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix weightMatrix = getWeight();\n    if (weightMatrix.getRowDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n    }\n    if (weightMatrix.getColumnDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n    }\n\n    // Diagonal of the weight matrix.\n    final double[] residualsWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n\n    final double[] currentPoint = getStart();\n    final int nC = currentPoint.length;\n\n    // iterate until convergence is reached\n    PointVectorValuePair current = null;\n    for (boolean converged = false; !converged;) {\n        incrementIterationCount();\n\n        // evaluate the objective function and its jacobian\n        PointVectorValuePair previous = current;\n        // Value of the objective function at \"currentPoint\".\n        final double[] currentObjective = computeObjectiveValue(currentPoint);\n        final double[] currentResiduals = computeResiduals(currentObjective);\n        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n        current = new PointVectorValuePair(currentPoint, currentObjective);\n\n        // build the linear problem\n        final double[]   b = new double[nC];\n        final double[][] a = new double[nC][nC];\n        for (int i = 0; i < nR; ++i) {\n\n            final double[] grad   = weightedJacobian.getRow(i);\n            final double weight   = residualsWeights[i];\n            final double residual = currentResiduals[i];\n\n            // compute the normal equation\n            final double wr = weight * residual;\n            for (int j = 0; j < nC; ++j) {\n                b[j] += wr * grad[j];\n            }\n\n}\n}\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix weightMatrix = getWeight();\n    if (weightMatrix.getRowDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n    }\n    if (weightMatrix.getColumnDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n    }\n\n    // Diagonal of the weight matrix.\n    final double[] residualsWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n\n    final double[] currentPoint = getStart();\n    final int nC = currentPoint.length;\n\n    // iterate until convergence is reached\n    PointVectorValuePair current = null;\n    for (boolean converged = false; !converged;) {\n        incrementIterationCount();\n\n        // evaluate the objective function and its jacobian\n        PointVectorValuePair previous = current;\n        // Value of the objective function at \"currentPoint\".\n        final double[] currentObjective = computeObjectiveValue(currentPoint);\n        final double[] currentResiduals = computeResiduals(currentObjective);\n        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n        current = new PointVectorValuePair(currentPoint, currentObjective);\n\n        // build the linear problem\n        final double[]   b = new double[nC];\n        final double[][] a = new double[nC][nC];\n        for (int i = 0; i < nR; ++i) {\n\n            final double[] grad   = weightedJacobian.getRow(i);\n            final double weight   = residualsWeights[i];\n            final double residual = currentResiduals[i];\n\n            // compute the normal equation\n            final double wr = weight * residual;\n            for (int j = 0; j < nC; ++j) {\n                b[j] += wr * grad[j];\n            }\n\n}\n}\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    final RealMatrix weightMatrix = getWeight();\n    if (weightMatrix.getRowDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n    }\n    if (weightMatrix.getColumnDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n    }\n\n    // Diagonal of the weight matrix.\n    final double[] residualsWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n\n    final double[] currentPoint = getStart();\n    final int nC = currentPoint.length;\n\n    // iterate until convergence is reached\n    PointVectorValuePair current = null;\n    for (boolean converged = false; !converged;) {\n        incrementIterationCount();\n\n        // evaluate the objective function and its jacobian\n        PointVectorValuePair previous = current;\n        // Value of the objective function at \"currentPoint\".\n        final double[] currentObjective = computeObjectiveValue(currentPoint);\n        final double[] currentResiduals = computeResiduals(currentObjective);\n        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n        current = new PointVectorValuePair(currentPoint, currentObjective);\n\n        // build the linear problem\n        final double[]   b = new double[nC];\n        final double[][] a = new double[nC][nC];\n        for (int i = 0; i < nR; ++i) {\n\n            final double[] grad   = weightedJacobian.getRow(i);\n            final double weight   = residualsWeights[i];\n            final double residual = currentResiduals[i];\n\n            // compute the normal equation\n            final double wr = weight * residual;\n            for (int j = 0; j < nC; ++j) {\n                b[j] += wr * grad[j];\n            }\n}\n}\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix weightedJacobian = computeJacobian(params);\n    weightedResidualJacobian = weightMatrixSqrt.multiply(weightedJacobian).getData();\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix weightMatrix = getWeight();\n    if (weightMatrix.getRowDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n    }\n    if (weightMatrix.getColumnDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n    }\n\n    // Diagonal of the weight matrix.\n    final double[] residualsWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n\n    final double[] currentPoint = getStart();\n    final int nC = currentPoint.length;\n\n    // iterate until convergence is reached\n    PointVectorValuePair current = null;\n    for (boolean converged = false; !converged;) {\n        incrementIterationCount();\n\n        // evaluate the objective function and its jacobian\n        PointVectorValuePair previous = current;\n        // Value of the objective function at \"currentPoint\".\n        final double[] currentObjective = computeObjectiveValue(currentPoint);\n        final double[] currentResiduals = computeResiduals(currentObjective);\n        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n        current = new PointVectorValuePair(currentPoint, currentObjective);\n\n        // build the linear problem\n        final double[]   b = new double[nC];\n        final double[][] a = new double[nC][nC];\n        for (int i = 0; i < nR; ++i) {\n\n            final double[] grad   = weightedJacobian.getRow(i);\n            final double weight   = residualsWeights[i];\n            final double residual = currentResiduals[i];\n\n            // compute the normal equation\n            final double wr = weight * residual;\n            for (int j = 0; j < nC; ++j) {\n                b[j] += wr * grad[j];\n            }\n\n}\n}\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    final RealMatrix weightMatrix = getWeight();\n    if (weightMatrix.getRowDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n    }\n    if (weightMatrix.getColumnDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n    }\n\n    // Diagonal of the weight matrix.\n    final double[] residualsWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n\n    final double[] currentPoint = getStart();\n    final int nC = currentPoint.length;\n\n    // iterate until convergence is reached\n    PointVectorValuePair current = null;\n    for (boolean converged = false; !converged;) {\n        incrementIterationCount();\n\n        // evaluate the objective function and its jacobian\n        PointVectorValuePair previous = current;\n        // Value of the objective function at \"currentPoint\".\n        final double[] currentObjective = computeObjectiveValue(currentPoint);\n        final double[] currentResiduals = computeResiduals(currentObjective);\n        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n        current = new PointVectorValuePair(currentPoint, currentObjective);\n\n        // build the linear problem\n        final double[]   b = new double[nC];\n        final double[][] a = new double[nC][nC];\n        for (int i = 0; i < nR; ++i) {\n\n            final double[] grad   = weightedJacobian.getRow(i);\n            final double weight   = residualsWeights[i];\n            final double residual = currentResiduals[i];\n\n            // compute the normal equation\n            final double wr = weight * residual;\n            for (int j = 0; j < nC; ++j) {\n                b[j] += wr * grad[j];\n            }\n}\n}\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Diagonal of the weight matrix.\n    final RealMatrix weightMatrix = getWeight();\n    if (weightMatrix.getRowDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n    }\n    if (weightMatrix.getColumnDimension() != nR) {\n        throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n    }\n\n    // Diagonal of the weight matrix.\n    final double[] residualsWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n\n    final double[] currentPoint = getStart();\n    final int nC = currentPoint.length;\n\n    // iterate until convergence is reached\n    PointVectorValuePair current = null;\n    for (boolean converged = false; !converged;) {\n        incrementIterationCount();\n\n        // evaluate the objective function and its jacobian\n        PointVectorValuePair previous = current;\n        // Value of the objective function at \"currentPoint\".\n        final double[] currentObjective = computeObjectiveValue(currentPoint);\n        final double[] currentResiduals = computeResiduals(currentObjective);\n        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n        current = new PointVectorValuePair(currentPoint, currentObjective);\n\n        // build the linear problem\n        final double[]   b = new double[nC];\n        final double[][] a = new double[nC][nC];\n        for (int i = 0; i < nR; ++i) {\n\n            final double[] grad   = weightedJacobian.getRow(i);\n            final double weight   = residualsWeights[i];\n            final double residual = currentResiduals[i];\n\n            // compute the normal equation\n            final double wr = weight * residual;\n            for (int j = 0; j < nC; ++j) {\n}\n}\n}\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final RealMatrix weightMatrix = getWeight();\n    if (weightMatrix.getRowDimension() != nR) \n    {\n        throw new DimensionMismatchException(weightMatrix.getRowDimension(), nR);\n    }\n    if (weightMatrix.getColumnDimension() != nR) \n    {\n        throw new DimensionMismatchException(weightMatrix.getColumnDimension(), nR);\n    }\n\n    // Diagonal of the weight matrix.\n    final double[] residualsWeights = new double[nR];\n    for (int i = 0; i < nR; i++) \n    {\n        residualsWeights[i] = weightMatrix.getEntry(i, i);\n    }\n\n    final double[] currentPoint = getStart();\n    final int nC = currentPoint.length;\n\n    // iterate until convergence is reached\n    PointVectorValuePair current = null;\n    for (boolean converged = false; !converged;) \n    {\n        incrementIterationCount();\n\n        // evaluate the objective function and its jacobian\n        PointVectorValuePair previous = current;\n        // Value of the objective function at \"currentPoint\".\n        final double[] currentObjective = computeObjectiveValue(currentPoint);\n        final double[] currentResiduals = computeResiduals(currentObjective);\n        final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n        current = new PointVectorValuePair(currentPoint, currentObjective);\n\n        // build the linear problem\n        final double[]   b = new double[nC];\n        final double[][] a = new double[nC][nC];\n        for (int i = 0; i < nR; ++i) \n        {\n\n            final double[] grad   = weightedJacobian.getRow(i);\n            final double weight   = residualsWeights[i];\n            final double residual = currentResiduals[i];\n\n            // compute the normal equation\n            final double wr = weight * residual;\n            for (int j = 0; j < nC; ++j) \n            {\n}\n}\n}\n}"
    ],
    [
      "private int least()  {\n    final Comparator<? super E> comp = comparator;\n    if (comp == null) {\n        throw new NullPointerException(\"No comparator specified\");\n    }\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            for (int j = i + 1; j < values.size(); j++) {\n                if (valueSet.get(j)) {\n                    final int cmp = comp.compare(values.get(i), values.get(j));\n                    if (cmp > 0) {\n                        clear(i);\n                        i = j;\n                    } else if (cmp < 0) {\n                        clear(j);\n                    }\n                }\n            }\n        }\n    }\n    int least = 0;\n    for (int i = 1; i < values.size(); i++) {\n        if (valueSet.get(i) && (valueSet.get(least) == false || comp.compare(values.get(i), values.get(least)) < 0)) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    for (int i = 0; i < values.size(); i++) {\n        if (set(i)) {\n            return i;\n        }\n    }\n    throw new NoSuchElementException(\"No elements in iterators\");\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int i = 0;\n    while (i < values.size() && values.get(i) == null) {\n        i++;\n    }\n    if (i == values.size()) {\n        return i;\n    }\n    int least = i;\n    for (i++; i < values.size(); i++) {\n        if (values.get(i) != null && comparator.compare(values.get(i), values.get(least)) < 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must be set.\");\n    }\n    for (int i = 0; i < values.size(); i++) {\n        if (set(i)) {\n            return i;\n        }\n    }\n    return -1;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator is null\");\n    }\n    for (int i = 0; i < values.size(); i++) {\n        if (set(i)) {\n            return i;\n        }\n    }\n    throw new NullPointerException(\"No values are set\");\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must be set.\");\n    }\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            for (int j = i + 1; j < values.size(); j++) {\n                if (valueSet.get(j)) {\n                    if (comparator.compare(values.get(i), values.get(j)) > 0) {\n                        return j;\n                    }\n                }\n            }\n            return i;\n        }\n    }\n    return -1;\n}",
      "private int least()  {\n    checkNotStarted();\n    final int size = iterators.size();\n    for (int i = 0; i < size; i++) {\n        if (set(i)) {\n            return i;\n        }\n    }\n    throw new NoSuchElementException(\"No elements in any of the iterators\");\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must be set.\");\n    }\n    for (int i = 0; i < iterators.size(); i++) {\n        if (set(i)) {\n            return i;\n        }\n    }\n    throw new NoSuchElementException(\"No elements to iterate over.\");\n}",
      "private int least()  {\n    final Comparator<? super E> comp = comparator;\n    if (comp == null) {\n        throw new NullPointerException(\"No comparator specified\");\n    }\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i) && (i == 0 || comp.compare(values.get(i), values.get(least)) < 0)) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int i = 0;\n    while (i < iterators.size() && !anyValueSet(valueSet)) {\n        set(i);\n        i++;\n    }\n    if (i == iterators.size()) {\n        return -1;\n    }\n    int leastIndex = i;\n    while (i < iterators.size()) {\n        if (anyValueSet(valueSet) && comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n            leastIndex = i;\n        }\n        i++;\n    }\n    return leastIndex;\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    if (step.getAxis() == Compiler.AXIS_CHILD) {\n        childPointer = new ChildPropertyPointer(parentPointer);\n    } else if (step.getAxis() == Compiler.AXIS_ATTRIBUTE) {\n        childPointer = new AttributePropertyPointer(parentPointer);\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Create the child pointer\n    NodePointer childPointer = null;\n    if (step.getAxis() == Compiler.AXIS_CHILD) {\n        // Child node test\n        childPointer = parentPointer.createChildPointer(\n            ((NodeNameTest) step.getNodeTest()).getNodeName());\n    } else if (step.getAxis() == Compiler.AXIS_ATTRIBUTE) {\n        // Attribute node test\n        childPointer = parentPointer.createAttributePointer(\n            ((NodeNameTest) step.getNodeTest()).getNodeName());\n    } else {\n        // Self::node() test\n        childPointer = parentPointer;\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    return parentPointer.createChildPointer(name);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    PropertyPointer propertyPointer = parentPointer.getPropertyPointer();\n    if (propertyPointer.isValidProperty(name)) {\n        return propertyPointer.getPropertyPointer(name);\n    }\n    return new NullPropertyPointer(parentPointer);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    int axis = step.getAxis();\n    if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) {\n        QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n        childPointer = new PropertyPointer(parentPointer, name);\n        childPointer.setAttribute(axis == Compiler.AXIS_ATTRIBUTE);\n    } else if (axis == Compiler.AXIS_SELF) {\n        childPointer = parentPointer;\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    if (step.getAxis() == Compiler.AXIS_CHILD) {\n        childPointer = new ChildPropertyPointer(parentPointer);\n    } else if (step.getAxis() == Compiler.AXIS_ATTRIBUTE) {\n        childPointer = new AttributePropertyPointer(parentPointer);\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    if (step.getAxis() == Compiler.AXIS_CHILD) {\n        childPointer = parentPointer.createChildPointer(\n                step.getNodeTest(), step.getIndex());\n    } else if (step.getAxis() == Compiler.AXIS_ATTRIBUTE) {\n        childPointer = parentPointer.createAttributePointer(\n                step.getNodeTest(), step.getIndex());\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    int axis = step.getAxis();\n    NodeTest nodeTest = step.getNodeTest();\n    if (axis == Compiler.AXIS_CHILD || axis == Compiler.AXIS_ATTRIBUTE) {\n        QName name = ((NodeNameTest) nodeTest).getNodeName();\n        childPointer = new NullPropertyPointer(parentPointer);\n        ((NullPropertyPointer) childPointer).setPropertyName(name.toString());\n        ((NullPropertyPointer) childPointer).setAttribute(\n                axis == Compiler.AXIS_ATTRIBUTE);\n    } else if (axis == Compiler.AXIS_SELF) {\n        childPointer = parentPointer;\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    // Get the name of the step\n    QName name = step.getNodeTest().getNodeName();\n\n    // Get the value of the step\n    Object value = parentPointer.getValue();\n\n    // If the value is a collection, get the element at the specified index\n    if (value instanceof Collection) {\n        Collection collection = (Collection) value;\n        int index = indexFromPredicate(step);\n        if (index < 0 || index >= collection.size()) {\n            return null;\n        }\n        value = collection.get(index);\n    }\n\n    // If the value is a map, get the element at the specified key\n    if (value instanceof Map) {\n        Map map = (Map) value;\n        String key = keyFromPredicate(step);\n        if (key == null) {\n            return null;\n        }\n        value = map.get(key);\n    }\n\n    // If the value is a bean, get the property at the specified name\n    if (value instanceof Bean) {\n        Bean bean = (Bean) value;\n        String propertyName = name.toString();\n        if (!bean.hasProperty(propertyName)) {\n            return null;\n        }\n        value = bean.getPropertyValue(propertyName);\n    }\n\n    // Create the child pointer\n    return new PropertyOwnerPointer(parentPointer, value, name);\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodePointer childPointer = null;\n    int axis = step.getAxis();\n    if (axis == Compiler.AXIS_CHILD) {\n        childPointer = new ChildPropertyPointer(parentPointer);\n    } else if (axis == Compiler.AXIS_ATTRIBUTE) {\n        childPointer = new AttributePropertyPointer(parentPointer);\n    } else if (axis == Compiler.AXIS_SELF) {\n        childPointer = parentPointer;\n    }\n    return childPointer;\n}"
    ],
    [
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final Locale locale= this.locale;\n    Strategy strategy= null;\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy oldStrategy= cache.putIfAbsent(locale, strategy);\n        if(oldStrategy!=null) {\n            strategy= oldStrategy;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final Locale locale= getLocale();\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy existing= cache.putIfAbsent(locale, strategy);\n        if(existing!=null) {\n            strategy= existing;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final Locale locale= this.locale;\n    Strategy strategy= null;\n    if(locale==null) {\n        strategy= getCache(field).get(null);\n    }\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy oldStrategy= getCache(field).putIfAbsent(locale, strategy);\n        if(oldStrategy!=null) {\n            strategy= oldStrategy;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final Locale locale= getLocale();\n    Strategy strategy= null;\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        final Strategy existing= cache.putIfAbsent(locale, strategy);\n        if(existing!=null) {\n            strategy= existing;\n        }\n    }\n    return strategy;\n}"
    ],
    [
      "private boolean setNextObject()  {\n    if (nextObjectSet) {\n        return true;\n    }\n    while (iterator.hasNext()) {\n        final E next = iterator.next();\n        if (predicate.evaluate(next)) {\n            nextObject = next;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n        if (nextObjectSet) {\n            return true;\n        }\n        if (iterator == null) {\n            nextObject = null;\n            nextObjectSet = true;\n            return false;\n        }\n        while (iterator.hasNext()) {\n            final E next = iterator.next();\n            if (predicate == null || predicate.evaluate(next)) {\n                nextObject = next;\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        nextObject = null;\n        nextObjectSet = true;\n        return false;\n    }",
      "private boolean setNextObject()  {\n        boolean rval = false;\n        if (iterator.hasNext()) {\n            nextObject = iterator.next();\n            if (predicate.evaluate(nextObject)) {\n                rval = true;\n            } else {\n                nextObject = null;\n            }\n        }\n        nextObjectSet = rval;\n        return rval;\n    }",
      "private boolean setNextObject()  {\n        if (nextObjectSet) {\n            return true;\n        }\n        if (iterator == null) {\n            nextObject = null;\n            nextObjectSet = true;\n            return false;\n        }\n        while (iterator.hasNext()) {\n            nextObject = iterator.next();\n            if (predicate == null || predicate.evaluate(nextObject)) {\n                nextObjectSet = true;\n                return true;\n            }\n        }\n        nextObject = null;\n        nextObjectSet = true;\n        return false;\n    }",
      "private boolean setNextObject()  {\n        if (iterator.hasNext()) {\n            nextObject = iterator.next();\n            nextObjectSet = true;\n        } else {\n            nextObjectSet = false;\n        }\n        return nextObjectSet;\n    }",
      "private boolean setNextObject()  {\n        if (nextObjectSet) {\n            return true;\n        }\n        if (iterator.hasNext()) {\n            nextObject = iterator.next();\n            nextObjectSet = true;\n            return true;\n        }\n        return false;\n    }",
      "private boolean setNextObject()  {\n        boolean returnValue = false;\n        if (iterator.hasNext())  {\n            nextObject = iterator.next();\n            returnValue = true;\n        }\n        return returnValue;\n    }",
      "private boolean setNextObject()  {\n        if (nextObjectSet) {\n            return true;\n        }\n        if (iterator.hasNext()) {\n            nextObject = iterator.next();\n            nextObjectSet = true;\n            return true;\n        }\n        return false;\n    }",
      "private boolean setNextObject()  {\n        if (iterator.hasNext()) {\n            nextObject = iterator.next();\n            nextObjectSet = true;\n            return true;\n        } else {\n            nextObjectSet = false;\n            return false;\n        }\n    }",
      "private boolean setNextObject()  {\n    if (iterator.hasNext()) {\n        nextObject = iterator.next();\n        nextObjectSet = true;\n        return true;\n    } else {\n        nextObject = null;\n        nextObjectSet = false;\n        return false;\n    }\n}"
    ],
    [
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            repaired[i] = lB[i];\n        } \n        else if (x[i] > uB[i]) \n        {\n            repaired[i] = uB[i];\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lowerBound[i]) \n        {\n            repaired[i] = lowerBound[i];\n        }\n        else if (x[i] > upperBound[i]) \n        {\n            repaired[i] = upperBound[i];\n        }\n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) \n        {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++)\n    {\n        if (x[i] < lowerBound[i])\n        {\n            repaired[i] = lowerBound[i];\n        }\n        else if (x[i] > upperBound[i])\n        {\n            repaired[i] = upperBound[i];\n        }\n        else\n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            repaired[i] = lB[i];\n        } \n        else if (x[i] > uB[i]) \n        {\n            repaired[i] = uB[i];\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            x[i] = lB[i];\n        }\n        if (x[i] > uB[i]) \n        {\n            x[i] = uB[i];\n        }\n    }\n    return x;\n}"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    // transform the matrix to Schur form\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    final double[][] matrixT = transformer.getT().getData();\n    final double[][] matrixP = transformer.getP().getData();\n\n    final int n = matrixT.length;\n\n    // compute matrix norm\n    double norm = 0.0;\n    for (int i = 0; i < n; i++) {\n        for (int j = FastMath.max(i - 1, 0); j < n; j++) {\n            norm = norm + FastMath.abs(matrixT[i][j]);\n        }\n    }\n\n    // we can not handle a matrix with zero norm\n    if (Precision.equals(norm, 0.0, EPSILON)) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    // Backsubstitute to find vectors of upper triangular form\n\n    double r = 0.0;\n    double s = 0.0;\n    double z = 0.0;\n\n    for (int idx = n - 1; idx >= 0; idx--) {\n        double p = realEigenvalues[idx];\n        double q = imagEigenvalues[idx];\n\n        // If p is nearly zero, the matrix is singular.\n        if (FastMath.abs(p) <= EPSILON * norm) {\n            p = 0.0;\n        }\n\n        // Real eigenvalue\n        if (q == 0) {\n            int l = idx;\n            while (l > 0 && FastMath.abs(matrixT[l - 1][l - 1]) <= EPSILON * norm) {\n                l--;\n            }\n            for (int i = l; i <= idx - 1; i++) {\n                r = 0.0;\n                for (int j = i; j <= idx - 1; j++) {\n                    r += matrixT[i][j] * matrixT[j][idx];\n                }\n}\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to Schur form\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    final double[][] matrixT = transformer.getT().getData();\n    final double[][] matrixP = transformer.getP().getData();\n\n    // compute matrix norm\n    double norm = 0.0;\n    for (int i = 0; i < matrixT.length; i++) {\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            norm = norm + FastMath.abs(matrixT[i][j]);\n        }\n    }\n\n    // we can not handle a matrix with zero norm\n    if (Precision.equals(norm, 0.0, EPSILON)) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    // Backsubstitute to find vectors of upper triangular form\n\n    double r = 0.0;\n    double s = 0.0;\n    double z = 0.0;\n\n    for (int idx = matrixT.length - 1; idx >= 0; idx--) {\n        double p = realEigenvalues[idx];\n        double q = imagEigenvalues[idx];\n\n        // If diagonal is non-zero, use diagonal element for argument of\n        // division\n        if (FastMath.abs(q) > EPSILON) {\n            r = (matrixT[idx][idx] - p) / q;\n        } else {\n            // matrixT[idx][idx] == p\n            r = matrixT[idx][idx] - p;\n        }\n\n        s = FastMath.hypot(r, q);\n\n        if (q < 0) {\n            s = -s;\n        }\n        if (s == 0) {\n            s = EPSILON;\n        }\n        r = r / s;\n        t = q / s;\n        matrixT[idx][idx] = p + s;\n\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer schur = new SchurTransformer(matrix);\n    final double[][] matrixT = schur.getT().getData();\n    final double[][] matrixP = schur.getP().getData();\n\n    final int n = matrixT.length;\n    final double[] realEigenvalues = new double[n];\n    final double[] imagEigenvalues = new double[n];\n\n    for (int i = 0; i < n; i++) {\n        final double[] hVec = new double[n];\n        final int idx = i;\n        final double norm = schur.getNorm();\n        final int maxIter = 100;\n        int iteration = 0;\n        while (iteration < maxIter) {\n            final double[] hVec = new double[n];\n            final int idx = i;\n            final double norm = schur.getNorm();\n            final int maxIter = 100;\n            int iteration = 0;\n            while (iteration < maxIter) {\n                final double[] hVec = new double[n];\n                final int idx = i;\n                final double norm = schur.getNorm();\n                final int maxIter = 100;\n                int iteration = 0;\n                while (iteration < maxIter) {\n                    final double[] hVec = new double[n];\n                    final int idx = i;\n                    final double norm = schur.getNorm();\n                    final int maxIter = 100;\n                    int iteration = 0;\n                    while (iteration < maxIter) {\n                        final double[] hVec = new double[n];\n                        final int idx = i;\n                        final double norm = schur.getNorm();\n                        final int maxIter = 100;\n                        int iteration = 0;\n                        while (iteration < maxIter) {\n                            final double[] hVec = new double[n];\n                            final int idx = i;\n                            final double norm = schur.getNorm();\n                            final int maxIter = 100;\n                            int iteration = 0;\n}\n}\n}\n}\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    final double[][] matrixT = transformer.getT().getData();\n    final double[][] matrixP = transformer.getP().getData();\n\n    final int n = matrixT.length;\n\n    // compute matrix norm\n    double norm = 0.0;\n    for (int i = 0; i < n; i++) {\n        for (int j = FastMath.max(i - 1, 0); j < n; j++) {\n            norm = norm + FastMath.abs(matrixT[i][j]);\n        }\n    }\n\n    // we can not handle a matrix with zero norm\n    if (Precision.equals(norm, 0.0, EPSILON)) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    // Backsubstitute to find vectors of upper triangular form\n\n    double r = 0.0;\n    double s = 0.0;\n    double z = 0.0;\n\n    for (int idx = n - 1; idx >= 0; idx--) {\n        double p = realEigenvalues[idx];\n        double q = imagEigenvalues[idx];\n\n        // If p is almost zero, avoid division by p.\n        if (FastMath.abs(p) > EPSILON) {\n            for (int i = idx - 1; i >= 0; i--) {\n                r = 0.0;\n                for (int k = i; k <= FastMath.min(idx - 1, i + 1); k++) {\n                    r += matrixT[i][k] * matrixT[k][idx];\n                }\n                s = matrixT[i][i] - p;\n                z = (matrixT[i][idx] - r) / s;\n                matrixT[i][idx] = z;\n\n                // Recalculate matrixT[i][k] in the next for loop\n}\n}\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to Schur form\n    SchurTransformer schur = new SchurTransformer(matrix);\n    matrixT = schur.getT().getData();\n    matrixP = schur.getP().getData();\n    cachedT = null;\n    cachedP = null;\n    cachedPt = null;\n\n    // compute matrix norm\n    double norm = 0.0;\n    for (int i = 0; i < matrixT.length; i++) {\n        for (int j = FastMath.max(i - 1, 0); j < matrixT.length; j++) {\n            norm = norm + FastMath.abs(matrixT[i][j]);\n        }\n    }\n\n    // we can not handle a matrix with zero norm\n    if (Precision.equals(norm, 0.0, EPSILON)) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    // Backsubstitute to find vectors of upper triangular form\n\n    double r = 0.0;\n    double s = 0.0;\n    double z = 0.0;\n\n    for (int idx = matrixT.length - 1; idx >= 0; idx--) {\n        double p = realEigenvalues[idx];\n        double q = imagEigenvalues[idx];\n\n        // find the largest remaining diagonal element\n        for (int k = idx; k < matrixT.length; k++) {\n            r = FastMath.abs(matrixT[k][k]);\n            if (r <= FastMath.abs(p) + FastMath.abs(q)) {\n                break;\n            }\n        }\n\n        // find the largest off-diagonal element in the current column\n        for (int k = idx - 1; k >= 0; k--) {\n            s = FastMath.abs(matrixT[k][idx]) + FastMath.abs(matrixT[idx][k]);\n            if (s >= r) {\n                break;\n            }\n        }\n\n        p = p + q;\n        q = (p - q) / (2 * s);\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to Schur form\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    matrixT = transformer.getT().getData();\n    matrixP = transformer.getP().getData();\n    cachedT = null;\n    cachedP = null;\n    cachedPt = null;\n\n    // transform matrix\n    transform();\n\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer schur = new SchurTransformer(matrix);\n    realEigenvalues = schur.getRealEigenvalues();\n    imagEigenvalues = schur.getImagEigenvalues();\n    return schur;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    // transform the matrix to Schur form\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    final double[][] matrixT = transformer.getT().getData();\n    final double[][] matrixP = transformer.getP().getData();\n\n    final int n = matrixT.length;\n\n    // compute matrix norm\n    double norm = 0.0;\n    for (int i = 0; i < n; i++) {\n       for (int j = FastMath.max(i - 1, 0); j < n; j++) {\n          norm = norm + FastMath.abs(matrixT[i][j]);\n       }\n    }\n\n    // we can not handle a matrix with zero norm\n    if (Precision.equals(norm, 0.0, EPSILON)) {\n       throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    // Backsubstitute to find vectors of upper triangular form\n\n    double r = 0.0;\n    double s = 0.0;\n    double z = 0.0;\n\n    for (int idx = n - 1; idx >= 0; idx--) {\n        double p = realEigenvalues[idx];\n        double q = imagEigenvalues[idx];\n\n        // If p is almost zero, avoid division by p.\n        if (FastMath.abs(q) > EPSILON * norm) {\n            r = (matrixT[idx][idx] - p) / q;\n        } else {\n            r = -matrixT[idx][idx] / q;\n        }\n\n        if (FastMath.abs(r) + FastMath.abs(z) == FastMath.abs(r) + FastMath.abs(z)) {\n            s = FastMath.copySign(FastMath.sqrt(FastMath.abs(r * r + z * z)), r);\n        } else {\n            s = FastMath.copySign(FastMath.sqrt(FastMath.abs(r * r - z * z)), r);\n        }\n\n}\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    final SchurTransformer schur = new SchurTransformer(matrix);\n    final double[][] matrixT = schur.getT().getData();\n    final double[][] matrixP = schur.getP().getData();\n\n    final int n = matrixT.length;\n    final double[] realEigenvalues = new double[n];\n    final double[] imagEigenvalues = new double[n];\n\n    for (int i = 0; i < n; i++) {\n        final double[] hVec = new double[n];\n        final int idx = schur.initQRStep(i, i, new ShiftInfo(), hVec);\n        schur.performDoubleQRStep(i, idx, i, new ShiftInfo(), hVec);\n\n        realEigenvalues[i] = matrixT[i][i];\n        imagEigenvalues[i] = 0;\n\n        if (FastMath.abs(matrixT[i][i + 1]) > Precision.EPSILON) {\n            realEigenvalues[i] = matrixT[i][i] + matrixT[i][i + 1];\n            imagEigenvalues[i] = matrixT[i][i] - matrixT[i][i + 1];\n        }\n\n        if (FastMath.abs(imagEigenvalues[i]) > Precision.EPSILON) {\n            realEigenvalues[i] = 0.5 * (realEigenvalues[i] + imagEigenvalues[i]);\n            imagEigenvalues[i] = 0.5 * (realEigenvalues[i] - imagEigenvalues[i]);\n        }\n    }\n\n    this.realEigenvalues = realEigenvalues;\n    this.imagEigenvalues = imagEigenvalues;\n\n    return schur;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final SchurTransformer transformer = new SchurTransformer(matrix);\n    final double[][] matrixT = transformer.getT().getData();\n    final double[][] matrixP = transformer.getP().getData();\n\n    final int n = matrixT.length;\n\n    // compute matrix norm\n    double norm = 0.0;\n    for (int i = 0; i < n; i++) {\n        for (int j = FastMath.max(i - 1, 0); j < n; j++) {\n            norm = norm + FastMath.abs(matrixT[i][j]);\n        }\n    }\n\n    // we can not handle a matrix with zero norm\n    if (Precision.equals(norm, 0.0, EPSILON)) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    // Backsubstitute to find vectors of upper triangular form\n\n    double r = 0.0;\n    double s = 0.0;\n    double z = 0.0;\n\n    for (int idx = n - 1; idx >= 0; idx--) {\n        double p = realEigenvalues[idx];\n        double q = imagEigenvalues[idx];\n\n        // If diagonal is non-zero, use diagonal element for iteration.\n        if (FastMath.abs(matrixT[idx][idx]) > EPSILON) {\n            r = 0.0;\n            for (int i = idx + 1; i < n; i++) {\n                r = r - matrixT[i][idx] * matrixT[i][idx] / matrixT[idx][idx];\n            }\n            s = matrixT[idx][idx] + r;\n            s = FastMath.sqrt(FastMath.abs(s));\n            if (matrixT[idx][idx] > 0) {\n                s = -s;\n            }\n            matrixT[idx][idx] = matrixT[idx][idx] - s;\n\n            // Overflow control\n}\n}\n}"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E constant : enumClass.getEnumConstants()) {\n        for (int i = 0; i < values.length; i++) {\n            if ((values[i] & (1 << constant.ordinal() % Long.SIZE)) != 0) {\n                result.add(constant);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E constant : enumClass.getEnumConstants()) {\n        for (int i = 0; i < values.length; i++) {\n            if ((values[i] & (1L << constant.ordinal() % Long.SIZE)) != 0) {\n                result.add(constant);\n                break;\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) \n    {\n        for (int j = 0; j < Long.SIZE; j++) \n        {\n            if ((values[i] & (1 << j)) != 0) \n            {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E value : enumClass.getEnumConstants()) {\n        for (int i = 0; i < values.length; i++) {\n            if ((values[i] & (1 << value.ordinal() % Long.SIZE)) != 0) {\n                result.add(value);\n                break;\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((values[i] & (1L << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E value : enumClass.getEnumConstants()) {\n        if (value.ordinal() / Long.SIZE < values.length && (values[value.ordinal() / Long.SIZE] & (1 << (value.ordinal() % Long.SIZE))) != 0) {\n            result.add(value);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass).getEnumConstants();\n    Validate.notNull(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) \n    {\n        for (int j = 0; j < Long.SIZE; j++) \n        {\n            if ((values[i] & (1L << j)) != 0) \n            {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E constant : enumClass.getEnumConstants()) {\n        for (final long value : values) {\n            if ((value & (1L << constant.ordinal())) != 0) {\n                result.add(constant);\n                break;\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E value : enumClass.getEnumConstants()) {\n        for (int i = 0; i < values.length; i++) {\n            if ((values[i] & (1 << value.ordinal() % Long.SIZE)) != 0) {\n                result.add(value);\n                break;\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    ArrayUtils.reverse(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (final E constant : enumClass.getEnumConstants()) {\n        for (int i = 0; i < values.length; i++) {\n            if ((values[i] & (1L << constant.ordinal() % Long.SIZE)) != 0) {\n                result.add(constant);\n                break;\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // Convert to local millis\n    long localMillis = convertUTCToLocal(oldInstant);\n    // Convert back to UTC millis in new zone\n    return newZone.convertLocalToUTC(localMillis);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // Convert to local millis\n    long localMillis = convertUTCToLocal(oldInstant);\n    // Convert back to UTC millis in new zone\n    return newZone.convertLocalToUTC(localMillis);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // convert to local millis\n    long localMillis = convertUTCToLocal(oldInstant);\n    // convert back to UTC millis\n    return newZone.convertLocalToUTC(localMillis);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localInstant = convertUTCToLocal(oldInstant);\n    long newLocalInstant = newZone.convertUTCToLocal(localInstant);\n    return newZone.convertLocalToUTC(newLocalInstant, false);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // convert to local millis\n    long localMillis = convertUTCToLocal(oldInstant);\n    // convert back to UTC millis\n    return newZone.convertLocalToUTC(localMillis);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // convert to local millis\n    long localMillis = convertUTCToLocal(oldInstant);\n    // convert back to UTC millis\n    return newZone.convertLocalToUTC(localMillis);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    return newZone.convertLocalToUTC(convertUTCToLocal(oldInstant), true, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // convert to local millis\n    long localMillis = convertUTCToLocal(oldInstant);\n    // convert back to UTC millis using the new zone\n    return newZone.convertLocalToUTC(localMillis, false);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // convert old instant to local instant\n    long localInstant = convertUTCToLocal(oldInstant);\n    // convert local instant to new instant\n    return newZone.convertLocalToUTC(localInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    // convert oldInstant to local millis\n    int offsetOld = getOffset(oldInstant);\n    long localOld = oldInstant - offsetOld;\n    // convert localOld to newZone millis\n    int offsetNew = newZone.getOffset(localOld);\n    long newZoneMillis = localOld - offsetNew;\n    return newZoneMillis;\n}"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    if (unit.equals(DateTickUnitType.YEAR)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.YEAR, unit.getMultiple());\n        return calendar.getTime();\n    } \n    else if (unit.equals(DateTickUnitType.MONTH)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.MONTH, unit.getMultiple());\n        return calendar.getTime();\n    } \n    else if (unit.equals(DateTickUnitType.DAY)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.DAY_OF_MONTH, unit.getMultiple());\n        return calendar.getTime();\n    } \n    else if (unit.equals(DateTickUnitType.HOUR)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.HOUR_OF_DAY, unit.getMultiple());\n        return calendar.getTime();\n    } \n    else if (unit.equals(DateTickUnitType.MINUTE)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.MINUTE, unit.getMultiple());\n        return calendar.getTime();\n    } \n    else if (unit.equals(DateTickUnitType.SECOND)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.SECOND, unit.getMultiple());\n        return calendar.getTime();\n    } \n    else if (unit.equals(DateTickUnitType.MILLISECOND)) \n    {\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    if (unit.equals(DateTickUnitType.YEAR)) \n    {\n        return new Date(date.getTime() + 365L * 24L * 60L * 60L * 1000L);\n    } \n    else if (unit.equals(DateTickUnitType.MONTH)) \n    {\n        return new Date(date.getTime() + 31L * 24L * 60L * 60L * 1000L);\n    } \n    else if (unit.equals(DateTickUnitType.DAY)) \n    {\n        return new Date(date.getTime() + 24L * 60L * 60L * 1000L);\n    } \n    else if (unit.equals(DateTickUnitType.HOUR)) \n    {\n        return new Date(date.getTime() + 60L * 60L * 1000L);\n    } \n    else if (unit.equals(DateTickUnitType.MINUTE)) \n    {\n        return new Date(date.getTime() + 60L * 1000L);\n    } \n    else if (unit.equals(DateTickUnitType.SECOND)) \n    {\n        return new Date(date.getTime() + 1000L);\n    } \n    else if (unit.equals(DateTickUnitType.MILLISECOND)) \n    {\n        return new Date(date.getTime() + 1);\n    } \n    else \n    {\n        throw new IllegalArgumentException(\"The 'unit' argument has a \" +\n                \"value that is not recognised.\");\n    }\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    calendar.set(unit.getCalendarField(), value + count);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    if (unit.getUnitType() == DateTickUnitType.YEAR) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.YEAR, unit.getCount());\n        return calendar.getTime();\n    }\n    else if (unit.getUnitType() == DateTickUnitType.MONTH) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.MONTH, unit.getCount());\n        return calendar.getTime();\n    }\n    else if (unit.getUnitType() == DateTickUnitType.DAY) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.DAY_OF_MONTH, unit.getCount());\n        return calendar.getTime();\n    }\n    else if (unit.getUnitType() == DateTickUnitType.HOUR) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.HOUR_OF_DAY, unit.getCount());\n        return calendar.getTime();\n    }\n    else if (unit.getUnitType() == DateTickUnitType.MINUTE) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.MINUTE, unit.getCount());\n        return calendar.getTime();\n    }\n    else if (unit.getUnitType() == DateTickUnitType.SECOND) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.SECOND, unit.getCount());\n        return calendar.getTime();\n    }\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    if (unit.equals(DateTickUnitType.YEAR)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.YEAR, unit.getMultiple());\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MONTH)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.MONTH, unit.getMultiple());\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.DAY)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.DAY_OF_MONTH, unit.getMultiple());\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.HOUR)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.HOUR_OF_DAY, unit.getMultiple());\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.MINUTE, unit.getMultiple());\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.SECOND)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.SECOND, unit.getMultiple());\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MILLISECOND)) \n    {\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    if (unit.equals(DateTickUnitType.YEAR)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.YEAR, 1);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MONTH)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.MONTH, 1);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.DAY)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.DAY_OF_YEAR, 1);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.HOUR)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.HOUR_OF_DAY, 1);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.MINUTE, 1);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.SECOND)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.SECOND, 1);\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MILLISECOND)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    if (unit.equals(DateTickUnitType.YEAR)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.YEAR, unit.getMultiple());\n        return calendar.getTime();\n    } \n    else if (unit.equals(DateTickUnitType.MONTH)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.MONTH, unit.getMultiple());\n        return calendar.getTime();\n    } \n    else if (unit.equals(DateTickUnitType.DAY)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.DAY_OF_MONTH, unit.getMultiple());\n        return calendar.getTime();\n    } \n    else if (unit.equals(DateTickUnitType.HOUR)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.HOUR_OF_DAY, unit.getMultiple());\n        return calendar.getTime();\n    } \n    else if (unit.equals(DateTickUnitType.MINUTE)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.MINUTE, unit.getMultiple());\n        return calendar.getTime();\n    } \n    else if (unit.equals(DateTickUnitType.SECOND)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.SECOND, unit.getMultiple());\n        return calendar.getTime();\n    } \n    else if (unit.equals(DateTickUnitType.MILLISECOND)) \n    {\n}\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    if (unit.equals(DateTickUnitType.YEAR)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.YEAR, unit.getMultiple());\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MONTH)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.MONTH, unit.getMultiple());\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.DAY)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.DAY_OF_MONTH, unit.getMultiple());\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.HOUR)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.HOUR_OF_DAY, unit.getMultiple());\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.MINUTE, unit.getMultiple());\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.SECOND)) \n    {\n        Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n        calendar.setTime(date);\n        calendar.add(Calendar.SECOND, unit.getMultiple());\n        return calendar.getTime();\n    }\n    else if (unit.equals(DateTickUnitType.MILLISECOND)) \n    {\n}\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver == null) {\n        return null;\n    }\n    final Object value = variableResolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    if (value instanceof String) {\n        return (String) value;\n    }\n    return value.toString();\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // check for null resolver\n    if (this.variableResolver == null) {\n        return null;\n    }\n    // check for escape\n    if (this.escapeChar != StrSubstitutor.NO_ESCAPE_CHARACTER) {\n        if (buf.charAt(startPos) == this.escapeChar) {\n            return variableName;\n        }\n    }\n    // check for prefix and suffix\n    if (this.prefixMatcher != null && this.suffixMatcher != null) {\n        final String prefix = this.prefixMatcher.getPrefixChars();\n        final String suffix = this.suffixMatcher.getSuffixChars();\n        if (variableName.startsWith(prefix) && variableName.endsWith(suffix)) {\n            return variableName.substring(prefix.length(), variableName.length() - suffix.length());\n        }\n    }\n    // delegate to resolver\n    final Object value = this.variableResolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    if (value instanceof String) {\n        return (String) value;\n    }\n    return value.toString();\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    final Object value = resolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    if (value instanceof String) {\n        return (String) value;\n    }\n    return value.toString();\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver == null) {\n        return null;\n    }\n    final Object value = variableResolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    if (enableSubstitutionInVariables) {\n        return substitute(value.toString(), buf, startPos, endPos);\n    }\n    return value.toString();\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver == null) {\n        return null;\n    }\n    final Object value = variableResolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    return value.toString();\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver == null) {\n        return null;\n    }\n    final Object value = variableResolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    return value.toString();\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // check the variable resolver\n    if (this.variableResolver != null) \n    {\n        final Object value = this.variableResolver.lookup(variableName);\n        if (value != null) \n        {\n            return value.toString();\n        }\n    }\n    // check the system properties\n    if (this.systemProperties) \n    {\n        final String value = System.getProperty(variableName);\n        if (value != null) \n        {\n            return value;\n        }\n    }\n    // check the environment variables\n    if (this.environmentVariables) \n    {\n        final String value = System.getenv(variableName);\n        if (value != null) \n        {\n            return value;\n        }\n    }\n    // check the map\n    if (this.valueMap != null) \n    {\n        final Object value = this.valueMap.get(variableName);\n        if (value != null) \n        {\n            return value.toString();\n        }\n    }\n    // check the default value\n    if (this.defaultValue != null) \n    {\n        return this.defaultValue;\n    }\n    // no value found\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // if there is no variable resolver, return null\n    if (this.variableResolver == null) {\n        return null;\n    }\n\n    // if substitution in variables is disabled, return null\n    if (this.enableSubstitutionInVariables == false) {\n        return null;\n    }\n\n    // if the variable name is empty, return null\n    if (variableName.length() == 0) {\n        return null;\n    }\n\n    // if the variable name is not a string, return null\n    if (this.variableResolver instanceof StrLookup) {\n        final StrLookup<?> lookup = (StrLookup<?>) this.variableResolver;\n        final Object value = lookup.lookup(variableName);\n        if (value == null) {\n            return null;\n        }\n        if (value instanceof String) {\n            return (String) value;\n        }\n        buf.append(value);\n        return buf.toString();\n    }\n\n    // if the variable name is not a string, return null\n    if (this.variableResolver instanceof Map) {\n        final Map<?, ?> map = (Map<?, ?>) this.variableResolver;\n        final Object value = map.get(variableName);\n        if (value == null) {\n            return null;\n        }\n        if (value instanceof String) {\n            return (String) value;\n        }\n        buf.append(value);\n        return buf.toString();\n    }\n\n    // if the variable name is not a string, return null\n    if (this.variableResolver instanceof Properties) {\n        final Properties props = (Properties) this.variableResolver;\n        final String value = props.getProperty(variableName);\n        if (value == null) {\n            return null;\n        }\n        return value;\n    }\n\n    // if the variable name is not a string, return null\n    if (this.variableResolver instanceof StrSubstitutor) {\n        final StrSubstitutor sub = (StrSubstitutor) this.variableResolver;\n        final String value = sub.replace(variableName);\n        if (value == null) {\n            return null;\n        }\n        return value;\n    }\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (this.variableResolver == null) {\n        return null;\n    }\n    Object value = this.variableResolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    if (value instanceof String) {\n        return (String) value;\n    }\n    return value.toString();\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    // perform variable substitution\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver != null) {\n        final Object value = resolver.lookup(variableName);\n        if (value != null) {\n            return value.toString();\n        }\n    }\n    // no value found\n    return null;\n}"
    ],
    [
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    final char[] code = new char[4];\n    code[0] = Character.toUpperCase(str.charAt(0));\n    int index = 1;\n    int last = 'B';\n    for (int i = 1; i < str.length() && index < 4; i++) \n    {\n        final char ch = Character.toUpperCase(str.charAt(i));\n        if (ch == 'W' || ch == 'H') \n        {\n            if (last != 'W') \n            {\n                code[index++] = 'H';\n            }\n        } \n        else if (ch != 'A' && ch != 'E' && ch != 'I' && ch != 'O' && ch != 'U' && ch != 'Y') \n        {\n            if (ch != last) \n            {\n                code[index++] = this.map(ch);\n            }\n        }\n        last = ch;\n    }\n    return new String(code, 0, index);\n}",
      "public String soundex(String str)  {\n    // Implement your solution here\n    return null;\n}",
      "public String soundex(String str)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public String soundex(String str)  {\n    // TODO: Implement this method\n    return null;\n}",
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    // Implement your code here\n    return null;\n}",
      "public String soundex(String str)  {\n    //TODO: Implement the soundex algorithm for the given string\n    return null;\n}",
      "public String soundex(String str)  {\n    // Implement your answer here\n    return \"\";\n}",
      "public String soundex(String str)  {\n        if (str == null) {\n            return null;\n        }\n        // Remove non-alpha characters from the given String object\n        str = str.replaceAll(\"[^A-Z]\", \"\");\n        if (str.length() == 0) {\n            return \"\";\n        }\n        // Uppercase the given String object\n        str = str.toUpperCase();\n        // Initialize the soundex code\n        char[] soundexCode = new char[str.length()];\n        // Map the first character of the given String object\n        soundexCode[0] = map(str.charAt(0));\n        // Iterate over the remaining characters\n        for (int i = 1; i < str.length(); i++) {\n            char ch = str.charAt(i);\n            // If the current character is a vowel, append it to the soundex code\n            if (ch == 'A' || ch == 'E' || ch == 'I' || ch == 'O' || ch == 'U' || ch == 'Y') {\n                soundexCode[i] = ch;\n            }\n            // If the current character is a consonant, append the mapped value to the soundex code\n            else {\n                soundexCode[i] = map(ch);\n            }\n        }\n        // Return the soundex code\n        return new String(soundexCode);\n    }",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    final char[] s = str.toUpperCase().toCharArray();\n    final StringBuilder sb = new StringBuilder();\n    char prev = 'A';\n    for (int i = 0; i < s.length; i++) {\n        final char ch = this.map(s[i]);\n        if (ch != prev) {\n            sb.append(ch);\n            prev = ch;\n        }\n    }\n    sb.append('0');\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    // YOUR CODE HERE\n}"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Boolean.class) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == Comparable.class) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == Class.class) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == Enum.class) {\n        return CORE_TYPE_ENUM;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Boolean.class || clz == Boolean.TYPE) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == Integer.class || clz == Integer.TYPE) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Long.class || clz == Long.TYPE) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == Comparable.class) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == Class.class) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == Enum.class) {\n        return CORE_TYPE_ENUM;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == Comparable.class) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == Class.class) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == Enum.class) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == Boolean.class) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Boolean.class) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == Comparable.class) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == Class.class) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == Enum.class) {\n        return CORE_TYPE_ENUM;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Boolean.class || clz == Boolean.TYPE) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == Integer.class || clz == Integer.TYPE) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Long.class || clz == Long.TYPE) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == Comparable.class) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == Class.class) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz.isEnum()) {\n        return CORE_TYPE_ENUM;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == Boolean.class) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Comparable.class) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == Class.class) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == Enum.class) {\n        return CORE_TYPE_ENUM;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Boolean.class || clz == boolean.class) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == Integer.class || clz == int.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Long.class || clz == long.class) {\n        return CORE_TYPE_LONG;\n    }\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == Comparable.class) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == Class.class) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == Enum.class) {\n        return CORE_TYPE_ENUM;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == Object.class) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == Comparable.class) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == Class.class) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == Enum.class) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == Boolean.class) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == Integer.class) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == Long.class) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.getType() != Token.GETPROP) {\n    return null;\n  }\n\n  Node left = n.getFirstChild();\n  Node right = n.getLastChild();\n\n  if (right.getString().equals(\"prototype\")) {\n    if (left.getType() == Token.GETPROP) {\n      return extractDeclaration(left);\n    } else if (left.getType() == Token.NAME) {\n      return new PrototypeMemberDeclaration(n, n.getParent());\n    }\n  }\n\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.getType() == Token.GETPROP) {\n    Node left = n.getFirstChild();\n    Node right = n.getLastChild();\n    if (left.isQualifiedName() && right.getString().equals(\"prototype\")) {\n      return new PrototypeMemberDeclaration(left, n);\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.getType() == Token.ASSIGN) \n  {\n    Node lhs = n.getFirstChild();\n    if (lhs.getType() == Token.GETPROP) \n    {\n      Node obj = lhs.getFirstChild();\n      Node prop = lhs.getLastChild();\n      if (prop.getType() == Token.STRING &&\n          obj.getType() == Token.GETPROP &&\n          obj.getFirstChild().getType() == Token.THIS &&\n          obj.getLastChild().getType() == Token.STRING &&\n          obj.getLastChild().getString().equals(\"prototype\")) \n      {\n        return new PrototypeMemberDeclaration(lhs, n);\n      }\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isGetProp() && n.getFirstChild().isGetProp()) \n  {\n    Node prop = n.getFirstChild().getFirstChild();\n    if (prop.isQualifiedName() &&\n        prop.getString().equals(\"prototype\")) \n    {\n      return new PrototypeMemberDeclaration(n.getFirstChild(), n);\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.getType() == Token.ASSIGN) {\n    Node lhs = n.getFirstChild();\n    Node rhs = n.getLastChild();\n    if (lhs.getType() == Token.GETPROP) {\n      Node obj = lhs.getFirstChild();\n      Node prop = lhs.getLastChild();\n      if (obj.getType() == Token.GETPROP) {\n        Node obj2 = obj.getFirstChild();\n        Node prop2 = obj.getLastChild();\n        if (prop2.getType() == Token.STRING &&\n            prop2.getString().equals(\"prototype\")) {\n          return new PrototypeMemberDeclaration(lhs, rhs);\n        }\n      }\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.getType() == Token.ASSIGN) {\n    Node lhs = n.getFirstChild();\n    Node rhs = n.getLastChild();\n    if (lhs.isGetProp() && rhs.isFunction()) {\n      return new PrototypeMemberDeclaration(lhs, n);\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.getType() == Token.ASSIGN) {\n    Node lhs = n.getFirstChild();\n    if (lhs.getType() == Token.GETPROP) {\n      Node getprop = lhs.getFirstChild();\n      if (getprop.getType() == Token.GETPROP) {\n        Node getprop2 = getprop.getFirstChild();\n        if (getprop2.getType() == Token.THIS) {\n          Node string = getprop2.getNext();\n          if (string.getType() == Token.STRING) {\n            Node rhs = n.getLastChild();\n            if (rhs.getType() == Token.FUNCTION) {\n              return new PrototypeMemberDeclaration(lhs, n);\n            }\n          }\n        }\n      }\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isGetProp() &&\n      n.getFirstChild().isGetProp() &&\n      n.getFirstChild().getFirstChild().isGetProp() &&\n      n.getFirstChild().getFirstChild().getFirstChild().isThis() &&\n      n.getFirstChild().getFirstChild().getLastChild().isQualifiedName() &&\n      n.getLastChild().isAssign()) {\n    return new PrototypeMemberDeclaration(n.getFirstChild().getFirstChild(), n);\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.isGetProp()) {\n    Node parent = n.getParent();\n    if (parent.isGetProp() && parent.getLastChild() == n) {\n      Node grandparent = parent.getParent();\n      if (grandparent.isAssign() && grandparent.getFirstChild() == parent) {\n        Node lhs = parent.getFirstChild();\n        if (lhs.isGetProp() && lhs.getLastChild() == parent.getFirstChild()) {\n          Node rhs = grandparent.getLastChild();\n          if (rhs.isFunction()) {\n            return new PrototypeMemberDeclaration(lhs, n);\n          }\n        }\n      }\n    }\n  }\n  return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n  if (n.getType() == Token.GETPROP && n.getFirstChild().isQualifiedName()) {\n    Node parent = n.getParent();\n    if (parent.getType() == Token.ASSIGN &&\n        parent.getFirstChild() == n) {\n      Node grandParent = parent.getParent();\n      if (grandParent.getType() == Token.EXPR_RESULT) {\n        return new PrototypeMemberDeclaration(n.getFirstChild(), parent);\n      }\n    }\n  }\n  return null;\n}"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < n * mat.getRowDimension(); r++) {\n        for (int c = 0; c < m * mat.getColumnDimension(); c++) {\n            d[r][c] = mat.getEntry(r % mat.getRowDimension(), c % mat.getColumnDimension());\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < n * mat.getRowDimension(); r++) {\n        for (int c = 0; c < m * mat.getColumnDimension(); c++) {\n            d[r][c] = mat.getEntry(r % mat.getRowDimension(), c % mat.getColumnDimension());\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < n; r++) {\n        for (int c = 0; c < m; c++) {\n            for (int i = 0; i < mat.getRowDimension(); i++) {\n                for (int j = 0; j < mat.getColumnDimension(); j++) {\n                    d[r * mat.getRowDimension() + i][c * mat.getColumnDimension() + j] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[i * mat.getRowDimension() + r][j * mat.getColumnDimension() + c] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < n; r++) {\n        for (int c = 0; c < m; c++) {\n            for (int i = 0; i < mat.getRowDimension(); i++) {\n                for (int j = 0; j < mat.getColumnDimension(); j++) {\n                    d[r * mat.getRowDimension() + i][c * mat.getColumnDimension() + j] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < n; r++) {\n        for (int c = 0; c < m; c++) {\n            for (int i = 0; i < mat.getRowDimension(); i++) {\n                for (int j = 0; j < mat.getColumnDimension(); j++) {\n                    d[r * mat.getRowDimension() + i][c * mat.getColumnDimension() + j] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < n; r++) {\n        for (int c = 0; c < m; c++) {\n            for (int i = 0; i < mat.getRowDimension(); i++) {\n                for (int j = 0; j < mat.getColumnDimension(); j++) {\n                    d[r * mat.getRowDimension() + i][c * mat.getColumnDimension() + j] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < mat.getRowDimension(); r++) {\n        for (int c = 0; c < mat.getColumnDimension(); c++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    d[i * mat.getRowDimension() + r][j * mat.getColumnDimension() + c] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < n; r++) {\n        for (int c = 0; c < m; c++) {\n            for (int i = 0; i < mat.getRowDimension(); i++) {\n                for (int j = 0; j < mat.getColumnDimension(); j++) {\n                    d[r * mat.getRowDimension() + i][c * mat.getColumnDimension() + j] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final double[][] d = new double[n * mat.getRowDimension()][m * mat.getColumnDimension()];\n    for (int r = 0; r < n; r++) {\n        for (int c = 0; c < m; c++) {\n            for (int i = 0; i < mat.getRowDimension(); i++) {\n                for (int j = 0; j < mat.getColumnDimension(); j++) {\n                    d[r * mat.getRowDimension() + i][c * mat.getColumnDimension() + j] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  {\n    return (current.bytesReadFromStream & 0xffffffffL);\n}",
      "private long getBytesInflated()  {\n    return (long) inf.getBytesRead();\n}",
      "private long getBytesInflated()  {\n    return current.bytesReadFromStream;\n}",
      "private long getBytesInflated()  {\n    final long bytesRead = current.bytesRead;\n    final long bytesReadFromStream = current.bytesReadFromStream;\n    if (bytesReadFromStream > bytesRead) {\n        return bytesReadFromStream;\n    }\n    return bytesRead;\n}",
      "private long getBytesInflated()  {\n    return current.bytesReadFromStream;\n}",
      "private long getBytesInflated()  {\n    return (inf.getBytesRead() & 0xffffffffL) + (inf.getBytesWritten() & 0xffffffffL);\n}",
      "private long getBytesInflated()  {\n    return (inf.getBytesRead() & 0xffffffffL) + (inf.getBytesWritten() & 0xffffffffL);\n}",
      "private long getBytesInflated()  {\n    final long totalBytesRead = getBytesRead();\n    final long bytesReadFromStream = current.bytesReadFromStream;\n    final long bytesInflated = totalBytesRead - bytesReadFromStream;\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    return current.bytesReadFromStream;\n}",
      "private long getBytesInflated()  {\n    return current.bytesReadFromStream;\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object.getClass().isArray()) \n    {\n        return Array.getLength(object) == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object.getClass().isArray()) \n    {\n        return Array.getLength(object) == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try \n    {\n        return Array.getLength(object) == 0;\n    } \n    catch (final IllegalArgumentException ex) \n    {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try \n    {\n        return Array.getLength(object) == 0;\n    } \n    catch (final IllegalArgumentException ex) \n    {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) \n    {\n        return true;\n    }\n    if (object instanceof Collection<?>) \n    {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Map<?, ?>) \n    {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) \n    {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) \n    {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) \n    {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try \n    {\n        return Array.getLength(object) == 0;\n    } \n    catch (final IllegalArgumentException ex) \n    {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?,?>) object).isEmpty();\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n  return isValidSimpleName(name);\n}"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = matrixT[iu][iu];\n    double q = matrixT[iu][iu - 1];\n    double r = matrixT[iu - 1][iu - 1];\n    shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n    if (!Precision.equals(shift.x, 0.0, epsilon)) {\n        p = p / shift.x;\n        q = q / shift.x;\n        r = r / shift.x;\n    }\n    if (shift.x == 0.0) {\n        return iu;\n    }\n    hVec[0] = p;\n    hVec[1] = q;\n    hVec[2] = r;\n    return il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // initialize the householder vector\n    hVec[0] = matrixT[iu][iu];\n    hVec[1] = 0.0;\n    hVec[2] = 0.0;\n\n    // check for convergence\n    if (iu == il) \n    {\n        matrixT[iu][iu] = matrixT[iu][iu] + shift.exShift;\n        return iu;\n    }\n\n    // compute the shift\n    computeShift(il, iu, 0, shift);\n\n    // chase bulge from bottom to top\n    for (int i = iu - 2; i >= il; i--) \n    {\n        double x = matrixT[i][i + 1];\n        double y = matrixT[i + 1][i + 1];\n        double z = FastMath.sqrt(x * x + y * y);\n        hVec[0] = matrixT[i][i] - shift.x + z;\n        hVec[1] = matrixT[i + 1][i];\n        hVec[2] = matrixT[i + 1][i + 1] = -z;\n        double s = FastMath.abs(matrixT[i][i + 1]) + FastMath.abs(matrixT[i + 1][i + 1]);\n        if (s == 0.0) \n        {\n            s = norm;\n        }\n        double t = matrixT[i][i] + shift.x / s;\n        double tau = matrixT[i + 1][i + 1] / t;\n        hVec[1] = -tau * y;\n        hVec[2] = tau * x;\n        matrixT[i][i] = t;\n        matrixT[i + 1][i + 1] = 0.0;\n        for (int j = i + 2; j < matrixT.length; j++) \n        {\n            x = matrixT[i][j];\n            y = matrixT[i + 1][j];\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    int im = il;\n    while (im <= iu - 1) {\n        // Scale to avoid under/overflow\n        double scale = 0.0;\n        double h = 0.0;\n        for (int k = im; k <= iu; k++) {\n            scale += FastMath.abs(matrixT[k][k - 1]);\n        }\n        if (scale == 0.0) {\n            h = 0.0;\n        } else {\n            for (int k = im; k <= iu; k++) {\n                h += matrixT[k][k - 1] * matrixT[k][k - 1];\n            }\n            h = h / scale / scale;\n        }\n        hVec[0] = scale * FastMath.sqrt(h);\n        hVec[1] = matrixT[im][im - 1];\n        hVec[2] = 0.0;\n        if (hVec[0] != 0.0) {\n            if (hVec[1] < 0.0) {\n                hVec[0] = -hVec[0];\n            }\n            for (int k = im; k <= iu; k++) {\n                hVec[2] += matrixT[k][k - 1] * hVec[1];\n            }\n            hVec[2] = hVec[2] / hVec[0];\n            hVec[1] = hVec[1] - hVec[2];\n            for (int k = im; k <= iu; k++) {\n                matrixT[k][k - 1] = matrixT[k][k - 1] - hVec[1] * hVec[1];\n            }\n            hVec[0] = -hVec[0];\n        }\n        if (FastMath.abs(hVec[1]) > epsilon) {\n            break;\n        }\n        im++;\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = 0.0;\n    double q = 0.0;\n    double r = 0.0;\n    if (il == iu) {\n        hVec[0] = 1.0;\n        hVec[1] = 0.0;\n        hVec[2] = 0.0;\n        return il;\n    }\n    for (int i = il; i <= iu - 1; i++) {\n        if (i != il) {\n            p = matrixT[i][i - 1];\n            q = matrixT[i + 1][i - 1];\n            r = 0.0;\n            if (i < iu - 1) {\n                r = matrixT[i + 2][i - 1];\n            }\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (i != il) {\n                matrixT[i][i - 1] = -s * shift.x;\n            } else if (il != i) {\n                matrixT[i][i - 1] = -matrixT[i][i - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n            hVec[0] = p + shift.x;\n            hVec[1] = q;\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = 0.0;\n    double q = 0.0;\n    double r = 0.0;\n\n    // Initialize the householder vector\n    if (il == iu) {\n        hVec[0] = matrixT[il][il];\n        hVec[1] = 0.0;\n        hVec[2] = 0.0;\n        p = FastMath.abs(hVec[0]);\n        if (p == 0.0) {\n            hVec[0] = 0.0;\n            return iu;\n        }\n        hVec[0] = hVec[0] > 0.0 ? -FastMath.sqrt(hVec[0]) : FastMath.sqrt(hVec[0]);\n        return il;\n    }\n\n    // Initialize the householder vector\n    for (int k = il; k <= iu - 1; k++) {\n        p = p + FastMath.abs(matrixT[k][k]);\n    }\n    if (p == 0.0) {\n        hVec[0] = 0.0;\n        return iu;\n    }\n    if (il != iu) {\n        q = matrixT[iu - 1][iu - 1];\n        r = (iu < n - 1) ? matrixT[iu][iu] : 0.0;\n        shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n        if (!Precision.equals(shift.x, 0.0, epsilon)) {\n            p = p / shift.x;\n            q = q / shift.x;\n            r = r / shift.x;\n        }\n    }\n    if (shift.x == 0.0) {\n        hVec[0] = 0.0;\n        return iu;\n    }\n    double s = FastMath.sqrt(p * p + q * q + r * r);\n    if (p < 0.0) {\n        s = -s;\n    }\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    int im = il;\n    while (im <= iu - 1) {\n        hVec[0] = matrixT[im][im];\n        hVec[1] = matrixT[im + 1][im];\n        hVec[2] = 0.0;\n        if (im != il) {\n            hVec[0] = -hVec[0];\n        }\n        double s = FastMath.abs(hVec[0]) + FastMath.abs(hVec[1]);\n        if (s == 0.0) {\n            s = norm;\n        }\n        hVec[0] = hVec[0] / s;\n        hVec[1] = hVec[1] / s;\n        hVec[2] = -s;\n        matrixT[im][im] = matrixT[im][im] - shift.x;\n        matrixT[im + 1][im] = 0.0;\n        im++;\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    int im = il;\n    while (im < iu) {\n        // generate householder vector\n        double s = 0.0;\n        for (int j = im; j < n; j++) {\n            s += matrixT[im][j] * matrixT[im][j];\n        }\n        if (s <= epsilon * epsilon) {\n            im++;\n        } else {\n            break;\n        }\n    }\n    if (im > il) {\n        hVec[0] = matrixT[im][im];\n        hVec[1] = 0.0;\n        hVec[2] = 0.0;\n        for (int j = im + 1; j < n; j++) {\n            hVec[1] += matrixT[im][j] * matrixT[im][j];\n        }\n        hVec[1] = FastMath.sqrt(hVec[1]);\n        if (matrixT[im][im] > 0.0) {\n            hVec[1] = -hVec[1];\n        }\n        hVec[2] = matrixT[im][im + 1];\n        for (int j = im + 2; j < n; j++) {\n            hVec[2] += matrixT[im][j] * matrixT[im][j];\n        }\n        hVec[2] /= hVec[1];\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    int im = il;\n    while (im < iu) {\n        if (matrixT[im][im] != 0.0) {\n            break;\n        }\n        im++;\n    }\n    if (im > il) {\n        final double s = FastMath.sqrt(matrixT[im][im - 1] * matrixT[im][im - 1] + matrixT[im - 1][im - 1]);\n        if (matrixT[im][im - 1] < 0.0) {\n            s = -s;\n        }\n        matrixT[im][im - 1] = s * matrixT[im][im - 1];\n        matrixT[im - 1][im - 1] = s * matrixT[im - 1][im - 1];\n        hVec[0] = matrixT[im][im - 1];\n        hVec[1] = matrixT[im - 1][im - 1] - s;\n        hVec[2] = matrixT[im - 1][im];\n    } else {\n        hVec[0] = 0.0;\n        hVec[1] = -matrixT[im][im];\n        hVec[2] = 0.0;\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    int im = il;\n    while (im <= iu - 1) {\n        // compute shift\n        computeShift(im, iu, 0, shift);\n\n        // Chase bulge from top\n        int i = im - 1;\n        while (i >= il) {\n            double s = matrixT[i][i + 1];\n            if (s == 0.0) {\n                break;\n            }\n            double t = (matrixT[i + 1][i] - shift.x) / s;\n            double r = FastMath.sqrt(t * t + 1.0);\n            if (t < 0.0) {\n                r = -r;\n            }\n            matrixT[i][i + 1] = s = r;\n            if (i > il) {\n                matrixT[i - 1][i + 1] = -s * t;\n            }\n            hVec[i - il] = s;\n            i--;\n        }\n        hVec[i - il + 1] = 0.0;\n\n        // Chase bulge from bottom\n        i = im + 1;\n        while (i <= iu) {\n            double s = matrixT[i][i - 1];\n            if (s == 0.0) {\n                break;\n            }\n            double t = (matrixT[i][i] - shift.x) / s;\n            double r = FastMath.sqrt(t * t + 1.0);\n            if (t < 0.0) {\n                r = -r;\n            }\n            matrixT[i][i - 1] = s = r;\n            if (i < iu) {\n                matrixT[i + 1][i - 1] = -s * t;\n            }\n            hVec[i - il] = -s;\n            i++;\n        }\n        hVec[i - il] = 0.0;\n\n        // If off-diagonal element is non-zero, do one qr step\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = matrixT[iu][iu];\n    double q = matrixT[iu][iu - 1];\n    double r = 0.0;\n    if (iu > il + 1) {\n        r = matrixT[iu - 1][iu - 1];\n    }\n    shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n    if (!Precision.equals(shift.x, 0.0, epsilon)) {\n        p = p / shift.x;\n        q = q / shift.x;\n        r = r / shift.x;\n    }\n    if (shift.x == 0.0) {\n        return iu;\n    }\n    double s = FastMath.sqrt(p * p + q * q + r * r);\n    if (p < 0.0) {\n        s = -s;\n    }\n    if (s != 0.0) {\n        if (iu > il + 1) {\n            matrixT[iu - 1][iu - 1] = -s * shift.x;\n        } else if (il != iu) {\n            matrixT[iu][iu - 1] = -matrixT[iu][iu - 1];\n        }\n        p = p + s;\n        shift.x = p / s;\n        shift.y = q / s;\n        double z = r / s;\n        q = q / p;\n        r = r / p;\n        hVec[0] = p;\n        hVec[1] = q;\n        hVec[2] = r;\n        return il;\n    }\n    return iu;\n}"
    ],
    [
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (!segment.inExceptionSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have same number of fields\");\n        }\n        if (zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePeriod must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int size = start.size();\n        int amount = 0;\n        for (int i = 0; i < size; i++) {\n            DateTimeFieldType fieldType = start.getFieldType(i);\n            if (fieldType.isSupported() == false) {\n                throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n            }\n            if (fieldType.getField(chrono).isLenient() == false) {\n                throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not lenient\");\n            }\n            int startValue = start.getValue(i);\n            int endValue = end.getValue(i);\n            if (startValue != endValue) {\n                amount += zeroInstance.getValue(fieldType) * (endValue - startValue);\n            }\n        }\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same number of fields\");\n        }\n        int size = start.size();\n        int amount = 0;\n        for (int i = 0; i < size; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same fields\");\n            }\n            amount += zeroInstance.getValue(i) - start.getValue(i) + end.getValue(i);\n        }\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same size\");\n    }\n    int amount = 0;\n    for (int i = 0; i < start.size(); i++) {\n        DateTimeFieldType fieldType = start.getFieldType(i);\n        if (fieldType.isSupported() && fieldType.isDurationField()) {\n            amount += fieldType.getDurationField().getUnitMillis();\n        } else {\n            amount += zeroInstance.getValue(fieldType);\n        }\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have same amount of fields\");\n        }\n        int amount = 0;\n        for (int i = 0; i < start.size(); i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have same field types\");\n            }\n            amount += start.getValue(i) - end.getValue(i);\n        }\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same number of fields\");\n        }\n        if (zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePeriod must not be null\");\n        }\n        int size = start.size();\n        int amount = 0;\n        for (int i = 0; i < size; i++) {\n            DateTimeFieldType fieldType = start.getFieldType(i);\n            if (fieldType.isSupported() == false) {\n                throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n            }\n            if (fieldType.getField(start.getChronology()) != fieldType.getField(end.getChronology())) {\n                throw new IllegalArgumentException(\"Field '\" + fieldType + \"' is not the same in both objects\");\n            }\n            amount += fieldType.getField(start.getChronology()).getDifference(end.getValue(i), start.getValue(i));\n        }\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same number of fields\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePeriod must not be null\");\n    }\n    int size = start.size();\n    int amount = 0;\n    for (int i = 0; i < size; i++) {\n        if (start.getFieldType(i) != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same field types\");\n        }\n        amount += zeroInstance.getValue(i) - start.getValue(i) + end.getValue(i);\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same number of fields\");\n        }\n        if (zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePeriod must not be null\");\n        }\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int size = start.size();\n        int[] values1 = new int[size];\n        int[] values2 = new int[size];\n        for (int i = 0; i < size; i++) {\n            DateTimeFieldType fieldType = start.getFieldType(i);\n            values1[i] = start.get(fieldType);\n            values2[i] = end.get(fieldType);\n        }\n        int amount = chrono.getDurationMillis(values1, values2);\n        return amount / zeroInstance.get(DurationFieldType.millis());\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same size\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePeriod must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = 0;\n    for (int i = 0; i < start.size(); i++) {\n        int startValue = start.get(i);\n        int endValue = end.get(i);\n        if (startValue == endValue) {\n            continue;\n        }\n        if (startValue < endValue) {\n            amount += endValue - startValue;\n        } else {\n            amount -= startValue - endValue;\n        }\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have same number of fields\");\n    }\n    if (zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePeriod must not be null\");\n    }\n    int size = start.size();\n    int amount = 0;\n    for (int i = 0; i < size; i++) {\n        DateTimeFieldType fieldType = start.getFieldType(i);\n        int startValue = start.getValue(i, fieldType);\n        int endValue = end.getValue(i, fieldType);\n        int zeroValue = zeroInstance.getValue(i, fieldType);\n        int fieldAmount = endValue - startValue - zeroValue;\n        if (fieldAmount < 0) {\n            fieldAmount += fieldType.getDurationField().getUnitMillis();\n        }\n        amount += fieldAmount;\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = zeroInstance.size() - start.size() + end.size();\n    for (int i = 0; i < zeroInstance.size(); i++) {\n        if (i >= start.size()) {\n            amount -= start.getValue(i, chrono);\n        } else if (i >= end.size()) {\n            amount += end.getValue(i, chrono);\n        } else {\n            int startValue = start.getValue(i, chrono);\n            int endValue = end.getValue(i, chrono);\n            if (startValue != endValue) {\n                amount += endValue - startValue;\n            }\n        }\n    }\n    return amount;\n}"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles == null) {\n        return null;\n    }\n    return (LegendTitle) this.subtitles.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles != null) \n    {\n        for (int i = 0; i < this.subtitles.size(); i++) \n        {\n            Title title = (Title) this.subtitles.get(i);\n            if (title instanceof LegendTitle) \n            {\n                if (index == 0) \n                {\n                    return (LegendTitle) title;\n                }\n                index--;\n            }\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    // check arguments...\n    if (index < 0) {\n        throw new IllegalArgumentException(\"Requires index >= 0.\");\n    }\n\n    // search for the legend...\n    LegendTitle result = null;\n    for (int i = 0; i < getSubtitleCount(); i++) {\n        Title t = getSubtitle(i);\n        if (t instanceof LegendTitle) {\n            if (index == 0) {\n                result = (LegendTitle) t;\n                break;\n            }\n            index--;\n        }\n    }\n    return result;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles != null) \n    {\n        for (int i = 0; i < this.subtitles.size(); i++) \n        {\n            Title title = (Title) this.subtitles.get(i);\n            if (title instanceof LegendTitle) \n            {\n                if (index == 0) \n                {\n                    return (LegendTitle) title;\n                }\n                index--;\n            }\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    // check arguments...\n    if (index < 0) {\n        throw new IllegalArgumentException(\"The 'index' argument must be \" +\n                \"non-negative.\");\n    }\n\n    // get the subtitle count...\n    int count = getSubtitleCount();\n\n    // check the index...\n    if (index >= count) {\n        return null;\n    }\n\n    // get the subtitle...\n    Title subtitle = getSubtitle(index);\n\n    // check the class...\n    if (!(subtitle instanceof LegendTitle)) {\n        return null;\n    }\n\n    // cast and return...\n    return (LegendTitle) subtitle;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles != null) \n    {\n        for (int i = 0; i < this.subtitles.size(); i++) \n        {\n            Title title = (Title) this.subtitles.get(i);\n            if (title instanceof LegendTitle) \n            {\n                if (index == 0) \n                {\n                    return (LegendTitle) title;\n                }\n                index--;\n            }\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles != null) \n    {\n        for (int i = 0; i < this.subtitles.size(); i++) \n        {\n            Title title = (Title) this.subtitles.get(i);\n            if (title instanceof LegendTitle) \n            {\n                if (index == 0) \n                {\n                    return (LegendTitle) title;\n                }\n                index--;\n            }\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    // check arguments...\n    if (index < 0) {\n        throw new IllegalArgumentException(\"Requires index >= 0.\");\n    }\n\n    // get the list of subtitles...\n    List subtitles = getSubtitles();\n    if (subtitles == null) {\n        return null;\n    }\n\n    // search for a legend...\n    int count = 0;\n    for (int i = 0; i < subtitles.size(); i++) {\n        Object obj = subtitles.get(i);\n        if (obj instanceof LegendTitle) {\n            if (count == index) {\n                return (LegendTitle) obj;\n            }\n            count++;\n        }\n    }\n\n    // no legend found...\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles != null) \n    {\n        for (int i = 0; i < this.subtitles.size(); i++) \n        {\n            Title title = (Title) this.subtitles.get(i);\n            if (title instanceof LegendTitle) \n            {\n                if (index == 0) \n                {\n                    return (LegendTitle) title;\n                }\n                index--;\n            }\n        }\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (this.subtitles == null) \n    {\n        return null;\n    }\n    if (index < 0 || index >= this.subtitles.size()) \n    {\n        return null;\n    }\n    return (LegendTitle) this.subtitles.get(index);\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    return Collections.enumeration(entries);\n}"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseOptionalParameterType(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseOptionalParameterType(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseOptionalParameterType(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseOptionalParameterType(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            }\n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    }\n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseOptionalParameterType(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            }\n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    }\n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseOptionalParameterType(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            }\n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    }\n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            }\n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    }\n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseOptionalParameterType(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    if (t == null) {\n        return Collections.emptyList();\n    }\n    final StringWriter sw = new StringWriter();\n    final PrintWriter pw = new PrintWriter(sw, true);\n    t.printStackTrace(pw);\n    final String trace = sw.getBuffer().toString();\n    final String[] frames = getStackFrames(trace);\n    final List<String> list = new ArrayList<String>(frames.length);\n    for (final String frame : frames) {\n        final int pos = frame.indexOf(\"at\");\n        if (pos >= 0) {\n            list.add(frame.substring(pos + 3));\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final StringWriter sw = new StringWriter();\n    final PrintWriter pw = new PrintWriter(sw, true);\n    t.printStackTrace(pw);\n    final String trace = sw.getBuffer().toString();\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(trace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    while (frames.hasMoreTokens()) {\n        list.add(frames.nextToken());\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final StringWriter sw = new StringWriter();\n    final PrintWriter pw = new PrintWriter(sw, true);\n    t.printStackTrace(pw);\n    final String trace = sw.getBuffer().toString();\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(trace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    while (frames.hasMoreTokens()) {\n        list.add(frames.nextToken());\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final StringWriter sw = new StringWriter();\n    final PrintWriter pw = new PrintWriter(sw, true);\n    t.printStackTrace(pw);\n    final String trace = sw.getBuffer().toString();\n    final String[] frames = ExceptionUtils.getStackFrames(trace);\n    final List<String> list = new ArrayList<String>();\n    for (final String frame : frames) {\n        final int i = frame.indexOf(\"at\");\n        if (i >= 0) {\n            list.add(frame.substring(i + 3));\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final StringWriter sw = new StringWriter();\n    final PrintWriter pw = new PrintWriter(sw, true);\n    t.printStackTrace(pw);\n    final String trace = sw.getBuffer().toString();\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(trace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    while (frames.hasMoreTokens()) \n    {\n        list.add(frames.nextToken());\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final StringWriter sw = new StringWriter();\n    final PrintWriter pw = new PrintWriter(sw, true);\n    t.printStackTrace(pw);\n    final String trace = sw.getBuffer().toString();\n    final String[] frames = ExceptionUtils.getStackFrames(trace);\n    final List<String> list = new ArrayList<String>();\n    for (int i = 0; i < frames.length; i++) {\n        list.add(frames[i]);\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final StringWriter sw = new StringWriter();\n    final PrintWriter pw = new PrintWriter(sw, true);\n    t.printStackTrace(pw);\n    final String trace = sw.getBuffer().toString();\n    final String linebreak = SystemUtils.LINE_SEPARATOR;\n    final StringTokenizer frames = new StringTokenizer(trace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    while (frames.hasMoreTokens()) {\n        list.add(frames.nextToken());\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final StringWriter sw = new StringWriter();\n    final PrintWriter pw = new PrintWriter(sw, true);\n    t.printStackTrace(pw);\n    final String trace = sw.getBuffer().toString();\n    final String[] frames = ExceptionUtils.getStackFrames(trace);\n    final List<String> list = new ArrayList<String>();\n    for (int i = 0; i < frames.length; i++) {\n        list.add(frames[i]);\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final StringWriter sw = new StringWriter();\n    final PrintWriter pw = new PrintWriter(sw, true);\n    t.printStackTrace(pw);\n    final String trace = sw.getBuffer().toString();\n    final String[] frames = ExceptionUtils.getStackFrames(trace);\n    final List<String> list = new ArrayList<String>();\n    for (final String frame : frames) {\n        final int space = frame.indexOf(' ');\n        if (space == -1) {\n            list.add(frame);\n        } else {\n            list.add(frame.substring(space + 1));\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final StringWriter sw = new StringWriter();\n    final PrintWriter pw = new PrintWriter(sw, true);\n    t.printStackTrace(pw);\n    final String trace = sw.getBuffer().toString();\n    final String[] frames = ExceptionUtils.getStackFrames(trace);\n    final List<String> list = new ArrayList<String>();\n    for (final String frame : frames) {\n        final int pos = frame.indexOf(\"at\");\n        if (pos >= 0) {\n            list.add(frame.substring(pos + 3));\n        }\n    }\n    return list;\n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  }\n  if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  }\n  if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } else if (p == PEEKED_FALSE) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    }\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  }\n  if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n}"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getSecondChild(); arg != null; arg = arg.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node argList = call.getSecondChild();\n  for (Node arg = argList.getFirstChild(); arg != null; arg = arg.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getSecondChild(); arg != null; arg = arg.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  Node arg = call.getSecondChild();\n  while (arg != null) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n    arg = arg.getNext();\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getSecondChild(); arg != null; arg = arg.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getSecondChild(); arg != null;\n       arg = arg.getNext()) {\n    if (mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getSecondChild(); arg != null; arg = arg.getNext()) {\n    if (mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getSecondChild(); arg != null; arg = arg.getNext()) {\n    if (mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getSecondChild(); arg != null; arg = arg.getNext()) {\n    if (mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n  for (Node arg = call.getSecondChild(); arg != null;\n       arg = arg.getNext()) {\n    if (NodeUtil.mayHaveSideEffects(arg)) {\n      return true;\n    }\n  }\n  return false;\n}"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = MatrixUtils.createFieldMatrix(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (true) {\n        c = reader.read();\n        // important: make sure a new char gets consumed in each iteration\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (isWhitespace(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (true) {\n        c = reader.read();\n        // important: make sure a new char gets consumed in each iteration\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (isWhitespace(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (true) {\n        c = reader.read();\n}\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (true) {\n        c = reader.read();\n}\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (true) {\n        c = reader.read();\n        // important: make sure a new char gets consumed in each iteration\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (isWhitespace(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (true) {\n        c = reader.read();\n        // important: make sure a new char gets consumed in each iteration\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (isWhitespace(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (true) {\n        c = reader.read();\n}\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (true) {\n        c = reader.read();\n        // important: make sure a new char gets consumed in each iteration\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (isWhitespace(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (true) {\n        c = reader.read();\n// Lexer.java\n// important: make sure a new char gets consumed in each iteration\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (isWhitespace(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    // save current line number in case needed for IOE\n    final long startLineNumber = getCurrentLineNumber();\n    int c;\n    while (true) {\n        c = reader.read();\n        // important: make sure a new char gets consumed in each iteration\n        while (token.type == INVALID) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces) {\n                while (isWhitespace(c) && !eol) {\n                    c = reader.read();\n                    eol = readEndOfLine(c);\n                }\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(c)) {\n                // empty token return TOKEN(\"\")\n                token.type = TOKEN;\n            } else if (eol) {\n                // empty token return EORECORD(\"\")\n                // noop: token.content.append(\"\");\n                token.type = EORECORD;\n            } else if (isQuoteChar(c)) {\n                // consume encapsulated token\n                parseEncapsulatedToken(token);\n            } else if (isEndOfFile(c)) {\n                // end of file return EOF()\n                // noop: token.content.append(\"\");\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n            } else {\n                // next token must be a simple token\n                // add removed blanks when not ignoring whitespace chars...\n                parseSimpleToken(token, c);\n            }\n        }\n        return token;\n    }\n}"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) \n    {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) \n    {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return counts;\n}"
    ],
    [
      "public JsonPointer last()  {\n    JsonPointer tail = _nextSegment;\n    if (tail == null) {\n        return this;\n    }\n    return tail.last();\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = this;\n    while (tail._nextSegment != null) {\n        tail = tail._nextSegment;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    if (this == EMPTY) {\n        return this;\n    }\n    JsonPointer tail = _nextSegment;\n    while (tail._nextSegment != null) {\n        tail = tail._nextSegment;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = _nextSegment;\n    if (tail == null) {\n        return this;\n    }\n    while (tail._nextSegment != null) {\n        tail = tail._nextSegment;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = _nextSegment;\n    if (tail == null) {\n        return this;\n    }\n    while (tail._nextSegment != null) {\n        tail = tail._nextSegment;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer ptr = this;\n    while (ptr._nextSegment != null) {\n        ptr = ptr._nextSegment;\n    }\n    return ptr;\n}",
      "public JsonPointer last()  {\n    if (this == EMPTY) {\n        return null;\n    }\n    JsonPointer ptr = this;\n    while (ptr._nextSegment != null) {\n        ptr = ptr._nextSegment;\n    }\n    return ptr;\n}",
      "public JsonPointer last()  {\n    JsonPointer ptr = this;\n    while (ptr._nextSegment != null) {\n        ptr = ptr._nextSegment;\n    }\n    return ptr;\n}",
      "public JsonPointer last()  {\n    if (_nextSegment == null) {\n        return this;\n    }\n    JsonPointer last = _nextSegment.last();\n    if (last == null) {\n        return null;\n    }\n    return last.head();\n}",
      "public JsonPointer last()  {\n    if (_nextSegment == null) {\n        return this;\n    }\n    JsonPointer last = _nextSegment;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer);\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  {\n    if (obj == null) \n    {\n        return null;\n    }\n    if (obj instanceof Cloneable) \n    {\n        try \n        {\n            @SuppressWarnings(\"unchecked\") // assume this is correct\n            final T clone = (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            return clone;\n        }\n        catch (final NoSuchMethodException ex) \n        {\n            throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \" does not implement cloneable\", ex);\n        }\n        catch (final IllegalAccessException ex) \n        {\n            throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \" is not accessible\", ex);\n        }\n        catch (final InvocationTargetException ex) \n        {\n            throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \" throws an exception during cloning\", ex);\n        }\n    }\n    return null;\n}\n\n    //-----------------------------------------------------------------------",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        } else if (obj instanceof Cloneable) {\n            try {\n                @SuppressWarnings(\"unchecked\") // ok because we create a new instance and there is no type mismatch\n                final T clone = (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n                return clone;\n            } catch (final NoSuchMethodException ex) {\n                throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \" does not implement cloneable\", ex);\n            } catch (final IllegalAccessException ex) {\n                throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \" is not accessible\", ex);\n            } catch (final InvocationTargetException ex) {\n                throw new CloneFailedException(\"Cloneable type \" + obj.getClass().getName() + \" throws an exception during cloning\", ex);\n            }\n        } else {\n            return obj;\n        }\n    }\n\n    // Null",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    } else if (obj instanceof Cloneable) {\n        try {\n            @SuppressWarnings(\"unchecked\") // ok because we create a new instance of the right type\n                    final T clone = (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final IllegalAccessException ex) {\n            throw new CloneFailedException(obj, ex);\n        } catch (final IllegalArgumentException ex) {\n            throw new CloneFailedException(obj, ex);\n        } catch (final NoSuchMethodException ex) {\n            throw new CloneFailedException(obj, ex);\n        } catch (final SecurityException ex) {\n            throw new CloneFailedException(obj, ex);\n        } catch (final InvocationTargetException ex) {\n            throw new CloneFailedException(obj, ex);\n        }\n    } else {\n        return null;\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    } else if (obj instanceof Cloneable) {\n        try {\n            @SuppressWarnings(\"unchecked\") // ok because we have a return type\n            final T clone = (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final IllegalAccessException ex) {\n            throw new CloneFailedException(\"Cloning failed.\", ex);\n        } catch (final InvocationTargetException ex) {\n            throw new CloneFailedException(\"Cloning failed.\", ex);\n        } catch (final NoSuchMethodException ex) {\n            throw new CloneFailedException(\"Cloning failed.\", ex);\n        }\n    } else {\n        return obj;\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    } else if (obj instanceof Cloneable) {\n        try {\n            @SuppressWarnings(\"unchecked\") // ok because we create a new instance of the right type\n            final T clone = (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final NoSuchMethodException ex) {\n            throw new CloneFailedException(\"Clone not supported due to missing method\", ex);\n        } catch (final IllegalAccessException ex) {\n            throw new CloneFailedException(\"Clone not accessible\", ex);\n        } catch (final InvocationTargetException ex) {\n            throw new CloneFailedException(\"Clone operation failed\", ex.getTargetException());\n        }\n    } else {\n        return null;\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    } else if (obj instanceof Cloneable) {\n        try {\n            @SuppressWarnings(\"unchecked\") // ok because we create a new instance\n            final T clone = (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final NoSuchMethodException ex) {\n            throw new CloneFailedException(\"Clone not supported due to missing method\", ex);\n        } catch (final IllegalAccessException ex) {\n            throw new CloneFailedException(\"Clone not accessible\", ex);\n        } catch (final InvocationTargetException ex) {\n            throw new CloneFailedException(\"Clone operation failed\", ex.getTargetException());\n        }\n    } else {\n        return obj;\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) \n    {\n        return null;\n    }\n    if (obj instanceof Cloneable) \n    {\n        try \n        {\n            @SuppressWarnings(\"unchecked\") // ok because we create a new instance with the same type T\n            final T clone = (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            return clone;\n        } \n        catch (final NoSuchMethodException ex) \n        {\n            throw new CloneFailedException(\"Clone not supported due to missing method\", ex);\n        } \n        catch (final IllegalAccessException ex) \n        {\n            throw new CloneFailedException(\"Clone not accessible\", ex);\n        } \n        catch (final InvocationTargetException ex) \n        {\n            throw new CloneFailedException(\"Clone operation failed\", ex.getTargetException());\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    } else if (obj instanceof Cloneable) {\n        try {\n            @SuppressWarnings(\"unchecked\") // ok because we create a new instance of the same class\n                    final T clone = (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final IllegalAccessException ex) {\n            throw new CloneFailedException(\"Cloning failed.\", ex);\n        } catch (final IllegalArgumentException ex) {\n            throw new CloneFailedException(\"Cloning failed.\", ex);\n        } catch (final InvocationTargetException ex) {\n            throw new CloneFailedException(\"Cloning failed.\", ex);\n        } catch (final NoSuchMethodException ex) {\n            throw new CloneFailedException(\"Cloning failed.\", ex);\n        }\n    } else {\n        return null;\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    } else if (obj instanceof Cloneable) {\n        try {\n            @SuppressWarnings(\"unchecked\") // OK, because we create a new instance of 'cls' which is a subclass of 'obj's class\n                    final T clone = (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            return clone;\n        } catch (final Throwable ex) {\n            throw new CloneFailedException(\"Cloning failed.\", ex);\n        }\n    } else {\n        return obj;\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) \n    {\n        return null;\n    }\n    if (obj instanceof Cloneable) \n    {\n        try \n        {\n            @SuppressWarnings(\"unchecked\") // assume this can be cast to T\n            final T clone = (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            return clone;\n        }\n        catch (final IllegalAccessException ex) \n        {\n            throw new CloneFailedException(\"Cloning failed.\", ex);\n        }\n        catch (final InvocationTargetException ex) \n        {\n            throw new CloneFailedException(\"Cloning failed.\", ex);\n        }\n        catch (final NoSuchMethodException ex) \n        {\n            throw new CloneFailedException(\"Cloning failed.\", ex);\n        }\n    }\n    return null;\n}\n\n// ObjectUtils.java\n// Mode"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (!sym.isFunction()) \n  {\n    return null;\n  }\n  FunctionType type = sym.getFunctionType();\n  if (type == null) \n  {\n    return null;\n  }\n  if (!type.hasInstanceType()) \n  {\n    return null;\n  }\n  ObjectType instanceType = type.getInstanceType();\n  if (!instanceType.hasReferenceName()) \n  {\n    return null;\n  }\n  String name = instanceType.getReferenceName();\n  SymbolScope scope = getScope(name);\n  if (scope == null) \n  {\n    return null;\n  }\n  return scope.getQualifiedSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  SymbolScope scope = getScopeInFunction(sym);\n  if (scope == null) {\n    return null;\n  }\n  return scope.getQualifiedSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (!sym.getType().isFunctionType()) \n    {\n        return null;\n    }\n\n    FunctionType type = sym.getFunctionType();\n    if (type == null) \n    {\n        return null;\n    }\n\n    String name = NodeUtil.getBestLValueName(\n            NodeUtil.getBestLValue(type.getSource()));\n    if (name == null) \n    {\n        return null;\n    }\n\n    SymbolScope scope = getScope(getSymbolForName(type.getSource(), name));\n    if (scope == null) \n    {\n        return null;\n    }\n\n    return scope.getQualifiedSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) \n  {\n    return null;\n  }\n  return type.getParameter(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) \n  {\n    return null;\n  }\n\n  SymbolScope scope = getScopeInFunction(sym);\n  if (scope == null) \n  {\n    return null;\n  }\n\n  return scope.getQualifiedSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getFunctionType() == null)\n    {\n        return null;\n    }\n\n    // This is a function, so it must have a scope.\n    SymbolScope functionScope = getScope(sym);\n\n    // Look for the parameter in the function scope.\n    Symbol param = functionScope.getQualifiedSlot(paramName);\n\n    // If we found the parameter, return it.\n    if (param != null)\n    {\n        return param;\n    }\n\n    // If we didn't find the parameter, try looking in the function's\n    // parent scope.\n    SymbolScope parentScope = functionScope.getParentScope();\n    if (parentScope != null)\n    {\n        return getParameterInFunction(getSymbolForScope(parentScope), paramName);\n    }\n\n    // We didn't find the parameter.\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) \n    {\n        return null;\n    }\n\n    for (Symbol slot : type.getParameters()) \n    {\n        if (slot.getName().equals(paramName)) \n        {\n            return slot;\n        }\n    }\n\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n    return type.getParameter(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  FunctionType type = sym.getFunctionType();\n  if (type == null) \n  {\n    return null;\n  }\n  SymbolScope scope = getScopeInFunction(sym);\n  if (scope == null) \n  {\n    return null;\n  }\n  Symbol param = scope.getQualifiedSlot(paramName);\n  if (param == null) \n  {\n    return null;\n  }\n  return param;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  if (!sym.isFunction()) {\n    return null;\n  }\n  FunctionType type = sym.getFunctionType();\n  if (type == null) {\n    return null;\n  }\n  String name = NodeUtil.getBestLValueName(\n      NodeUtil.getBestLValue(type.getSource()));\n  if (name == null) {\n    return null;\n  }\n  return type.getScope().getQualifiedSlot(name).getParameterInFunction(paramName);\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getRowDimension();\n        int p = matrix.getColumnDimension();\n        RealMatrix m = matrix.transpose().multiply(matrix);\n        m.walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\n}\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int m = matrix.getColumnDimension();\n        int n = matrix.getRowDimension();\n        if (m < 2 || n < 1) {\n            throw new MathIllegalArgumentException(LocalizedCoreFormats.INSUFFICIENT_DATA);\n        }\n        double[][] data = new double[m][m];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < m; j++) {\n                data[i][j] = matrix.getEntry(i, j);\n            }\n        }\n        return computeCovarianceMatrix(data, biasCorrected);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getRowDimension();\n        int p = matrix.getColumnDimension();\n        double[][] data = new double[p][p];\n        for (int i = 0; i < p; i++) {\n            for (int j = i; j < p; j++) {\n                data[i][j] = matrix.getEntry(i, j);\n                data[j][i] = data[i][j];\n            }\n        }\n        return new BlockRealMatrix(data);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getRowDimension();\n        RealMatrix m = matrix.transpose().multiply(matrix);\n        m = m.scalarMultiply(1.0 / (n - (biasCorrected ? 1 : 0)));\n        return m;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        n = matrix.getRowDimension();\n        RealMatrix m = matrix.transpose().multiply(matrix);\n        if (biasCorrected) {\n            m.walkInOptimizedOrder(new CovarianceChangingVisitor(n));\n        }\n        return m.scalarMultiply(1.0 / (n - 1));\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        n = matrix.getRowDimension();\n        double[][] data = matrix.getData();\n        double[][] covariance = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                covariance[i][j] = computeCovariance(data, i, j, biasCorrected);\n                covariance[j][i] = covariance[i][j];\n            }\n        }\n        return new BlockRealMatrix(covariance);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getRowDimension();\n        int p = matrix.getColumnDimension();\n        double[][] data = new double[n][p];\n        for (int i = 0; i < n; i++) {\n            data[i] = matrix.getRow(i);\n        }\n        return computeCovarianceMatrix(data, biasCorrected);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        n = matrix.getRowDimension();\n        double[][] data = matrix.getData();\n        double[][] covarianceMatrix = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                double covariance = computeCovariance(data[i], data[j], biasCorrected);\n                covarianceMatrix[i][j] = covariance;\n                covarianceMatrix[j][i] = covariance;\n            }\n        }\n        return new BlockRealMatrix(covarianceMatrix);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        n = matrix.getRowDimension();\n        double[][] data = matrix.getData();\n        double[][] covariance = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                covariance[i][j] = data[i][j] - data[i][i] * data[j][j] / n;\n            }\n        }\n        return new BlockRealMatrix(covariance);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        n = matrix.getRowDimension();\n        final int m = matrix.getColumnDimension();\n        final double[][] data = new double[m][m];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < m; j++) {\n                data[i][j] = matrix.getEntry(i, j);\n            }\n        }\n        return computeCovarianceMatrix(data, biasCorrected);\n    }"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (count == 0) {\n        return 0;\n    }\n    if (ensureCache(count)) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCachedSize -= count;\n        bitsCached >>>= count;\n        return bitsOut;\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (ensureCache(count)) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCachedSize -= count;\n        bitsCached >>>= count;\n        return bitsOut;\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > 63) {\n        throw new IllegalArgumentException(\"count must be between 0 and 63\");\n    }\n    if (count == 0) {\n        return 0;\n    }\n    if (ensureCache(count)) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCachedSize -= count;\n        bitsCached >>>= count;\n        return bitsOut;\n    }\n    return processBitsGreater57(count);\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        return processBitsGreater57(count);\n    }\n    if (count < 0) {\n        throw new IllegalArgumentException(\"Negative count\");\n    }\n    if (count == 0) {\n        return 0;\n    }\n    ensureCache(count);\n    final int cacheSize = bitsCachedSize;\n    final long bitsOut = bitsCached & MASKS[cacheSize];\n    bitsCachedSize = cacheSize - count;\n    bitsCached >>>= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > 63) {\n        throw new IllegalArgumentException(\"Count must be less than 64\");\n    }\n    if (count < 0) {\n        throw new IllegalArgumentException(\"Count must be positive\");\n    }\n    if (count == 0) {\n        return 0;\n    }\n    if (ensureCache(count)) {\n        return bitsCached & MASKS[count];\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"Count must be between 0 and \" + MAXIMUM_CACHE_SIZE + \" (was \" + count + \")\");\n    }\n    if (ensureCache(count)) {\n        final long bitsOut = bitsCached & MASKS[count];\n        bitsCachedSize -= count;\n        bitsCached >>>= count;\n        return bitsOut;\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > 63) {\n        throw new IllegalArgumentException(\"count must be smaller than 64\");\n    }\n    if (count < 0) {\n        throw new IllegalArgumentException(\"count must be positive\");\n    }\n    if (count == 0) {\n        return 0;\n    }\n    if (ensureCache(count)) {\n        final int bitsToSkip = bitsCachedSize - count;\n        bitsCachedSize = count;\n        bitsCached = bitsCached >>> bitsToSkip;\n        return bitsCached;\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"Maximum number of bits that can be read is 63\");\n    }\n    if (count < 0) {\n        throw new IllegalArgumentException(\"Number of bits to read must be positive\");\n    }\n    if (count == 0) {\n        return 0;\n    }\n    if (ensureCache(count)) {\n        final long bits = bitsCached & MASKS[count];\n        bitsCachedSize -= count;\n        bitsCached >>>= count;\n        return bits;\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (ensureCache(count)) {\n        return bitsCached & MASKS[count];\n    }\n    return -1;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > 63) {\n        throw new IllegalArgumentException(\"count must be between 0 and 63\");\n    }\n    if (count == 0) {\n        return 0;\n    }\n    if (count > bitsCachedSize) {\n        if (!ensureCache(count)) {\n            return -1;\n        }\n    }\n    final long bitsOut = bitsCached & MASKS[count];\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return byteOrder == ByteOrder.LITTLE_ENDIAN ? bitsOut : Long.reverseBytes(bitsOut);\n}"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> product;\n    if (v instanceof SparseFieldVector<?>) {\n        product = new SparseFieldMatrix<T>(field, m, n);\n    } else {\n        product = new Array2DRowFieldMatrix<T>(field, m, n);\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            product.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return product;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> product;\n    if (v instanceof SparseFieldVector<?>) {\n        product = new SparseFieldMatrix<T>(field, m, n);\n    } else {\n        product = new Array2DRowFieldMatrix<T>(field, m, n);\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            product.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return product;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    return new Array2DRowFieldMatrix<T>(field, data, v.data);\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> product;\n    if (v instanceof SparseArrayFieldVector<?>) {\n        product = new SparseFieldMatrix<T>(field, m, n);\n    } else {\n        product = new Array2DRowFieldMatrix<T>(field, m, n);\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            product.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return product;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    return new Array2DRowFieldMatrix<T>(field, data, v.getData());\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    return new Array2DRowFieldMatrix<T>(field, data, v.getData());\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    return outerProduct((FieldVector<T>) v);\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    return outerProduct((FieldVector<T>) v);\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    return new Array2DRowFieldMatrix<T>(field, this, v);\n}"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node parent = target.getParent();\n  while (parent != null) {\n    if (parent.isLabel() && label.equals(parent.getFirstChild().getString())) {\n      return true;\n    }\n    parent = parent.getParent();\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target.isLabel()) {\n    return label.equals(target.getFirstChild().getString());\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target.isLabel()) {\n    return label.equals(target.getFirstChild().getString());\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target.isLabel()) {\n    return label.equals(target.getFirstChild().getString());\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node parent = target.getParent();\n  if (parent.isLabel() && parent.getFirstChild().getString().equals(label)) {\n    return true;\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target.isLabel()) {\n    return label.equals(target.getFirstChild().getString());\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node parent = target.getParent();\n  while (parent != null) {\n    if (parent.isLabel()) {\n      return label.equals(parent.getFirstChild().getString());\n    }\n    parent = parent.getParent();\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target.isLabel()) {\n    return label.equals(target.getFirstChild().getString());\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target.isLabel()) {\n    return label.equals(target.getFirstChild().getString());\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target.isLabel()) {\n    return label.equals(target.getFirstChild().getString());\n  }\n  return false;\n}"
    ],
    [
      "public String getURL(int series, int item)  {\n    String result = null;\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null) {\n        result = generator.generateURL(this.dataset, series, item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null) {\n        return generator.generateURL(this.dataset, series, item);\n    }\n    else {\n        return null;\n    }\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null) {\n        result = generator.generateURL(getDataset(), series, item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null) {\n        XYDataset dataset = getPlot().getDataset();\n        if (dataset != null) {\n            result = generator.generateURL(dataset, series, item);\n        }\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null) \n    {\n        XYDataset dataset = getPlot().getDataset();\n        if (dataset != null) \n        {\n            result = generator.generateURL(dataset, series, item);\n        }\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null) \n    {\n        XYDataset dataset = getPlot().getDataset();\n        result = generator.generateURL(dataset, series, item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null) {\n        result = generator.generateURL(getDataset(), series, item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null) {\n        return generator.generateURL(this.dataset, series, item);\n    }\n    else {\n        return null;\n    }\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null) {\n        return generator.generateURL(getDataset(), series, item);\n    }\n    else {\n        return null;\n    }\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator != null)  {\n        return generator.generateURL(this.dataset, series, item);\n    } else  {\n        return null;\n    }\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c < '0') {\n        return -1;\n    }\n    if (c > '9') {\n        return -1;\n    }\n    int i = 0;\n    int v = c - '0';\n    for (; i < len; ++i) {\n        c = str.charAt(i);\n        if (c < '0') {\n            return -1;\n        }\n        if (c > '9') {\n            return -1;\n        }\n        v = v * 10 + (c - '0');\n    }\n    return v;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    int i = 0;\n    if (str.charAt(0) == '0') {\n        if (len == 1) {\n            return 0;\n        }\n        char c = str.charAt(1);\n        if (c == 'x' || c == 'X') {\n            if (len > 2) {\n                return Integer.parseInt(str.substring(2), 16);\n            }\n        } else {\n            while (i < len) {\n                c = str.charAt(i);\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                i++;\n            }\n            if (i == len) {\n                return 0;\n            }\n        }\n    }\n    while (i < len) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            break;\n        }\n        i++;\n    }\n    if (i == 0) {\n        return -1;\n    }\n    return Integer.parseInt(str.substring(0, i));\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    int i = 0;\n    while (i < len) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n        i++;\n    }\n    return Integer.parseInt(str);\n}\nprotected JsonPointer _parseTail(String input) \n{\n    int len = input.length();\n    if (len == 0) {\n        return this;\n    }\n    char c = input.charAt(0);\n    if (c == SEPARATOR) {\n        return new JsonPointer(input, null, this);\n    }\n    if (c == '~') {\n        if (len < 2) {\n            return null;\n        }\n        c = input.charAt(1);\n        if (c == '1') {\n            return new JsonPointer(input, input.substring(2), this);\n        }\n        if (c == '0') {\n            return new JsonPointer(input, input.substring(2), this);\n        }\n        return null;\n    }\n    if (c == '/') {\n        return new JsonPointer(input, input.substring(1), this);\n    }\n    if (c == '~') {\n        if (len < 2) {\n            return null;\n        }\n        c = input.charAt(1);\n        if (c == '1') {\n            return new JsonPointer(input, input.substring(2), this);\n        }\n        if (c == '0') {\n            return new JsonPointer(input, input.substring(2), this);\n        }\n        return null;\n    }\n    if (c == '0') {\n        if (len == 1) {\n            return new JsonPointer(input, null, this);\n        }\n        c = input.charAt(1);\n}\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    int i = 0;\n    char c = str.charAt(0);\n    if (c == '0') {\n        if (len == 1) {\n            return 0;\n        }\n        c = str.charAt(1);\n        if (c == 'x' || c == 'X') {\n            if (len == 2) {\n                return -1;\n            }\n            i = 2;\n            for (; i < len; ++i) {\n                c = str.charAt(i);\n                if (c > '9' || c < '0') {\n                    break;\n                }\n            }\n            if (i == len) {\n                return -1;\n            }\n        }\n    }\n    for (; i < len; ++i) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            break;\n        }\n    }\n    if (i == len) {\n        return -1;\n    }\n    return i;\n}\n\nprotected static JsonPointer _parseTail(String input) \n{\n    int len = input.length();\n    if (len == 0) {\n        return EMPTY;\n    }\n    int i = 0;\n    char c = input.charAt(0);\n    if (c == '/') {\n        if (len == 1) {\n            return EMPTY;\n        }\n        i = 1;\n        c = input.charAt(i);\n    }\n    if (c == '~') {\n        if (len == 1) {\n            return EMPTY;\n        }\n        i = 1;\n        c = input.charAt(i);\n        if (c == '1') {\n            if (len == 2) {\n                return EMPTY;\n            }\n            i = 2;\n            c = input.charAt(i);\n            if (c == '~') {\n}\n}\n}\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c == '0') {\n        if (len == 1) {\n            return 0;\n        }\n        c = str.charAt(1);\n        if (c == 'x' || c == 'X') {\n            return Integer.parseInt(str.substring(2), 16);\n        }\n    }\n    return Integer.parseInt(str);\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    int i = 0;\n    int result = 0;\n    while (i < len) {\n        c = str.charAt(i++);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n        result = (result * 10) + (c - '0');\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    int i = 0;\n    if (str.charAt(0) == '0') {\n        if (len == 1) {\n            return 0;\n        }\n        char c = str.charAt(1);\n        if (c == 'x' || c == 'X') {\n            if (len >= 3) {\n                int radix = 16;\n                int max = Integer.MAX_VALUE / radix;\n                int result = 0;\n                for (i = 2; i < len; ++i) {\n                    c = str.charAt(i);\n                    int digit = CharTypes.charToHex(c);\n                    if (digit == -1) {\n                        break;\n                    }\n                    if (result < max) {\n                        result = result * radix + digit;\n                    } else {\n                        result = Integer.MAX_VALUE;\n                        while (++i < len) {\n                            if (str.charAt(i) != '0') {\n                                break;\n                            }\n                        }\n                        break;\n                    }\n                }\n                if (i == 2) {\n                    return 0;\n                }\n                if (i == len) {\n                    return result;\n                }\n            }\n        }\n    } else {\n        int radix = 10;\n        int max = Integer.MAX_VALUE / radix;\n        int result = 0;\n        for (; i < len; ++i) {\n            c = str.charAt(i);\n            int digit = CharTypes.charToDecimal(c);\n            if (digit == -1) {\n                break;\n            }\n            if (result < max) {\n                result = result * radix + digit;\n            } else {\n                result = Integer.MAX_VALUE;\n                while (++i < len) {\n                    if (str.charAt(i) != '0') {\n                        break;\n                    }\n                }\n}\n}\n}\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    int i = 0;\n    if (str.charAt(0) == '0') {\n        if (len == 1) {\n            return 0;\n        }\n        char c = str.charAt(1);\n        if (c == 'x' || c == 'X') {\n            i = 2;\n        }\n    }\n    for (; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    int i = 0;\n    char c = str.charAt(0);\n    if (c == '0') {\n        if (len == 1) {\n            return 0;\n        }\n        c = str.charAt(1);\n        if (c == 'x' || c == 'X') {\n            i = 2;\n            if (i < len) {\n                c = str.charAt(i);\n                if (c >= '0' && c <= '9') {\n                    return pad(Integer.parseInt(str.substring(i), 16), 4);\n                }\n            }\n        }\n    }\n    while (i < len) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n        i++;\n    }\n    return Integer.parseInt(str);\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    int i = 0;\n    if (str.charAt(0) == '0') {\n        if (len == 1) {\n            return 0;\n        }\n        if (str.charAt(1) == 'x' || str.charAt(1) == 'X') {\n            i = 2;\n            if (i == len) {\n                return -1;\n            }\n            if (!Character.isDigit(str.charAt(i))) {\n                return -1;\n            }\n        }\n    }\n    for (; i < len; ++i) {\n        char ch = str.charAt(i);\n        if (!Character.isDigit(ch)) {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return RandomDataGenerator.nextSample(c, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_POPULATION_SIZE,\n                k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                k);\n    }\n\n    int[] index = nextPermutation(c.size(), k);\n    Object[] out = new Object[k];\n    for (int i = 0; i < k; i++) {\n        out[i] = c.toArray()[index[i]];\n    }\n\n    return out;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_POPULATION_SIZE,\n                k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                k);\n    }\n\n    int[] index = nextPermutation(c.size(), k);\n    Object[] out = new Object[k];\n    for (int i = 0; i < k; i++) {\n        out[i] = c.toArray()[index[i]];\n    }\n\n    return out;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return RandomDataGenerator.nextSample(c, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) \n    {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_POPULATION_SIZE,\n                k, c.size(), true);\n    }\n    if (k <= 0) \n    {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                k);\n    }\n\n    int[] index = nextPermutation(c.size(), k);\n    Object[] out = new Object[k];\n    for (int i = 0; i < k; i++) \n    {\n        out[i] = c.get(index[i]);\n    }\n\n    return out;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return nextPermutation(c.size(), k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return RandomDataGenerator.nextSample(c, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return RandomDataGenerator.nextSample(c, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    return RandomDataGenerator.nextSample(c, k);\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node call = new Node(Token.CALL, new Node(Token.GETPROP,\n      argumentNode, new Node(Token.STRING, methodName)));\n  call.srcrefTree(srcref);\n  return call;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  return new Node(Token.CALL,\n      new Node(Token.GETPROP,\n          new Node(Token.THIS, \"this\"),\n          new Node(Token.STRING, methodName)),\n      argumentNode).srcref(srcref);\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node call = new Node(Token.CALL, new Node(Token.GETPROP,\n      argumentNode, new Node(Token.STRING, methodName)));\n  call.srcrefTree(srcref);\n  return call;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  return new Node(Token.CALL,\n      new Node(Token.GETPROP,\n          new Node(Token.THIS, \"this\"),\n          new Node(Token.STRING, methodName)),\n      argumentNode).srcref(srcref);\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node call = new Node(Token.CALL,\n      new Node(Token.GETPROP,\n          new Node(Token.THIS, \"this\"),\n          new Node(Token.STRING, methodName)));\n  call.srcrefTree(srcref);\n  call.addChildToBack(argumentNode);\n  return call;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node call = new Node(Token.CALL,\n      new Node(Token.GETPROP,\n          new Node(Token.THIS, \"this\"),\n          new Node(Token.STRING, methodName)));\n  call.srcrefTree(srcref);\n  call.addChildToBack(argumentNode);\n  return call;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node call = new Node(Token.CALL,\n      new Node(Token.GETPROP,\n          new Node(Token.THIS, \"this\"),\n          new Node(Token.STRING, methodName)));\n  call.setLength(argumentNode.getLength());\n  call.setSourceFile(srcref.getStaticSourceFile());\n  call.setLineno(srcref.getLineno());\n  call.setCharno(srcref.getCharno());\n  call.addChildToBack(argumentNode);\n  return call;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node call = new Node(Token.CALL, new Node(Token.GETPROP,\n      new Node(Token.THIS, \"this\"),\n      new Node(Token.STRING, methodName)));\n  call.srcrefTree(srcref);\n  call.getFirstChild().getLastChild().addChildToBack(argumentNode);\n  return call;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node call = new Node(Token.CALL,\n      new Node(Token.GETPROP,\n          new Node(Token.THIS, \"this\"),\n          new Node(Token.STRING, methodName)),\n      argumentNode);\n  call.setSourceFileName(srcref.getSourceFileName());\n  call.setLineno(srcref.getLineno());\n  call.setCharno(srcref.getCharno());\n  return call;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n  Node call = new Node(Token.CALL,\n      new Node(Token.GETPROP,\n          new Node(Token.THIS, \"this\"),\n          new Node(Token.STRING, methodName)));\n  call.setLineno(srcref.getLineno());\n  call.setCharno(srcref.getCharno());\n  call.addChildToBack(argumentNode);\n  return call;\n}"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indexValue = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) \n    {\n        indexValue[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indexValue);\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) \n    {\n        indices[i] = indexValue[i].index;\n    }\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indexValue = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) \n    {\n        indexValue[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indexValue);\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) \n    {\n        indices[i] = indexValue[i].index;\n    }\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    final int[] sorted = new int[indices.length];\n    for (int i = 0; i < sorted.length; i++) {\n        sorted[i] = indices[i].index;\n    }\n    return sorted;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indexValue = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) \n    {\n        indexValue[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indexValue);\n    final int[] indices = new int[indexValue.length];\n    for (int i = 0; i < indexValue.length; i++) \n    {\n        indices[i] = indexValue[i].index;\n    }\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] doubleIndices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        doubleIndices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(doubleIndices);\n    final int[] indices = new int[doubleIndices.length];\n    for (int i = 0; i < doubleIndices.length; i++) {\n        indices[i] = doubleIndices[i].index;\n    }\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] doubleIndices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) \n    {\n        doubleIndices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(doubleIndices);\n    final int[] indices = new int[doubleIndices.length];\n    for (int i = 0; i < doubleIndices.length; i++) \n    {\n        indices[i] = doubleIndices[i].index;\n    }\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] doubleIndices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) \n    {\n        doubleIndices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(doubleIndices);\n    final int[] indices = new int[doubleIndices.length];\n    for (int i = 0; i < doubleIndices.length; i++) \n    {\n        indices[i] = doubleIndices[i].index;\n    }\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) \n    {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    final int[] sorted = new int[indices.length];\n    for (int i = 0; i < sorted.length; i++) \n    {\n        sorted[i] = indices[i].index;\n    }\n    return sorted;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    final int[] sorted = new int[indices.length];\n    for (int i = 0; i < sorted.length; i++) {\n        sorted[i] = indices[i].index;\n    }\n    return sorted;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    final int[] sorted = new int[indices.length];\n    for (int i = 0; i < sorted.length; i++) {\n        sorted[i] = indices[i].index;\n    }\n    return sorted;\n}"
    ],
    [
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n\n    // return the cached matrix\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n\n    // return the cached matrix\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) \n    {\n        result = this.defaultGroup;\n    }\n    return result;\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n        if (buffer.length < capacity) {\n            final char[] old = buffer;\n            buffer = new char[capacity];\n            System.arraycopy(old, 0, buffer, 0, size);\n        }\n        return this;\n    }",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n        if (buffer.length < capacity) {\n            final char[] old = buffer;\n            buffer = new char[capacity];\n            System.arraycopy(old, 0, buffer, 0, size);\n        }\n        return this;\n    }",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (buffer.length < capacity) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset, true);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // TODO: implement this method\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // check arguments\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    // find the range\n    int seriesCount = dataset.getRowCount();\n    int itemCount = dataset.getColumnCount();\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    for (int series = 0; series < seriesCount; series++) {\n        double runningTotal = 0.0;\n        for (int item = 0; item < itemCount; item++) {\n            double value = dataset.getValue(series, item);\n            if (!Double.isNaN(value)) {\n                runningTotal = runningTotal + value;\n                minimum = Math.min(minimum, runningTotal);\n                maximum = Math.max(maximum, runningTotal);\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // check arguments\n    if (dataset == null)\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n\n    // find the range\n    int seriesCount = dataset.getColumnCount();\n    int itemCount = dataset.getRowCount();\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    for (int s = 0; s < seriesCount; s++)\n    {\n        double cumulative = 0.0;\n        for (int i = 0; i < itemCount; i++)\n        {\n            double value = dataset.getValue(i, s).doubleValue();\n            if (!Double.isNaN(value))\n            {\n                cumulative += value;\n                minimum = Math.min(minimum, cumulative);\n                maximum = Math.max(maximum, cumulative);\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset, true);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    return findCumulativeRangeBounds(dataset, 0.0);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) \n    {\n        double total = 0.0;\n        int itemCount = dataset.getItemCount(s);\n        for (int i = 0; i < itemCount; i++) \n        {\n            double value = dataset.getValue(s, i);\n            if (!Double.isNaN(value)) \n            {\n                total = total + value;\n            }\n        }\n        if (result == null) \n        {\n            result = new Range(total, total);\n        }\n        else \n        {\n            result = Range.expandToInclude(result, total);\n        }\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    return findCumulativeRangeBounds(dataset, 0.0);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    // calculate the total for each series\n    double[] totals = new double[dataset.getRowCount()];\n    for (int s = 0; s < dataset.getRowCount(); s++) \n    {\n        double total = 0.0;\n        for (int i = 0; i < dataset.getColumnCount(); i++) \n        {\n            double value = dataset.getValue(s, i);\n            if (!Double.isNaN(value)) \n            {\n                total = total + value;\n            }\n        }\n        totals[s] = total;\n    }\n\n    // find the minimum and maximum values in the array\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    for (int i = 0; i < totals.length; i++) \n    {\n        if (totals[i] < minimum) \n        {\n            minimum = totals[i];\n        }\n        if (totals[i] > maximum) \n        {\n            maximum = totals[i];\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof RangeInfo) {\n        RangeInfo info = (RangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset, true);\n    }\n    return result;\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Invalid hours offset: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Invalid minutes offset: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be positive when hours are positive\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (totalMinutes > 23 * 60 + 59 || totalMinutes < -23 * 60 - 59) {\n        throw new IllegalArgumentException(\"Total minutes out of range: \" + totalMinutes);\n    }\n    return fixedOffsetZone(createShortName(hoursOffset, minutesOffset), totalMinutes * DateTimeConstants.MILLIS_PER_MINUTE);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Invalid hours offset: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Invalid minutes offset: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be positive when hours are positive\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (totalMinutes > 23 * 60 + 59 || totalMinutes < -23 * 60 - 59) {\n        throw new IllegalArgumentException(\"Total offset exceeds +/- 23:59:59.000\");\n    }\n    return new DateTimeZone(DateTimeZone.class, \"UTC\" + (totalMinutes < 0 ? \"-\" : \"+\") + Math.abs(totalMinutes / 60) + \":\" + (totalMinutes % 60));\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Invalid hours offset: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Invalid minutes offset: \" + minutesOffset);\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes must be zero or positive when hours are positive\");\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (totalMinutes >= -14 * 60 && totalMinutes < 14 * 60) {\n        return DateTimeZone.getDefault();\n    }\n    return fixedOffsetZone(totalMinutes < 0 ? \"UTC-\" : \"UTC+\", Math.abs(totalMinutes));\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Invalid hours offset: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Invalid minutes offset: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be positive when hours are positive\");\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (totalMinutes > 23 * 60 + 59 || totalMinutes < -23 * 60 - 59) {\n        throw new IllegalArgumentException(\"Total minutes out of range: \" + totalMinutes);\n    }\n    return fixedOffsetZone(formatOffset(hoursOffset, minutesOffset), totalMinutes);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Invalid hours offset: \" + hoursOffset);\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Invalid minutes offset: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be positive when hours are positive: \" + hoursOffset + \":\" + minutesOffset);\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes > 23 * 60 + 59 || totalMinutes < -23 * 60 - 59) {\n        throw new IllegalArgumentException(\"Total minutes out of range: \" + totalMinutes);\n    }\n    return fixedOffsetZone(createShortName(hoursOffset, minutesOffset), totalMinutes);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Invalid hours offset: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Invalid minutes offset: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be positive when hours are positive\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (minutesOffset == 0) {\n        return fixedOffsetZone(String.format(\"%+03d:00\", hoursOffset), hoursOffset * 60);\n    }\n    return fixedOffsetZone(String.format(\"%+03d:%02d\", hoursOffset, minutesOffset), (hoursOffset * 60) + minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Invalid hoursOffset: \" + hoursOffset);\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Invalid minutesOffset: \" + minutesOffset);\n    }\n    if (hoursOffset >= 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be positive when hours are positive\");\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes > 23 * 60 + 59 || totalMinutes < -23 * 60 - 1) {\n        throw new IllegalArgumentException(\"Invalid offset: \" + hoursOffset + \":\" + minutesOffset);\n    }\n    return fixedOffsetZone(createShortName(hoursOffset, minutesOffset), totalMinutes);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Invalid hours offset: \" + hoursOffset);\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Invalid minutes offset: \" + minutesOffset);\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes must be positive when hours are positive\");\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes > 23 * 60 + 59 || totalMinutes < -23 * 60 - 59) {\n        throw new IllegalArgumentException(\"Invalid total offset: \" + totalMinutes);\n    }\n    return fixedOffsetZone(getOffsetName(hoursOffset, minutesOffset), totalMinutes);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Invalid hoursOffset: \" + hoursOffset);\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Invalid minutesOffset: \" + minutesOffset);\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Invalid offset: \" + hoursOffset + \":\" + minutesOffset);\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (totalMinutes > 23 * 60 + 59 || totalMinutes < -23 * 60 - 1) {\n        throw new IllegalArgumentException(\"Invalid offset: \" + hoursOffset + \":\" + minutesOffset);\n    }\n    return new DateTimeZone(DateTimeZone.HOURS_MINUTES, hoursOffset, minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Invalid hoursOffset: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Invalid minutesOffset: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be positive when hours are positive\");\n    }\n    if (hoursOffset == 0 && minutesOffset == 0) {\n        return DateTimeZone.UTC;\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes == 0) {\n        return DateTimeZone.UTC;\n    }\n    if (totalMinutes >= -14 * 60 && totalMinutes < 14 * 60) {\n        return DateTimeZone.forOffsetHours(hoursOffset);\n    }\n    return fixedOffsetZone(hoursOffset < 0 ? \"Etc/GMT-\" : \"Etc/GMT+\", hoursOffset);\n}"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty())\n        return \"\";\n    int start = pos;\n    int depth = 0;\n    boolean inQuote = false;\n    boolean escaped = false;\n    while (pos < queue.length()) \n    {\n        char c = queue.charAt(pos);\n        if (c == ESC)\n        {\n            escaped = !escaped;\n        }\n        else if (c == open && !escaped)\n        {\n            depth++;\n        }\n        else if (c == close && !escaped)\n        {\n            depth--;\n            if (depth == 0)\n                break;\n        }\n        else if (c == '\\'' || c == '\"')\n        {\n            if (!escaped)\n            {\n                inQuote = !inQuote;\n            }\n            escaped = false;\n        }\n        pos++;\n    }\n    String consumed = queue.substring(start, pos);\n    pos++;\n    return consumed;\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty())\n        return \"\";\n    int start = pos;\n    int depth = 0;\n    boolean inQuote = false;\n    boolean escaped = false;\n    while (!isEmpty()) \n    {\n        char current = peek();\n        if (escaped) \n        {\n            escaped = false;\n        } \n        else if (current == ESC) \n        {\n            escaped = true;\n        } \n        else if (inQuote) \n        {\n            if (current == open) \n            {\n                depth++;\n            } \n            else if (current == close) \n            {\n                depth--;\n            }\n        } \n        else if (current == open) \n        {\n            depth++;\n        } \n        else if (current == close) \n        {\n            if (depth > 0) \n            {\n                depth--;\n            } \n            else \n            {\n                break;\n            }\n        } \n        else if (current == '\\'') \n        {\n            inQuote = !inQuote;\n        }\n        advance();\n    }\n    if (depth > 0) \n    {\n        return \"\";\n    }\n    return queue.substring(start, pos);\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty())\n        return null;\n    int start = nextIndexOf(open);\n    if (start != -1) {\n        int end = nextIndexOf(close, start + 1);\n        if (end != -1) {\n            String consumed = queue.substring(start + 1, end);\n            pos = end + 1;\n            return consumed;\n        }\n    }\n    return null;\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty() || !matches(String.valueOf(open)))\n        return null;\n\n    int start = pos;\n    Stack<Character> stack = new Stack<>();\n    stack.push(open);\n\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (c == open)\n            stack.push(c);\n        else if (c == close)\n        {\n            if (stack.size() == 1)\n                break;\n            else\n                stack.pop();\n        }\n    }\n\n    if (stack.size() != 1)\n        return null;\n\n    return unescape(queue.substring(start, pos));\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty()) return \"\";\n    int start = pos;\n    int depth = 0;\n    char last;\n    boolean inQuote = false;\n    boolean escaped = false;\n    while (!isEmpty()) \n    {\n        last = peek();\n        if (last == open && !escaped) \n        {\n            depth++;\n        } \n        else if (last == close && !escaped) \n        {\n            depth--;\n            if (depth < 0) break;\n        }\n        else if (last == '\"' || last == '\\'') \n        {\n            inQuote = !inQuote;\n        }\n        escaped = last == ESC;\n        advance();\n    }\n    if (depth > 0) \n    {\n        return \"\";\n    }\n    int end = pos;\n    pos = start;\n    String consumed = queue.substring(pos, end);\n    pos = end;\n    return consumed;\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty())\n        return \"\";\n    int start = pos;\n    int depth = 0;\n    boolean inQuote = false;\n    boolean escaped = false;\n    while (pos < queue.length()) {\n        char c = queue.charAt(pos);\n        if (c == ESC) {\n            escaped = !escaped;\n        }\n        else if (c == open && !escaped) {\n            depth++;\n        }\n        else if (c == close && !escaped) {\n            depth--;\n            if (depth < 0)\n                break;\n        }\n        else if (c == '\\'' || c == '\"') {\n            inQuote = !inQuote;\n        }\n        pos++;\n    }\n    String data = queue.substring(start, pos);\n    pos++; // move off \"outer\" close\n    return data;\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty())\n        return \"\";\n    int start = pos;\n    int depth = 0;\n    char c;\n    while (pos < queue.length()) {\n        c = queue.charAt(pos);\n        if (c == ESC) {\n            pos++;\n        } else if (c == open) {\n            depth++;\n        } else if (c == close) {\n            if (depth == 0)\n                break;\n            depth--;\n        }\n        pos++;\n    }\n    String consumed = queue.substring(start, pos);\n    pos++; // move past close bracket/quote\n    return consumed;\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty())\n        return \"\";\n    int start = pos;\n    int depth = 0;\n    boolean inQuote = false;\n    boolean escaped = false;\n    while (pos < queue.length()) {\n        char c = queue.charAt(pos);\n        if (c == ESC) {\n            escaped = !escaped;\n        }\n        else if (c == open && !escaped) {\n            depth++;\n        }\n        else if (c == close && !escaped) {\n            depth--;\n            if (depth < 0)\n                break;\n        }\n        else if (c == '\\'' || c == '\"') {\n            inQuote = !inQuote;\n        }\n        pos++;\n    }\n    String data = queue.substring(start, pos);\n    pos++; // move off \"unbalanced\" closing marker\n    return data;\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty()) return \"\";\n    int start = pos;\n    int depth = 0;\n    boolean inQuote = false;\n    boolean escaped = false;\n    boolean lastWasEscape = false;\n    while (pos < queue.length()) \n    {\n        char c = queue.charAt(pos);\n        if (c == ESC) \n        {\n            escaped = !escaped;\n            lastWasEscape = true;\n        } \n        else if (c == open && !escaped) \n        {\n            depth++;\n        } \n        else if (c == close && !escaped) \n        {\n            depth--;\n            if (depth == 0) \n            {\n                break;\n            }\n        } \n        else if (c == '\"' || c == '\\'') \n        {\n            inQuote = !inQuote;\n        }\n        lastWasEscape = false;\n        escaped = false;\n        pos++;\n    }\n    String data = queue.substring(start, pos);\n    pos++; // move offset after closing bracket or quote\n    return data;\n}",
      "public String chompBalanced(char open, char close)  {\n    if (isEmpty())\n        return null;\n    int start = pos;\n    int depth = 0;\n    boolean inQuote = false;\n    boolean escaped = false;\n    boolean lastEscaped = false;\n    while (!isEmpty()) {\n        char current = peek();\n        if (current == ESC) {\n            escaped = !escaped;\n            lastEscaped = true;\n        }\n        else if (current == open && !escaped) {\n            depth++;\n        }\n        else if (current == close && !escaped) {\n            depth--;\n            if (depth == 0) {\n                break;\n            }\n        }\n        else if (current == '\\'' || current == '\"') {\n            inQuote = !inQuote;\n        }\n        lastEscaped = false;\n        advance();\n    }\n    if (depth != 0 || inQuote) {\n        return null;\n    }\n    String consumed = queue.substring(start, pos);\n    pos++;\n    return consumed;\n}"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix hat = calculateHat();\n        return hat.subtract(calculateBeta().mapMultiply(calculateBeta().getTranspose()));\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Calculate Hat matrix\n        RealMatrix hat = calculateHat();\n\n        // Calculate Hat inverse\n        RealMatrix hatInverse = new LUDecomposition(hat).getSolver().getInverse();\n\n        // Calculate beta variance\n        return hatInverse.multiply(xMatrix.transpose()).multiply(xMatrix);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix XT = xMatrix.transpose();\n        RealMatrix XTX = XT.multiply(xMatrix);\n        RealMatrix hatMatrix = calculateHat();\n        RealMatrix beta = calculateBeta();\n        RealMatrix betaTranspose = beta.transpose();\n        RealMatrix betaTransposeHatBeta = betaTranspose.multiply(hatMatrix).multiply(beta);\n        return XTX.subtract(betaTransposeHatBeta);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Calculate Hat matrix\n        RealMatrix hat = calculateHat();\n\n        // Return (X'X)^-1\n        return hat.multiply(xMatrix.transpose()).inverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Calculate X'X\n        RealMatrix XT = xMatrix.transpose();\n        RealMatrix XX = XT.multiply(xMatrix);\n\n        // Perform QR decomposition\n        QRDecomposition qr = new QRDecomposition(XX);\n\n        // Calculate R'R\n        RealMatrix R = qr.getR();\n        RealMatrix RT = R.transpose();\n        RealMatrix RR = RT.multiply(R);\n\n        // Calculate (R'R)^-1\n        RealMatrix invRR = new LUDecomposition(RR).getSolver().getInverse();\n\n        // Calculate (X'X)^-1\n        RealMatrix invXX = new LUDecomposition(XX).getSolver().getInverse();\n\n        // Calculate beta variance\n        RealMatrix betaVariance = invRR.multiply(invXX);\n\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Get the QR decomposition\n        final QRDecomposition qr = new QRDecomposition(xMatrix);\n\n        // Get the R matrix\n        final RealMatrix r = qr.getR();\n\n        // Get the number of observations\n        final int nobs = xMatrix.getRowDimension();\n\n        // Get the number of parameters\n        final int nparams = r.getColumnDimension();\n\n        // Get the hat matrix\n        final RealMatrix hat = calculateHat();\n\n        // Compute the variance-covariance matrix\n        // No DME advertised - args valid if we get here\n        return hat.multiply(r.transpose()).multiply(r).scalarMultiply(nobs / (nobs - nparams)).subtract(hat);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Calculate X'X\n        RealMatrix XTX = xMatrix.transpose().multiply(xMatrix);\n\n        // Calculate QR decomposition\n        QRDecomposition qr = new QRDecomposition(XTX);\n\n        // Calculate R'R\n        RealMatrix RR = qr.getR().transpose().multiply(qr.getR());\n\n        // Calculate (R'R)^-1\n        RealMatrix invRR = new LUDecomposition(RR).getSolver().getInverse();\n\n        // Calculate X'X^-1\n        RealMatrix XTXinv = xMatrix.transpose().multiply(invRR);\n\n        // Calculate X'X^-1X'\n        RealMatrix XTXinvXT = XTXinv.multiply(xMatrix.transpose());\n\n        // Calculate (X'X^-1X')^-1\n        RealMatrix invXTXinvXT = new LUDecomposition(XTXinvXT).getSolver().getInverse();\n\n        // Calculate beta variance-covariance matrix\n        return invXTXinvXT;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Get QR decomposition\n        RealMatrix Q = qr.getQ();\n        RealMatrix R = qr.getR();\n        final int p = qr.getR().getColumnDimension();\n        final int n = Q.getColumnDimension();\n        // No try-catch or advertised NotStrictlyPositiveException - NPE above if n < 3\n        Array2DRowRealMatrix augI = new Array2DRowRealMatrix(n, n);\n        double[][] augIData = augI.getDataRef();\n        for (int i = 0; i < n; i++) {\n            for (int j =0; j < n; j++) {\n                if (i == j && i < p) {\n                    augIData[i][j] = 1d;\n                } else {\n                    augIData[i][j] = 0d;\n                }\n            }\n        }\n\n        // Compute and return Hat matrix\n        // No DME advertised - args valid if we get here\n        RealMatrix Hat = Q.multiply(augI).multiply(Q.transpose());\n\n        // Compute and return beta variance-covariance matrix\n        // No DME advertised - args valid if we get here\n        return Hat.multiply(R.transpose()).multiply(R).scalarMultiply(1d / (n - p));\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Create augmented identity matrix\n        RealMatrix Q = qr.getQ();\n        final int p = qr.getR().getColumnDimension();\n        final int n = Q.getColumnDimension();\n        // No try-catch or advertised NotStrictlyPositiveException - NPE above if n < 3\n        Array2DRowRealMatrix augI = new Array2DRowRealMatrix(n, n);\n        double[][] augIData = augI.getDataRef();\n        for (int i = 0; i < n; i++) {\n            for (int j =0; j < n; j++) {\n                if (i == j && i < p) {\n                    augIData[i][j] = 1d;\n                } else {\n                    augIData[i][j] = 0d;\n                }\n            }\n        }\n\n        // Compute and return Hat matrix\n        // No DME advertised - args valid if we get here\n        return Q.multiply(augI).multiply(Q.transpose());\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix XT = xMatrix.transpose();\n        RealMatrix XTX = XT.multiply(xMatrix);\n        QRDecomposition qr = new QRDecomposition(XTX);\n        RealMatrix R = qr.getR();\n        int p = R.getColumnDimension();\n        RealMatrix Rp = R.getSubMatrix(0, p - 1, 0, p - 1);\n        RealMatrix invRp = new LUDecomposition(Rp).getSolver().getInverse();\n        return XTX.multiply(invRp);\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n        return offsetFormatter().print(offset);\n    }",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    if (offset % 60000 == 0) {\n        return String.format(\"%+03d:00\", offset / 60000);\n    }\n    return String.format(\"%+03d:%02d\", offset / 60000, Math.abs(offset % 60000) / 1000);\n}",
      "private static String printOffset(int offset)  {\n        return offsetFormatter().print(offset);\n    }",
      "private static String printOffset(int offset)  {\n    // Can't use a real chronology if called during class\n    // initialization. Offset parser doesn't need it anyhow.\n    Chronology chrono = new BaseChronology() \n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n        return offsetFormatter().print(offset);\n    }",
      "private static String printOffset(int offset)  {\n    if (offset == 0) \n    {\n        return \"Z\";\n    }\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / 60 / 60 / 1000;\n    int minutes = (absOffset / 60 / 1000) % 60;\n    StringBuffer buf = new StringBuffer();\n    if (offset < 0) \n    {\n        buf.append('-');\n    } \n    else \n    {\n        buf.append('+');\n    }\n    if (hours < 10) \n    {\n        buf.append('0');\n    }\n    buf.append(hours);\n    if (minutes != 0) \n    {\n        buf.append(':');\n        if (minutes < 10) \n        {\n            buf.append('0');\n        }\n        buf.append(minutes);\n    }\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n    // Can't use a real chronology if called during class\n    // initialization. Offset parser doesn't need it anyhow.\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"+00:00\";\n    }\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / 60 / 60;\n    int minutes = (absOffset - hours * 60 * 60) / 60;\n    int seconds = absOffset - hours * 60 * 60 - minutes * 60;\n    String sign = offset < 0 ? \"-\" : \"+\";\n    return sign + String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n}"
    ],
    [
      "public int getIndex(Comparable key)  {\n    // perform some simple checks first\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    // if the key is already in the index map, return the index\n    if (this.indexMap.containsKey(key)) {\n        return ((Integer) this.indexMap.get(key)).intValue();\n    }\n    // if we get here, the key is not in the index map\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    // perform some basic checks\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    // is the key already in the index?\n    if (this.indexMap.containsKey(key)) {\n        return (Integer) this.indexMap.get(key);\n    }\n    // no, so search the keys for the key\n    int count = this.keys.size();\n    for (int i = 0; i < count; i++) {\n        Comparable k = this.keys.get(i);\n        if (k.equals(key)) {\n            this.indexMap.put(key, new Integer(i));\n            return i;\n        }\n    }\n    // key not found\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    // perform some basic checks\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    // search for the key\n    int count = this.keys.size();\n    for (int i = 0; i < count; i++) {\n        if (this.keys.get(i).equals(key)) {\n            return i;\n        }\n    }\n    // key not found\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int index = this.underlying.getIndex(key);\n    if (index >= this.firstCategoryIndex && index <= lastCategoryIndex()) {\n        return index - this.firstCategoryIndex;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = -1;\n    for (int i = 0; i < this.keys.size(); i++) {\n        Comparable k = this.keys.get(i);\n        if (k.equals(key)) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n    // perform some basic checks\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    // now perform the lookup\n    int index = -1;\n    for (int i = 0; i < this.keys.size(); i++) {\n        Comparable k = (Comparable) this.keys.get(i);\n        if (k.equals(key)) {\n            index = i;\n            break;\n        }\n    }\n    return index;\n}",
      "public int getIndex(Comparable key)  {\n    // perform some basic checks\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    // search for the key\n    int index = -1;\n    for (int i = 0; i < this.keys.size(); i++) {\n        Comparable k = (Comparable) this.keys.get(i);\n        if (k.equals(key)) {\n            index = i;\n            break;\n        }\n    }\n    return index;\n}",
      "public int getIndex(Comparable key)  {\n    // perform some basic checks\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    // if the key is not in the index, return -1\n    if (!this.indexMap.containsKey(key)) {\n        return -1;\n    }\n    // return the index\n    return ((Integer) this.indexMap.get(key)).intValue();\n}",
      "public int getIndex(Comparable key)  {\n    // perform some simple checks first\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    // now search the list for the key\n    for (int i = 0; i < this.keys.size(); i++) {\n        Comparable currentKey = (Comparable) this.keys.get(i);\n        if (currentKey.equals(key)) {\n            return i;\n        }\n    }\n    // if we get here, the key was not found\n    return -1;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int index = -1;\n    for (int i = 0; i < this.keys.size(); i++) {\n        if (this.keys.get(i).equals(key)) {\n            index = i;\n            break;\n        }\n    }\n    return index;\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n\n  for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n    if (!slots.containsKey(symbolEntry.getKey())) {\n      slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n    }\n  }\n\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) \n    {\n        if (!slots.containsKey(symbolEntry.getKey())) \n        {\n            slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n    }\n\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n  for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n    if (!slots.containsKey(symbolEntry.getKey())) {\n      slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n    }\n  }\n\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n  LinkedFlowScope current = this;\n  while (current != null) {\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : current.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n    current = current.parent;\n  }\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n  LinkedFlowScope current = this;\n  while (current != null) {\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : current.cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n    current = current.parent;\n  }\n\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n\n  // The cache at the bottom of the lattice.\n  FlatFlowScopeCache cache = this.flattened;\n  while (cache != null) {\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    cache = cache.linkedEquivalent;\n  }\n\n  return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n  Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n\n  // The first slot is the current scope.\n  LinkedFlowScope currentScope = this;\n\n  // We can't use traditional iterators and iterables for this list,\n  // because our lazily-evaluated continuations will modify it while\n  // we traverse it.\n  for (int current = 0; current < maybeUnreferenced.size(); current++) \n  {\n    Var var = maybeUnreferenced.get(current);\n    if (referenced.contains(var)) \n    {\n      maybeUnreferenced.remove(current);\n      current--;\n    } \n    else \n    {\n      boolean assignedToUnknownValue = false;\n      boolean hasPropertyAssign = false;\n\n      if (var.getParentNode().isVar() &&\n          !NodeUtil.isForIn(var.getParentNode().getParent())) \n      {\n        Node value = var.getInitialValue();\n        assignedToUnknownValue = value != null &&\n            !NodeUtil.isLiteralValue(value, true);\n      } \n      else \n      {\n        // This was initialized to a function arg or a catch param\n        // or a for...in variable.\n        assignedToUnknownValue = true;\n      }\n\n      // If this variable is assigned to an unknown value, then we\n      // need to look at all the variables in the current scope\n      // to see if it is shadowed by any of them.\n      if (assignedToUnknownValue) \n      {\n        // If this variable is assigned to an unknown value, then we\n        // need to look at all the variables in the current scope\n        // to see if it is shadowed by any of them.\n        for (StaticSlot<JSType> slot : currentScope.slots.values()) \n        {\n          if (slot.getName().equals(var.getName())) \n          {\n            // This variable is shadowed by a variable in the current\n            // scope.\n            break;\n          }\n        }\n      }\n\n}\n}\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    return slots;\n  }"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
    ],
    [
      "public static double atanh(double a)  {\n    return 0.5 * FastMath.log((1.0 + a) / (1.0 - a));\n}",
      "public static double atanh(double a)  {\n    // atanh(x) = log((1+x)/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n    // atanh(x) = log1p(2x/(1-x))/2\n}",
      "public static double atanh(double a)  {\n    return FastMath.log((1.0 + a) / (1.0 - a)) / 2.0;\n}",
      "public static double atanh(double a)  {\n    return 0.5 * FastMath.log((1.0 + a) / (1.0 - a));\n}",
      "public static double atanh(double a)  {\n    // atanh(z) = (ln((1+z)/(1-z)))/2\n    double x = 1d / (1d + a);\n    double y = 1d - x;\n    double hiPrec[] = new double[2];\n    exp(x, y, hiPrec);\n    return (hiPrec[0] + hiPrec[1]) / 2d;\n}",
      "public static double atanh(double a)  {\n    return FastMath.log((1.0 + a) / (1.0 - a)) / 2.0;\n}",
      "public static double atanh(double a)  {\n    // atanh(x) = 0.5 * ln((1+x)/(1-x))\n    double x = 1.0 / (1.0 + a);\n    return 0.5 * FastMath.log(x / (1.0 - x));\n}",
      "public static double atanh(double a)  {\n    return FastMath.log((1+a)/(1-a))/2;\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) \n    {\n        negative = true;\n        a = -a;\n    }\n    double absAsinh;\n    if (a > 0.167) \n    {\n        absAsinh = log(sqrt(a * a + 1) + a);\n    } \n    else \n    {\n        double a2 = a * a;\n        if (a > 0.097) \n        {\n            absAsinh = a * (1 - a2 * (1 / 3 - a2 * (1 / 5 - a2 * (1 / 7 - a2 * (1 / 9 - a2 * (1 / 11 - a2 * (1 / 13 - a2 * (1 / 15 - a2 * 1 / 17 * 15 / 16) * 13 / 14) * 11 / 12) * 9 / 10) * 7 / 8) * 5 / 6) * 3 / 4) * 1 / 2);\n        } \n        else if (a > 0.036) \n        {\n            absAsinh = a * (1 - a2 * (1 / 3 - a2 * (1 / 5 - a2 * (1 / 7 - a2 * (1 / 9 - a2 * (1 / 11 - a2 * 1 / 13 * 11 / 12) * 9 / 10) * 7 / 8) * 5 / 6) * 3 / 4) * 1 / 2);\n        } \n        else if (a > 0.0036) \n        {\n            absAsinh = a * (1 - a2 * (1 / 3 - a2 * (1 / 5 - a2 * (1 / 7 - a2 * 1 / 9 * 7 / 8) * 5 / 6) * 3 / 4) * 1 / 2);\n        } \n}\n}",
      "public static double atanh(double a)  {\n    return FastMath.log((1+a)/(1-a))/2;\n}"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_NOT_VALID, normalizedSum);\n    }\n    if (normalizedSum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_WITH_ZERO_SUM);\n    }\n    int n = 0;\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            n++;\n            sum += values[i];\n        }\n    }\n    if (n == 0) {\n        return values;\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            result[i] = Double.NaN;\n        } else {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_MUST_BE_FINITE,\n                normalizedSum);\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_WITH_ZERO_SUM,\n                sum);\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            result[i] = Double.NaN;\n        } else {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_MUST_BE_FINITE, normalizedSum);\n    }\n    if (normalizedSum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_WITH_ZERO_SUM, normalizedSum);\n    }\n    double sum = 0;\n    int n = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n            n++;\n        }\n    }\n    if (n == 0) {\n        return values;\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            result[i] = values[i];\n        } else {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_WITH_ZERO_SUM,\n                                          sum);\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.CANNOT_NORMALIZE_WITH_INFINITE_SUM,\n                                               normalizedSum);\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            result[i] = Double.NaN;\n        } else {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_NOT_SUPPORTED,\n                normalizedSum);\n    }\n    int n = 0;\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            n++;\n            sum += values[i];\n        }\n    }\n    if (n == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_EMPTY_ARRAY);\n    }\n    if (Double.isInfinite(sum) || Double.isNaN(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_INFINITE_SUM,\n                sum);\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NAN_OR_INFINITE_SUM, normalizedSum);\n        }\n        double sum = 0;\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                sum += values[i];\n            }\n        }\n        if (sum == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_SUM);\n        }\n        double[] result = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                result[i] = values[i] * normalizedSum / sum;\n            } else {\n                result[i] = Double.NaN;\n            }\n        }\n        return result;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_MUST_BE_FINITE,\n                normalizedSum);\n    }\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_WITH_ZERO_SUM,\n                sum);\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            result[i] = values[i];\n        } else {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_IS_NOT_A_FINITE_NUMBER,\n                normalizedSum);\n    }\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (Double.isInfinite(sum) || sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_ARRAY_WITH_SUM,\n                sum);\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            result[i] = values[i];\n        } else {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_MUST_BE_FINITE,\n                                                   normalizedSum);\n        }\n        double sum = 0;\n        int count = 0;\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                sum += values[i];\n                count++;\n            }\n        }\n        if (count == 0) {\n            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_EMPTY_ARRAY);\n        }\n        if (Double.isInfinite(sum) || Double.isNaN(sum)) {\n            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_INFINITE_SUM,\n                                              sum);\n        }\n        double[] result = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                result[i] = values[i] * normalizedSum / sum;\n            } else {\n                result[i] = values[i];\n            }\n        }\n        return result;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_IS_NOT_A_FINITE_NUMBER,\n                normalizedSum);\n    }\n    double sum = StatUtils.sum(values);\n    if (Double.isInfinite(sum) || Double.isNaN(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_INFINITE_SUM,\n                sum);\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_ZERO_SUM,\n                sum);\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            result[i] = values[i] * normalizedSum / sum;\n        } else {\n            result[i] = values[i];\n        }\n    }\n    return result;\n}"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return new MutableDateTime(millis, chrono);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXI = new LUDecomposition(XTOIX).getSolver().getInverse();\n        return XTOIXI.multiply(getX().transpose().multiply(OI).multiply(getY()));\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXOI = new LUDecomposition(XTOIX).getSolver().getInverse();\n        return XTOIXOI.multiply(getX().transpose()).multiply(OI).multiply(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXI = new LUDecomposition(XTOIX).getSolver().getInverse();\n        return XTOIXI.multiply(getX().transpose()).multiply(OI).multiply(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXOI = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealMatrix XTOIXOI_X = XTOIXOI.multiply(getX().transpose());\n        return XTOIXOI_X.multiply(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXI = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealVector XTOIy = getX().transpose().multiply(OI).multiply(getY());\n        return XTOIXI.multiply(XTOIy);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXOI = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealVector beta = XTOIXOI.multiply(getX().transpose().multiply(OI).multiply(getY()));\n        return beta;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXI = new LUDecomposition(XTOIX).getSolver().getInverse();\n        return XTOIXI.multiply(getX().transpose()).multiply(OI).multiply(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXI = new LUDecomposition(XTOIX).getSolver().getInverse();\n        return XTOIXI.multiply(getX().transpose().multiply(OI).multiply(getY()));\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXI = new LUDecomposition(XTOIX).getSolver().getInverse();\n        return XTOIXI.multiply(getX().transpose()).multiply(OI).multiply(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXI = new LUDecomposition(XTOIX).getSolver().getInverse();\n        return XTOIXI.multiply(getX().transpose().multiply(OI)).multiply(getY());\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    id = id.trim();\n    if (id.isEmpty()) \n    {\n        return null;\n    }\n    if (attributes != null && id.equals(attributes.get(\"id\"))) \n    {\n        return this;\n    }\n    for (Element child : children()) \n    {\n        Elements elements = child.getElementsByAttribute(\"id\");\n        for (Element element : elements) \n        {\n            if (id.equals(element.id())) \n            {\n                return element;\n            }\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    id = id.trim();\n    if (id.isEmpty()) \n    {\n        return null;\n    }\n    if (id.equals(this.id())) \n    {\n        return this;\n    }\n    Elements elements = this.getElementsByAttribute(\"id\");\n    for (Element element : elements) \n    {\n        if (id.equals(element.id())) \n        {\n            return element;\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n\n    id = id.trim();\n    if (id.isEmpty()) \n    {\n        return null;\n    }\n\n    if (id.equals(this.id())) \n    {\n        return this;\n    }\n\n    Elements elements = this.getElementsByAttribute(\"id\");\n    for (Element element : elements) \n    {\n        if (id.equals(element.id())) \n        {\n            return element;\n        }\n    }\n\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n\n    id = id.trim();\n    if (id.isEmpty()) \n    {\n        return null;\n    }\n\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}",
      "public Element getElementById(String id)  {\n    if (id == null)\n        return null;\n\n    // first check id attr\n    String idAttr = attributes().getIgnoreCase(\"id\");\n    if (idAttr != null && idAttr.equals(id))\n        return this;\n\n    // not found, search children\n    for (Element child : children()) \n    {\n        Elements elements = child.getElementsByAttribute(\"id\");\n        for (Element element : elements) \n        {\n            if (element.id().equals(id))\n                return element;\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}",
      "public Element getElementById(String id)  {\n    if (id == null)\n        return null;\n\n    id = id.trim();\n    if (id.isEmpty())\n        return null;\n\n    if (id.equals(this.id()))\n        return this;\n\n    Elements elements = this.getElementsByAttribute(\"id\");\n    for (Element element : elements)\n    {\n        if (id.equals(element.id()))\n            return element;\n    }\n\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    id = id.trim();\n    if (id.isEmpty()) \n    {\n        return null;\n    }\n    if (id.equals(this.id())) \n    {\n        return this;\n    }\n    for (Element child : this.children()) \n    {\n        Elements elements = child.getElementsByAttribute(\"id\", id);\n        if (!elements.isEmpty()) \n        {\n            return elements.first();\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null) \n    {\n        return null;\n    }\n    id = id.trim();\n    if (id.isEmpty()) \n    {\n        return null;\n    }\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}",
      "public Element getElementById(String id)  {\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns.isEmpty()) {\n        return pattern;\n    }\n    final StringBuilder buf = new StringBuilder(pattern.length() + 16 * customPatterns.size());\n    final int[] indexes = new int[customPatterns.size()];\n    int last = 0;\n    for (int i = 0; i < customPatterns.size(); i++) {\n        final String desc = customPatterns.get(i);\n        final int start = pattern.indexOf(desc, last);\n        if (start < 0) {\n            throw new IllegalArgumentException(\"Format element not found: \" + desc);\n        }\n        indexes[i] = start;\n        buf.append(pattern, last, start);\n        buf.append('{');\n        buf.append(i);\n        buf.append('}');\n        last = start + desc.length();\n    }\n    buf.append(pattern, last, pattern.length());\n    for (int i = customPatterns.size() - 1; i >= 0; i--) {\n        indexes[i] = buf.indexOf(\"{}\", indexes[i]);\n    }\n    for (int i = 0; i < customPatterns.size(); i++) {\n        buf.replace(indexes[i], indexes[i] + 2, customPatterns.get(i));\n    }\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder buf = new StringBuilder(pattern.length());\n    final int len = customPatterns.size();\n    int pos = 0;\n    for (int i = 0; i < len; i++) {\n        final String custom = customPatterns.get(i);\n        final int start = pattern.indexOf(custom, pos);\n        if (start < 0) {\n            break;\n        }\n        buf.append(pattern, pos, start);\n        buf.append(custom);\n        pos = start + custom.length();\n    }\n    buf.append(pattern, pos, pattern.length());\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder buf = new StringBuilder(pattern.length());\n    final int length = pattern.length();\n    int lastPos = 0;\n    int start = 0;\n    int i = 0;\n    while (i < length) {\n        final char ch = pattern.charAt(i);\n        if (ch == START_FMT) {\n            if (i == start) {\n                start++;\n            } else {\n                buf.append(pattern.substring(start, i));\n                start = i + 1;\n            }\n            final int end = pattern.indexOf(END_FE, i);\n            if (end > i) {\n                final String desc = pattern.substring(i + 1, end);\n                final int j = customPatterns.indexOf(desc);\n                if (j > -1) {\n                    buf.append(customPatterns.get(j));\n                } else {\n                    buf.append(pattern.substring(start, end + 1));\n                }\n                i = end + 1;\n                lastPos = i;\n            } else {\n                throw new IllegalArgumentException(\"Unterminated format element at position \" + i);\n            }\n        } else if (ch == QUOTE) {\n            buf.append(pattern.substring(start, i));\n            start = i + 1;\n            getQuotedString(pattern, i, true);\n            i = lastPos;\n            lastPos = i + 1;\n        } else {\n            i++;\n        }\n    }\n    buf.append(pattern.substring(start, i));\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder buf = new StringBuilder(pattern.length());\n    final int length = pattern.length();\n    int pos = 0;\n    for (int i = 0; i < length; i++) {\n        final char ch = pattern.charAt(i);\n        if (ch == START_FMT) {\n            if (i + 1 < length && pattern.charAt(i + 1) == START_FMT) {\n                buf.append(START_FMT);\n                i++;\n            } else {\n                final int start = i;\n                while (i < length && pattern.charAt(i) != END_FE) {\n                    i++;\n                }\n                if (i < length) {\n                    final String desc = pattern.substring(start + 1, i);\n                    final int j = customPatterns.indexOf(desc);\n                    if (j >= 0) {\n                        buf.append(customPatterns.get(j));\n                    } else {\n                        buf.append(pattern.substring(start, i + 1));\n                    }\n                    i++;\n                }\n            }\n        } else {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder buf = new StringBuilder(pattern.length());\n    final int length = pattern.length();\n    int custom = 0;\n    for (int i = 0; i < length; i++) {\n        final char ch = pattern.charAt(i);\n        if (ch == START_FE) {\n            buf.append(START_FMT);\n            if (custom < customPatterns.size()) {\n                buf.append(customPatterns.get(custom++));\n            } else {\n                buf.append(START_FE);\n            }\n            buf.append(END_FE);\n        } else {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder buf = new StringBuilder(pattern.length());\n    final int length = pattern.length();\n    int custom = 0;\n    for (int i = 0; i < length; i++) \n    {\n        final char ch = pattern.charAt(i);\n        if (ch == START_FE) \n        {\n            if (custom < customPatterns.size()) \n            {\n                buf.append(customPatterns.get(custom++));\n            }\n        } \n        else \n        {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder buf = new StringBuilder(pattern.length());\n    final int length = customPatterns.size();\n    int last = 0;\n    for (int i = 0; i < length; i++) {\n        final String customPattern = customPatterns.get(i);\n        final int start = pattern.indexOf(customPattern, last);\n        if (start == -1) {\n            break;\n        }\n        buf.append(pattern.substring(last, start));\n        buf.append(customPattern);\n        last = start + customPattern.length();\n    }\n    buf.append(pattern.substring(last));\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder buf = new StringBuilder(pattern.length());\n    final int len = customPatterns.size();\n    int pos = 0;\n    for (int i = 0; i < len; i++) \n    {\n        buf.append(pattern.substring(pos, customPatterns.get(i)));\n        buf.append(customPatterns.get(i + 1));\n        pos = customPatterns.get(i) + 1;\n    }\n    buf.append(pattern.substring(pos));\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns.isEmpty()) {\n        return pattern;\n    }\n    final StringBuilder buf = new StringBuilder(pattern.length());\n    final int[] customFormats = new int[customPatterns.size()];\n    int j = 0;\n    for (int i = 0; i < customPatterns.size(); i++) {\n        customFormats[j++] = pattern.indexOf(customPatterns.get(i));\n    }\n    Arrays.sort(customFormats);\n    int last = 0;\n    for (int i = 0; i < customFormats.length; i++) {\n        buf.append(pattern.substring(last, customFormats[i]));\n        buf.append(customPatterns.get(i));\n        last = customFormats[i] + customPatterns.get(i).length();\n    }\n    buf.append(pattern.substring(last));\n    return buf.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder buf = new StringBuilder(pattern.length());\n    final int length = pattern.length();\n    int pos = 0;\n    for (int i = 0; i < length; i++) {\n        final char ch = pattern.charAt(i);\n        if (ch == START_FE) {\n            if (pos < customPatterns.size()) {\n                buf.append(customPatterns.get(pos++));\n            }\n        } else {\n            buf.append(ch);\n        }\n    }\n    return buf.toString();\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n    checkAlterInstantConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    InstantConverter[] removed = new InstantConverter[1];\n    iInstantConverters = iInstantConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getOwnerType() != to.getOwnerType()) {\n      return false;\n    }\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    Type[] fromTypeArgs = from.getActualTypeArguments();\n    Type[] toTypeArgs = to.getActualTypeArguments();\n    if (fromTypeArgs.length != toTypeArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromTypeArgs.length; i++) {\n      if (!typeEquals(fromTypeArgs[i], toTypeArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // Check if the erased types are the same.\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    // Check if the type arguments are the same.\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      while (fromArg instanceof TypeVariable<?>) {\n        fromArg = typeVarMap.get(((TypeVariable<?>) fromArg).getName());\n      }\n      while (toArg instanceof TypeVariable<?>) {\n        toArg = typeVarMap.get(((TypeVariable<?>) toArg).getName());\n      }\n      if (!fromArg.equals(toArg)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getOwnerType() != to.getOwnerType()) {\n        return false;\n    }\n    if (!from.getRawType().equals(to.getRawType())) {\n        return false;\n    }\n    if (from.getActualTypeArguments().length != to.getActualTypeArguments().length) {\n        return false;\n    }\n    for (int i = 0; i < from.getActualTypeArguments().length; i++) {\n        if (!typeEquals(from.getActualTypeArguments()[i], to.getActualTypeArguments()[i], typeVarMap)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // Check if the raw types are the same\n    if (!from.getRawType().equals(to.getRawType())) {\n        return false;\n    }\n\n    // Check if the type parameters are the same\n    Type[] fromTypeArgs = from.getActualTypeArguments();\n    Type[] toTypeArgs = to.getActualTypeArguments();\n    if (fromTypeArgs.length != toTypeArgs.length) {\n        return false;\n    }\n\n    for (int i = 0; i < fromTypeArgs.length; i++) {\n        if (!typeEquals(fromTypeArgs[i], toTypeArgs[i], typeVarMap)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getOwnerType() != to.getOwnerType()) {\n      return false;\n    }\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    if (from.getActualTypeArguments().length != to.getActualTypeArguments().length) {\n      return false;\n    }\n    for (int i = 0; i < from.getActualTypeArguments().length; i++) {\n      if (!typeEquals(from.getActualTypeArguments()[i],\n              to.getActualTypeArguments()[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // Check if the erased types are the same.\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    // Check if the type parameters are the same.\n    Type[] fromTypeArgs = from.getActualTypeArguments();\n    Type[] toTypeArgs = to.getActualTypeArguments();\n    if (fromTypeArgs.length != toTypeArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromTypeArgs.length; i++) {\n      Type fromTypeArg = fromTypeArgs[i];\n      Type toTypeArg = toTypeArgs[i];\n      if (!typeEquals(fromTypeArg, toTypeArg, typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getOwnerType() != to.getOwnerType()) {\n      return false;\n    }\n    return from.getRawType().equals(to.getRawType())\n        && typeVarMap.entrySet().containsAll(to.getActualTypeArguments());\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getOwnerType() != to.getOwnerType()) {\n      return false;\n    }\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    Type[] fromTypeArguments = from.getActualTypeArguments();\n    Type[] toTypeArguments = to.getActualTypeArguments();\n    if (fromTypeArguments.length != toTypeArguments.length) {\n      return false;\n    }\n    for (int i = 0; i < fromTypeArguments.length; i++) {\n      if (!typeEquals(fromTypeArguments[i], toTypeArguments[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getOwnerType() != to.getOwnerType()) {\n      return false;\n    }\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // If the two types are equal, return true\n    if (from.equals(to)) {\n        return true;\n    }\n\n    // If the types are not equal, check if the raw types are equal\n    if (!from.getRawType().equals(to.getRawType())) {\n        return false;\n    }\n\n    // If the types are not equal, check if the type variables are equal\n    Type[] fromTypeArguments = from.getActualTypeArguments();\n    Type[] toTypeArguments = to.getActualTypeArguments();\n    for (int i = 0; i < fromTypeArguments.length; i++) {\n        // If the type variables are not equal, check if they are equivalent\n        // under the variable replacement described in the typeVarMap\n        if (!fromTypeArguments[i].equals(toTypeArguments[i])\n                && !typeEquals(fromTypeArguments[i], toTypeArguments[i],\n                        typeVarMap)) {\n            return false;\n        }\n    }\n\n    // If the types are not equal, check if the owner types are equal\n    Type fromOwnerType = from.getOwnerType();\n    Type toOwnerType = to.getOwnerType();\n    if (fromOwnerType == null) {\n        if (toOwnerType != null) {\n            return false;\n        }\n    } else {\n        if (!fromOwnerType.equals(toOwnerType)) {\n            return false;\n        }\n    }\n\n    // If the types are not equal, check if the type variables are equal\n    Type[] fromTypeParameters = from.getActualTypeArguments();\n    Type[] toTypeParameters = to.getActualTypeArguments();\n    for (int i = 0; i < fromTypeParameters.length; i++) {\n        // If the type variables are not equal, check if they are equivalent\n        // under the variable replacement described in the typeVarMap\n        if (!fromTypeParameters[i].equals(toTypeParameters[i])\n                && !typeEquals(fromTypeParameters[i], toTypeParameters[i],\n                        typeVarMap)) {\n            return false;\n        }\n    }\n\n}"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        \n        return (PeriodConverter)iPeriodConverters.add(converter, new PeriodConverter[0]);\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return (PeriodConverter)iPeriodConverters.add(converter, null);\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        return (PeriodConverter)iPeriodConverters.add(converter, null);\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return (PeriodConverter)iPeriodConverters.add(converter, null);\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        return (PeriodConverter) iPeriodConverters.add(converter, null);\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return (PeriodConverter)iPeriodConverters.add(converter, null);\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        return (PeriodConverter) iPeriodConverters.add(converter, null);\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return iPeriodConverters.add(converter, null);\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    return iPeriodConverters.add(converter, new PeriodConverter[0]);\n}",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        \n        return iPeriodConverters.add(converter, null);\n    }"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        if (iterator instanceof UnmodifiableIterator<?>) {\n            @SuppressWarnings(\"unchecked\") // safe cast\n            final Iterator<E> it = (Iterator<E>) iterator;\n            return it;\n        }\n        return new UnmodifiableIterator<E>(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        if (iterator instanceof UnmodifiableIterator<?>) {\n            @SuppressWarnings(\"unchecked\") // safe cast\n            final Iterator<E> it = (Iterator<E>) iterator;\n            return it;\n        }\n        return new UnmodifiableIterator<E>(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        if (iterator instanceof UnmodifiableIterator<?>) {\n            @SuppressWarnings(\"unchecked\") // safe cast\n            final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n            return it;\n        }\n        return new UnmodifiableIterator<E>(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    return UnmodifiableIterator.unmodifiableIterator(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n        if (iterator == null) {\n            throw new NullPointerException(\"Iterator must not be null\");\n        }\n        if (iterator instanceof UnmodifiableIterator<?>) {\n            @SuppressWarnings(\"unchecked\") // safe cast\n            final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n            return it;\n        }\n        return new UnmodifiableIterator<E>(iterator);\n    }",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n  return colorToNodeMap[node.getAnnotation(Color.class).value];\n}",
      "public N getPartitionSuperNode(N node)  {\n  return colorToNodeMap[graph.getNodeAnnotation(node).value];\n}",
      "public N getPartitionSuperNode(N node)  {\n    Color color = (Color) node.getAnnotation();\n    if (colorToNodeMap[color.value] == null) \n    {\n        colorToNodeMap[color.value] = node;\n    }\n    return colorToNodeMap[color.value];\n}",
      "public N getPartitionSuperNode(N node)  {\n  // If the node is already colored, return the node that represents the\n  // partition it is in.\n  if (node.getAnnotation() instanceof Color) \n  {\n    int color = ((Color) node.getAnnotation()).value;\n    return colorToNodeMap[color];\n  }\n  // Otherwise, color the node and return itself.\n  else \n  {\n    node.setAnnotation(new Color(colorToNodeMap.length));\n    colorToNodeMap[colorToNodeMap.length - 1] = node;\n    return node;\n  }\n}",
      "public N getPartitionSuperNode(N node)  {\n    return colorToNodeMap[((Color) node.getAnnotation()).value];\n}",
      "public N getPartitionSuperNode(N node)  {\n  return colorToNodeMap[((Color) node.getAnnotation()).value];\n}",
      "public N getPartitionSuperNode(N node)  {\n  return colorToNodeMap[((Color) node.getAnnotation()).value];\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = (Color) node.getAnnotation();\n  return colorToNodeMap[color.value];\n}",
      "public N getPartitionSuperNode(N node)  {\n  Color color = (Color) node.getAnnotation();\n  return colorToNodeMap[color.value];\n}",
      "public N getPartitionSuperNode(N node)  {\n    Color color = (Color) node.getAnnotation();\n    return colorToNodeMap[color.value];\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < getNumberOfPoints(); i++) \n    {\n        result += f.value(getPoint(i)) * getWeight(i);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < getNumberOfPoints(); i++) \n    {\n        sum += getWeight(i) * f.value(getPoint(i));\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) \n    {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < getNumberOfPoints(); i++) \n    {\n        sum += f.value(getPoint(i)) * getWeight(i);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < getNumberOfPoints(); i++) \n    {\n        result += f.value(getPoint(i)) * getWeight(i);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < getNumberOfPoints(); i++) {\n        result += f.value(getPoint(i)) * getWeight(i);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < getNumberOfPoints(); i++) \n    {\n        sum += getWeight(i) * f.value(getPoint(i));\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < getNumberOfPoints(); i++) {\n        sum += f.value(getPoint(i)) * getWeight(i);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < getNumberOfPoints(); i++) {\n        sum += getWeight(i) * f.value(getPoint(i));\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < getNumberOfPoints(); i++) {\n        sum += getWeight(i) * f.value(getPoint(i));\n    }\n    return sum;\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return map2 == null;\n    }\n    else if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key = (Comparable) iterator1.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return map2 == null;\n    }\n    else if (map2 == null) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (keys1.size() != keys2.size()) {\n        return false;\n    }\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key = (Comparable) iterator1.next();\n        if (!keys2.contains(key)) {\n            return false;\n        }\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return map2 == null;\n    }\n    else if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key = (Comparable) iterator1.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return map2 == null;\n    }\n    if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key = (Comparable) iterator1.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return map2 == null;\n    }\n    if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key = (Comparable) iterator1.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return map2 == null;\n    }\n    if (map2 == null) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (keys1.size() != keys2.size()) {\n        return false;\n    }\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key1 = (Comparable) iterator1.next();\n        Object value1 = map1.get(key1);\n        Object value2 = map2.get(key1);\n        if (!value1.equals(value2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator = keys1.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return map2 == null;\n    }\n    else if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key = (Comparable) iterator1.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator = keys1.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!p1.equals(p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return map2 == null;\n    }\n    else if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys1 = map1.keySet();\n    Set keys2 = map2.keySet();\n    if (!keys1.equals(keys2)) {\n        return false;\n    }\n    Iterator iterator1 = keys1.iterator();\n    while (iterator1.hasNext()) {\n        Comparable key = (Comparable) iterator1.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!paint1.equals(paint2)) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // EXPR_RESULT\n  //   expression\n  Node expression = expr.getFirstChild();\n  if (expression.isString()) \n  {\n    String key = expression.getString();\n    String replacement = getReplacement(key);\n    if (replacement != null) \n    {\n      // Replace the node in parent, and reset current to the first new child.\n      Node replacementNode = IR.string(replacement);\n      replacementNode.copyInformationFromForTree(expression);\n      parent.replaceChild(expression, replacementNode);\n      recordReplacement(expression, key);\n      return replacementNode;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) \n  {\n    String key = expr.getString();\n    String replacement = getReplacement(key);\n    if (replacement != null) \n    {\n      Node replacementNode = IR.string(replacement);\n      replacementNode.copyInformationFromForTree(expr);\n      parent.replaceChild(expr, replacementNode);\n      recordReplacement(expr, key);\n      return replacementNode;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // EXPR_RESULT\n    //   expression\n    Node expression = expr.getFirstChild();\n    if (expression.isString()) \n    {\n        String key = expression.getString();\n        String replacement = getReplacement(key);\n        if (replacement != null) \n        {\n            Node replacementNode = IR.string(replacement);\n            replacementNode.copyInformationFromForTree(expression);\n            parent.replaceChild(expression, replacementNode);\n            recordReplacement(expression, key);\n            return replacementNode;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // EXPR_RESULT\n  //   expression\n  Node expression = expr.getFirstChild();\n  if (expression.isString()) \n  {\n    String key = expression.getString();\n    String replacement = getReplacement(key);\n    if (replacement != null) \n    {\n      Node replacementNode = IR.string(replacement);\n      replacementNode.copyInformationFromForTree(expression);\n      parent.replaceChild(expr, replacementNode);\n      recordReplacement(expression, key);\n      return replacementNode;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  if (expr.isString()) \n  {\n    String key = expr.getString();\n    String replacement = getReplacement(key);\n    if (replacement != null) \n    {\n      Node replacementNode = IR.string(replacement);\n      replacementNode.copyInformationFromForTree(expr);\n      parent.replaceChild(expr, replacementNode);\n      recordReplacement(expr, key);\n      return replacementNode;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n  // EXPR_RESULT\n  //   expression\n  Node expression = expr.getFirstChild();\n  if (expression.isString()) \n  {\n    String key = expression.getString();\n    String replacement = getReplacement(key);\n    if (replacement != null) \n    {\n      // Replace the node in parent, and reset current to the first new child.\n      Node replacementNode = IR.string(replacement);\n      parent.replaceChild(expr, replacementNode);\n      return replacementNode;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String key = expr.getString();\n        String replacement = getReplacement(key);\n        if (replacement != null) \n        {\n            Node replacementNode = IR.string(replacement);\n            replacementNode.copyInformationFromForTree(expr);\n            parent.replaceChild(expr, replacementNode);\n            recordReplacement(expr, key);\n            return replacementNode;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // TODO(user): This is a placeholder implementation.\n    // Replace the expression with a short encoded string expression.\n    // If the expression is a string literal, then return a string literal\n    // with the same value.\n    if (expr.isString()) \n    {\n        return IR.string(expr.getString());\n    }\n    // If the expression is a name, then return a string literal with the\n    // same value.\n    if (expr.isName()) \n    {\n        return IR.string(expr.getString());\n    }\n    // If the expression is a number, then return a string literal with the\n    // same value.\n    if (expr.isNumber()) \n    {\n        return IR.string(expr.getString());\n    }\n    // If the expression is a string concatenation, then return a string\n    // literal with the same value.\n    if (expr.isAdd()) \n    {\n        return IR.string(expr.getString());\n    }\n    // If the expression is a variable declaration, then return a string\n    // literal with the same value.\n    if (expr.isVar()) \n    {\n        return IR.string(expr.getString());\n    }\n    // If the expression is a function declaration, then return a string\n    // literal with the same value.\n    if (expr.isFunction()) \n    {\n        return IR.string(expr.getString());\n    }\n    // If the expression is a function call, then return a string literal\n    // with the same value.\n    if (expr.isCall()) \n    {\n        return IR.string(expr.getString());\n    }\n    // If the expression is a property access, then return a string literal\n    // with the same value.\n    if (expr.isGetProp()) \n    {\n        return IR.string(expr.getString());\n    }\n    // If the expression is a property access, then return a string literal\n    // with the same value.\n    if (expr.isGetElem()) \n    {\n        return IR.string(expr.getString());\n    }\n    // If the expression is a property access, then return a string literal\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    // EXPR_RESULT\n    //   expression\n    Node expression = expr.getFirstChild();\n    if (expression.isString()) \n    {\n        String key = expression.getString();\n        String replacement = getReplacement(key);\n        if (replacement != null) \n        {\n            Node replacementNode = IR.string(replacement);\n            replacementNode.copyInformationFromForTree(expression);\n            parent.replaceChild(expression, replacementNode);\n            recordReplacement(expression, key);\n            return replacementNode;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String key = expr.getString();\n        String replacement = getReplacement(key);\n        if (replacement != null) \n        {\n            Node replacementNode = IR.string(replacement);\n            replacementNode.copyInformationFromForTree(expr);\n            parent.replaceChild(expr, replacementNode);\n            return replacementNode;\n        }\n    }\n    return expr;\n}"
    ],
    [
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo docInfo = node.getJSDocInfo();\n  if (docInfo == null) {\n    return false;\n  }\n\n  // Check for description in @desc annotation\n  String desc = docInfo.getDescription();\n  if (desc != null) {\n    if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n      builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n      builder.setIsHidden(true);\n    } else {\n      builder.setDesc(desc);\n    }\n    return true;\n  }\n\n  // Check for description in @desc annotation\n  desc = docInfo.getLicense();\n  if (desc != null) {\n    builder.setDesc(desc);\n    return true;\n  }\n\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo docInfo = node.getJSDocInfo();\n  if (docInfo == null) {\n    return false;\n  }\n  if (docInfo.isNoSideEffects()) {\n    builder.setIsNoSideEffects();\n  }\n  if (docInfo.isModifiesThis()) {\n    builder.setModifiesThis();\n  }\n  if (docInfo.isModifiesArguments()) {\n    builder.setModifiesArguments();\n  }\n  if (docInfo.isModifiesThisOrArguments()) {\n    builder.setModifiesThisOrArguments();\n  }\n  if (docInfo.isNoReturn()) {\n    builder.setNoReturn();\n  }\n  if (docInfo.isNoThrow()) {\n    builder.setNoThrow();\n  }\n  if (docInfo.isPure()) {\n    builder.setPure();\n  }\n  if (docInfo.isNoInline()) {\n    builder.setNoInline();\n  }\n  if (docInfo.isNoWrapper()) {\n    builder.setNoWrapper();\n  }\n  if (docInfo.isNoAlias()) {\n    builder.setNoAlias();\n  }\n  if (docInfo.isNoCompare()) {\n    builder.setNoCompare();\n  }\n  if (docInfo.isNoCollapse()) {\n    builder.setNoCollapse();\n  }\n  if (docInfo.isNoFold()) {\n    builder.setNoFold();\n  }\n  if (docInfo.isNoFoldArguments()) {\n    builder.setNoFoldArguments();\n  }\n  if (docInfo.isNoFoldConstant()) {\n    builder.setNoFoldConstant();\n  }\n  if (docInfo.isNoFoldUnused()) {\n    builder.setNoFoldUnused();\n  }\n  if (docInfo.isNoFoldEquivalent()) {\n    builder.setNoFoldEquivalent();\n  }\n  if (docInfo.isNoFoldEquivalentArguments()) {\n    builder.setNoFoldEquivalentArguments();\n  }\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info == null) {\n    return false;\n  }\n\n  // Check for a @desc annotation\n  String desc = info.getDescription();\n  if (desc != null) {\n    builder.setDesc(desc);\n    return true;\n  }\n\n  // Check for a @desc annotation in a @param tag\n  List<JSDocInfo.Tag> tags = info.getTags();\n  for (JSDocInfo.Tag tag : tags) {\n    if (tag.getName().equals(\"param\")) {\n      desc = tag.getDescription();\n      if (desc != null) {\n        builder.setDesc(desc);\n        return true;\n      }\n    }\n  }\n\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    String desc = info.getDescription();\n    if (desc != null) {\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo docInfo = node.getJSDocInfo();\n  if (docInfo != null) {\n    // Check for @desc\n    if (docInfo.hasDesc()) {\n      String desc = docInfo.getDesc();\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info == null) {\n    return false;\n  }\n  if (info.containsKey(\"desc\")) {\n    builder.setDesc(info.getDescription());\n    return true;\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo docInfo = node.getJSDocInfo();\n  if (docInfo != null) {\n    if (docInfo.containsKey(\"desc\")) {\n      builder.setDesc(docInfo.getDescription());\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo docInfo = node.getJSDocInfo();\n  if (docInfo != null) {\n    // Check the description in @desc\n    if (docInfo.hasDescription()) {\n      String desc = docInfo.getDescription();\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo docInfo = node.getJSDocInfo();\n  if (docInfo != null) {\n    if (docInfo.hasDescription()) {\n      builder.setDesc(docInfo.getDescription());\n    }\n    if (docInfo.isNoSideEffects()) {\n      builder.setIsHidden(true);\n    }\n    return true;\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    if (info.hasDescription()) {\n      builder.setDesc(info.getDescription());\n      return true;\n    }\n    if (info.isNoSideEffects()) {\n      builder.setIsHidden(true);\n    }\n  }\n  return false;\n}"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double sum = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            sum += (xArray[i] - xArray[0]) * (yArray[i] - yArray[0]);\n        }\n        double mean = sum / (xArray.length - 1);\n        double sum2 = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            sum2 += (xArray[i] - xArray[0]) * (yArray[i] - yArray[0]) - mean;\n        }\n        return biasCorrected ? sum2 / (xArray.length - 1) : sum2 / xArray.length;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIFFERENT_LENGTH_OF_ARRAYS,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DATA_POINTS,\n                xArray.length, 2);\n    } else {\n        double sum = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            sum += (xArray[i] - xArray[0]) * (yArray[i] - yArray[0]);\n        }\n        double covariance = sum / (xArray.length - 1);\n        if (biasCorrected) {\n            covariance /= (xArray.length - 2);\n        }\n        return covariance;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIFFERENT_LENGTH_ARRAYS, xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION, xArray.length, 2);\n    } else {\n        double sum = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            sum += (xArray[i] - xArray[0]) * (yArray[i] - yArray[0]);\n        }\n        double cov = sum / (xArray.length - (biasCorrected ? 1 : 0));\n        return cov;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIFFERENT_LENGTH_FOR_ARRAYS,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double[] x = xArray;\n        double[] y = yArray;\n        if (rankingAlgorithm instanceof NaturalRanking &&\n                NaNStrategy.REMOVED == ((NaturalRanking) rankingAlgorithm).getNanStrategy()) {\n            final Set<Integer> nanPositions = new HashSet<Integer>();\n\n            nanPositions.addAll(getNaNPositions(xArray));\n            nanPositions.addAll(getNaNPositions(yArray));\n\n            x = removeValues(xArray, nanPositions);\n            y = removeValues(yArray, nanPositions);\n        }\n        return new PearsonsCorrelation().correlation(rankingAlgorithm.rank(x), rankingAlgorithm.rank(y));\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIFFERENT_LENGTH_FOR_COVARIANCE_ARRAYS,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DATA_FOR_COVARIANCE,\n                xArray.length);\n    } else {\n        double sum1 = 0;\n        double sum2 = 0;\n        double sum3 = 0;\n        double sum4 = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            final double x = xArray[i];\n            final double y = yArray[i];\n            sum1 += x;\n            sum2 += y;\n            sum3 += x * x;\n            sum4 += y * y;\n        }\n        final double meanX = sum1 / xArray.length;\n        final double meanY = sum2 / xArray.length;\n        final double meanX2 = sum3 / xArray.length;\n        final double meanY2 = sum4 / xArray.length;\n        return (biasCorrected ? xArray.length : (xArray.length - 1)) * (meanX2 - meanX * meanX) *\n                (meanY2 - meanY * meanY) / ((xArray.length - 1) * (meanX2 - meanX * meanX + meanY2 - meanY * meanY));\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIFFERENT_LENGTH_OF_ARRAYS,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DATA_POINTS,\n                xArray.length, 2);\n    }\n    double sum = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sum += (xArray[i] - xArray.mean()) * (yArray[i] - yArray.mean());\n    }\n    return sum / (xArray.length - (biasCorrected ? 1 : 0));\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIFFERENT_LENGTH_OF_ARRAYS,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double sum = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            sum += (xArray[i] - xArray.mean()) * (yArray[i] - yArray.mean());\n        }\n        return biasCorrected ? sum / (xArray.length - 1) : sum / xArray.length;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIFFERENT_LENGTH_OF_ARRAYS,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DATA_POINTS,\n                xArray.length, 2);\n    } else {\n        double covariance = 0;\n        double sumX = 0;\n        double sumY = 0;\n        double sumX2 = 0;\n        double sumY2 = 0;\n        double sumXY = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumX2 += xArray[i] * xArray[i];\n            sumY2 += yArray[i] * yArray[i];\n            sumXY += xArray[i] * yArray[i];\n        }\n        double meanX = sumX / xArray.length;\n        double meanY = sumY / yArray.length;\n        double varianceX = sumX2 / xArray.length - meanX * meanX;\n        double varianceY = sumY2 / yArray.length - meanY * meanY;\n        if (biasCorrected) {\n            covariance = (sumXY - (sumX * sumY) / xArray.length) /\n                    (Math.sqrt(varianceX) * Math.sqrt(varianceY));\n        } else {\n            covariance = (sumXY - (sumX * sumY) / xArray.length) /\n                    (xArray.length - 1) /\n                    (Math.sqrt(varianceX) * Math.sqrt(varianceY));\n        }\n        return covariance;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIFFERENT_LENGTH_OF_ARRAYS,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    } else {\n        double sum = 0;\n        double xmean = 0;\n        double ymean = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            xmean += xArray[i];\n            ymean += yArray[i];\n        }\n        xmean /= xArray.length;\n        ymean /= yArray.length;\n        for (int i = 0; i < xArray.length; i++) {\n            sum += (xArray[i] - xmean) * (yArray[i] - ymean);\n        }\n        if (biasCorrected) {\n            return sum / (xArray.length - 1);\n        } else {\n            return sum / xArray.length;\n        }\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIFFERENT_LENGTH_FOR_COVARIANCE,\n                xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DATA_FOR_COVARIANCE,\n                xArray.length);\n    } else {\n        double[] x = xArray;\n        double[] y = yArray;\n        if (rankingAlgorithm instanceof NaturalRanking &&\n                NaNStrategy.REMOVED == ((NaturalRanking) rankingAlgorithm).getNanStrategy()) {\n            final Set<Integer> nanPositions = new HashSet<Integer>();\n\n            nanPositions.addAll(getNaNPositions(xArray));\n            nanPositions.addAll(getNaNPositions(yArray));\n\n            x = removeValues(xArray, nanPositions);\n            y = removeValues(yArray, nanPositions);\n        }\n        return new PearsonsCorrelation().correlation(rankingAlgorithm.rank(x), rankingAlgorithm.rank(y));\n    }\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) \n        {\n            return;\n        }\n        skipped += x;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) \n        {\n            return;\n        }\n        skipped += x;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) \n        {\n            return;\n        }\n        skipped += x;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target, false);\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Calculate the fingerprint of the message parts\n    long fingerprint = 0;\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            // Use the placeholder reference name as the fingerprint\n            fingerprint = mix64(fingerprint,\n                fingerprint(\n                    CaseFormat.LOWER_CAMEL.to(\n                        CaseFormat.UPPER_UNDERSCORE,\n                        ((PlaceholderReference) part).getName())),\n                0);\n        }\n        else \n        {\n            // Use the string value as the fingerprint\n            fingerprint = mix64(fingerprint,\n                fingerprint(part.toString()),\n                0);\n        }\n    }\n\n    // Convert the fingerprint to a string\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < 63; i++) \n    {\n        // Use the least significant bit of the fingerprint to determine\n        // whether to append a character to the string\n        if ((fingerprint & 1) == 1) \n        {\n            sb.append(ALPHABET.charAt((int) (fingerprint % ALPHABET.length())));\n        }\n\n        // Shift the fingerprint to the next bit\n        fingerprint >>= 1;\n    }\n\n    return sb.toString();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Fingerprint the message parts\n    long fingerprint = 0;\n    for (CharSequence part : messageParts)\n    {\n        if (part instanceof PlaceholderReference)\n        {\n            fingerprint = mix64(fingerprint,\n                fingerprint(part.toString()), 0);\n        }\n        else\n        {\n            fingerprint = mix64(fingerprint,\n                fingerprint(part.toString()), 0);\n        }\n    }\n\n    // Convert the fingerprint to a string\n    String fingerprintString = Long.toHexString(fingerprint);\n\n    // Truncate the string to 63 characters\n    if (fingerprintString.length() > 63)\n    {\n        fingerprintString = fingerprintString.substring(0, 63);\n    }\n\n    // Uppercase the string\n    fingerprintString = fingerprintString.toUpperCase();\n\n    return fingerprintString;\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    long fp = 0;\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            fp = mix64(fp, 0x130f9bef, 0x94a0a928);\n        } \n        else \n        {\n            fp = mix64(fp, 0x130f9bef, 0x94a0a928);\n        }\n    }\n    return String.valueOf(fp);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Convert messageParts to a string\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n\n    // Generate a 63-bit fingerprint of the string\n    long fingerprint = 0;\n    for (int i = 0; i < tcValue.length(); i++) {\n        fingerprint = (fingerprint << 8) + tcValue.charAt(i);\n    }\n\n    // Convert the fingerprint to a string\n    StringBuilder result = new StringBuilder();\n    while (fingerprint != 0) {\n        result.append(Character.toUpperCase((char) (fingerprint % 64)));\n        fingerprint /= 64;\n    }\n\n    // Return the fingerprint as a string\n    return result.toString();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Implement the fingerprinting algorithm here\n    // ...\n    return \"\";\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n\n    String projectScopedMeaning =\n        (projectId != null ? (projectId + \": \") : \"\") + meaning;\n    return String.valueOf(\n        MessageId.generateId(tcValue, projectScopedMeaning));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(MessageId.generateId(tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Fingerprint the message parts\n    long fingerprint = 0;\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            // Fingerprint the placeholder name\n            fingerprint = mix64(fingerprint,\n                    fingerprint(\n                            ((PlaceholderReference) part).getName()),\n                    0x100000000L);\n        }\n        else \n        {\n            // Fingerprint the message part\n            fingerprint = mix64(fingerprint,\n                    fingerprint(part.toString()),\n                    0x100000000L);\n        }\n    }\n\n    // Truncate the fingerprint to 63 bits\n    fingerprint &= 0x7fffffffffffffffL;\n\n    // Convert the fingerprint to a compact uppercase alphanumeric string\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < 10; i++) \n    {\n        int index = (int) (fingerprint % 62);\n        sb.append(BASE62[index]);\n        fingerprint /= 62;\n    }\n\n    return sb.toString();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Implement your solution here\n    return null;\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    // Implement your solution here\n    return null;\n}"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long maxPosition = archive.size() - maxDistanceFromEnd;\n    long minPosition = archive.size() - minDistanceFromEnd;\n    long position = currentPosition;\n    while (position > minPosition) {\n        position -= WORD;\n        if (position < 0) {\n            position = 0;\n        }\n        archive.position(position);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(sig, wordBuf)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long pos = archive.size() - minDistanceFromEnd;\n    final long maxPos = archive.size() - maxDistanceFromEnd;\n    if (pos < 0) {\n        pos = 0;\n    }\n    while (pos < maxPos) {\n        archive.position(pos);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(sig, wordBuf)) {\n            return true;\n        }\n        pos += WORD;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long maxPosition = archive.size() - maxDistanceFromEnd;\n    long minPosition = archive.size() - minDistanceFromEnd;\n    if (minPosition < 0) {\n        minPosition = 0;\n    }\n    long position = archive.position();\n    long lastPosition = position;\n    while (position >= minPosition) {\n        archive.position(position);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(wordBuf, sig)) {\n            return true;\n        }\n        lastPosition = position;\n        position = archive.position() - WORD;\n        if (position < minPosition) {\n            break;\n        }\n    }\n    archive.position(lastPosition);\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long maxPosition = archive.size() - maxDistanceFromEnd;\n    long minPosition = Math.max(currentPosition - minDistanceFromEnd,\n                                ZIP64_EOCDL_LENGTH);\n    long position = currentPosition;\n    while (position > minPosition) {\n        position -= WORD;\n        archive.position(position);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(wordBuf, sig)) {\n            return true;\n        }\n    }\n    position = maxPosition;\n    while (position > minPosition) {\n        position -= WORD;\n        archive.position(position);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(wordBuf, sig)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long maxDistance = maxDistanceFromEnd;\n    long minDistance = minDistanceFromEnd;\n    long pos = archive.size() - minDistance;\n    if (pos < 0) {\n        pos = 0;\n        minDistance = 0;\n    }\n    while (pos >= minDistance) {\n        archive.position(pos);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(sig, wordBuf)) {\n            return true;\n        }\n        pos--;\n        maxDistance--;\n        if (maxDistance == 0) {\n            break;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long start = archive.size() - minDistanceFromEnd;\n    final long end = archive.size() - maxDistanceFromEnd;\n    final long step = (end - start) / 2;\n    long pos = start;\n    while (pos >= end) {\n        archive.position(pos);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(wordBuf, sig)) {\n            return true;\n        }\n        pos -= step;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long start = archive.size() - maxDistanceFromEnd;\n    final long end = archive.size() - minDistanceFromEnd;\n    final long len = end - start;\n    if (len < sig.length) {\n        return false;\n    }\n    final byte[] buf = new byte[sig.length];\n    long pos = start;\n    while (pos <= end) {\n        archive.position(pos);\n        IOUtils.readFully(archive, buf);\n        if (Arrays.equals(buf, sig)) {\n            return true;\n        }\n        pos++;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long minPosition = currentPosition - minDistanceFromEnd;\n    long maxPosition = currentPosition - maxDistanceFromEnd;\n    if (minPosition < 0) {\n        minPosition = 0;\n    }\n    if (maxPosition < 0) {\n        maxPosition = 0;\n    }\n    archive.position(maxPosition);\n    while (archive.position() >= minPosition) {\n        archive.position(archive.position() - sig.length);\n        byte[] buf = new byte[sig.length];\n        IOUtils.readFully(archive, buf);\n        if (Arrays.equals(buf, sig)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.position();\n    long maxPosition = archive.size() - maxDistanceFromEnd;\n    long minPosition = archive.size() - minDistanceFromEnd;\n    long position = currentPosition;\n    while (position >= minPosition && position <= maxPosition) \n    {\n        archive.position(position);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(sig, wordBuf)) \n        {\n            return true;\n        }\n        position--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long maxPosition = archive.size() - maxDistanceFromEnd;\n    long minPosition = archive.size() - minDistanceFromEnd;\n    if (minPosition < 0) {\n        minPosition = 0;\n    }\n    for (long position = maxPosition; position >= minPosition; position--) {\n        archive.position(position);\n        wordBbuf.rewind();\n        IOUtils.readFully(archive, wordBbuf);\n        if (Arrays.equals(wordBuf, sig)) {\n            return true;\n        }\n    }\n    return false;\n}"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) \n    {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) \n        {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public InputStream getDataStream()  {\n    return new InputStream() \n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) \n    {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) \n    {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream != null) {\n        return _originalStream;\n    }\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    return new InputStream() \n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) \n    {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new SequenceInputStream(new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength), _originalStream);\n}",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream != null) \n    {\n        return _originalStream;\n    }\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    // generate a key for the section...\n    Comparable key = new Integer(section);\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.dataset instanceof KeyedValues) {\n        KeyedValues kvalues = (KeyedValues) this.dataset;\n        result = kvalues.getKey(section);\n    }\n    if (result == null) {\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.dataset != null) \n    {\n        result = this.dataset.getRowKey(section);\n    }\n    if (result == null) \n    {\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    // check for existing key\n    Comparable result = null;\n    if (this.sectionKeys != null) \n    {\n        result = this.sectionKeys.get(section);\n    }\n    // generate a new key if necessary\n    if (result == null) \n    {\n        result = new Integer(section);\n        if (this.sectionKeys == null) \n        {\n            this.sectionKeys = new ArrayList();\n        }\n        this.sectionKeys.add(result);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    // if the section index is out of bounds, return null\n    if (section < 0 || section >= getItemCount()) \n    {\n        return null;\n    }\n\n    // get the key for the specified section\n    Comparable key = getDataset().getRowKey(section);\n\n    // if there is no key for the section, generate one\n    if (key == null) \n    {\n        key = \"Section \" + section;\n    }\n\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.dataset != null) {\n        result = this.dataset.getRowKey(section);\n    }\n    if (result == null) {\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    // check for existing key...\n    Comparable result = null;\n    int seriesCount = getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) \n    {\n        if (getItemCount(s) > section) \n        {\n            result = getSeriesKey(s);\n            break;\n        }\n    }\n    if (result == null) \n    {\n        // generate a new key...\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    // if there is no section key for this index, we create one...\n    Comparable result = this.sectionKeys.get(section);\n    if (result == null) {\n        result = new Integer(section);\n        this.sectionKeys.put(section, result);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable result = null;\n    if (this.dataset != null) {\n        result = this.dataset.getRowKey(section);\n    }\n    if (result == null) {\n        result = new Integer(section);\n    }\n    return result;\n}",
      "protected Comparable getSectionKey(int section)  {\n    // we don't have a dataset, so we can't use the section index\n    // directly as the key.  We'll generate a key instead.\n    return new Integer(section);\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            Number n = getNumberValue();\n            return (n instanceof Double) && ((Double) n).isNaN();\n        }",
      "@Override\n        public boolean isNaN()  {\n            Number n = getNumberValue();\n            return (n instanceof Double) && ((Double) n).isNaN();\n        }",
      "@Override\n        public boolean isNaN()  {\n            return (_currToken == JsonToken.VALUE_NUMBER_FLOAT)\n                    && (_currentObject() instanceof Double)\n                    && (((Double) _currentObject()).isNaN());\n        }",
      "@Override\n        public boolean isNaN()  {\n            Number n = getNumberValue();\n            return (n instanceof Double) && ((Double) n).isNaN();\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                Number n = _currentObject();\n                return (n instanceof Double) && Double.isNaN(((Double) n).doubleValue());\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            return (_currToken == JsonToken.VALUE_NUMBER_FLOAT)\n                    && Double.isNaN(((Number) _currentObject()).doubleValue());\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return Double.isNaN(((Number) _currentObject()).doubleValue());\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                return Double.isNaN(((Number) _currentObject()).doubleValue());\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            return (_currToken == JsonToken.VALUE_NUMBER_FLOAT &&\n                    _currentObject() instanceof Double &&\n                    ((Double) _currentObject()).isNaN());\n        }",
      "@Override\n        public boolean isNaN()  {\n            Number n = getNumberValue();\n            if (n instanceof Double) {\n                return Double.isNaN((Double) n);\n            }\n            if (n instanceof Float) {\n                return Float.isNaN((Float) n);\n            }\n            return false;\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) \n    {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) \n    {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}"
    ],
    [
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_BUFFERED) {\n        peekedString = peekedString.substring(0, peekedString.length() - peekedNumberLength);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return nextUnquotedValue();\n  }\n  if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n  }\n  throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_BUFFERED) {\n        peekedString = peekedString.substring(0, peekedString.length() - peekedNumberLength);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    } else if (p == PEEKED_LONG) {\n        peekedString = peekedString.substring(0, peekedString.length() - peekedNumberLength);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return nextUnquotedValue();\n  }\n  if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n  }\n  throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return nextUnquotedValue();\n  }\n  if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n  }\n  throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_BUFFERED) {\n        peekedString = peekedString.substring(0, peekedString.length() - peekedNumberLength);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    } else if (p == PEEKED_LONG) {\n        peekedString = peekedString.substring(0, peekedString.length() - peekedNumberLength);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextUnquotedValue();\n    }\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return nextUnquotedValue();\n  }\n  if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n  }\n  throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n}",
      "public String nextString() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return nextUnquotedValue();\n  }\n  if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n  }\n  throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextUnquotedValue();\n    }\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n}"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (maxWidth < 4) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) \n    {\n        return str;\n    }\n    if (offset > str.length()) \n    {\n        offset = str.length();\n    }\n    if ((str.length() - offset) < (maxWidth - 3)) \n    {\n        offset = str.length() - (maxWidth - 3);\n    }\n    if (offset <= 4) \n    {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) \n    {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if ((offset + (maxWidth - 3)) < str.length()) \n    {\n        return \"...\" + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return \"...\" + str.substring(str.length() - (maxWidth - 3));\n}"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n        if (s1 == null) {\n            return (s2 == null);\n        }\n        if (s2 == null) {\n            return false;\n        }\n        if (s1.length != s2.length) {\n            return false;\n        }\n        for (int i = 0; i < s1.length; i++) {\n            if (!ShapeUtilities.equal(s1[i], s2[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n        if (s1 == null) {\n            return (s2 == null);\n        }\n        if (s2 == null) {\n            return false;\n        }\n        if (s1.length != s2.length) {\n            return false;\n        }\n        for (int i = 0; i < s1.length; i++) {\n            if (!ShapeUtilities.equal(s1[i], s2[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n        if (s1 == null) {\n            return (s2 == null);\n        }\n        if (s2 == null) {\n            return false;\n        }\n        if (s1.length != s2.length) {\n            return false;\n        }\n        for (int i = 0; i < s1.length; i++) {\n            if (!ShapeUtilities.equal(s1[i], s2[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n        if (s1 == null) {\n            return (s2 == null);\n        }\n        if (s2 == null) {\n            return false;\n        }\n        if (s1.length != s2.length) {\n            return false;\n        }\n        for (int i = 0; i < s1.length; i++) {\n            if (!ShapeUtilities.equal(s1[i], s2[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n        if (s1 == null) {\n            return (s2 == null);\n        }\n        if (s2 == null) {\n            return false;\n        }\n        if (s1.length != s2.length) {\n            return false;\n        }\n        for (int i = 0; i < s1.length; i++) {\n            if (!ShapeUtilities.equal(s1[i], s2[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n        if (s1 == null) {\n            return (s2 == null);\n        }\n        if (s2 == null) {\n            return false;\n        }\n        if (s1.length != s2.length) {\n            return false;\n        }\n        for (int i = 0; i < s1.length; i++) {\n            if (!ShapeUtilities.equal(s1[i], s2[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) {\n            return index;\n        }\n        index = originalNameMap.size();\n        originalNameMap.put(symbolName, index);\n        return index;\n    }\n    return -1;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) \n    {\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) \n        {\n            return index;\n        }\n        index = originalNameMap.size();\n        originalNameMap.put(symbolName, index);\n        return index;\n    }\n    return -1;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) \n    {\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) \n        {\n            return index;\n        }\n        index = originalNameMap.size();\n        originalNameMap.put(symbolName, index);\n        return index;\n    }\n    return -1;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) \n    {\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) \n        {\n            return index;\n        }\n        index = originalNameMap.size();\n        originalNameMap.put(symbolName, index);\n        return index;\n    }\n    return -1;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != null) {\n    Integer index = originalNameMap.get(symbolName);\n    if (index != null) {\n      return index;\n    }\n    index = originalNameMap.size();\n    originalNameMap.put(symbolName, index);\n    return index;\n  }\n  return -1;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != null) {\n    Integer index = originalNameMap.get(symbolName);\n    if (index != null) {\n      return index;\n    }\n    index = originalNameMap.size();\n    originalNameMap.put(symbolName, index);\n    return index;\n  }\n  return -1;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) \n    {\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) \n        {\n            return index;\n        }\n        index = originalNameMap.size();\n        originalNameMap.put(symbolName, index);\n        return index;\n    }\n    return -1;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != null) {\n    Integer index = originalNameMap.get(symbolName);\n    if (index != null) {\n      return index;\n    }\n    index = originalNameMap.size();\n    originalNameMap.put(symbolName, index);\n    return index;\n  }\n  return -1;\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != null) {\n    Integer index = originalNameMap.get(symbolName);\n    if (index != null) {\n      return index;\n    } else {\n      index = originalNameMap.size();\n      originalNameMap.put(symbolName, index);\n      return index;\n    }\n  }\n  return -1;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) \n    {\n        Integer index = originalNameMap.get(symbolName);\n        if (index != null) \n        {\n            return index;\n        }\n        index = originalNameMap.size();\n        originalNameMap.put(symbolName, index);\n        return index;\n    }\n    return -1;\n}"
    ],
    [
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return (double) peekedLong;\n    } else if (p == PEEKED_NUMBER) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return Double.parseDouble(new String(buffer, pos, peekedNumberLength));\n    } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED) {\n        String result = nextQuotedValue(p == PEEKED_DOUBLE_QUOTED ? '\"' : '\\'');\n        if (result.length() == 0) {\n            throw new IllegalStateException(\"Expected value but was \" + peek() + locationString());\n        }\n        return Double.parseDouble(result);\n    }\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return (double) peekedLong;\n  }\n  if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED || p == PEEKED_UNQUOTED) {\n    peekedString = nextQuotedValue(p == PEEKED_DOUBLE_QUOTED ? '\"' : '\\'');\n  } else {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return Double.parseDouble(peekedString);\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return (double) peekedLong;\n  } else if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(peekedString);\n  }\n  throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return (double) peekedLong;\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return Double.parseDouble(peekedString);\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return (double) peekedLong;\n  } else if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(peekedString);\n  }\n  throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return (double) peekedLong;\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED || p == PEEKED_UNQUOTED) {\n      peekedString = nextQuotedValue(p == PEEKED_DOUBLE_QUOTED ? '\"' : '\\'');\n    } else {\n      throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(peekedString);\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return (double) peekedLong;\n    }\n    if (p == PEEKED_NUMBER) {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED || p == PEEKED_UNQUOTED) {\n        peekedString = nextQuotedValue(p == PEEKED_DOUBLE_QUOTED ? '\"' : '\\'');\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(peekedString);\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return (double) peekedLong;\n  }\n  if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED || p == PEEKED_UNQUOTED) {\n    peekedString = nextQuotedValue(p == PEEKED_DOUBLE_QUOTED ? '\"' : '\\'');\n  } else {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return Double.parseDouble(peekedString);\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_LONG) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return (double) peekedLong;\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return Double.parseDouble(peekedString);\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED || p == PEEKED_UNQUOTED) \n    {\n        peekedString = nextQuotedValue(p == PEEKED_DOUBLE_QUOTED ? '\"' : '\\'');\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return Double.parseDouble(peekedString);\n    }\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_LONG) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return (double) peekedLong;\n  } else if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return Double.parseDouble(peekedString);\n  }\n  throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n}"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    // Performance tuned for 2.0 (JDK1.4)\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    if (str.length() == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            char ch = str.charAt(0);\n            char[] output1 = new char[outputLength];\n            for (int i = repeat - 1; i >= 0; i--) {\n                output1[i] = ch;\n            }\n            return new String(output1);\n        case 2 :\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int inputLength = str.length();\n    if (repeat == 1 || inputLength == 0) {\n        return str;\n    }\n    if (inputLength == 1 && repeat <= PAD_LIMIT) {\n        return repeat(str.charAt(0), repeat);\n    }\n\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder buf = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i >= 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i >= 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                return repeat(str.charAt(0), repeat);\n            case 2 :\n                final char ch0 = str.charAt(0);\n                final char ch1 = str.charAt(1);\n                final char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                final StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }",
      "public static String repeat(final String str, final int repeat)  {\n        if (str == null) {\n            return null;\n        }\n        if (repeat <= 0) {\n            return EMPTY;\n        }\n        final int inputLength = str.length();\n        if (repeat == 1 || inputLength == 0) {\n            return str;\n        }\n        if (inputLength == 1 && repeat <= PAD_LIMIT) {\n            return repeat(str.charAt(0), repeat);\n        }\n        final int outputLength = inputLength * repeat;\n        switch (inputLength) {\n            case 1 :\n                char ch = str.charAt(0);\n                char[] output1 = new char[outputLength];\n                for (int i = repeat - 1; i >= 0; i--) {\n                    output1[i] = ch;\n                }\n                return new String(output1);\n            case 2 :\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                char[] output2 = new char[outputLength];\n                for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                    output2[i] = ch0;\n                    output2[i + 1] = ch1;\n                }\n                return new String(output2);\n            default :\n                StringBuilder buf = new StringBuilder(outputLength);\n                for (int i = 0; i < repeat; i++) {\n                    buf.append(str);\n                }\n                return buf.toString();\n        }\n    }"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField extraField = null;\n    Class<?> extraFieldClass = implementations.get(headerId);\n    if (extraFieldClass == null) {\n        extraFieldClass = UnrecognizedExtraField.class;\n    }\n    extraField = (ZipExtraField) extraFieldClass.newInstance();\n    extraField.setHeaderId(headerId);\n    return extraField;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField extraField = (ZipExtraField)\n            ExtraFieldUtils.implementations.get(headerId);\n    if (extraField == null) {\n        extraField = new UnrecognizedExtraField();\n        ((UnrecognizedExtraField) extraField).setHeaderId(headerId);\n    }\n    return extraField;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> extraClass = ExtraFieldUtils.implementations.get(headerId);\n    if (extraClass == null) {\n        extraClass = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) extraClass.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField extraField = (ZipExtraField) implementations.get(headerId).newInstance();\n    extraField.setHeaderId(headerId);\n    return extraField;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> extraClass = implementations.get(headerId);\n    if (extraClass == null) {\n        extraClass = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) extraClass.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField result = null;\n    Class<?> impl = implementations.get(headerId);\n    if (impl != null) {\n        result = (ZipExtraField) impl.newInstance();\n    } else {\n        result = new UnrecognizedExtraField();\n        ((UnrecognizedExtraField) result).setHeaderId(headerId);\n    }\n    return result;\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    Class<?> extraFieldClass = ExtraFieldUtils.implementations.get(headerId);\n    if (extraFieldClass == null) {\n        extraFieldClass = UnrecognizedExtraField.class;\n    }\n    return (ZipExtraField) extraFieldClass.newInstance();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> extraClass = ExtraFieldUtils.implementations.get(headerId);\n    if (extraClass != null) {\n        return (ZipExtraField) extraClass.newInstance();\n    }\n    return new UnrecognizedExtraField(headerId);\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return (ZipExtraField) clazz.newInstance();\n    }\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    ZipExtraField extra = (ZipExtraField)implementations.get(headerId);\n    if (extra == null) {\n        extra = new UnrecognizedExtraField();\n        ((UnrecognizedExtraField)extra).setHeaderId(headerId);\n    }\n    return extra;\n}"
    ],
    [
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for (int i = 0; i < sz; i++) {\n        if (chars.contains(chrs[i])) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for(int i=0; i<sz; i++) {\n        if(chars.contains(chrs[i])) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloned = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Marker marker = (Marker) entry.getValue();\n        cloned.put(key, marker.clone());\n    }\n    return cloned;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = new HashMap();\n    Iterator iterator = map.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        result.put(key, (Marker) map.get(key).clone());\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloned = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Marker marker = (Marker) entry.getValue();\n        cloned.put(key, (Marker) marker.clone());\n    }\n    return cloned;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloned = new HashMap();\n    for (Iterator it = map.keySet().iterator(); it.hasNext();) {\n        Comparable key = (Comparable) it.next();\n        Marker marker = (Marker) map.get(key);\n        cloned.put(key, (Marker) marker.clone());\n    }\n    return cloned;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Marker marker = (Marker) entry.getValue();\n        result.put(key, marker.clone());\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloned = new HashMap();\n    Iterator iterator = map.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Marker marker = (Marker) map.get(key);\n        cloned.put(key, (Marker) marker.clone());\n    }\n    return cloned;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Marker marker = (Marker) entry.getValue();\n        result.put(key, marker.clone());\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = new HashMap();\n    for (Iterator it = map.keySet().iterator(); it.hasNext();) {\n        Comparable key = (Comparable) it.next();\n        Marker marker = (Marker) map.get(key);\n        result.put(key, (Marker) marker.clone());\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map cloned = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Marker marker = (Marker) entry.getValue();\n        cloned.put(key, marker.clone());\n    }\n    return cloned;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = new HashMap();\n    for (Iterator iterator = map.keySet().iterator(); iterator.hasNext();) {\n        Comparable key = (Comparable) iterator.next();\n        result.put(key, (Marker) map.get(key).clone());\n    }\n    return result;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E object : coll) \n        {\n            if (set.contains(object) == false) \n            {\n                super.add(index, object);\n                set.add(object);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (set.contains(e)) {\n                continue;\n            }\n            toAdd.add(e);\n            changed = true;\n        }\n        // adds element if it is not contained already\n        if (changed) {\n            super.addAll(index, toAdd);\n            set.addAll(toAdd);\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) \n        {\n            if (set.contains(e)) \n            {\n                continue;\n            }\n            toAdd.add(e);\n            changed = true;\n        }\n        // adds element if it is not contained already\n        if (changed) \n        {\n            super.addAll(index, toAdd);\n            set.addAll(toAdd);\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // checks if collection is null\n        if (coll == null) {\n            throw new NullPointerException(\"The collection to add is null\");\n        }\n        // checks if collection is empty\n        if (coll.isEmpty()) {\n            return false;\n        }\n        // creates a new set from the collection\n        final Set<E> set = new HashSet<E>(coll);\n        // adds the set to the list\n        addAll(index, set);\n        return true;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E e : coll) {\n            if (set.contains(e) == false) {\n                super.add(index, e);\n                set.add(e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) \n        {\n            if (set.contains(e)) \n            {\n                continue;\n            }\n            toAdd.add(e);\n            changed = true;\n        }\n        // adds element if it is not contained already\n        for (final E e : toAdd) \n        {\n            super.add(index, e);\n            set.add(e);\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // adds element if it is not contained already\n        if (set.containsAll(coll) == false) \n        {\n            super.addAll(index, coll);\n            set.addAll(coll);\n        }\n        return false;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // checks if collection is null\n        if (coll == null) {\n            throw new NullPointerException(\"The collection to add is null\");\n        }\n\n        // checks if collection is empty\n        if (coll.isEmpty()) {\n            return false;\n        }\n\n        // adds elements to the list\n        for (final E e : coll) {\n            add(index++, e);\n        }\n\n        return true;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // gets initial size\n        final int sizeBefore = size();\n\n        // adds element if it is not contained already\n        for (final E object : coll) {\n            if (set.contains(object) == false) {\n                super.add(index, object);\n                set.add(object);\n            }\n        }\n\n        // compares sizes to detect if collection changed\n        return sizeBefore != size();\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // adds element if it is not contained already\n        for (final E element : coll) \n        {\n            if (set.contains(element) == false) \n            {\n                super.add(index, element);\n                set.add(element);\n            }\n        }\n        return true;\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}"
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints)\n    {\n        if (constraint.getValue() < 0)\n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1), constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()));\n        }\n        else\n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue()));\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getValue() < 0) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                                           constraint.getRelationship().oppositeRelationship(),\n                                                           -1 * constraint.getValue()));\n        } \n        else \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(),\n                                                           constraint.getRelationship(), constraint.getValue()));\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        if (constraint.getValue() < 0) \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                                           constraint.getRelationship().oppositeRelationship(),\n                                                           -1 * constraint.getValue()));\n        }\n        else \n        {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients(),\n                                                           constraint.getRelationship(), constraint.getValue()));\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints)\n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound) \n    {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound) \n    {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound < bin.upperBound && this.upperBound > bin.lowerBound) \n    {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound < bin.upperBound) \n    {\n        return true;\n    }\n    if (this.upperBound > bin.lowerBound) \n    {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound) {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound) \n    {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound < bin.lowerBound) {\n        return false;\n    }\n    if (this.upperBound > bin.upperBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.getUpperBound()) \n    {\n        return false;\n    }\n    if (this.upperBound < bin.getLowerBound()) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound < bin.lowerBound) \n    {\n        return false;\n    }\n    if (this.lowerBound > bin.lowerBound) \n    {\n        return true;\n    }\n    // lower bounds are the same\n    if (this.upperBound < bin.upperBound) \n    {\n        return false;\n    }\n    if (this.upperBound > bin.upperBound) \n    {\n        return true;\n    }\n    return true;\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>(sz / 2);\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(tokenStart));\n    for (int pos = tokenStart + 1; pos < sz; pos++) {\n        final int type = Character.getType(str.charAt(pos));\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            int newTokenStart = pos - 1;\n            while (newTokenStart >= tokenStart && Character.isLetter(str.charAt(newTokenStart))) {\n                newTokenStart--;\n            }\n            if (newTokenStart < tokenStart) {\n                tokenStart = newTokenStart;\n                list.add(str.substring(tokenStart, pos));\n                currentType = type;\n                continue;\n            }\n        }\n        list.add(str.substring(tokenStart, pos));\n        tokenStart = pos;\n        currentType = type;\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>(sz / 2);\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(0));\n    for (int c = 1; c < sz; c++) {\n        final int type = Character.getType(str.charAt(c));\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            tokenStart = c;\n            continue;\n        }\n        list.add(str.substring(tokenStart, c));\n        tokenStart = c;\n        currentType = type;\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (str.isEmpty()) \n    {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>(sz);\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(tokenStart));\n    for (int i = tokenStart + 1; i < sz; i++) \n    {\n        final int type = Character.getType(str.charAt(i));\n        if (type == currentType) \n        {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) \n        {\n            i--;\n            continue;\n        }\n        list.add(str.substring(tokenStart, i));\n        tokenStart = i;\n        currentType = type;\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>(sz / 2);\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(tokenStart));\n    for (int pos = tokenStart + 1; pos < sz; pos++) {\n        final int type = Character.getType(str.charAt(pos));\n        if (type == currentType) {\n            continue;\n        }\n        if (type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            if (camelCase) {\n                list.add(str.substring(tokenStart, pos - 1));\n                tokenStart = pos - 1;\n            } else {\n                tokenStart = pos;\n            }\n        } else {\n            list.add(str.substring(tokenStart, pos));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (str.isEmpty()) \n    {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>(sz / 2);\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(0));\n    for (int c = 1; c < sz; c++) \n    {\n        final int type = Character.getType(str.charAt(c));\n        if (type == currentType) \n        {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) \n        {\n            int c2 = 1;\n            while (c2 < c && Character.isLetter(str.charAt(c - c2))) \n            {\n                c2++;\n            }\n            if (c2 == c) \n            {\n                continue;\n            }\n        }\n        list.add(str.substring(tokenStart, c));\n        tokenStart = c;\n        currentType = type;\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (str.isEmpty()) \n    {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>(sz);\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(0));\n    for (int c = 1; c < sz; c++) \n    {\n        final int type = Character.getType(str.charAt(c));\n        if (type == currentType) \n        {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) \n        {\n            list.set(list.size() - 1, str.substring(tokenStart, c));\n        } \n        else \n        {\n            list.add(str.substring(tokenStart, c));\n            tokenStart = c;\n        }\n        currentType = type;\n    }\n    if (tokenStart < sz) \n    {\n        list.add(str.substring(tokenStart, sz));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (str.isEmpty()) \n    {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>(sz / 2);\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(0));\n    for (int c = 1; c < sz; c++) \n    {\n        final int type = Character.getType(str.charAt(c));\n        if (type == currentType) \n        {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) \n        {\n            int c2 = c - 1;\n            while (c2 >= 0 && Character.isLetter(str.charAt(c2))) \n            {\n                c2--;\n            }\n            if (str.charAt(c2 + 1) == '_') \n            {\n                continue;\n            }\n        }\n        list.add(str.substring(tokenStart, c));\n        tokenStart = c;\n        currentType = type;\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>(sz / 2);\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(tokenStart));\n    for (int pos = tokenStart + 1; pos < sz; pos++) {\n        final int type = Character.getType(str.charAt(pos));\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            final int newTokenStart = pos - 1;\n            if (newTokenStart != tokenStart) {\n                list.add(str.substring(tokenStart, newTokenStart));\n                tokenStart = newTokenStart;\n            }\n        } else {\n            list.add(str.substring(tokenStart, pos));\n            tokenStart = pos;\n        }\n        currentType = type;\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>(sz);\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(0));\n    for (int c = 1; c < sz; c++) {\n        final int type = Character.getType(str.charAt(c));\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            list.set(list.size() - 1, str.substring(tokenStart, c));\n        } else {\n            list.add(str.substring(tokenStart, c));\n            tokenStart = c;\n        }\n        currentType = type;\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.isEmpty()) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final int sz = str.length();\n    List<String> list = new ArrayList<String>(sz);\n    int tokenStart = 0;\n    int currentType = Character.getType(str.charAt(0));\n    for (int c = 1; c < sz; c++) {\n        final int type = Character.getType(str.charAt(c));\n        if (type == currentType) {\n            continue;\n        }\n        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {\n            tokenStart = c;\n            continue;\n        }\n        list.add(str.substring(tokenStart, c));\n        tokenStart = c;\n        currentType = type;\n    }\n    list.add(str.substring(tokenStart, sz));\n    return list.toArray(new String[list.size()]);\n}"
    ],
    [
      "public long parseMillis(String text)  {\n    return parseDateTime(text).getMillis();\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            return bucket.computeMillis(true, text);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(\"Invalid format: \\\"\" + text + \"\\\"\" +\n            (newPos >= 0 ? \" (at position \" + newPos + \")\" : \"\"));\n}",
      "public long parseMillis(String text)  {\n    // TODO: implement\n    return 0;\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(\"Invalid format: \\\"\" + text.substring(newPos) + \"\\\"\");\n    }\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(\"Invalid format: \" + text.substring(newPos));\n    }\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(\"Invalid format: \\\"\" + text + \"\\\"\" + infoError(newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            return bucket.computeMillis(true, text);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(\"Invalid format: \" + text.substring(newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(\"Invalid format: \\\"\" + text + \"\\\"\" + infoError(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            return bucket.computeMillis(true, text);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(\"Invalid format: \\\"\" + text + \"\\\"\" +\n            (newPos >= 0 ? \"\" : \" (error at position \" + newPos + \")\"));\n}",
      "public long parseMillis(String text)  {\n    return parseDateTime(text).getMillis();\n}"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  switch (n.getType()) {\n    case Token.NOT: {\n      MinimizedCondition subtree =\n          unoptimized(n.getFirstChild().detachFromParent());\n      return new MinimizedCondition(\n          subtree.positive.cloneTree().addNot(),\n          new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, true));\n    }\n    case Token.AND:\n    case Token.OR: {\n      int opType = n.getType();\n      int complementType = opType == Token.AND ? Token.OR : Token.AND;\n      MinimizedCondition leftSubtree =\n          unoptimized(n.getFirstChild().detachFromParent());\n      MinimizedCondition rightSubtree =\n          unoptimized(n.getLastChild().detachFromParent());\n      return new MinimizedCondition(\n          MeasuredNode.addNode(new Node(opType).srcref(n),\n              leftSubtree.positive.cloneTree(),\n              rightSubtree.positive.cloneTree()),\n          MeasuredNode.addNode(new Node(complementType).srcref(n),\n              leftSubtree.negative.cloneTree(),\n              rightSubtree.negative.cloneTree()).negate());\n    }\n    default:\n      return new MinimizedCondition(\n          new MeasuredNode(n.cloneTree(), Integer.MAX_VALUE, true),\n          new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, true));\n  }\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return new MinimizedCondition(\n      MeasuredNode.addNode(n.cloneTree(),\n          new Node(Token.SCRIPT).setLength(Integer.MAX_VALUE)),\n      MeasuredNode.addNode(n.cloneTree(),\n          new Node(Token.SCRIPT).setLength(Integer.MAX_VALUE)));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  MeasuredNode positive = MeasuredNode.addNode(\n      new Node(Token.SCRIPT).srcref(n),\n      MeasuredNode.addNode(\n          new Node(Token.SCRIPT).srcref(n),\n          MeasuredNode.addNode(\n              new Node(Token.SCRIPT).srcref(n),\n              MeasuredNode.addNode(\n                  new Node(Token.SCRIPT).srcref(n),\n                  MeasuredNode.addNode(\n                      new Node(Token.SCRIPT).srcref(n),\n                      MeasuredNode.addNode(\n                          new Node(Token.SCRIPT).srcref(n),\n                          MeasuredNode.addNode(\n                              new Node(Token.SCRIPT).srcref(n),\n                              MeasuredNode.addNode(\n                                  new Node(Token.SCRIPT).srcref(n),\n                                  MeasuredNode.addNode(\n                                      new Node(Token.SCRIPT).srcref(n),\n                                      MeasuredNode.addNode(\n                                          new Node(Token.SCRIPT).srcref(n),\n                                          MeasuredNode.addNode(\n                                              new Node(Token.SCRIPT).srcref(n),\n                                              MeasuredNode.addNode(\n                                                  new Node(Token.SCRIPT).srcref(n),\n                                                  MeasuredNode.addNode(\n                                                      new Node(Token.SCRIPT).srcref(n),\n                                                      MeasuredNode.addNode(\n                                                          new Node(Token.SCRIPT).srcref(n),\n                                                          MeasuredNode.addNode(\n                                                              new Node(Token.SCRIPT).srcref(n),\n                                                              MeasuredNode.addNode(\n                                                                  new Node(Token.SCRIPT).srcref(n),\n                                                                  MeasuredNode.addNode(\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return new MinimizedCondition(\n      MeasuredNode.fromNode(n),\n      MeasuredNode.fromNode(new Node(Token.SCRIPT).srcref(n)));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return new MinimizedCondition(\n      new MeasuredNode(n.cloneTree(), Integer.MAX_VALUE, false),\n      new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  switch (n.getType()) {\n    case Token.NOT:\n      return computeMinimizedCondition(n.getFirstChild().detachFromParent());\n    case Token.AND:\n    case Token.OR:\n      int opType = n.getType();\n      int complementType = opType == Token.AND ? Token.OR : Token.AND;\n      MinimizedCondition leftSubtree =\n          computeMinimizedCondition(n.getFirstChild().detachFromParent());\n      MinimizedCondition rightSubtree =\n          computeMinimizedCondition(n.getLastChild().detachFromParent());\n      return new MinimizedCondition(\n          MeasuredNode.addNode(new Node(opType).srcref(n),\n              leftSubtree.positive.cloneTree(),\n              rightSubtree.positive.cloneTree()),\n          MeasuredNode.addNode(new Node(complementType).srcref(n),\n              leftSubtree.negative.cloneTree(),\n              rightSubtree.negative.cloneTree()).negate());\n    default:\n      return new MinimizedCondition(\n          MeasuredNode.addNode(n.cloneTree(), new Node(Token.SCRIPT)),\n          MeasuredNode.addNode(new Node(Token.SCRIPT), new Node(Token.SCRIPT)));\n  }\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return new MinimizedCondition(\n      new MeasuredNode(n.cloneTree(), Integer.MAX_VALUE, false),\n      new MeasuredNode(new Node(Token.SCRIPT).srcref(n), Integer.MAX_VALUE, false));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  MeasuredNode positive = new MeasuredNode(n, Integer.MAX_VALUE, false);\n  MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, true);\n  return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  Preconditions.checkArgument(n.getParent() == null);\n  return new MinimizedCondition(\n      MeasuredNode.addNode(n.cloneTree(), new Node(Token.SCRIPT).srcref(n)),\n      MeasuredNode.addNode(new Node(Token.SCRIPT).srcref(n),\n          new Node(Token.SCRIPT).srcref(n)));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n  return new MinimizedCondition(\n      new MeasuredNode(n, Integer.MAX_VALUE, false),\n      new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false));\n}"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) \n    {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVectors(enumClass, values.toArray(new E[0]));\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVectors(enumClass, values.toArray(new E[0]));\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) \n    {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) \n    {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        ConverterSet set = iPartialConverters;\n        PartialConverter[] converters = new PartialConverter[set.size()];\n        set.copyInto(converters);\n        for (int i = 0; i < converters.length; i++) {\n            if (converters[i].equals(converter)) {\n                return converters[i];\n            }\n        }\n        Converter[] removed = new Converter[1];\n        ConverterSet newSet = set.add(converter, removed);\n        if (newSet == set) {\n            return null;\n        }\n        iPartialConverters = newSet;\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    return (PartialConverter)iPartialConverters.add(converter, null);\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    ConverterSet set = iPartialConverters;\n    Converter[] converters = set.getConverters();\n    int length = converters.length;\n    for (int i=0; i<length; i++) {\n        Converter existing = converters[i];\n        if (converter.equals(existing)) {\n            // Already in the set.\n            return (PartialConverter)existing;\n        }\n        \n        if (converter.getSupportedType() == existing.getSupportedType()) {\n            // Replace the converter.\n            Converter[] copy = new Converter[length];\n            \n            for (int j=0; j<length; j++) {\n                if (j != i) {\n                    copy[j] = converters[j];\n                } else {\n                    copy[j] = converter;\n                }\n            }\n\n            return (PartialConverter)set.add(converter, copy);\n        }\n    }\n\n    // Not found, so add it.\n    return (PartialConverter)set.add(converter, null);\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        ConverterSet set = iPartialConverters;\n        Converter[] removed = new Converter[1];\n        set = set.add(converter, removed);\n        if (removed[0] != null) {\n            return (PartialConverter) removed[0];\n        }\n        return null;\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        return null;\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    ConverterSet set = iPartialConverters;\n    Converter[] converters = set.getConverters();\n    for (int i=0; i<converters.length; i++) {\n        if (converter.equals(converters[i])) {\n            // Already in the set.\n            return (PartialConverter)converters[i];\n        }\n    }\n    // Not found, so add it.\n    return (PartialConverter)set.add(converter, null);\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        return (PartialConverter)iPartialConverters.add(converter, null);\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    ConverterSet set = iPartialConverters;\n    Converter[] converters = set.getConverters();\n    for (int i=0; i<converters.length; i++) {\n        if (converter.equals(converters[i])) {\n            // Already in the set.\n            return (PartialConverter)converters[i];\n        }\n    }\n    // Not found, so add it.\n    Converter[] copy = new Converter[converters.length + 1];\n    System.arraycopy(converters, 0, copy, 0, converters.length);\n    copy[converters.length] = converter;\n    return (PartialConverter)set.add(converter, null).getConverter();\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    return null;\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    ConverterSet set = iPartialConverters;\n    Converter[] converters = set.getConverters();\n    for (int i=0; i<converters.length; i++) {\n        if (converter.equals(converters[i])) {\n            // Already in the set.\n            return (PartialConverter)converters[i];\n        }\n    }\n    // Not found, so add it.\n    Converter[] copy = new Converter[converters.length + 1];\n    System.arraycopy(converters, 0, copy, 0, converters.length);\n    copy[converters.length] = converter;\n    return (PartialConverter)set.add(converter, null).getConverter();\n}"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  int depth = 0;\n  while (scope != null) {\n    if (scope.isLexicalScope()) {\n      return depth;\n    }\n    depth++;\n    scope = scope.getParentScope();\n  }\n  return 0;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  int depth = 0;\n  while (!scope.isGlobalScope()) {\n    depth++;\n    scope = scope.getParentScope();\n  }\n  return depth;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    Preconditions.checkState(scope.isDocScope());\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    SymbolScope parentScope = scope.getParentScope();\n    return getLexicalScopeDepth(parentScope) + 1;\n  } else if (scope.isDocScope()) {\n    return 0;\n  } else {\n    throw new IllegalStateException(\"Unexpected scope type\");\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    Preconditions.checkState(scope.isDocScope());\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  int depth = 0;\n  while (!scope.isGlobalScope()) {\n    depth++;\n    scope = scope.getParentScope();\n  }\n  return depth;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  int depth = 0;\n  while (scope != null && !scope.isGlobalScope()) {\n    depth++;\n    scope = scope.getParentScope();\n  }\n  return depth;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  int depth = 0;\n  while (!scope.isGlobalScope()) {\n    depth++;\n    scope = scope.getParentScope();\n  }\n  return depth;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    Preconditions.checkState(scope.isDocScope());\n    return 0;\n  }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n  if (scope.isLexicalScope()) {\n    return scope.getScopeDepth();\n  } else if (scope.isPropertyScope()) {\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n  } else {\n    Preconditions.checkState(scope.isDocScope());\n    return 0;\n  }\n}"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blockData = new double[blockRows][blockColumns];\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n            final int row = blockRow * BLOCK_SIZE;\n            final int column = blockColumn * BLOCK_SIZE;\n            final int blockRowEnd = FastMath.min(row + BLOCK_SIZE, rows);\n            final int blockColumnEnd = FastMath.min(column + BLOCK_SIZE, columns);\n            for (int i = row; i < blockRowEnd; ++i) {\n                for (int j = column; j < blockColumnEnd; ++j) {\n                    blockData[blockRow][blockColumn] = rawData[i][j];\n                }\n            }\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blockData = new double[blockRows][blockColumns];\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        final int rowStart = blockRow * BLOCK_SIZE;\n        final int rowEnd = Math.min(rowStart + BLOCK_SIZE, rows);\n        for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n            final int columnStart = blockColumn * BLOCK_SIZE;\n            final int columnEnd = Math.min(columnStart + BLOCK_SIZE, columns);\n            for (int row = rowStart; row < rowEnd; ++row) {\n                for (int column = columnStart; column < columnEnd; ++column) {\n                    blockData[blockRow][blockColumn] = rawData[row][column];\n                }\n            }\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blockData = new double[blockRows][blockColumns];\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        final int rowStart = blockRow * BLOCK_SIZE;\n        final int rowEnd = Math.min(rowStart + BLOCK_SIZE, rows);\n        for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n            final int columnStart = blockColumn * BLOCK_SIZE;\n            final int columnEnd = Math.min(columnStart + BLOCK_SIZE, columns);\n            for (int i = rowStart; i < rowEnd; ++i) {\n                System.arraycopy(rawData[i], columnStart, blockData[blockRow][blockColumn],\n                                 i - rowStart, columnEnd - columnStart);\n            }\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blockData = new double[blockRows][blockColumns];\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n            final int rowStart = blockRow * BLOCK_SIZE;\n            final int columnStart = blockColumn * BLOCK_SIZE;\n            final int rowEnd = Math.min(rowStart + BLOCK_SIZE, rows);\n            final int columnEnd = Math.min(columnStart + BLOCK_SIZE, columns);\n            for (int row = rowStart; row < rowEnd; ++row) {\n                System.arraycopy(rawData[row], columnStart, blockData[blockRow][blockColumn],\n                                 row - rowStart, columnEnd - columnStart);\n            }\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blockData = new double[blockRows][blockColumns];\n\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        final int row0 = blockRow * BLOCK_SIZE;\n        final int row1 = FastMath.min(row0 + BLOCK_SIZE, rows);\n        for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n            final int column0 = blockColumn * BLOCK_SIZE;\n            final int column1 = FastMath.min(column0 + BLOCK_SIZE, columns);\n            for (int i = row0; i < row1; ++i) {\n                for (int j = column0; j < column1; ++j) {\n                    blockData[blockRow][blockColumn] = rawData[i][j];\n                }\n            }\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blockData = new double[blockRows][blockColumns];\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n            final int startRow = blockRow * BLOCK_SIZE;\n            final int startColumn = blockColumn * BLOCK_SIZE;\n            final int endRow = startRow + BLOCK_SIZE;\n            final int endColumn = startColumn + BLOCK_SIZE;\n            final int blockHeight = Math.min(endRow, rows) - startRow;\n            final int blockWidth = Math.min(endColumn, columns) - startColumn;\n            for (int i = 0; i < blockHeight; ++i) {\n                System.arraycopy(rawData[startRow + i], startColumn,\n                                 blockData[blockRow][blockColumn], i * blockWidth,\n                                 blockWidth);\n            }\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blockData = new double[blockRows][blockColumns];\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        final int row0 = blockRow * BLOCK_SIZE;\n        final int row1 = FastMath.min(row0 + BLOCK_SIZE, rows);\n        for (int blockCol = 0; blockCol < blockColumns; ++blockCol) {\n            final int col0 = blockCol * BLOCK_SIZE;\n            final int col1 = FastMath.min(col0 + BLOCK_SIZE, columns);\n            for (int row = row0; row < row1; ++row) {\n                for (int col = col0; col < col1; ++col) {\n                    blockData[blockRow][blockCol] = rawData[row][col];\n                }\n            }\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blockData = new double[blockRows][blockColumns];\n\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        final int rowStart = blockRow * BLOCK_SIZE;\n        final int rowEnd = Math.min(rowStart + BLOCK_SIZE, rows);\n        for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n            final int columnStart = blockColumn * BLOCK_SIZE;\n            final int columnEnd = Math.min(columnStart + BLOCK_SIZE, columns);\n            for (int i = rowStart; i < rowEnd; ++i) {\n                for (int j = columnStart; j < columnEnd; ++j) {\n                    blockData[blockRow][blockColumn] = rawData[i][j];\n                }\n            }\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blockData = new double[blockRows][blockColumns];\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        final int rowStart = blockRow * BLOCK_SIZE;\n        final int rowEnd   = FastMath.min(rowStart + BLOCK_SIZE, rows);\n        for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n            final int columnStart = blockColumn * BLOCK_SIZE;\n            final int columnEnd   = FastMath.min(columnStart + BLOCK_SIZE, columns);\n            for (int row = rowStart; row < rowEnd; ++row) {\n                for (int column = columnStart; column < columnEnd; ++column) {\n                    blockData[blockRow][blockColumn] = rawData[row][column];\n                }\n            }\n        }\n    }\n\n    return blockData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blockData = new double[blockRows][blockColumns];\n    for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n        for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n            final int startRow = blockRow * BLOCK_SIZE;\n            final int endRow = Math.min(rows, startRow + BLOCK_SIZE);\n            final int startColumn = blockColumn * BLOCK_SIZE;\n            final int endColumn = Math.min(columns, startColumn + BLOCK_SIZE);\n            for (int i = startRow; i < endRow; ++i) {\n                System.arraycopy(rawData[i], startColumn, blockData[blockRow][blockColumn],\n                                 i - startRow, endColumn - startColumn);\n            }\n        }\n    }\n\n    return blockData;\n}"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    // Implement your code here\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVector(enumClass, values);\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVector(enumClass, values);\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVector(enumClass, values);\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVector(enumClass, values);\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    return generateBitVector(enumClass, values.toArray(new E[0]));\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a;\n    c = c.multiply(c);\n\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 2; i < 90; i += 2) \n    {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i - 1) * i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) \n        {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\n        final Dfp inta = a.rint();\n        final Dfp fraca = a.subtract(inta);\n\n        final int ia = inta.intValue();\n        if (ia > 2147483646) {\n            // return +Infinity\n            return a.newInstance((byte)1, Dfp.INFINITE);\n        }\n\n        if (ia < -2147483646) {\n            // return 0;\n            return a.newInstance();\n        }\n\n        final Dfp einta = splitPow(a.getField().getESplit(), ia);\n        final Dfp efraca = expInternal(fraca);\n\n        return einta.multiply(efraca);\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n    // Check for special cases\n    if (a.equals(a.getZero())) {\n        return a.getOne();\n    }\n\n    if (a.lessThan(a.getZero())) {\n        return a.getOne().divide(expInternal(a.negate()));\n    }\n\n    if (a.greaterThan(a.getField().getLn2())) {\n        return exp(a.divide(a.getField().getLn2()).multiply(a.getField().getLn2()));\n    }\n\n    // General case:  create another dfp, result, that contains the\n    // a with the fractional part lopped off.  */\n    Dfp result = a.rint();\n    Dfp x = a.subtract(result);\n\n    Dfp y = newInstance(1);\n    Dfp fact = newInstance(1);\n    Dfp py = newInstance(1);\n\n    for (int i = 1; i < 90; i += 2) {\n        x = x.multiply(x);\n        x = x.multiply(a);\n\n        fact = fact.divide(i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = newInstance(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\n    final Dfp inta = a.rint();\n    final Dfp fraca = a.subtract(inta);\n\n    final int ia = inta.intValue();\n    if (ia > 2147483646) {\n        // return +Infinity\n        return a.newInstance((byte)1, Dfp.INFINITE);\n    }\n\n    if (ia < -2147483646) {\n        // return 0;\n        return a.newInstance();\n    }\n\n    final Dfp einta = splitPow(a.getField().getESplit(), ia);\n    final Dfp efraca = expInternal(fraca);\n\n    return einta.multiply(efraca);\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\n        final Dfp one = a.getOne();\n\n        Dfp x = one;\n        Dfp y = one;\n        Dfp c = a.multiply(a);\n\n        Dfp fact = one;\n        Dfp py = new Dfp(y);\n\n        for (int i = 2; i < 90; i += 2) {\n            x = x.multiply(c);\n            x = x.divide(i);\n\n            fact = fact.divide((i - 1) * i);  // 1 over fact\n            y = y.add(x.multiply(fact));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n    // compute 1 + x**2/2! + x**3/3! + x**4/4!  ...\n    Dfp result = a.getOne();\n    Dfp x2 = a.multiply(a);\n    Dfp x4 = x2.multiply(x2);\n    Dfp x6 = x4.multiply(x2);\n    Dfp x8 = x4.multiply(x4);\n    Dfp x10 = x8.multiply(x2);\n    Dfp x12 = x8.multiply(x4);\n    Dfp x14 = x8.multiply(x6);\n    Dfp x16 = x8.multiply(x8);\n    Dfp x18 = x8.multiply(x10);\n    Dfp x20 = x8.multiply(x12);\n    Dfp x22 = x8.multiply(x14);\n    Dfp x24 = x8.multiply(x16);\n    Dfp x26 = x8.multiply(x18);\n    Dfp x28 = x8.multiply(x20);\n    Dfp x30 = x8.multiply(x22);\n    Dfp x32 = x8.multiply(x24);\n    Dfp x34 = x8.multiply(x26);\n    Dfp x36 = x8.multiply(x28);\n    Dfp x38 = x8.multiply(x30);\n    Dfp x40 = x8.multiply(x32);\n    Dfp x42 = x8.multiply(x34);\n    Dfp x44 = x8.multiply(x36);\n    Dfp x46 = x8.multiply(x38);\n    Dfp x48 = x8.multiply(x40);\n    Dfp x50 = x8.multiply(x42);\n    Dfp x52 = x8.multiply(x44);\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\n        final Dfp inta = a.rint();\n        final Dfp fraca = a.subtract(inta);\n\n        final int ia = inta.intValue();\n        if (ia > 2147483646) {\n            // return +Infinity\n            return a.newInstance((byte)1, Dfp.INFINITE);\n        }\n\n        if (ia < -2147483646) {\n            // return 0;\n            return a.newInstance();\n        }\n\n        final Dfp einta = splitPow(a.getField().getESplit(), ia);\n        final Dfp efraca = expInternal(fraca);\n\n        return einta.multiply(efraca);\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n    // Use the classic Taylor series.  1 + x**2/2! + x**3/3! + x**4/4!  ...\n    // This is much faster than using the natural logarithm.\n\n    Dfp x = a;\n    Dfp y = x;\n    Dfp c = x;\n    Dfp fact = a.getOne();\n    Dfp py = new Dfp(y);\n\n    for (int i = 2; i < 90; i += 2) \n    {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i - 1) * i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) \n        {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp two = a.getField().getTwo();\n    final Dfp one = a.getField().getOne();\n    final Dfp zero = a.getField().getZero();\n    final Dfp half = a.getField().getTwo().divide(two);\n\n    Dfp x = a;\n    Dfp y = a;\n    Dfp c = a;\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i - 1) * i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n\n    final Dfp inta = a.rint();\n    final Dfp fraca = a.subtract(inta);\n\n    final int ia = inta.intValue();\n    if (ia > 2147483646) {\n        // return +Infinity\n        return a.newInstance((byte)1, Dfp.INFINITE);\n    }\n\n    if (ia < -2147483646) {\n        // return 0;\n        return a.newInstance();\n    }\n\n    final Dfp einta = splitPow(a.getField().getESplit(), ia);\n    final Dfp efraca = expInternal(fraca);\n\n    return einta.multiply(efraca);\n}"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getReal() * y.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal());\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getReal() * y.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal());\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getReal() * y.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal());\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getReal() * y.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal());\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getReal() * y.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal());\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getReal() * y.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal());\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getReal() * y.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal());\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getReal() * y.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal());\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getReal() * y.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal());\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getReal() * y.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal());\n    return new FieldVector3D<T>(inverse * y, -inverse * x, 0);\n\n}"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  {\n        if (other == null) {\n            return null;\n        }\n        if (!isOverlappedBy(other)) {\n            throw new IllegalArgumentException(\"Ranges do not overlap: \" + this + \" and \" + other);\n        }\n        return Range.between(Math.max(minimum, other.minimum), Math.min(maximum, other.maximum), comparator);\n    }",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    if (equals(other)) {\n        return this;\n    }\n    return Range.between(\n            other.getMinimum(),\n            other.getMaximum(),\n            other.getComparator()\n    );\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    return between(Math.max(minimum, other.minimum), Math.min(maximum, other.maximum));\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n        if (!isOverlappedBy(other)) {\n            throw new IllegalArgumentException(\"Ranges must overlap\");\n        }\n        if (this.equals(other)) {\n            return this;\n        }\n        return Range.between(\n            this.comparator.compare(this.minimum, other.minimum) < 0 ? other.minimum : this.minimum,\n            this.comparator.compare(this.maximum, other.maximum) > 0 ? other.maximum : this.maximum,\n            this.comparator\n        );\n    }",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap: \" + this + \" and \" + other);\n    }\n    if (this.equals(other)) {\n        return this;\n    }\n    return between(Math.max(this.minimum, other.minimum), Math.min(this.maximum, other.maximum), this.comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n        if (other == null) {\n            return null;\n        }\n        if (!isOverlappedBy(other)) {\n            throw new IllegalArgumentException(\"Ranges do not overlap\");\n        }\n        return contains(other.minimum) ? other : this;\n    }",
      "public Range<T> intersectionWith(final Range<T> other)  {\n        if (other == null) {\n            throw new IllegalArgumentException(\"Range must not be null\");\n        }\n        if (!isOverlappedBy(other)) {\n            throw new IllegalArgumentException(\"Ranges must overlap\");\n        }\n        return between(Math.max(minimum, other.minimum), Math.min(maximum, other.maximum), comparator);\n    }",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    return contains(other.minimum) ? this : other;\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n        if (other == null) {\n            throw new IllegalArgumentException(\"The Range must not be null\");\n        }\n        if (!isOverlappedBy(other)) {\n            throw new IllegalArgumentException(\"The Ranges must overlap\");\n        }\n        return contains(other.minimum) ? this : other;\n    }",
      "public Range<T> intersectionWith(final Range<T> other)  {\n        if (other == null) {\n            throw new IllegalArgumentException(\"The Range must not be null\");\n        }\n        if (!isOverlappedBy(other)) {\n            throw new IllegalArgumentException(\"The Ranges must overlap\");\n        }\n        return contains(other.minimum) ? this : other;\n    }"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterJsonGenerator(ctxt, _generatorFeatures, out, _objectCodec);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterJsonGenerator(ctxt, _generatorFeatures, out, _objectCodec, _byteSymbolCanonicalizer);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterJsonGenerator(ctxt, _generatorFeatures, out, _objectCodec);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterJsonGenerator(ctxt, _generatorFeatures, out, _objectCodec);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterJsonGenerator(ctxt, _generatorFeatures, out, _objectCodec, _byteSymbolCanonicalizer);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterJsonGenerator(ctxt, _generatorFeatures, out, _objectCodec);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8WriterJsonGenerator(ctxt, _generatorFeatures, out, _objectCodec);\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return Arrays.equals((byte[]) o1, (byte[]) o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return Arrays.equals((short[]) o1, (short[]) o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return Arrays.equals((int[]) o1, (int[]) o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return Arrays.equals((char[]) o1, (char[]) o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return Arrays.equals((long[]) o1, (long[]) o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return Arrays.equals((float[]) o1, (float[]) o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return Arrays.equals((double[]) o1, (double[]) o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return Arrays.equals((boolean[]) o1, (boolean[]) o2);\n    }\n    return Arrays.equals((Object[]) o1, (Object[]) o2);\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  return null;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) \n  {\n    return type;\n  }\n  else \n  {\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) \n  {\n    return type;\n  }\n  else if (type.isNoType()) \n  {\n    return type;\n  }\n  else if (type.isUnknownType()) \n  {\n    return type;\n  }\n  else if (type.isObject()) \n  {\n    return type;\n  }\n  else \n  {\n    return type.getNativeType(JSTypeNative.NO_TYPE);\n  }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n\n  if (type.isObject() && type.isUnresolved()) {\n    return type.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  }\n\n  return type.getNativeType(JSTypeNative.NO_TYPE);\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n  }\n  return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n  if (type.isNoResolvedType()) {\n    return type;\n  }\n  return null;\n}"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType == originalType) {\n      return blindScope;\n    }\n    return blindScope.createChildFlowScope().inferSlotType(\n        node.getQualifiedName(), restrictedType);\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (restrictedType == originalType) {\n      return blindScope;\n    }\n    return blindScope.createChildFlowScope().inferSlotType(node.getQualifiedName(), restrictedType);\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType == originalType) {\n      return blindScope;\n    }\n    // If we're in a global scope, then we can't create a new flow scope\n    // because we're not in a function.\n    if (blindScope.isGlobal()) {\n      return blindScope;\n    }\n    // If we're in a local scope, then we can create a new flow scope\n    // to represent the refined type.\n    FlowScope informed = blindScope.createChildFlowScope();\n    declareNameInScope(informed, node, restrictedType);\n    return informed;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null) {\n      return blindScope;\n    }\n    if (restrictedType == originalType) {\n      return blindScope;\n    }\n    if (node.isQualifiedName()) {\n      return blindScope.createChildFlowScope().inferSlotType(\n          node.getQualifiedName(), restrictedType);\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType == originalType) {\n      return blindScope;\n    }\n\n    // We don't want to create a new scope if the type is already restricted.\n    if (originalType.isRestrictedType()) {\n      return blindScope;\n    }\n\n    // We don't want to create a new scope if the type is unknown.\n    if (restrictedType.isUnknownType()) {\n      return blindScope;\n    }\n\n    // We don't want to create a new scope if the type is not a subtype of\n    // the original type.\n    if (!restrictedType.isSubtypeOf(originalType)) {\n      return blindScope;\n    }\n\n    FlowScope informed = blindScope.createChildFlowScope();\n    declareNameInScope(informed, node, restrictedType);\n    return informed;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType == null || restrictedType == originalType) {\n      return blindScope;\n    }\n\n    // If the restricted type is not a subtype of the original type, then\n    // we can't restrict the type.\n    if (!restrictedType.isSubtypeOf(originalType)) {\n      return blindScope;\n    }\n\n    // If the restricted type is a subtype of the original type, then we\n    // can create a new flow scope with the restricted type.\n    FlowScope informed = blindScope.createChildFlowScope();\n    declareNameInScope(informed, node, restrictedType);\n    return informed;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n    // Move past the 'function' keyword.\n    next();\n\n    // Parse the type parameters, if any.\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n      return null;\n    }\n\n    // Move past the '(' token.\n    next();\n\n    // Parse the 'this' parameter, if any.\n    Node thisType = null;\n    if (match(JsDocToken.THIS)) {\n      // Move past the 'this' keyword.\n      next();\n\n      // Move past the ':' token.\n      next();\n\n      // Parse the type of 'this'.\n      thisType = parseTypeExpression(token);\n      if (thisType == null) {\n        return null;\n      }\n    }\n\n    // Parse the parameter list.\n    Node parameterList = parseParametersType(token);\n    if (parameterList == null) {\n      return null;\n    }\n\n    // Move past the ')' token.\n    next();\n\n    // Parse the result type.\n    Node resultType = parseResultType(token);\n    if (resultType == null) {\n      return null;\n    }\n\n    // Create the function type node.\n    Node functionType = newNode(Token.FUNCTION);\n    functionType.addChildToBack(typeParameters);\n    functionType.addChildToBack(parameterList);\n    functionType.addChildToBack(resultType);\n\n    // Add the 'this' parameter, if any.\n    if (thisType != null) {\n      functionType.addChildToBack(thisType);\n    }\n\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node typeParameters = parseTypeParameters(token);\n  if (typeParameters != null) {\n    functionType.addChildToFront(typeParameters);\n  }\n\n  Node paramsType = parseParametersType(next());\n  if (paramsType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.params\");\n  }\n  functionType.addChildToBack(paramsType);\n\n  skipEOLs();\n  if (!match(JsDocToken.RP)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n\n  Node resultType = parseResultType(next());\n  if (resultType == null) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.result\");\n  }\n  functionType.addChildToBack(resultType);\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    if (match(JsDocToken.LT)) \n    {\n        next();\n        skipEOLs();\n        Node typeParameters = parseTypeParameters(next());\n        if (typeParameters != null) \n        {\n            functionType.addChildToFront(typeParameters);\n        }\n    }\n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    token = next();\n    if (match(JsDocToken.THIS)) \n    {\n        next();\n        skipEOLs();\n        if (!match(JsDocToken.COLON)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n        }\n        next();\n        skipEOLs();\n        token = next();\n    }\n    Node parametersType = parseParametersType(token);\n    if (parametersType == null) \n    {\n        return null;\n    }\n    functionType.addChildToBack(parametersType);\n    skipEOLs();\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    token = next();\n    if (match(JsDocToken.RP)) \n    {\n        next();\n        skipEOLs();\n        token = next();\n    }\n    Node resultType = parseResultType(token);\n    if (resultType == null) \n    {\n        return null;\n    }\n    functionType.addChildToBack(resultType);\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    // Parse the type parameters\n    if (match(JsDocToken.LT)) \n    {\n        next();\n        skipEOLs();\n        Node typeParameters = parseTypeExpressionList(next());\n        if (typeParameters != null) \n        {\n            functionType.addChildToFront(typeParameters);\n        }\n        skipEOLs();\n        if (!match(JsDocToken.GT)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n        next();\n    }\n    // Parse the parameters\n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    Node paramType = parseTypeExpression(next());\n    if (paramType == null) \n    {\n        return null;\n    }\n    functionType.addChildToBack(paramType);\n    // Parse the rest of the parameters\n    while (match(JsDocToken.COMMA)) \n    {\n        next();\n        skipEOLs();\n        paramType = parseTypeExpression(next());\n        if (paramType == null) \n        {\n            return null;\n        }\n        functionType.addChildToBack(paramType);\n    }\n    skipEOLs();\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    // Parse the result type\n    skipEOLs();\n    if (!match(JsDocToken.ARROW)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.arrow\");\n    }\n    next();\n    skipEOLs();\n    Node resultType = parseTypeExpression(next());\n    if (resultType == null) \n    {\n        return null;\n    }\n    functionType.addChildToBack(resultType);\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    if (match(JsDocToken.LT)) {\n        // Type parameters\n        next();\n        skipEOLs();\n        Node typeParameters = parseTypeExpressionList(next());\n        if (typeParameters == null) {\n            return null;\n        }\n        functionType.addChildToBack(typeParameters);\n        skipEOLs();\n        if (!match(JsDocToken.RP)) {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n        }\n        next();\n    }\n    // '('\n    if (!match(JsDocToken.LP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    token = next();\n    // 'this' ':' TypeName\n    if (match(JsDocToken.THIS)) {\n        next();\n        skipEOLs();\n        if (!match(JsDocToken.COLON)) {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n        }\n        next();\n        skipEOLs();\n        Node typeName = parseTypeExpression(next());\n        if (typeName == null) {\n            return null;\n        }\n        functionType.addChildToBack(typeName);\n        skipEOLs();\n        token = next();\n    }\n    // ParametersType\n    Node parametersType = parseParametersType(token);\n    if (parametersType == null) {\n        return null;\n    }\n    functionType.addChildToBack(parametersType);\n    // ')' ResultType\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    token = next();\n    Node resultType = parseResultType(token);\n    if (resultType == null) {\n        return null;\n    }\n    functionType.addChildToBack(resultType);\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    // Move past the 'function' keyword.\n    next();\n    skipEOLs();\n    token = next();\n\n    // Parse the type parameters.\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n      return null;\n    }\n\n    // Parse the '(' token.\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    token = next();\n\n    // Parse the 'this' parameter.\n    Node thisType = null;\n    if (match(JsDocToken.THIS)) {\n      // Move past the 'this' keyword.\n      next();\n      skipEOLs();\n      token = next();\n\n      // Parse the ':' token.\n      if (!match(JsDocToken.COLON)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n      }\n      next();\n      skipEOLs();\n      token = next();\n\n      // Parse the type name.\n      thisType = parseTypeExpression(token);\n      if (thisType == null) {\n        return null;\n      }\n\n      skipEOLs();\n      if (!match(JsDocToken.COMMA)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n      }\n      next();\n      skipEOLs();\n      token = next();\n    }\n\n    // Parse the parameter list.\n    Node paramList = parseParametersType(token);\n    if (paramList == null) {\n      return null;\n    }\n\n    // Parse the ')' token.\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    token = next();\n\n    // Parse the result type.\n    Node resultType = parseResultType(token);\n    if (resultType == null) {\n      return null;\n    }\n\n    // Create the function type node.\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  if (match(JsDocToken.LT)) \n  {\n    // Type parameters\n    next();\n    skipEOLs();\n    Node typeParameters = parseTypeExpressionList(next());\n    if (typeParameters != null) \n    {\n      functionType.addChildToFront(typeParameters);\n    }\n    skipEOLs();\n    if (!match(JsDocToken.LP)) \n    {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n  }\n  // 'this' type\n  if (match(JsDocToken.THIS)) \n  {\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) \n    {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    Node thisType = parseTypeExpression(next());\n    if (thisType != null) \n    {\n      functionType.addChildToBack(thisType);\n    }\n    skipEOLs();\n  }\n  // Parameters\n  if (!match(JsDocToken.RP)) \n  {\n    Node parametersType = parseParametersType(next());\n    if (parametersType != null) \n    {\n      functionType.addChildToBack(parametersType);\n    }\n  }\n  // Result type\n  if (!match(JsDocToken.RP)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  Node typeParameters = parseTypeParameters(token);\n  if (typeParameters != null)\n  {\n    functionType.addChildToFront(typeParameters);\n  }\n  if (!match(JsDocToken.LP))\n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  skipEOLs();\n  token = next();\n  if (match(JsDocToken.THIS))\n  {\n    next();\n    skipEOLs();\n    token = next();\n    if (!match(JsDocToken.COLON))\n    {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    token = next();\n  }\n  Node paramType = parseTypeExpression(token);\n  if (paramType == null)\n  {\n    return null;\n  }\n  functionType.addChildToBack(paramType);\n  skipEOLs();\n  if (!match(JsDocToken.RP))\n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  skipEOLs();\n  token = next();\n  Node resultType = parseResultType(token);\n  if (resultType == null)\n  {\n    return null;\n  }\n  functionType.addChildToBack(resultType);\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  // Parse the type parameters.\n  if (match(JsDocToken.LT)) \n  {\n    next();\n    skipEOLs();\n    Node typeParameters = parseTypeExpressionList(next());\n    if (typeParameters != null) \n    {\n      functionType.addChildToFront(typeParameters);\n    }\n    skipEOLs();\n    if (!match(JsDocToken.GT)) \n    {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n    }\n    next();\n  }\n  // Parse the '(' token.\n  if (!match(JsDocToken.LP)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n  }\n  next();\n  // Parse the 'this' token.\n  if (match(JsDocToken.THIS)) \n  {\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) \n    {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    Node typeName = parseTypeExpression(next());\n    if (typeName == null) \n    {\n      return null;\n    }\n    functionType.addChildToBack(typeName);\n    skipEOLs();\n  }\n  // Parse the parameter list.\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) \n  {\n    return null;\n  }\n  functionType.addChildToBack(parametersType);\n  // Parse the ')' token.\n  skipEOLs();\n  if (!match(JsDocToken.RP)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n  }\n  next();\n  // Parse the result type.\n  skipEOLs();\n  Node resultType = parseTypeExpression(next());\n  if (resultType == null) \n  {\n    return null;\n  }\n  functionType.addChildToBack(resultType);\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParameters = null;\n    if (match(JsDocToken.LT)) \n    {\n        next();\n        skipEOLs();\n        typeParameters = parseTypeParameters(next());\n        if (typeParameters == null) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n    }\n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n    skipEOLs();\n    token = next();\n    Node thisType = null;\n    if (match(JsDocToken.THIS)) \n    {\n        next();\n        skipEOLs();\n        token = next();\n        if (!match(JsDocToken.COLON)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n        }\n        next();\n        skipEOLs();\n        thisType = parseTypeExpression(next());\n        if (thisType == null) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n        }\n    }\n    Node parametersType = parseParametersType(token);\n    if (parametersType == null) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    functionType.addChildToBack(typeParameters);\n    functionType.addChildToBack(parametersType);\n    if (thisType != null) \n    {\n        functionType.addChildToBack(thisType);\n    }\n    skipEOLs();\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n    skipEOLs();\n    token = next();\n    Node resultType = parseResultType(token);\n    if (resultType == null) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rt\");\n    }\n    functionType.addChildToBack(resultType);\n}"
    ],
    [
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) \n    {\n        if (!Character.isWhitespace(str.charAt(i))) \n        {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) \n    {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) \n    {\n        if (!Character.isWhitespace(str.charAt(i))) \n        {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) \n    {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chs = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chs[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chs, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        final int sz = str.length();\n        final char[] chs = new char[sz];\n        int count = 0;\n        for (int i = 0; i < sz; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                chs[count++] = str.charAt(i);\n            }\n        }\n        if (count == sz) {\n            return str;\n        }\n        return new String(chs, 0, count);\n    }"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics aggregateStatistics = new SummaryStatistics();\n    for (SummaryStatistics contributingStatistics : statistics) {\n        StatisticalSummaryValues contributingValues = contributingStatistics.getSummary();\n        aggregateStatistics.addValue(contributingValues.getSum());\n        aggregateStatistics.addValue(contributingValues.getN());\n        aggregateStatistics.addValue(contributingValues.getMin());\n        aggregateStatistics.addValue(contributingValues.getMax());\n        aggregateStatistics.addValue(contributingValues.getMean());\n        aggregateStatistics.addValue(contributingValues.getVariance());\n        aggregateStatistics.addValue(contributingValues.getStandardDeviation());\n        aggregateStatistics.addValue(contributingValues.getSumsq());\n        aggregateStatistics.addValue(contributingValues.getSecondMoment());\n        aggregateStatistics.addValue(contributingValues.getSumOfLogs());\n        aggregateStatistics.addValue(contributingValues.getGeometricMean());\n    }\n\n    return aggregateStatistics.getSummary();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics prototype = statistics.iterator().next();\n    SummaryStatistics aggregate = new SummaryStatistics(prototype);\n\n    for (SummaryStatistics contributing : statistics) {\n        SummaryStatistics.copy(contributing, aggregate);\n    }\n\n    return new StatisticalSummaryValues(\n            aggregate.getMean(),\n            aggregate.getVariance(),\n            aggregate.getN(),\n            aggregate.getMax(),\n            aggregate.getMin(),\n            aggregate.getSum()\n    );\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    // Initialize with the first statistics object's values\n    SummaryStatistics first = statistics.iterator().next();\n    StatisticalSummaryValues values = new StatisticalSummaryValues(\n            first.getMean(), first.getVariance(), first.getN(),\n            first.getMax(), first.getMin(), first.getSum());\n\n    for (SummaryStatistics stats : statistics) {\n        values.setMean(values.getMean() + stats.getMean());\n        values.setVariance(values.getVariance() + stats.getVariance());\n        values.setN(values.getN() + stats.getN());\n        values.setMax(Math.max(values.getMax(), stats.getMax()));\n        values.setMin(Math.min(values.getMin(), stats.getMin()));\n        values.setSum(values.getSum() + stats.getSum());\n    }\n\n    return values;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    // Initialize with first non-null statistics object\n    SummaryStatistics first = null;\n    for (SummaryStatistics stat : statistics) {\n        if (stat != null) {\n            first = stat;\n            break;\n        }\n    }\n    if (first == null) {\n        return null;\n    }\n    // Copy first object's state to the aggregate object\n    SummaryStatistics aggregate = new SummaryStatistics(first);\n    // Add all non-null statistics objects to the aggregate\n    for (SummaryStatistics stat : statistics) {\n        if (stat != null) {\n            aggregate.addValues(stat);\n        }\n    }\n    return new StatisticalSummaryValues(aggregate.getMean(),\n                                        aggregate.getVariance(),\n                                        aggregate.getN(),\n                                        aggregate.getMax(),\n                                        aggregate.getMin(),\n                                        aggregate.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    SummaryStatistics prototype = statistics.iterator().next();\n    SummaryStatistics aggregate = new SummaryStatistics(prototype);\n    for (SummaryStatistics contributing : statistics) {\n        SummaryStatistics.copy(contributing, aggregate);\n    }\n    return new StatisticalSummaryValues(\n            aggregate.getMean(),\n            aggregate.getVariance(),\n            aggregate.getN(),\n            aggregate.getMax(),\n            aggregate.getMin(),\n            aggregate.getSum()\n    );\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics aggregatedStatistics = new SummaryStatistics();\n\n    for (SummaryStatistics contributingStatistics : statistics) {\n        // No try - catch or advertising NAE because neither argument will ever be null\n        SummaryStatistics.copy(contributingStatistics, aggregatedStatistics);\n    }\n\n    return new StatisticalSummaryValues(\n            aggregatedStatistics.getMean(),\n            aggregatedStatistics.getVariance(),\n            aggregatedStatistics.getN(),\n            aggregatedStatistics.getMax(),\n            aggregatedStatistics.getMin(),\n            aggregatedStatistics.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    // Compute aggregate values\n    double sum = 0.0;\n    double sumsq = 0.0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    long n = 0;\n    for (SummaryStatistics stat : statistics) {\n        if (stat == null) {\n            continue;\n        }\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n        n += stat.getN();\n    }\n    // Compute aggregate variance\n    double variance = 0.0;\n    if (n > 1) {\n        variance = (sumsq - ((sum * sum) / n)) / (n - 1);\n    }\n    // Compute aggregate standard deviation\n    double standardDeviation = Math.sqrt(variance);\n    // Compute aggregate geometric mean\n    double geometricMean = Math.exp(MathUtils.logSumExp(statistics) - Math.log(n));\n    // Compute aggregate second moment\n    double secondMoment = 0.0;\n    for (SummaryStatistics stat : statistics) {\n        if (stat == null) {\n            continue;\n        }\n        secondMoment += stat.getSecondMoment();\n    }\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum, secondMoment);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics aggregateStatistics = new SummaryStatistics();\n\n    for (SummaryStatistics contributingStatistics : statistics) {\n        StatisticalSummaryValues contributingSummary = contributingStatistics.getSummary();\n        aggregateStatistics.addValue(contributingSummary.getSum());\n        aggregateStatistics.addValue(contributingSummary.getN());\n        aggregateStatistics.addValue(contributingSummary.getMax());\n        aggregateStatistics.addValue(contributingSummary.getMin());\n        aggregateStatistics.addValue(contributingSummary.getMean());\n        aggregateStatistics.addValue(contributingSummary.getStandardDeviation());\n        aggregateStatistics.addValue(contributingSummary.getVariance());\n    }\n\n    return new StatisticalSummaryValues(\n            aggregateStatistics.getMean(),\n            aggregateStatistics.getVariance(),\n            aggregateStatistics.getN(),\n            aggregateStatistics.getMax(),\n            aggregateStatistics.getMin(),\n            aggregateStatistics.getSum()\n    );\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics contributingStatistics = statistics.iterator().next();\n    for (SummaryStatistics stat : statistics) {\n        contributingStatistics.addValue(stat.getSum());\n    }\n\n    return new StatisticalSummaryValues(\n            contributingStatistics.getMean(),\n            contributingStatistics.getVariance(),\n            contributingStatistics.getN(),\n            contributingStatistics.getMax(),\n            contributingStatistics.getMin(),\n            contributingStatistics.getSum());\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics aggregatedStatistics = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregatedStatistics.addValue(stat.getSum());\n        aggregatedStatistics.addValue(stat.getSumsq());\n        aggregatedStatistics.addValue(stat.getMin());\n        aggregatedStatistics.addValue(stat.getMax());\n        aggregatedStatistics.addValue(stat.getMean());\n        aggregatedStatistics.addValue(stat.getGeometricMean());\n        aggregatedStatistics.addValue(stat.getVariance());\n        aggregatedStatistics.addValue(stat.getStandardDeviation());\n        aggregatedStatistics.addValue(stat.getSumOfLogs());\n        aggregatedStatistics.addValue(stat.getSecondMoment());\n    }\n\n    return new StatisticalSummaryValues(\n            aggregatedStatistics.getMean(),\n            aggregatedStatistics.getVariance(),\n            aggregatedStatistics.getN(),\n            aggregatedStatistics.getMax(),\n            aggregatedStatistics.getMin(),\n            aggregatedStatistics.getSum()\n    );\n}"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double variance = 0;\n        for (int i = 0; i < n; i++) {\n            variance += (sample1[i] - sample2[i] - meanDifference) *\n                    (sample1[i] - sample2[i] - meanDifference);\n        }\n        variance /= (n - 1);\n        return variance;\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, false);\n        }\n        double variance = 0;\n        for (int i = 0; i < n; i++) {\n            variance += (sample1[i] - sample2[i] - meanDifference) *\n                    (sample1[i] - sample2[i] - meanDifference);\n        }\n        return variance / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double sumOfSquares = 0;\n        for (int i = 0; i < n; i++) {\n            sumOfSquares += (sample1[i] - sample2[i] - meanDifference) *\n                    (sample1[i] - sample2[i] - meanDifference);\n        }\n        return sumOfSquares / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(n, 2, false);\n        }\n        double variance = 0;\n        for (int i = 0; i < n; i++) {\n            variance += (sample1[i] - sample2[i] - meanDifference) *\n                    (sample1[i] - sample2[i] - meanDifference);\n        }\n        return variance / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(n, 2, false);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i] - meanDifference) *\n                    (sample1[i] - sample2[i] - meanDifference);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double sumOfSquares = 0;\n        for (int i = 0; i < n; i++) {\n            sumOfSquares += (sample1[i] - sample2[i]) * (sample1[i] - sample2[i]);\n        }\n        return sumOfSquares / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    n, 2, false);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i] - meanDifference) *\n                    (sample1[i] - sample2[i] - meanDifference);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(LocalizedFormats.SAMPLE_SIZE, n, 2, true);\n        }\n        double sumOfSquares = 0;\n        for (int i = 0; i < n; i++) {\n            sumOfSquares += (sample1[i] - sample2[i]) * (sample1[i] - sample2[i]);\n        }\n        return sumOfSquares / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, false);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += (sample1[i] - sample2[i] - meanDifference) *\n                    (sample1[i] - sample2[i] - meanDifference);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(LocalizedFormats.SAMPLE_SIZE, n, 2, false);\n        }\n        double sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += (sample1[i] - sample2[i]) * (sample1[i] - sample2[i]);\n        }\n        return sum / (n - 1);\n    }"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total = total + value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int item = 0; item < itemCount; item++) {\n        Number value = dataset.getValue(item);\n        if (value != null) {\n            total = total + value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total = total + value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total = total + value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total = total + value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total = total + value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total = total + value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    for (int i = 0; i < dataset.getItemCount(); i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total = total + value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total = total + value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int item = 0; item < itemCount; item++) {\n        Number value = dataset.getValue(item);\n        if (value != null) {\n            total = total + value.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    } else if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return new String(buffer, pos, peekedNumberLength);\n    } else {\n        throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = nextUnquotedValue();\n      pathNames[stackSize - 1] = result;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = nextQuotedValue('\\'');\n      pathNames[stackSize - 1] = result;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = nextQuotedValue('\"');\n      pathNames[stackSize - 1] = result;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED_NAME) {\n    peeked = PEEKED_NONE;\n    String result = source.subSequence(pos, peekedNameEnd).toString();\n    pos = peekedNameEnd;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n  throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = source.subSequence(pos + 1, peekedNameEnd).toString();\n      pos = peekedNameEnd + 1;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = nextQuotedValue('\\'');\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      peeked = PEEKED_NONE;\n      String result = nextQuotedValue('\"');\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED_NAME) {\n    peeked = PEEKED_NONE;\n    String result = source.subSequence(nameStart, pos).toString();\n    pathNames[stackSize - 1] = result;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n  if (p == PEEKED_SINGLE_QUOTED_NAME) {\n    return nextQuotedName('\\'');\n  }\n  if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n    return nextQuotedName('\"');\n  }\n  throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        String result = nextUnquotedValue();\n        pathNames[stackSize - 1] = result;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        String result = nextQuotedValue('\\'');\n        pathNames[stackSize - 1] = result;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n    if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        String result = nextQuotedValue('\"');\n        pathNames[stackSize - 1] = result;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    } else {\n        throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextQuotedValue('\\'');\n    }\n    if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextQuotedValue('\"');\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextQuotedValue('\\'');\n    }\n    if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextQuotedValue('\"');\n    }\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return peekedString;\n    } else if (p == PEEKED_LONG) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return new String(buffer, pos, peekedNumberLength);\n    } else {\n        throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n}"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            final Integer b = array[i];\n            result[i] = (b == null ? valueForNull : b.intValue());\n        }\n        return result;\n    }",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            final Integer b = array[i];\n            result[i] = (b == null ? valueForNull : b.intValue());\n        }\n        return result;\n    }",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    }\n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return EMPTY_INT_ARRAY;\n        }\n        final int[] result = new int[array.length];\n        for (int i = 0; i < array.length; i++) {\n            final Integer b = array[i];\n            result[i] = (b == null ? valueForNull : b.intValue());\n        }\n        return result;\n    }"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) \n    {\n        return readFromBuffer(b, off, len);\n    }\n    else if (currentCompressedChunk != null) \n    {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) \n    {\n        return readFromBuffer(b, off, len);\n    }\n    else if (currentCompressedChunk != null) \n    {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) \n    {\n        return readFromBuffer(b, off, len);\n    } \n    else if (currentCompressedChunk != null) \n    {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) \n    {\n        return readFromBuffer(b, off, len);\n    } \n    else if (currentCompressedChunk != null) \n    {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) \n    {\n        return readFromBuffer(b, off, len);\n    }\n    else if (currentCompressedChunk != null) \n    {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) \n    {\n        return readFromBuffer(b, off, len);\n    } \n    else if (currentCompressedChunk != null) \n    {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) \n    {\n        return readFromBuffer(b, off, len);\n    }\n    else if (currentCompressedChunk != null) \n    {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) \n    {\n        return readFromBuffer(b, off, len);\n    } \n    else if (currentCompressedChunk != null) \n    {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) \n    {\n        return readFromBuffer(b, off, len);\n    } \n    else if (currentCompressedChunk != null) \n    {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (inUncompressedChunk) \n    {\n        return readFromBuffer(b, off, len);\n    }\n    else if (currentCompressedChunk != null) \n    {\n        return currentCompressedChunk.read(b, off, len);\n    }\n    return -1;\n}"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site.node.isCall() || site.node.isNew()) \n    {\n        return getArgumentForCallOrNew(site.node, argIndex);\n    }\n    else if (site.node.isGetProp()) \n    {\n        Node parent = site.node.getParent();\n        if (parent.isCall()) \n        {\n            return getArgumentForCallOrNew(parent, argIndex);\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site.node.isCall() || site.node.isNew()) \n    {\n        return getArgumentForCallOrNew(site.node, argIndex);\n    }\n    else if (site.node.isGetProp()) \n    {\n        return getArgumentForCallOrNew(site.node.getFirstChild(), argIndex);\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site.node.isCall() || site.node.isNew()) \n    {\n        return getArgumentForCallOrNew(site.node, argIndex);\n    } \n    else if (isGet(site.node)) \n    {\n        Node propNode = site.node.getLastChild();\n        if (propNode.isString()) \n        {\n            String propName = propNode.getString();\n            if (propName.equals(\"call\")) \n            {\n                return getArgumentForCallOrNew(site.node, argIndex);\n            } \n            else if (propName.equals(\"apply\")) \n            {\n                Node arg = getArgumentForCallOrNew(site.node, argIndex);\n                if (arg != null && arg.isArrayLit()) \n                {\n                    return arg.getFirstChild();\n                }\n            }\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node arg = null;\n    if (site.node.isCall() || site.node.isNew()) {\n        arg = getArgumentForCallOrNew(site.node, argIndex);\n    } else if (site.node.isGetProp()) {\n        Node obj = site.node.getFirstChild();\n        if (obj.isGetProp() && obj.getLastChild().getString().equals(\"call\")) {\n            arg = getArgumentForCallOrNew(obj, argIndex);\n        }\n    }\n    return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node arg = null;\n    if (site.node.isCall() || site.node.isNew()) \n    {\n        arg = getArgumentForCallOrNew(site.node, argIndex);\n    }\n    else if (site.node.isGetProp()) \n    {\n        Node target = site.node.getFirstChild();\n        if (target.isGetProp() && isToStringMethodCall(target)) \n        {\n            arg = target.getNext();\n        }\n    }\n    return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site.node.isCall() || site.node.isNew()) {\n        return getArgumentForCallOrNew(site.node, argIndex);\n    } else if (site.node.isGetProp()) {\n        Node obj = site.node.getFirstChild();\n        Node prop = site.node.getLastChild();\n        if (prop.isString() && prop.getString().equals(\"call\")) {\n            return getArgumentForCallOrNew(obj, argIndex);\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node arg = null;\n    if (site.node.isCall()) \n    {\n        arg = NodeUtil.getArgumentForCallOrNew(site.node, argIndex);\n    }\n    else if (site.node.isGetProp()) \n    {\n        arg = NodeUtil.getArgumentForCallOrNew(site.node.getFirstChild(),\n                argIndex);\n    }\n    return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node arg = null;\n    if (site.node.isCall() || site.node.isNew()) \n    {\n        arg = NodeUtil.getArgumentForCallOrNew(site.node, argIndex);\n    } \n    else if (site.node.isGetProp()) \n    {\n        arg = NodeUtil.getArgumentForCallOrNew(site.node.getFirstChild(),\n                argIndex);\n    }\n    return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site.node.isCall()) {\n        return getArgumentForCallOrNew(site.node, argIndex);\n    } else if (site.node.isGetProp()) {\n        return getArgumentForCallOrNew(site.node.getFirstChild(), argIndex);\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    if (site.node.isCall() || site.node.isNew()) {\n        return getArgumentForCallOrNew(site.node, argIndex);\n    } else if (site.node.isGetProp()) {\n        return getArgumentForCallOrNew(site.node.getFirstChild(), argIndex);\n    }\n    return null;\n}"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type.isUnknownType() || type.isAllType() || type.isNoResolvedType()) {\n    return null;\n  }\n\n  if (type.isTemplatizedType()) {\n    TemplatizedType templatizedType = type.toMaybeTemplatizedType();\n    JSType templateType = templatizedType.getReferencedType();\n    if (templateType.isUnknownType()) {\n      return null;\n    }\n\n    String reason = getTypeDeprecationInfo(templateType);\n    if (reason != null) {\n      return reason;\n    }\n  }\n\n  if (type.isObjectType()) {\n    ObjectType objectType = type.toMaybeObjectType();\n    JSDocInfo docInfo = objectType.getJSDocInfo();\n    if (docInfo != null && docInfo.isDeprecated()) {\n      if (docInfo.getDeprecationReason() != null) {\n        return docInfo.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type.isUnknownType() || type.isAllType() || type.isNoResolvedType()) \n  {\n    return null;\n  }\n\n  if (type.isObject()) \n  {\n    ObjectType objectType = type.toObjectType();\n    JSDocInfo info = objectType.getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n      if (info.getDeprecationReason() != null) \n      {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n\n    ObjectType implicitProto = objectType.getImplicitPrototype();\n    if (implicitProto != null) \n    {\n      return getTypeDeprecationInfo(implicitProto);\n    }\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type.isUnknownType() || type.isAllType() || type.isNoResolvedType()) \n  {\n    return null;\n  }\n\n  if (type.isObject()) \n  {\n    ObjectType objType = type.toMaybeObjectType();\n    if (objType.getConstructor() != null &&\n        isDeprecatedFunction(objType.getConstructor())) \n    {\n      return getTypeDeprecationInfo(objType.getConstructor().getJSType());\n    }\n  }\n\n  if (type.isTemplatizedType()) \n  {\n    TemplatizedType templatizedType = type.toMaybeTemplatizedType();\n    if (templatizedType.getReferencedType() != null) \n    {\n      return getTypeDeprecationInfo(templatizedType.getReferencedType());\n    }\n  }\n\n  if (type.isFunctionType()) \n  {\n    FunctionType fnType = type.toMaybeFunctionType();\n    if (fnType.getTypeOfThis() != null &&\n        isDeprecatedFunction(fnType.getTypeOfThis())) \n    {\n      return getTypeDeprecationInfo(fnType.getTypeOfThis());\n    }\n  }\n\n  if (type.isEnumType()) \n  {\n    EnumType enumType = type.toMaybeEnumType();\n    if (enumType.getEnumType() != null &&\n        isDeprecatedFunction(enumType.getEnumType())) \n    {\n      return getTypeDeprecationInfo(enumType.getEnumType());\n    }\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type.isUnknownType() || type.isAllType()) \n  {\n    return null;\n  }\n\n  if (type.isObject()) \n  {\n    ObjectType objType = type.toObjectType();\n    JSDocInfo info = objType.getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n      if (info.getDeprecationReason() != null) \n      {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n  }\n\n  if (type.isUnionType()) \n  {\n    UnionType unionType = type.toMaybeUnionType();\n    for (JSType alt : unionType.getAlternates()) \n    {\n      String info = getTypeDeprecationInfo(alt);\n      if (info != null) \n      {\n        return info;\n      }\n    }\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type.isUnknownType() || type.isAllType() || type.isNoResolvedType()) \n  {\n    return null;\n  }\n\n  if (type.isObject()) \n  {\n    ObjectType objectType = type.toMaybeObjectType();\n    if (objectType.getConstructor() != null) \n    {\n      return getTypeDeprecationInfo(objectType.getConstructor().getJSType());\n    }\n  }\n\n  if (type.isFunctionType()) \n  {\n    FunctionType functionType = type.toMaybeFunctionType();\n    if (functionType.getTypeOfThis() != null) \n    {\n      return getTypeDeprecationInfo(functionType.getTypeOfThis());\n    }\n  }\n\n  if (type.isTemplatizedType()) \n  {\n    TemplatizedType templatizedType = type.toMaybeTemplatizedType();\n    return getTypeDeprecationInfo(templatizedType.getReferencedType());\n  }\n\n  if (type.isEnumType()) \n  {\n    EnumType enumType = type.toMaybeEnumType();\n    return getTypeDeprecationInfo(enumType.getReferencedType());\n  }\n\n  if (type.isNamedType()) \n  {\n    JSType namedType = type.toMaybeNamedType();\n    if (namedType.isNoResolvedType()) \n    {\n      return null;\n    }\n\n    if (namedType.isObject()) \n    {\n      ObjectType objectType = namedType.toMaybeObjectType();\n      if (objectType.getConstructor() != null) \n      {\n        return getTypeDeprecationInfo(objectType.getConstructor().getJSType());\n      }\n    }\n\n    if (namedType.isFunctionType()) \n    {\n      FunctionType functionType = namedType.toMaybeFunctionType();\n      if (functionType.getTypeOfThis() != null) \n      {\n        return getTypeDeprecationInfo(functionType.getTypeOfThis());\n      }\n    }\n\n}\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) \n  {\n    return null;\n  }\n\n  if (type.isFunctionType()) \n  {\n    FunctionType fnType = type.toMaybeFunctionType();\n    JSDocInfo info = fnType.getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n      if (info.getDeprecationReason() != null) \n      {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n  }\n\n  if (type.isObjectType()) \n  {\n    ObjectType objType = type.toMaybeObjectType();\n    JSDocInfo info = objType.getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n      if (info.getDeprecationReason() != null) \n      {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type.isUnknownType() || type.isAllType()) {\n    return null;\n  }\n\n  if (type.isNoResolvedType()) {\n    type = type.restrictByNotNullOrUndefined();\n  }\n\n  if (type.isNoType()) {\n    return null;\n  }\n\n  if (type.isObject()) {\n    ObjectType objType = type.toObjectType();\n    JSDocInfo info = objType.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n  }\n\n  if (type.isTemplatizedType()) {\n    TemplatizedType templatizedType = type.toTemplatizedType();\n    JSType templateType = templatizedType.getReferencedType();\n    if (templateType.isNoResolvedType()) {\n      templateType = templateType.restrictByNotNullOrUndefined();\n    }\n\n    if (templateType.isNoType()) {\n      return null;\n    }\n\n    if (templateType.isObject()) {\n      ObjectType objType = templateType.toObjectType();\n      JSDocInfo info = objType.getJSDocInfo();\n      if (info != null && info.isDeprecated()) {\n        if (info.getDeprecationReason() != null) {\n          return info.getDeprecationReason();\n        }\n\n        return \"\";\n      }\n    }\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type.isUnknownType() || type.isAllType()) {\n    return null;\n  }\n\n  if (type.isFunctionType()) {\n    return getTypeDeprecationInfo(type.toMaybeFunctionType());\n  }\n\n  if (type.isObjectType()) {\n    return getTypeDeprecationInfo(type.toMaybeObjectType());\n  }\n\n  if (type.isTemplatizedType()) {\n    return getTypeDeprecationInfo(type.toMaybeTemplatizedType());\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) {\n    return null;\n  }\n\n  // First check if the type is a named type.\n  if (type.isNamedType()) {\n    JSTypeNamed typeNamed = type.toMaybeNamedType();\n    if (typeNamed != null) {\n      JSDocInfo info = typeNamed.getJSDocInfo();\n      if (info != null && info.isDeprecated()) {\n        if (info.getDeprecationReason() != null) {\n          return info.getDeprecationReason();\n        }\n\n        return \"\";\n      }\n    }\n  }\n\n  // If the type is not a named type, check if it is a union type.\n  if (type.isUnionType()) {\n    UnionType unionType = type.toMaybeUnionType();\n    if (unionType != null) {\n      for (JSType altType : unionType.getAlternates()) {\n        String deprecationInfo = getTypeDeprecationInfo(altType);\n        if (deprecationInfo != null) {\n          return deprecationInfo;\n        }\n      }\n    }\n  }\n\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type.isUnknownType() || type.isAllType() || type.isNoResolvedType()) \n  {\n    return null;\n  }\n  if (type.isTemplatizedType()) \n  {\n    TemplatizedType templatizedType = type.toMaybeTemplatizedType();\n    if (templatizedType != null) \n    {\n      JSType typeTemplate = templatizedType.getReferencedType();\n      if (typeTemplate != null) \n      {\n        String deprecationReason = getTypeDeprecationInfo(typeTemplate);\n        if (deprecationReason != null) \n        {\n          return deprecationReason;\n        }\n      }\n    }\n  }\n  if (type.isObjectType()) \n  {\n    ObjectType objectType = type.toObjectType();\n    JSDocInfo docInfo = objectType.getJSDocInfo();\n    if (docInfo != null && docInfo.isDeprecated()) \n    {\n      if (docInfo.getDeprecationReason() != null) \n      {\n        return docInfo.getDeprecationReason();\n      }\n      return \"\";\n    }\n  }\n  return null;\n}"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final TimeZoneDisplayKey currentKey = new TimeZoneDisplayKey(tz, daylight, style, locale);\n        final TimeZoneDisplayKey previousKey = new TimeZoneDisplayKey(tz, !daylight, style, locale);\n        cTimeZoneDisplayCache.put(currentKey, value);\n        cTimeZoneDisplayCache.put(previousKey, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String text = cTimeZoneDisplayCache.get(key);\n    if (text == null) {\n        text = tz.getDisplayName(daylight, style, locale);\n        final TimeZoneDisplayKey existing = cTimeZoneDisplayCache.putIfAbsent(key, text);\n        if (existing != null) {\n            text = existing;\n        }\n    }\n    return text;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String text = cTimeZoneDisplayCache.get(key);\n    if (text == null) {\n        text = tz.getDisplayName(daylight, style, locale);\n        final TimeZoneDisplayKey existing = cTimeZoneDisplayCache.putIfAbsent(key, text);\n        if (existing != null) {\n            text = existing;\n        }\n    }\n    return text;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String existing = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (existing != null) {\n            value = existing;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final TimeZoneDisplayKey existing = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (existing != null) {\n            value = existing;\n        }\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cTimeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        final String existing = cTimeZoneDisplayCache.putIfAbsent(key, value);\n        if (existing != null) {\n            value = existing;\n        }\n    }\n    return value;\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    List keys = getColumnKeys();\n    for (int i = 0; i < keys.size(); i++) {\n        if (key.equals(keys.get(i))) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    if (key != null) \n    {\n        result = this.underlying.getColumnIndex(key);\n        if (result >= this.firstCategoryIndex && result < this.lastCategoryIndex()) \n        {\n            result = result - this.firstCategoryIndex;\n        }\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    List keys = getColumnKeys();\n    for (int i = 0; i < keys.size(); i++) \n    {\n        if (key.equals(keys.get(i))) \n        {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    // TODO: Implement this method\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    if (key != null) \n    {\n        result = this.underlying.getColumnIndex(key);\n        if (result >= this.firstCategoryIndex && result < this.firstCategoryIndex + this.maximumCategoryCount) \n        {\n            result = result - this.firstCategoryIndex;\n        }\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    if (key != null) \n    {\n        List keys = getColumnKeys();\n        for (int i = 0; i < keys.size(); i++) \n        {\n            Comparable ckey = (Comparable) keys.get(i);\n            if (ckey.equals(key)) \n            {\n                result = i;\n                break;\n            }\n        }\n    }\n    return result;\n}",
      "public int getColumnIndex(Comparable key)  {\n    // TODO: Implement this method\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    int result = -1;\n    List keys = getColumnKeys();\n    for (int i = 0; i < keys.size(); i++) \n    {\n        Comparable current = (Comparable) keys.get(i);\n        if (current.equals(key)) \n        {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point <= lower + tolerance) {\n        return Location.INSIDE;\n    } else if (point >= upper - tolerance) {\n        return Location.INSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point <= lower + tolerance) {\n        return Location.BOUNDARY;\n    }\n    if (point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    return (point >= lower - tolerance) && (point <= upper + tolerance) ? Location.INSIDE : Location.OUTSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point <= lower + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point <= lower + tolerance) {\n        return Location.BOUNDARY;\n    }\n    if (point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point <= lower + tolerance) {\n        return Location.BOUNDARY;\n    }\n    if (point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point <= lower + tolerance) {\n        return Location.BOUNDARY;\n    }\n    if (point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    return checkPoint(new Interval(point - tolerance, point + tolerance));\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n        return checkPoint(new Interval(point - tolerance, point + tolerance));\n    }",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point <= lower + tolerance) {\n        return Location.BOUNDARY;\n    }\n    if (point >= upper - tolerance) {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new LogTickUnit(1, numberFormat, 2));\n    units.add(new LogTickUnit(2, numberFormat, 2));\n    units.add(new LogTickUnit(5, numberFormat, 5));\n    units.add(new LogTickUnit(10, numberFormat, 2));\n    units.add(new LogTickUnit(20, numberFormat, 2));\n    units.add(new LogTickUnit(50, numberFormat, 5));\n    units.add(new LogTickUnit(100, numberFormat, 2));\n    units.add(new LogTickUnit(200, numberFormat, 2));\n    units.add(new LogTickUnit(500, numberFormat, 5));\n    units.add(new LogTickUnit(1000, numberFormat, 2));\n    units.add(new LogTickUnit(2000, numberFormat, 2));\n    units.add(new LogTickUnit(5000, numberFormat, 5));\n    units.add(new LogTickUnit(10000, numberFormat, 2));\n    units.add(new LogTickUnit(20000, numberFormat, 2));\n    units.add(new LogTickUnit(50000, numberFormat, 5));\n    units.add(new LogTickUnit(100000, numberFormat, 2));\n    units.add(new LogTickUnit(200000, numberFormat, 2));\n    units.add(new LogTickUnit(500000, numberFormat, 5));\n    units.add(new LogTickUnit(1000000, numberFormat, 2));\n    units.add(new LogTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new LogTickUnit(1, numberFormat, 2));\n    units.add(new LogTickUnit(2, numberFormat, 2));\n    units.add(new LogTickUnit(5, numberFormat, 5));\n    units.add(new LogTickUnit(10, numberFormat, 2));\n    units.add(new LogTickUnit(20, numberFormat, 2));\n    units.add(new LogTickUnit(50, numberFormat, 5));\n    units.add(new LogTickUnit(100, numberFormat, 2));\n    units.add(new LogTickUnit(200, numberFormat, 2));\n    units.add(new LogTickUnit(500, numberFormat, 5));\n    units.add(new LogTickUnit(1000, numberFormat, 2));\n    units.add(new LogTickUnit(2000, numberFormat, 2));\n    units.add(new LogTickUnit(5000, numberFormat, 5));\n    units.add(new LogTickUnit(10000, numberFormat, 2));\n    units.add(new LogTickUnit(20000, numberFormat, 2));\n    units.add(new LogTickUnit(50000, numberFormat, 5));\n    units.add(new LogTickUnit(100000, numberFormat, 2));\n    units.add(new LogTickUnit(200000, numberFormat, 2));\n    units.add(new LogTickUnit(500000, numberFormat, 5));\n    units.add(new LogTickUnit(1000000, numberFormat, 2));\n    units.add(new LogTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new LogTickUnit(1, numberFormat, 2));\n    units.add(new LogTickUnit(2, numberFormat, 2));\n    units.add(new LogTickUnit(5, numberFormat, 5));\n    units.add(new LogTickUnit(10, numberFormat, 2));\n    units.add(new LogTickUnit(20, numberFormat, 2));\n    units.add(new LogTickUnit(50, numberFormat, 5));\n    units.add(new LogTickUnit(100, numberFormat, 2));\n    units.add(new LogTickUnit(200, numberFormat, 2));\n    units.add(new LogTickUnit(500, numberFormat, 5));\n    units.add(new LogTickUnit(1000, numberFormat, 2));\n    units.add(new LogTickUnit(2000, numberFormat, 2));\n    units.add(new LogTickUnit(5000, numberFormat, 5));\n    units.add(new LogTickUnit(10000, numberFormat, 2));\n    units.add(new LogTickUnit(20000, numberFormat, 2));\n    units.add(new LogTickUnit(50000, numberFormat, 5));\n    units.add(new LogTickUnit(100000, numberFormat, 2));\n    units.add(new LogTickUnit(200000, numberFormat, 2));\n    units.add(new LogTickUnit(500000, numberFormat, 5));\n    units.add(new LogTickUnit(1000000, numberFormat, 2));\n    units.add(new LogTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new LogTickUnit(1, numberFormat, 2));\n    units.add(new LogTickUnit(2, numberFormat, 2));\n    units.add(new LogTickUnit(5, numberFormat, 5));\n    units.add(new LogTickUnit(10, numberFormat, 2));\n    units.add(new LogTickUnit(20, numberFormat, 2));\n    units.add(new LogTickUnit(50, numberFormat, 5));\n    units.add(new LogTickUnit(100, numberFormat, 2));\n    units.add(new LogTickUnit(200, numberFormat, 2));\n    units.add(new LogTickUnit(500, numberFormat, 5));\n    units.add(new LogTickUnit(1000, numberFormat, 2));\n    units.add(new LogTickUnit(2000, numberFormat, 2));\n    units.add(new LogTickUnit(5000, numberFormat, 5));\n    units.add(new LogTickUnit(10000, numberFormat, 2));\n    units.add(new LogTickUnit(20000, numberFormat, 2));\n    units.add(new LogTickUnit(50000, numberFormat, 5));\n    units.add(new LogTickUnit(100000, numberFormat, 2));\n    units.add(new LogTickUnit(200000, numberFormat, 2));\n    units.add(new LogTickUnit(500000, numberFormat, 5));\n    units.add(new LogTickUnit(1000000, numberFormat, 2));\n    units.add(new LogTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth(); i++) \n    {\n        final double entry = tableau.getEntry(tableau.getNumObjectiveFunctions(), i);\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) \n        {\n            final double ratio = tableau.getEntry(tableau.getNumObjectiveFunctions(), i) / tableau.getEntry(tableau.getNumObjectiveFunctions(), tableau.getSlackVariableOffset());\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) \n            {\n                minRatioPositions.add(i);\n            } \n            else if (cmp < 0) \n            {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) \n    {\n        return null;\n    } \n    else if (minRatioPositions.size() > 1) \n    {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        return minRatioPositions.get(0);\n    }\n    else \n    {\n        return minRatioPositions.get(0);\n    }\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth(); i++) \n    {\n        final double entry = tableau.getEntry(tableau.getNumObjectiveFunctions(), i);\n\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) \n        {\n            final double ratio = tableau.getEntry(tableau.getNumObjectiveFunctions(), i) / tableau.getEntry(tableau.getNumObjectiveFunctions(), tableau.getRhsOffset());\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) \n            {\n                minRatioPositions.add(i);\n            } \n            else if (cmp < 0) \n            {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) \n    {\n        return null;\n    } \n    else if (minRatioPositions.size() > 1) \n    {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        return minRatioPositions.get(0);\n    }\n    else \n    {\n        return minRatioPositions.get(0);\n    }\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth(); i++) \n    {\n        final double entry = tableau.getEntry(0, i);\n\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) \n        {\n            final double ratio = tableau.getEntry(0, i) / tableau.getEntry(0, tableau.getWidth() - 1);\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) \n            {\n                minRatioPositions.add(i);\n            } \n            else if (cmp < 0) \n            {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) \n    {\n        return null;\n    } \n    else if (minRatioPositions.size() > 1) \n    {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        return minRatioPositions.get(0);\n    }\n    else \n    {\n        return minRatioPositions.get(0);\n    }\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth(); i++) \n    {\n        final double entry = tableau.getEntry(tableau.getNumObjectiveFunctions(), i);\n\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) \n        {\n            final double ratio = tableau.getEntry(tableau.getNumObjectiveFunctions(), i) / tableau.getEntry(tableau.getNumObjectiveFunctions(), tableau.getRhsOffset());\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) \n            {\n                minRatioPositions.add(i);\n            } \n            else if (cmp < 0) \n            {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) \n    {\n        return null;\n    } \n    else if (minRatioPositions.size() > 1) \n    {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        return minRatioPositions.get(0);\n    } \n    else \n    {\n        return minRatioPositions.get(0);\n    }\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth(); i++) \n    {\n        final double entry = tableau.getEntry(tableau.getNumObjectiveFunctions(), i);\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) \n        {\n            final double ratio = tableau.getEntry(tableau.getNumObjectiveFunctions(), i) / tableau.getEntry(tableau.getNumObjectiveFunctions(), tableau.getNumDecisionVariables());\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) \n            {\n                minRatioPositions.add(i);\n            } \n            else if (cmp < 0) \n            {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) \n    {\n        return null;\n    } \n    else if (minRatioPositions.size() > 1) \n    {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        return minRatioPositions.get(0);\n    } \n    else \n    {\n        return minRatioPositions.get(0);\n    }\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth(); i++) \n    {\n        final double entry = tableau.getEntry(0, i);\n\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) \n        {\n            final double ratio = tableau.getEntry(0, i) / tableau.getEntry(0, tableau.getWidth() - 1);\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) \n            {\n                minRatioPositions.add(i);\n            } \n            else if (cmp < 0) \n            {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) \n    {\n        return null;\n    } \n    else if (minRatioPositions.size() > 1) \n    {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        return minRatioPositions.get(0);\n    } \n    else \n    {\n        return minRatioPositions.get(0);\n    }\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth(); i++) \n    {\n        final double entry = tableau.getEntry(tableau.getNumObjectiveFunctions(), i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) \n        {\n            final double ratio = tableau.getEntry(tableau.getNumObjectiveFunctions(), i) / tableau.getEntry(tableau.getNumObjectiveFunctions(), tableau.getSlackVariableOffset());\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) \n            {\n                minRatioPositions.add(i);\n            } \n            else if (cmp < 0) \n            {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) \n    {\n        return null;\n    } \n    else if (minRatioPositions.size() > 1) \n    {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        return minRatioPositions.get(0);\n    }\n    else \n    {\n        return minRatioPositions.get(0);\n    }\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth(); i++) \n    {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) \n        {\n            final double ratio = tableau.getEntry(0, i) / tableau.getEntry(0, tableau.getWidth() - 1);\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) \n            {\n                minRatioPositions.add(i);\n            } \n            else if (cmp < 0) \n            {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) \n    {\n        return null;\n    } \n    else if (minRatioPositions.size() > 1) \n    {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        return minRatioPositions.get(0);\n    } \n    else \n    {\n        return minRatioPositions.get(0);\n    }\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = 0;\n    double pivotVal = tableau.getEntry(0, pivotCol);\n    for (int col = 1; col < tableau.getWidth(); col++) \n    {\n        double entry = tableau.getEntry(0, col);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0) \n        {\n            pivotCol = col;\n            pivotVal = entry;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    // create a list of all the columns that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth(); i++) \n    {\n        final double entry = tableau.getEntry(0, i);\n\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) \n        {\n            final double ratio = tableau.getEntry(0, i) / tableau.getEntry(0, tableau.getRhsOffset());\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) \n            {\n                minRatioPositions.add(i);\n            } \n            else if (cmp < 0) \n            {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) \n    {\n        return null;\n    } \n    else if (minRatioPositions.size() > 1) \n    {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n        return minRatioPositions.get(0);\n    }\n    else \n    {\n        return minRatioPositions.get(0);\n    }\n}"
    ]
  ]
}