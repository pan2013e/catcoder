{
  "benchmark": "javaeval_xc",
  "lastest_eval": {
    "compile@1": 0.7040201005025125,
    "pass@1": 0.4241206030150753,
    "compile@3": 0.7957286432160804,
    "pass@3": 0.4965661641541038,
    "compile@5": 0.8228842625827549,
    "pass@5": 0.5229720028715004
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n         _checkNotNull(type, \"type to register serializer for\");\n         _checkNotNull(ser, \"serializer\");\n         if (_serializers == null) {\n             _serializers = new SimpleSerializers();\n         }\n         _serializers.addSerializer(type, ser);\n         return this;\n     }"
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        Number startValue = task.getStartValue();\n        Number endValue = task.getEndValue();\n        if (startValue != null && endValue != null) \n        {\n            long totalTime = endValue.longValue() - startValue.longValue();\n            long elapsedTime = System.currentTimeMillis() - startValue.longValue();\n            result = new Long(100 * elapsedTime / totalTime);\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        Number startValue = task.getStartValue();\n        Number endValue = task.getEndValue();\n        if (startValue != null && endValue != null) {\n            long duration = endValue.longValue() - startValue.longValue();\n            long elapsed = System.currentTimeMillis() - startValue.longValue();\n            result = new Long(100 * elapsed / duration);\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        Number startValue = task.getStartValue();\n        Number endValue = task.getEndValue();\n        if (startValue != null && endValue != null) \n        {\n            long total = endValue.longValue() - startValue.longValue();\n            long elapsed = System.currentTimeMillis() - startValue.longValue();\n            result = new Long((elapsed * 100) / total);\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        Number startValue = task.getStartValue();\n        Number endValue = task.getEndValue();\n        if (startValue != null && endValue != null) {\n            long totalTime = endValue.longValue() - startValue.longValue();\n            long elapsedTime = System.currentTimeMillis() - startValue.longValue();\n            result = new Long(100 * elapsedTime / totalTime);\n        }\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        Number startValue = task.getStartValue();\n        Number endValue = task.getEndValue();\n        if (startValue != null && endValue != null) {\n            long totalTime = endValue.longValue() - startValue.longValue();\n            long elapsedTime = System.currentTimeMillis() - startValue.longValue();\n            result = new Long(100 * elapsedTime / totalTime);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) {\n        int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int size = Math.min(m.getRowDimension(), m.getColumnDimension());\n    final double[][] d = new double[size][size];\n    for (int i = 0; i < size; i++) \n    {\n        d[i][i] = m.getEntry(i, 0);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int size = Math.min(m.getRowDimension(), m.getColumnDimension());\n    final double[][] d = new double[size][size];\n    for (int i = 0; i < size; i++) {\n        d[i][i] = m.getEntry(i, 0);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int size = Math.min(m.getRowDimension(), m.getColumnDimension());\n    final double[][] d = new double[size][size];\n    for (int i = 0; i < size; i++) \n    {\n        d[i][i] = m.getEntry(i, 0);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int size = Math.min(m.getRowDimension(), m.getColumnDimension());\n    final double[][] d = new double[size][size];\n    for (int i = 0; i < size; i++) {\n        d[i][i] = m.getEntry(i, 0);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int size = Math.min(m.getRowDimension(), m.getColumnDimension());\n    final double[][] d = new double[size][size];\n    for (int i = 0; i < size; i++) {\n        d[i][i] = m.getEntry(i, 0);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int rd = m.getRowDimension();\n    final int cd = m.getColumnDimension();\n    final int d = Math.min(rd, cd);\n    final double[][] dd = new double[d][1];\n    for (int i = 0; i < d; i++) {\n        dd[i][0] = m.getEntry(i, i);\n    }\n    return new Array2DRowRealMatrix(dd, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int r = m.getRowDimension();\n    final int c = m.getColumnDimension();\n    final int n = Math.min(r, c);\n    final double[][] d = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        d[i][i] = m.getEntry(i, i);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int size = Math.min(m.getRowDimension(), m.getColumnDimension());\n    final double[][] d = new double[size][size];\n    for (int i = 0; i < size; i++) {\n        d[i][i] = m.getEntry(i, 0);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int size = Math.min(m.getRowDimension(), m.getColumnDimension());\n    final double[][] d = new double[size][size];\n    for (int i = 0; i < size; i++) {\n        d[i][i] = m.getEntry(i, 0);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    final int rd = m.getRowDimension();\n    final int cd = m.getColumnDimension();\n    final int n = Math.min(rd, cd);\n    final double[][] d = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        d[i][i] = m.getEntry(i, i);\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = Math.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = Math.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = Math.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = Math.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = Math.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = Math.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = Math.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = Math.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = Math.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = Math.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = Math.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = Math.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = Math.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = Math.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = Math.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = Math.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = Math.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = Math.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = Math.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = Math.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    try {\n        return field.get(null);\n    } catch (IllegalAccessException e) {\n        throw new IllegalAccessException(\"Cannot access static field \" + field.getName() + \" on \" + field.getDeclaringClass());\n    }\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    try {\n        return field.get(null);\n    } catch (IllegalAccessException e) {\n        throw new IllegalAccessException(\"Cannot access static field \" + field.getName() + \" on \" + field.getDeclaringClass());\n    }\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            throw new IllegalArgumentException(\"ID must not be null\");\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (cAvailableIDs.contains(id)) {\n            return cProvider.getZone(id);\n        }\n        throw new IllegalArgumentException(\"ID not valid: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            throw new IllegalArgumentException(\"ID must not be null\");\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffsetHoursMinutes(parseOffset(id));\n        }\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            return cProvider.getZone(convId);\n        }\n        return cProvider.getZone(id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            throw new IllegalArgumentException(\"The id must not be null\");\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Check if it's a fixed offset\n        if (id.matches(\"[+-]\\\\d\\\\d:\\\\d\\\\d\")) {\n            return forOffset(id);\n        }\n\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            throw new IllegalArgumentException(\"ID must not be null\");\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int hoursOffset = parseOffset(id.substring(0, 3));\n            int minutesOffset = 0;\n            if (id.length() > 4) {\n                minutesOffset = parseOffset(id.substring(4));\n            }\n            return forOffsetHoursMinutes(hoursOffset, minutesOffset);\n        }\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            DateTimeZone dtz = cProvider.getZone(convId);\n            if (dtz != null) {\n                return dtz;\n            }\n        }\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            throw new IllegalArgumentException(\"The ID must not be null\");\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (cAvailableIDs.contains(id)) {\n            return fixedOffsetZone(id, parseOffset(id));\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            throw new IllegalArgumentException(\"The id must not be null\");\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (cAvailableIDs.contains(id)) {\n            return cProvider.getZone(id);\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            throw new IllegalArgumentException(\"ID must not be null\");\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        // If the ID is a fixed offset, try to parse it.\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            return forOffsetMillis(offset);\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            throw new IllegalArgumentException(\"The ID must not be null\");\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            throw new IllegalArgumentException(\"The id must not be null\");\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (cAvailableIDs.contains(id)) {\n            return fixedOffsetZone(id, parseOffset(id));\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            throw new IllegalArgumentException(\"ID must not be null\");\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffsetHoursMinutes(parseOffset(id));\n        }\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            return cProvider.getZone(convId);\n        }\n        return cProvider.getZone(id);\n    }"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n        if (x == 0) {\n            return getZero();\n        }\n\n        Dfp result = newInstance(this);\n        int carry = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final long temp = (long)mant[i] * x + carry;\n            result.mant[i] = (int)(temp % RADIX);\n            carry = (int)(temp / RADIX);\n        }\n\n        if (carry != 0) {\n            result.shiftLeft();\n            result.mant[0] = carry;\n        }\n\n        result.exp += x;\n\n        int excp = result.align(exp);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, this, result);\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = r - rh / RADIX;\n            result.mant[i] = rh % RADIX;\n        }\n\n        result.exp += x;\n\n        int excp = result.round(0);\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, newInstance(x), result);\n        }\n\n        return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n        if (x == 0) {\n            return getZero();\n        }\n\n        Dfp result = newInstance(this);\n        int carry = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int product = mant[i] * x + carry;\n            result.mant[i] = product % RADIX;\n            carry = product / RADIX;\n        }\n\n        result.exp += x * LOG10_RADIX;\n\n        if (carry != 0) {\n            final int excp = result.round(carry);\n            if (excp != 0) {\n                result = dotrap(excp, MULTIPLY_TRAP, newInstance(x), result);\n            }\n        }\n\n        return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    int carry = 0;\n    for (int i = 0; i < mant.length; i++) {\n        final int product = mant[i] * x + carry;\n        result.mant[i] = product % RADIX;\n        carry = product / RADIX;\n    }\n    result.exp += x * exp;\n    if (carry != 0) {\n        int excp = result.round(carry);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n    }\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    int carry = 0;\n    for (int i = 0; i < mant.length; i++) {\n        final int temp = mant[i] * x + carry;\n        result.mant[i] = temp % RADIX;\n        carry = temp / RADIX;\n    }\n    result.exp += x * exp;\n    if (carry != 0) {\n        final int excp = result.round(carry);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, newInstance(x), result);\n        }\n    }\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n        if (x == 0) {\n            return getZero();\n        }\n\n        if (x == 1) {\n            return newInstance(this);\n        }\n\n        Dfp result = newInstance(this);\n\n        int rl = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int r = rl*RADIX + result.mant[i];\n            final int rh = r * x;\n            rl = r - rh / RADIX;\n            result.mant[i] = rh % RADIX;\n        }\n\n        result.exp += x;\n\n        int excp = result.round(0);\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n\n        return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n        if (x == 0) {\n            return getZero();\n        }\n\n        Dfp result = newInstance(this);\n\n        int carry = 0;\n        for (int i = 0; i < mant.length; i++) {\n            final int prod = mant[i] * x + carry;\n            result.mant[i] = prod % RADIX;\n            carry = prod / RADIX;\n        }\n\n        result.exp += x * exp;\n\n        int excp = result.align(result.exp);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, newInstance(x), result);\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n    // Handle special cases\n    if (nans != FINITE) {\n        if (isNaN()) {\n            return this;\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n    }\n\n    // range check x\n    if (x < 0 || x >= RADIX) {\n        field.setIEEEFlagsBits(DfpField.FLAG_INVALID);\n        Dfp result = newInstance(getZero());\n        result.nans = QNAN;\n        return dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, result, result);\n    }\n\n    Dfp result = newInstance(this);\n\n    int carry = 0;\n    for (int i = 0; i < mant.length; i++) {\n        final int product = result.mant[i] * x + carry;\n        result.mant[i] = product % RADIX;\n        carry = product / RADIX;\n    }\n\n    if (carry != 0) {\n        final int excp = result.round(carry);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(this);\n        int carry = 0;\n        for (int i = 0; i < result.mant.length; i++) \n        {\n            final int temp = result.mant[i] * x + carry;\n            result.mant[i] = temp % RADIX;\n            carry = temp / RADIX;\n        }\n        result.exp += x * LOG2_RADIX;\n        if (carry != 0) \n        {\n            // Overflow\n            field.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\n            return dotrap(DfpField.FLAG_OVERFLOW, MULTIPLY_TRAP, newInstance(x), result);\n        }\n        return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    int carry = 0;\n    for (int i = 0; i < mant.length; i++) {\n        final int temp = mant[i] * x + carry;\n        result.mant[i] = temp % RADIX;\n        carry = temp / RADIX;\n    }\n    result.exp += x * exp;\n    if (carry != 0) {\n        int excp = result.round(1);\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, result, result);\n        }\n    }\n    return result;\n}"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function(null, null);\n    externFunction.setJSType(exportedFunction.getJSType());\n\n    // Copy the parameter names from the exported function to the extern function\n    for (Node child = exportedFunction.getFirstChild();\n         child != null;\n         child = child.getNext()) \n    {\n        if (child.isName()) \n        {\n            externFunction.addChildToBack(IR.name(child.getString()));\n        }\n    }\n\n    // If the exported function has a return type, copy it to the extern function\n    JSDocInfo jsDocInfo = exportedFunction.getJSDocInfo();\n    if (jsDocInfo != null && jsDocInfo.getReturnType() != null) \n    {\n        externFunction.setJSDocInfo(jsDocInfo);\n    }\n\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node functionNode = IR.function();\n    functionNode.setJSType(exportedFunction.getJSType());\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    functionNode.setJSDocInfo(new JSDocInfo());\n\n    for (Node child = exportedFunction.getFirstChild();\n         child != null;\n         child = child.getNext()) \n    {\n        // TODO(user): handle getters or setters?\n        if (child.isName()) \n        {\n            functionNode.addChildToBack(IR.param(child.getString()));\n        }\n    }\n    return functionNode;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function(null, null);\n    function.setJSType(exportedFunction.getJSType());\n\n    for (Node child = exportedFunction.getFirstChild();\n         child != null;\n         child = child.getNext()) {\n        if (child.isName()) {\n            function.addChildToBack(IR.name(child.getString()));\n        }\n    }\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node functionNode = IR.function();\n    functionNode.setJSType(exportedFunction.getJSType());\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    functionNode.setJSDocInfo(new JSDocInfo());\n\n    for (Node child = exportedFunction.getFirstChild();\n         child != null;\n         child = child.getNext()) {\n        if (child.isName()) {\n            functionNode.addChildToBack(IR.param(child.getString()));\n        }\n    }\n    return functionNode;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function(null, null);\n    externFunction.setJSType(exportedFunction.getJSType());\n\n    Node functionName = exportedFunction.getFirstChild();\n    if (functionName != null && functionName.isName()) {\n        externFunction.addChildToBack(functionName);\n    } else {\n        compiler.warning(\"Missing function name for extern function\");\n    }\n\n    Node paramList = exportedFunction.getChildAtIndex(1);\n    if (paramList != null && paramList.isParamList()) {\n        for (Node child = paramList.getFirstChild(); child != null; child = child.getNext()) {\n            if (child.isName()) {\n                externFunction.addChildToBack(child);\n            } else {\n                compiler.warning(\"Missing parameter name for extern function\");\n            }\n        }\n    } else {\n        compiler.warning(\"Missing parameter list for extern function\");\n    }\n\n    Node returnType = exportedFunction.getChildAtIndex(2);\n    if (returnType != null && returnType.isName()) {\n        externFunction.addChildToBack(returnType);\n    } else {\n        compiler.warning(\"Missing return type for extern function\");\n    }\n\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function();\n    externFunction.setJSType(exportedFunction.getJSType());\n\n    Node functionName = exportedFunction.getFirstChild();\n    if (functionName != null && functionName.isName()) {\n        externFunction.addChildToBack(functionName);\n    } else {\n        compiler.reportError(new CompilerException(\"Missing function name\"));\n    }\n\n    Node paramList = exportedFunction.getChildAtIndex(1);\n    if (paramList != null && paramList.isParamList()) {\n        for (Node child = paramList.getFirstChild(); child != null; child = child.getNext()) {\n            if (child.isName()) {\n                externFunction.addChildToBack(child);\n            } else {\n                compiler.reportError(new CompilerException(\"Missing parameter name\"));\n            }\n        }\n    } else {\n        compiler.reportError(new CompilerException(\"Missing parameter list\"));\n    }\n\n    Node returnType = exportedFunction.getChildAtIndex(2);\n    if (returnType != null && returnType.isName()) {\n        externFunction.addChildToBack(returnType);\n    } else {\n        compiler.reportError(new CompilerException(\"Missing return type\"));\n    }\n\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function();\n    function.setJSType(exportedFunction.getJSType());\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    function.setJSDocInfo(new JSDocInfo());\n\n    for (Node child = exportedFunction.getFirstChild();\n         child != null;\n         child = child.getNext()) {\n        if (child.isName()) {\n            function.addChildToBack(IR.param(child.getString()));\n        }\n    }\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function();\n    externFunction.setJSType(exportedFunction.getJSType());\n\n    // Set the name of the function\n    Node nameNode = exportedFunction.getFirstChild();\n    if (nameNode != null && nameNode.isName()) {\n        externFunction.addChildToBack(nameNode);\n    } else {\n        compiler.warning(\"Missing function name for \" + exportedFunction);\n    }\n\n    // Set the parameters of the function\n    Node paramList = exportedFunction.getChildAtIndex(1);\n    if (paramList != null && paramList.isParamList()) {\n        for (Node child = paramList.getFirstChild(); child != null; child = child.getNext()) {\n            if (child.isName()) {\n                externFunction.addChildToBack(child);\n            } else {\n                compiler.warning(\"Missing parameter name for \" + exportedFunction);\n            }\n        }\n    } else {\n        compiler.warning(\"Missing parameter list for \" + exportedFunction);\n    }\n\n    // Set the return type of the function\n    JSDocInfo jsDocInfo = exportedFunction.getJSDocInfo();\n    if (jsDocInfo != null && jsDocInfo.getReturnType() != null) {\n        externFunction.setJSDocInfo(jsDocInfo);\n    } else {\n        compiler.warning(\"Missing return type for \" + exportedFunction);\n    }\n\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function();\n    function.setJSType(exportedFunction.getJSType());\n\n    for (Node child = exportedFunction.getFirstChild();\n         child != null;\n         child = child.getNext()) {\n        if (child.isName()) {\n            function.addChildToBack(IR.name(child.getString()));\n        }\n    }\n\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = IR.function(null, null);\n    function.setJSType(exportedFunction.getJSType());\n\n    // This is an indirect way of telling the typed code generator\n    // \"print the type of this\"\n    function.setJSDocInfo(new JSDocInfo());\n\n    for (Node child = exportedFunction.getFirstChild();\n         child != null;\n         child = child.getNext()) {\n        if (child.isName()) {\n            function.addChildToBack(IR.param(child.getString()));\n        }\n    }\n    return function;\n}"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[][] covar = computeCovariances(params,\n                                              covarianceSingularityThreshold);\n        double[] sigma = new double[covar.length];\n        for (int i = 0; i < covar.length; ++i) {\n            sigma[i] = Math.sqrt(covar[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n        double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n        double[] sigma = new double[covar.length];\n        for (int i = 0; i < covar.length; i++) {\n            sigma[i] = Math.sqrt(covar[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[] sigma = new double[params.length];\n    double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n    for (int i = 0; i < sigma.length; ++i) {\n        sigma[i] = FastMath.sqrt(covar[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[covar.length];\n    for (int i = 0; i < covar.length; i++) {\n        sigma[i] = Math.sqrt(covar[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[covar.length];\n    for (int i = 0; i < covar.length; i++) \n    {\n        sigma[i] = Math.sqrt(covar[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n        double[] sigma = new double[covar.length];\n        for (int i = 0; i < covar.length; ++i) {\n            sigma[i] = Math.sqrt(covar[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n        double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; ++i) {\n            sigma[i] = FastMath.sqrt(covar[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[][] covar = computeCovariances(params,\n                                              covarianceSingularityThreshold);\n        double[] sigma = new double[covar.length];\n        for (int i = 0; i < covar.length; i++) {\n            sigma[i] = Math.sqrt(covar[i][i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n    double[] sigma = new double[covar.length];\n    for (int i = 0; i < covar.length; i++) {\n        sigma[i] = Math.sqrt(covar[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[][] covar = computeCovariances(params, covarianceSingularityThreshold);\n        double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; ++i) {\n            sigma[i] = Math.sqrt(covar[i][i]);\n        }\n        return sigma;\n    }"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic substitution detected for variable: \" + varName);\n    }\n    priorVariables.add(varName);\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic variable substitution detected: \" + varName);\n    }\n    priorVariables.add(varName);\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic substitution detected for variable '\" + varName + \"'\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic substitution detected for variable: \" + varName);\n    }\n    priorVariables.add(varName);\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic variable substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic substitution detected for variable: \" + varName);\n    }\n    priorVariables.add(varName);\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic substitution detected for variable '\" + varName + \"'\");\n    }\n    priorVariables.add(varName);\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic variable substitution detected: \" + varName);\n    }\n    priorVariables.add(varName);\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic substitution detected for variable: \" + varName);\n    }\n    priorVariables.add(varName);\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) \n    {\n        throw new IllegalArgumentException(\"Cyclic variable substitution detected: \" + varName);\n    }\n    priorVariables.add(varName);\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    List<INPUT> result = new ArrayList<INPUT>();\n    Set<INPUT> subGraph = new HashSet<INPUT>();\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n\n    for (INPUT root : roots) {\n      if (subGraph.contains(root)) {\n        throw new CircularDependencyException(\n            \"Circular dependency detected: \" + cycleToString(findCycle(root, subGraph, deps, new HashSet<INPUT>())));\n      }\n      subGraph.add(root);\n      result.addAll(deps.get(root));\n    }\n\n    if (sorted) {\n      result = topologicalStableSort(result, deps);\n    }\n\n    return result;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    List<INPUT> dependencies = new ArrayList<INPUT>();\n    Set<INPUT> subGraph = new HashSet<INPUT>();\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT root : roots) {\n      if (!subGraph.contains(root)) {\n        dependencies.addAll(getDependenciesOf(root, subGraph, deps));\n      }\n    }\n    if (sorted) {\n      dependencies = topologicalStableSort(dependencies, deps);\n    }\n    return dependencies;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT root : roots) {\n      for (String symbol : root.getRequires()) {\n        INPUT candidate = provideMap.get(symbol);\n        if (candidate == null) {\n          throw new CircularDependencyException(\n              \"Missing provide for symbol: \" + symbol);\n        }\n        deps.put(root, candidate);\n      }\n    }\n\n    if (sorted) {\n      return topologicalStableSort(roots, deps);\n    } else {\n      return roots;\n    }\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    List<INPUT> result = new ArrayList<INPUT>();\n    Set<INPUT> covered = new HashSet<INPUT>();\n    for (INPUT root : roots) {\n      if (!covered.contains(root)) {\n        result.addAll(getDependenciesOf(root, covered));\n      }\n    }\n    if (sorted) {\n      return topologicalStableSort(result, new HashMultimap<INPUT, INPUT>());\n    } else {\n      return result;\n    }\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    Multimap<INPUT, INPUT> deps = ArrayListMultimap.create();\n    for (INPUT root : roots) {\n      for (String symbol : root.getRequires()) {\n        INPUT provide = provideMap.get(symbol);\n        if (provide == null) {\n          throw new CircularDependencyException(\n              \"Missing provide for symbol: \" + symbol);\n        }\n        deps.put(root, provide);\n      }\n    }\n\n    if (sorted) {\n      return topologicalStableSort(roots, deps);\n    } else {\n      return roots;\n    }\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    List<INPUT> dependencies = new ArrayList<INPUT>();\n    for (INPUT root : roots) {\n      dependencies.addAll(getDependenciesOf(root, sorted));\n    }\n    return dependencies;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    List<INPUT> result = new ArrayList<INPUT>();\n    Set<INPUT> covered = new HashSet<INPUT>();\n    for (INPUT root : roots) {\n      if (!covered.contains(root)) {\n        result.addAll(getDependenciesOf(root, covered));\n      }\n    }\n    if (sorted) {\n      return topologicalStableSort(result, Multimaps.forList(result));\n    } else {\n      return result;\n    }\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    List<INPUT> result = new ArrayList<>();\n    Set<INPUT> covered = new HashSet<>();\n    for (INPUT root : roots) {\n      if (covered.contains(root)) {\n        continue;\n      }\n      covered.add(root);\n      result.addAll(getDependenciesOf(root, covered));\n    }\n    if (sorted) {\n      return topologicalStableSort(result, deps);\n    } else {\n      return result;\n    }\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    List<INPUT> result = new ArrayList<INPUT>();\n    Set<INPUT> subGraph = new HashSet<INPUT>(roots);\n    Multimap<INPUT, INPUT> deps = ArrayListMultimap.create();\n    for (INPUT input : inputs) {\n      for (String symbol : input.getRequires()) {\n        INPUT candidate = provideMap.get(symbol);\n        if (subGraph.contains(candidate)) {\n          deps.put(candidate, input);\n        }\n      }\n    }\n    if (sorted) {\n      result.addAll(topologicalStableSort(roots, deps));\n    } else {\n      result.addAll(roots);\n    }\n    List<INPUT> cycle = findCycle(roots.get(0), subGraph, deps, new HashSet<INPUT>());\n    if (cycle != null) {\n      throw new CircularDependencyException(cycleToString(cycle));\n    }\n    return result;\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    List<INPUT> result = new ArrayList<INPUT>();\n    Set<INPUT> subGraph = new HashSet<INPUT>(roots);\n    Multimap<INPUT, INPUT> deps = HashMultimap.create();\n    for (INPUT input : inputs) {\n      for (String symbol : input.getProvides()) {\n        INPUT candidate = provideMap.get(symbol);\n        if (subGraph.contains(candidate)) {\n          deps.put(candidate, input);\n        }\n      }\n    }\n    if (sorted) {\n      result.addAll(topologicalStableSort(roots, deps));\n    } else {\n      result.addAll(roots);\n    }\n    return result;\n  }"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext && Character.isTitleCase(ch)) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        } \n        else if (!uncapitalizeNext && Character.isTitleCase(ch)) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext && Character.isTitleCase(ch)) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        } \n        else if (!uncapitalizeNext && Character.isUpperCase(ch)) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext && Character.isTitleCase(ch)) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        } \n        else \n        {\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext && Character.isTitleCase(ch)) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext && Character.isTitleCase(ch)) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        } \n        else \n        {\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return str.substring(0, 1).toLowerCase() + str.substring(1);\n    }\n    char[] chars = str.toCharArray();\n    for (int i = 0; i < chars.length; i++) \n    {\n        if (i == 0 || isDelimiter(chars[i - 1], delimiters)) \n        {\n            chars[i] = Character.toLowerCase(chars[i]);\n        }\n    }\n    return new String(chars);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext && Character.isTitleCase(ch)) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        } \n        else if (!uncapitalizeNext && Character.isTitleCase(ch)) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < strLen; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext && Character.isTitleCase(ch)) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        } \n        else if (!uncapitalizeNext && Character.isTitleCase(ch)) \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    String aString = a.toString();\n    int decimalIndex = aString.indexOf('.');\n    if (decimalIndex == -1) {\n        result[0] = new Dfp(a.getField(), Integer.parseInt(aString));\n        result[1] = new Dfp(a.getField(), 0);\n    } else {\n        String wholePart = aString.substring(0, decimalIndex);\n        String fractionPart = aString.substring(decimalIndex + 1);\n        result[0] = new Dfp(a.getField(), Double.parseDouble(wholePart + \".\" + fractionPart.substring(0, fractionPart.length() / 2)));\n        result[1] = new Dfp(a.getField(), Double.parseDouble(\"0.\" + fractionPart.substring(fractionPart.length() / 2)));\n    }\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    String str = a.toString();\n    String firstHalf = str.substring(0, str.length()/2 + str.length()%2);\n    String secondHalf = str.substring(str.length()/2 + str.length()%2);\n    result[0] = new Dfp(a.getField(), firstHalf);\n    result[1] = new Dfp(a.getField(), secondHalf);\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    String str = a.toString();\n    int dotIndex = str.indexOf('.');\n    if (dotIndex == -1) {\n        result[0] = new Dfp(a.getField(), Integer.parseInt(str));\n        result[1] = new Dfp(a.getField(), 0);\n    } else {\n        String intPart = str.substring(0, dotIndex);\n        String fracPart = str.substring(dotIndex + 1);\n        result[0] = new Dfp(a.getField(), Integer.parseInt(intPart + fracPart));\n        result[1] = new Dfp(a.getField(), 0);\n    }\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n        Dfp[] result = new Dfp[2];\n        String str = a.toString();\n        int decimalIndex = str.indexOf('.');\n        if (decimalIndex == -1) {\n            result[0] = new Dfp(a.getField(), Integer.parseInt(str));\n            result[1] = new Dfp(a.getField(), 0);\n        } else {\n            String intPart = str.substring(0, decimalIndex);\n            String fracPart = str.substring(decimalIndex + 1);\n            result[0] = new Dfp(a.getField(), Integer.parseInt(intPart + fracPart));\n            result[1] = new Dfp(a.getField(), 0);\n        }\n        return result;\n    }",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    String aString = a.toString();\n    int decimalIndex = aString.indexOf('.');\n\n    if (decimalIndex == -1) {\n        result[0] = new Dfp(a.getField(), Integer.parseInt(aString));\n        result[1] = new Dfp(a.getField(), 0);\n    } else {\n        String integerPart = aString.substring(0, decimalIndex);\n        String fractionPart = aString.substring(decimalIndex + 1);\n\n        result[0] = new Dfp(a.getField(), Integer.parseInt(integerPart + fractionPart));\n        result[1] = new Dfp(a.getField(), 0);\n    }\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    String str = a.toString();\n    String[] parts = str.split(\"\\\\.\");\n    String whole = parts[0];\n    String fraction = parts[1];\n\n    result[0] = new Dfp(a.getField(), whole);\n    result[1] = new Dfp(a.getField(), fraction + \"0\".substring(fraction.length()));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    String aString = a.toString();\n    int decimalIndex = aString.indexOf('.');\n\n    if (decimalIndex == -1) {\n        result[0] = new Dfp(a.getField(), Integer.parseInt(aString));\n        result[1] = new Dfp(a.getField(), 0);\n    } else {\n        String intPart = aString.substring(0, decimalIndex);\n        String fracPart = aString.substring(decimalIndex + 1);\n\n        result[0] = new Dfp(a.getField(), Integer.parseInt(intPart + fracPart));\n        result[1] = new Dfp(a.getField(), 0);\n    }\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    String aString = a.toString();\n    int decimalIndex = aString.indexOf('.');\n\n    if (decimalIndex == -1) {\n        result[0] = new Dfp(a.getField(), Integer.parseInt(aString));\n        result[1] = new Dfp(a.getField(), 0);\n    } else {\n        String wholePart = aString.substring(0, decimalIndex);\n        String fractionPart = aString.substring(decimalIndex + 1);\n\n        result[0] = new Dfp(a.getField(), Integer.parseInt(wholePart + fractionPart));\n        result[1] = new Dfp(a.getField(), 0);\n    }\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    String aString = a.toString();\n    int decimalIndex = aString.indexOf('.');\n    if (decimalIndex == -1) {\n        result[0] = new Dfp(a.getField(), Integer.parseInt(aString));\n        result[1] = new Dfp(a.getField(), 0);\n    } else {\n        result[0] = new Dfp(a.getField(), Integer.parseInt(aString.substring(0, decimalIndex)));\n        result[1] = new Dfp(a.getField(), Double.parseDouble(\"0.\" + aString.substring(decimalIndex + 1)));\n    }\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    result[0] = a.newInstance(a.getField(), a.getField().getRadixDigits() / 2);\n    result[1] = a.newInstance(a.getField(), a.getField().getRadixDigits() / 2);\n    result[1] = result[1].subtract(result[0]);\n    return result;\n}"
    ],
    [
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    if (id() != null)\n        return \"#\" + id();\n    else {\n        Element parent = parent();\n        if (parent != null)\n            selector.append(parent.cssSelector()).append(\">\");\n        selector.append(tagName());\n        Set<String> classNames = classNames();\n        if (!classNames.isEmpty()) {\n            for (String className : classNames)\n                selector.append(\".\").append(className);\n        }\n        // TODO: implement nth-child\n        return selector.toString();\n    }\n}",
      "public String cssSelector()  {\n        StringBuilder selector = new StringBuilder();\n        Element el = this;\n        while (el != null) {\n            String tagName = el.tagName();\n            selector.insert(0, tagName);\n\n            // Add classes\n            Set<String> classNames = el.classNames();\n            if (!classNames.isEmpty()) {\n                selector.insert(0, \".\").insert(0, String.join(\".\", classNames));\n            }\n\n            // Add id\n            String id = el.id();\n            if (!Strings.isNullOrEmpty(id)) {\n                selector.insert(0, \"#\").insert(0, id);\n            }\n\n            // Move up the tree\n            el = el.parent();\n            if (el != null) {\n                selector.insert(0, \"> \");\n            }\n        }\n        return selector.toString();\n    }",
      "public String cssSelector()  {\n    StringBuilder sb = new StringBuilder();\n    Element el = this;\n    while (el.hasParent()) \n    {\n        Element parent = el.parent();\n        List<Element> siblings = parent.childElementsList();\n        int index = indexInList(el, siblings);\n        if (index == 0) \n        {\n            sb.insert(0, \":first-child\");\n        } \n        else if (index == siblings.size() - 1) \n        {\n            sb.insert(0, \":last-child\");\n        } \n        else \n        {\n            sb.insert(0, \":nth-child(\" + (index + 1) + \")\");\n        }\n        sb.insert(0, \">\");\n        el = parent;\n    }\n    if (el.id() != null) \n    {\n        sb.insert(0, \"#\" + el.id());\n    } \n    else \n    {\n        sb.insert(0, el.tagName());\n    }\n    return sb.toString();\n}",
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    if (id() != null)\n        return \"#\" + id();\n\n    Element parent = parent();\n    if (parent != null) \n    {\n        selector.append(parent.cssSelector());\n        selector.append(\">\");\n    }\n\n    selector.append(tagName());\n\n    Set<String> classNames = classNames();\n    if (!classNames.isEmpty()) \n    {\n        for (String className : classNames) \n        {\n            selector.append(\".\");\n            selector.append(className);\n        }\n    }\n\n    List<Element> siblings = parent().childElementsList();\n    int index = indexInList(this, siblings);\n    if (index != -1) \n    {\n        selector.append(\":nth-child(\");\n        selector.append(index + 1);\n        selector.append(\")\");\n    }\n\n    return selector.toString();\n}",
      "public String cssSelector()  {\n        StringBuilder selector = new StringBuilder();\n        Element el = this;\n        while (el != null && !el.tagName().equals(\"#root\")) {\n            selector.insert(0, \">\");\n            if (!el.id().isEmpty()) {\n                selector.insert(0, \"#\" + el.id());\n                break;\n            }\n            selector.insert(0, el.tagName());\n            if (!el.className().isEmpty()) {\n                selector.insert(0, \".\" + el.className());\n            }\n            el = el.parent();\n        }\n        return selector.toString();\n    }",
      "public String cssSelector()  {\n        StringBuilder sb = new StringBuilder();\n        Element el = this;\n        while (el != null && !el.tagName().equals(\"#root\")) {\n            if (el.id() != null && !el.id().isEmpty()) {\n                sb.insert(0, \"#\" + el.id());\n                break;\n            }\n            sb.insert(0, \"> \" + el.tagName());\n            el = el.parent();\n        }\n        return sb.toString();\n    }",
      "public String cssSelector()  {\n    if (!attributes().hasKey(\"id\")) \n    {\n        if (parent() == null) \n        {\n            return \"#\" + attributes().get(\"id\");\n        } \n        else \n        {\n            return parent().cssSelector() + \" > \" + tagName() + \"#\" + attributes().get(\"id\");\n        }\n    } \n    else \n    {\n        if (parent() == null) \n        {\n            return tagName();\n        } \n        else \n        {\n            return parent().cssSelector() + \" > \" + tagName();\n        }\n    }\n}",
      "public String cssSelector()  {\n    StringBuilder sb = new StringBuilder();\n    Element el = this;\n    while (el != null && !el.tagName().equals(\"#root\")) {\n        String tagName = el.tagName();\n        if (el.id() != null && !el.id().isEmpty()) {\n            sb.insert(0, \"#\" + el.id());\n            break;\n        }\n        sb.insert(0, \" > \" + tagName);\n        el = el.parent();\n    }\n    if (sb.length() == 0)\n        sb.append(tagName);\n    return sb.toString();\n}",
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    if (id() != null && !id().isEmpty()) \n    {\n        selector.append(\"#\").append(id());\n        return selector.toString();\n    }\n\n    Element parent = parent();\n    if (parent != null) \n    {\n        selector.append(parent.cssSelector()).append(\">\");\n    }\n\n    selector.append(tagName());\n\n    Set<String> classNames = classNames();\n    if (!classNames.isEmpty()) \n    {\n        for (String className : classNames) \n        {\n            selector.append(\".\").append(className);\n        }\n    }\n\n    List<Element> siblings = siblingElements();\n    int index = 0;\n    for (Element sibling : siblings) \n    {\n        if (sibling == this) \n        {\n            break;\n        }\n        if (sibling.tagName().equals(tagName())) \n        {\n            index++;\n        }\n    }\n\n    if (index > 0) \n    {\n        selector.append(\":nth-child(\").append(index + 1).append(\")\");\n    }\n\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    if (!hasAttr(\"id\"))\n        return \"\";\n\n    StringBuilder selector = new StringBuilder(\"#\" + attr(\"id\"));\n\n    Element parent = parent();\n    while (parent != null && !parent.tagName().equals(\"#root\")) \n    {\n        selector.insert(0, parent.tagName() + \">\");\n        parent = parent.parent();\n    }\n\n    int index = indexInList(this, parent.childElementsList());\n    if (index > 0) \n    {\n        selector.append(\":nth-child(\" + (index + 1) + \")\");\n    }\n\n    return selector.toString();\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) \n    {\n        case Token.NOT:\n            cost += PAREN_COST;\n            // fall through\n        case Token.AND:\n        case Token.OR:\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.LT:\n        case Token.LTE:\n        case Token.GT:\n        case Token.GTE:\n            cost += COMMA_COST;\n            // fall through\n        default:\n            return cost;\n    }\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n        case Token.NOT:\n            cost += PAREN_COST;\n            break;\n        case Token.OR:\n        case Token.AND:\n            cost += PAREN_COST;\n            break;\n        case Token.EQ:\n        case Token.NE:\n        case Token.SHEQ:\n        case Token.SHNE:\n            cost += COMMA_COST;\n            break;\n        default:\n            break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n        case Token.NOT:\n            // The NOT node itself counts as one character.\n            cost += 1;\n            // We count the cost of the child node.\n            cost += estimateCostOneLevel(n.getFirstChild());\n            break;\n        case Token.PAREN:\n            // The PAREN node itself counts as two characters.\n            cost += 2;\n            // We count the cost of the child node.\n            cost += estimateCostOneLevel(n.getFirstChild());\n            break;\n        default:\n            // For all other nodes, we count the length of the node's text.\n            cost += n.toString().length();\n            break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) \n    {\n        case Token.NOT:\n            // The NOT node itself is counted.\n            cost += 2; // \"!\"\n            break;\n        case Token.PAREN:\n            // Parentheses around an expression are counted by the parent node.\n            cost += 2; // \"(\" and \")\"\n            break;\n        default:\n            // Identifiers and literals are not counted.\n            break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n        case Token.NOT:\n            cost += PAREN_COST;\n            // fall through\n        case Token.OR:\n        case Token.AND:\n        case Token.EQ:\n        case Token.NE:\n        case Token.LT:\n        case Token.LTE:\n        case Token.GT:\n        case Token.GTE:\n        case Token.INSTANCEOF:\n        case Token.IN:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.SHLT:\n        case Token.SHGT:\n            cost += COMMA_COST;\n            break;\n        case Token.IDENT:\n            cost += NAME_COST_ESTIMATE;\n            break;\n        default:\n            break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n        case Token.NOT:\n            cost += n.getFirstChild().getLength();\n            break;\n        case Token.PAREN:\n            cost += PAREN_COST;\n            break;\n        default:\n            break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n        case Token.NOT:\n            cost += n.getFirstChild().getLength();\n            break;\n        case Token.PAREN:\n            cost += n.getFirstChild().getLength();\n            break;\n        default:\n            break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n        case Token.NOT:\n            // NOT node itself\n            cost += 2;\n            // Plus the cost of the child node\n            cost += estimateCostOneLevel(n.getFirstChild());\n            break;\n        case Token.PAREN:\n            // Parentheses around an expression\n            cost += 2;\n            break;\n        default:\n            // Identifier or other node\n            cost += n.getLength();\n            break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n        case Token.NOT:\n            cost += PAREN_COST;\n            Node child = n.getFirstChild();\n            if (child != null) {\n                cost += estimateCostOneLevel(child);\n            }\n            break;\n        case Token.OR:\n        case Token.AND:\n        case Token.OROR:\n        case Token.ANDAND:\n            cost += PAREN_COST;\n            Node left = n.getFirstChild();\n            Node right = n.getNext();\n            if (left != null) {\n                cost += estimateCostOneLevel(left);\n            }\n            if (right != null) {\n                cost += estimateCostOneLevel(right);\n            }\n            break;\n        default:\n            break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n        case Token.NOT:\n            cost += n.getFirstChild().getLength();\n            break;\n        case Token.PAREN:\n            cost += PAREN_COST;\n            break;\n        default:\n            break;\n    }\n    return cost;\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    for(int i = 0; i < size / 2; i++)\n    {\n        char temp = buffer[i];\n        buffer[i] = buffer[size - i - 1];\n        buffer[size - i - 1] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size > 0) {\n        final int len = size;\n        final char[] buf = buffer;\n        for (int i = 0; i < len / 2; i++) {\n            final char tmp = buf[i];\n            buf[i] = buf[len - i - 1];\n            buf[len - i - 1] = tmp;\n        }\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size > 0) {\n        final int len = size;\n        final char[] buf = buffer;\n        for (int i = 0; i < len / 2; i++) {\n            final char tmp = buf[i];\n            buf[i] = buf[len - i - 1];\n            buf[len - i - 1] = tmp;\n        }\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    for (int i = 0; i < size / 2; i++) {\n        char temp = buffer[i];\n        buffer[i] = buffer[size - i - 1];\n        buffer[size - i - 1] = temp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size > 0) \n    {\n        for (int i = 0; i < size / 2; i++) \n        {\n            char temp = buffer[i];\n            buffer[i] = buffer[size - i - 1];\n            buffer[size - i - 1] = temp;\n        }\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size > 0) \n    {\n        final int len = size;\n        final char[] buf = buffer;\n        for (int i = 0; i < len / 2; i++) \n        {\n            final char tmp = buf[i];\n            buf[i] = buf[len - i - 1];\n            buf[len - i - 1] = tmp;\n        }\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    while (left < right) {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    for (int left = 0, right = size - 1; left < right; left++, right--) {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n    }\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n    String text = coreValue();\n    String left = text.substring(0, offset);\n    String right = text.substring(offset);\n    coreValue(left);\n    TextNode newNode = new TextNode(right);\n    addSibling(newNode);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = coreValue();\n    if (offset < text.length()) {\n        String after = text.substring(offset);\n        coreValue(text.substring(0, offset));\n        TextNode newNode = new TextNode(after);\n        addSibling(newNode);\n        return newNode;\n    }\n    return this;\n}",
      "public TextNode splitText(int offset)  {\n    String text = coreValue();\n    String left = text.substring(0, offset);\n    String right = text.substring(offset);\n    TextNode newNode = new TextNode(right);\n    coreValue(left);\n    addSibling(newNode);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = coreValue();\n    String left = text.substring(0, offset);\n    String right = text.substring(offset);\n    coreValue(left);\n    TextNode newNode = new TextNode(right);\n    addSibling(newNode);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = coreValue();\n    String firstPart = text.substring(0, offset);\n    String secondPart = text.substring(offset);\n    TextNode newNode = new TextNode(secondPart);\n    coreValue(firstPart);\n    addSibling(newNode);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n        String text = coreValue();\n        if (offset >= text.length()) {\n            throw new IllegalArgumentException(\"Offset is greater than text length\");\n        }\n        String textAfter = text.substring(offset);\n        coreValue(text.substring(0, offset));\n        TextNode newNode = new TextNode(textAfter);\n        addSibling(newNode);\n        return newNode;\n    }",
      "public TextNode splitText(int offset)  {\n    String text = coreValue();\n    String firstPart = text.substring(0, offset);\n    String secondPart = text.substring(offset);\n\n    TextNode newNode = new TextNode(secondPart);\n\n    coreValue(firstPart);\n    siblingIndex(newNode, siblingIndex() + 1);\n\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = coreValue();\n    if (offset < text.length()) {\n        String after = text.substring(offset);\n        coreValue(text.substring(0, offset));\n        TextNode newNode = new TextNode(after);\n        addSibling(newNode);\n        return newNode;\n    }\n    return this;\n}",
      "public TextNode splitText(int offset)  {\n    String text = coreValue();\n    String left = text.substring(0, offset);\n    String right = text.substring(offset);\n    TextNode newNode = new TextNode(right);\n    coreValue(left);\n    addSibling(newNode);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = coreValue();\n    if (offset >= text.length()) {\n        return new TextNode(\"\");\n    }\n    String text1 = text.substring(0, offset);\n    String text2 = text.substring(offset);\n    coreValue(text1);\n    TextNode newNode = new TextNode(text2);\n    addSibling(newNode);\n    return newNode;\n}"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> intersection = intersection(a, b);\n    Collection<O> union = union(a, b);\n    \n    // Subtract the intersection from the union\n    subtract(union, intersection);\n    \n    return union;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> intersection = intersection(a, b);\n    Collection<O> union = union(a, b);\n    Collection<O> result = subtract(union, intersection);\n    return result;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> intersection = intersection(a, b);\n    Collection<O> union = union(a, b);\n    \n    // Subtract the intersection from the union\n    subtract(union, intersection);\n    \n    return union;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> intersection = intersection(a, b);\n    Collection<O> union = union(a, b);\n    Collection<O> result = subtract(union, intersection);\n    return result;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> intersection = intersection(a, b);\n    Collection<O> union = union(a, b);\n    \n    // subtract intersection from union\n    for (O obj : intersection) \n    {\n        int freqA = ((CardinalityHelper<O>)helper).freqA(obj);\n        int freqB = ((CardinalityHelper<O>)helper).freqB(obj);\n        int minFreq = Math.min(freqA, freqB);\n        int maxFreq = Math.max(freqA, freqB);\n        int diff = maxFreq - minFreq;\n        ((SetOperationCardinalityHelper<O>)helper).setCardinality(obj, diff);\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> intersection = intersection(a, b);\n    Collection<O> union = union(a, b);\n    Collection<O> result = new ArrayList<O>();\n    for (O obj : union) \n    {\n        int countA = cardinality(obj, a);\n        int countB = cardinality(obj, b);\n        int min = Math.min(countA, countB);\n        int max = Math.max(countA, countB);\n        int disjunction = max - min;\n        for (int i = 0; i < disjunction; i++) \n        {\n            result.add(obj);\n        }\n    }\n    return result;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> intersection = intersection(a, b);\n    Collection<O> union = union(a, b);\n    Collection<O> result = subtract(union, intersection);\n    return result;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> intersection = intersection(a, b);\n    Collection<O> union = union(a, b);\n    \n    for(O obj : intersection)\n    {\n        int freqA = CollectionUtils.cardinality(obj, a);\n        int freqB = CollectionUtils.cardinality(obj, b);\n        int minFreq = Math.min(freqA, freqB);\n        for(int i = 0; i < minFreq; i++)\n        {\n            union.remove(obj);\n        }\n    }\n    \n    return union;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> intersection = intersection(a, b);\n    Collection<O> union = union(a, b);\n    Collection<O> result = subtract(union, intersection);\n    return result;\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Collection<O> intersection = intersection(a, b);\n    Collection<O> union = union(a, b);\n    Collection<O> result = new ArrayList<O>();\n    for (O obj : union) \n    {\n        int freqA = ((CardinalityHelper<O>) new CardinalityHelper<O>(a, b)).freqA(obj);\n        int freqB = ((CardinalityHelper<O>) new CardinalityHelper<O>(a, b)).freqB(obj);\n        if (freqA + freqB - intersection.size() > 0) \n        {\n            result.add(obj);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n        byte[] result = new byte[8];\n        BigInteger v = value;\n        for (int i = 7; i >= 0; i--) {\n            BigInteger b = BigInteger.ONE.shiftLeft(i * 8);\n            if (v.compareTo(b) >= 0) {\n                int byteValue = v.divide(b).intValue();\n                result[7 - i] = (byte) byteValue;\n                v = v.subtract(BigInteger.valueOf(byteValue).multiply(b));\n            }\n        }\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    BigInteger left = value;\n    for (int i = 7; i >= 0; i--) \n    {\n        BigInteger mask = BigInteger.ONE.shiftLeft(i * 8);\n        BigInteger shifted = left.and(mask);\n        result[7 - i] = shifted.divide(mask).byteValue();\n        left = left.and(mask.negate());\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    byte[] temp = value.toByteArray();\n    int length = temp.length;\n    if (length > 8) \n    {\n        throw new IllegalArgumentException(\"BigInteger too large for ZipEightByteInteger\");\n    } \n    else if (length < 8) \n    {\n        System.arraycopy(temp, 0, result, 8 - length, length);\n    } \n    else \n    {\n        System.arraycopy(temp, 0, result, 0, 8);\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        byte[] bytes = value.toByteArray();\n        if (bytes.length > 8) {\n            throw new IllegalArgumentException(\"value out of range: \" + value);\n        }\n        byte[] result = new byte[8];\n        System.arraycopy(bytes, 0, result, 8 - bytes.length, bytes.length);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n        byte[] result = new byte[8];\n        BigInteger[] divmod = value.divideAndRemainder(BigInteger.valueOf(256));\n        result[7] = divmod[1].byteValue();\n        for (int i = 6; i >= 0; i--) {\n            divmod = divmod[0].divideAndRemainder(BigInteger.valueOf(256));\n            result[i] = divmod[1].byteValue();\n        }\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    BigInteger bigEndian = value.xor(BigInteger.valueOf(Long.MIN_VALUE));\n    byte[] eightBytes = bigEndian.toByteArray();\n    System.arraycopy(eightBytes, 0, result, 8 - eightBytes.length, eightBytes.length);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        byte[] bytes = value.toByteArray();\n        if (bytes.length > 8) {\n            throw new IllegalArgumentException(\"Value out of range: \" + value);\n        }\n        byte[] result = new byte[8];\n        System.arraycopy(bytes, 0, result, 8 - bytes.length, bytes.length);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    BigInteger left = value;\n    for (int i = 0; i < 8; i++) {\n        BigInteger mask = BigInteger.ONE.shiftLeft((7 - i) * 8);\n        BigInteger shifted = left.and(mask);\n        result[i] = shifted.divide(mask).byteValue();\n        left = left.and(mask.negate());\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] result = new byte[8];\n    BigInteger[] divmod = value.divideAndRemainder(BigInteger.valueOf(256));\n    result[7] = divmod[1].byteValue();\n    for (int i = 6; i >= 0; i--) {\n        divmod = divmod[0].divideAndRemainder(BigInteger.valueOf(256));\n        result[i] = divmod[1].byteValue();\n    }\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    putLong(value, result, 0);\n    return result;\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return str;\n    }\n    return modify(str, set, true);\n}"
    ],
    [
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric.\");\n    }\n\n    // Compute the eigenvalues and eigenvectors of the matrix\n    EigenDecomposition eig = new EigenDecomposition(this.transformer.getT());\n\n    // Get the real part of the eigenvalues\n    double[] eigenvalues = eig.getRealEigenvalues();\n\n    // Check if all eigenvalues are positive\n    for (int i = 0; i < eigenvalues.length; i++) {\n        if (eigenvalues[i] < 0) {\n            throw new MathUnsupportedOperationException(\"Matrix is not positive definite.\");\n        }\n    }\n\n    // Compute the square root of the eigenvalues\n    for (int i = 0; i < eigenvalues.length; i++) {\n        eigenvalues[i] = Math.sqrt(eigenvalues[i]);\n    }\n\n    // Compute the square root of the matrix\n    RealMatrix sqrtMatrix = eig.getV().scalarMultiply(eigenvalues[0]).multiply(eig.getV().transpose());\n\n    return sqrtMatrix;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric) {\n        throw new MathUnsupportedOperationException();\n    }\n    if (cachedV == null) {\n        cachedV = getV();\n    }\n    if (cachedD == null) {\n        cachedD = getD();\n    }\n    if (cachedVt == null) {\n        cachedVt = getVT();\n    }\n    RealMatrix sqrtD = new DiagonalMatrix(cachedD.getRowDimension(), cachedD.getColumnDimension());\n    for (int i = 0; i < cachedD.getRowDimension(); i++) {\n        double value = cachedD.getEntry(i, i);\n        if (value < 0) {\n            throw new MathUnsupportedOperationException(\"Matrix is not positive definite\");\n        }\n        sqrtD.setEntry(i, i, Math.sqrt(value));\n    }\n    return cachedV.multiply(sqrtD).multiply(cachedVt);\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric\");\n    }\n    if (cachedV == null) {\n        cachedV = transformer.getQ();\n    }\n    if (cachedD == null) {\n        cachedD = new Array2DRowRealMatrix(main.length, main.length);\n        for (int i = 0; i < main.length; i++) {\n            cachedD.setEntry(i, i, Math.sqrt(main[i]));\n        }\n    }\n    if (cachedVt == null) {\n        cachedVt = cachedV.transpose();\n    }\n    return new ProductMatrix(cachedD, cachedVt);\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric.\");\n    }\n    if (hasComplexEigenvalues()) {\n        throw new MathUnsupportedOperationException(\"Matrix has complex eigenvalues.\");\n    }\n\n    final int order = main.length;\n    final double[][] sqrtData = new double[order][order];\n\n    for (int i = 0; i < order; ++i) {\n        final double sqrtEigenvalue = Math.sqrt(realEigenvalues[i]);\n        for (int j = 0; j <= i; ++j) {\n            final double sqrtEigenvector = Math.sqrt(eigenvectors[j].getEntry(i));\n            sqrtData[i][j] = sqrtEigenvalue * sqrtEigenvector;\n            sqrtData[j][i] = sqrtData[i][j];\n        }\n    }\n\n    return new Array2DRowRealMatrix(sqrtData, false);\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric\");\n    }\n    if (cachedV == null) {\n        transformToTridiagonal(matrix);\n        double[] main = transformer.getMainDiagonalRef();\n        double[] secondary = transformer.getSecondaryDiagonalRef();\n        double[][] householderMatrix = transformer.getHouseholderVectorsRef();\n        double[][] sqrtMatrix = new double[order][order];\n        for (int i = 0; i < order; i++) {\n            for (int j = 0; j < order; j++) {\n                sqrtMatrix[i][j] = (i == j) ? Math.sqrt(main[i]) : 0;\n            }\n        }\n        for (int i = order - 2; i >= 0; i--) {\n            for (int j = 0; j < order; j++) {\n                double sum = 0;\n                for (int k = i + 1; k < order; k++) {\n                    sum += sqrtMatrix[i][k] * sqrtMatrix[k][j];\n                }\n                sqrtMatrix[i][j] = (j > i) ? (sqrtMatrix[j][i] - sum) / sqrtMatrix[i][i] : -sum / sqrtMatrix[i][i];\n            }\n        }\n        cachedV = MatrixUtils.createRealMatrix(sqrtMatrix);\n    }\n    return cachedV;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric\");\n    }\n\n    if (cachedV == null) {\n        cachedV = transformer.getQ();\n    }\n    if (cachedD == null) {\n        cachedD = RealMatrixImpl.ZEROES.copyStructure();\n        double[] main = transformer.getMainDiagonalRef();\n        double[] secondary = transformer.getSecondaryDiagonalRef();\n        for (int i = 0; i < main.length; i++) {\n            double sqrt = StrictMath.sqrt(main[i]);\n            if (i < secondary.length) {\n                sqrt = StrictMath.hypot(sqrt, secondary[i]);\n            }\n            cachedD.setEntry(i, i, sqrt);\n        }\n    }\n    if (cachedVt == null) {\n        cachedVt = cachedV.transpose();\n    }\n    return cachedV.multiply(cachedD).multiply(cachedVt);\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric\");\n    }\n    if (cachedV == null) {\n        cachedV = transformer.getQ();\n    }\n    if (cachedD == null) {\n        cachedD = new Array2DRowRealMatrix(main.length, main.length);\n        for (int i = 0; i < main.length; i++) {\n            cachedD.setEntry(i, i, Math.sqrt(main[i]));\n        }\n    }\n    if (cachedVt == null) {\n        cachedVt = cachedV.transpose();\n    }\n    return cachedD.multiply(cachedVt);\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric) {\n        throw new MathUnsupportedOperationException();\n    }\n    if (cachedV == null) {\n        cachedV = new Array2DRowRealMatrix(transformer.getQ());\n    }\n    return cachedV;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric\");\n    }\n    if (hasComplexEigenvalues()) {\n        throw new MathUnsupportedOperationException(\"Matrix has complex eigenvalues\");\n    }\n    final int order = main.length;\n    final double[][] sqrtData = new double[order][order];\n    for (int i = 0; i < order; i++) {\n        final double sqrtMain = Math.sqrt(main[i]);\n        sqrtData[i][i] = sqrtMain;\n        for (int j = 0; j < i; j++) {\n            final double sqrtSecondary = Math.sqrt(secondary[j]);\n            sqrtData[i][j] = sqrtMain * sqrtSecondary;\n            sqrtData[j][i] = sqrtMain * sqrtSecondary;\n        }\n    }\n    return new Array2DRowRealMatrix(sqrtData, false);\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isSymmetric) {\n        throw new MathUnsupportedOperationException(\"Matrix is not symmetric\");\n    }\n    if (hasComplexEigenvalues()) {\n        throw new MathUnsupportedOperationException(\"Matrix has complex eigenvalues\");\n    }\n\n    final int order = main.length;\n    final double[][] sqrtData = new double[order][order];\n\n    for (int i = 0; i < order; ++i) {\n        final double sqrtMain = Math.sqrt(main[i]);\n        sqrtData[i][i] = sqrtMain;\n        for (int j = 0; j < i; ++j) {\n            sqrtData[i][j] = secondary[i] / (sqrtMain * main[j]);\n            sqrtData[j][i] = sqrtData[i][j];\n        }\n    }\n\n    return new Array2DRowRealMatrix(sqrtData, false);\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tswitch (t) {\n    \t\tcase START_OBJECT:\n    \t\t\treturn _deserializeFromObject(p, ctxt);\n    \t\tcase START_ARRAY:\n    \t\t\treturn _deserializeFromArray(p, ctxt);\n    \t\tcase VALUE_STRING:\n    \t\t\treturn p.getText();\n    \t\tcase VALUE_NUMBER_INT:\n    \t\t\treturn p.getIntValue();\n    \t\tcase VALUE_NUMBER_FLOAT:\n    \t\t\treturn p.getFloatValue();\n    \t\tcase VALUE_TRUE:\n    \t\t\treturn Boolean.TRUE;\n    \t\tcase VALUE_FALSE:\n    \t\t\treturn Boolean.FALSE;\n    \t\tcase VALUE_NULL:\n    \t\t\treturn _deserializeFromNull(p, ctxt);\n    \t\tdefault:\n    \t\t\treturn ctxt.handleUnexpectedToken(Object.class, p);\n    \t\t}\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tObject bean = _creator.createUsingDefault();\n    \t\tdo {\n    \t\t\tString propName = p.getCurrentName();\n    \t\t\tSettableBeanProperty prop = _propertyMap.find(propName);\n    \t\t\tif (prop != null) {\n    \t\t\t\ttry {\n    \t\t\t\t\tprop.deserializeAndSet(p, ctxt, bean);\n    \t\t\t\t} catch (Exception e) {\n    \t\t\t\t\twrapAndThrow(e, bean, propName, ctxt);\n    \t\t\t\t}\n    \t\t\t\tcontinue;\n    \t\t\t}\n    \t\t\thandleUnknownVanilla(p, ctxt, bean, propName);\n    \t\t} while ((propName = p.nextFieldName()) != null);\n    \t\treturn bean;\n    \t}\n    \t\n    \tprotected Object deserializeFromObject(JsonParser p,\n    \t\tDeserializationContext ctxt)\n        throws IOException\n    \t{\n    \t\treturn vanillaDeserialize(p, ctxt, p.getCurrentToken());\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n         // 21-Apr-2017, tatu: Need separate methods to do proper merging\n         if (_standardStringKey) {\n             _readAndUpdateStringKeyMap(p, ctxt, result);\n             return result;\n         }\n         _readAndUpdate(p, ctxt, result);\n         return result;\n     }\n\n    /*\n    /**********************************************************\n    /* Shared helper methods\n    /**********************************************************",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tswitch (t) {\n    \t\tcase START_OBJECT:\n    \t\t\treturn _deserializeFromObject(p, ctxt);\n    \t\tcase START_ARRAY:\n    \t\t\treturn _deserializeFromArray(p, ctxt);\n    \t\tcase VALUE_STRING:\n    \t\t\treturn p.getText();\n    \t\tcase VALUE_NUMBER_INT:\n    \t\t\treturn p.getIntValue();\n    \t\tcase VALUE_NUMBER_FLOAT:\n    \t\t\treturn p.getFloatValue();\n    \t\tcase VALUE_TRUE:\n    \t\t\treturn Boolean.TRUE;\n    \t\tcase VALUE_FALSE:\n    \t\t\treturn Boolean.FALSE;\n    \t\tcase VALUE_NULL:\n    \t\t\treturn _deserializeFromNull(p, ctxt);\n    \t\tdefault:\n    \t\t\treturn _handleUnexpectedToken(p, ctxt, t);\n    \t\t}\n    \t}\n    /*\n    /**********************************************************\n    /* Shared helper methods\n    /**********************************************************",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.START_OBJECT) {\n            return deserializeFromObject(p, ctxt);\n        }\n        if (t == JsonToken.START_ARRAY) {\n            return deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_STRING) {\n            return p.getText();\n        }\n        if (t == JsonToken.VALUE_NUMBER_INT) {\n            return p.getIntValue();\n        }\n        if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n            return p.getFloatValue();\n        }\n        if (t == JsonToken.VALUE_TRUE) {\n            return Boolean.TRUE;\n        }\n        if (t == JsonToken.VALUE_FALSE) {\n            return Boolean.FALSE;\n        }\n        if (t == JsonToken.VALUE_NULL) {\n            return deserializeFromNull(p, ctxt);\n        }\n        return _missingToken(p, ctxt);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // 16-Feb-2017, tatu: This method is called by various other methods,\n        // and it's not always called with a valid parser, so we need to handle\n        // nulls gracefully.\n        if (p == null) {\n            return null;\n        }\n\n        // 17-Feb-2017, tatu: This is a bit of a kludge, but we need to\n        // handle a case where we have a missing property, and we're trying\n        // to deserialize it as a bean.\n        if (t == JsonToken.END_OBJECT) {\n            return null;\n        }\n\n        // 16-Feb-2017, tatu: Need to handle missing fields\n        // and unknown fields, but that's a bit more complex\n        // and needs to be handled in a more general way\n        // 17-Feb-2017, tatu: Also, we need to handle arrays and collections\n        // 18-Feb-2017, tatu: And we need to handle unwrapped values\n        // 21-Feb-2017, tatu: And we need to handle views\n        // 22-Feb-2017, tatu: And we need to handle external type ids\n        // 24-Feb-2017, tatu: And we need to handle unwrapped values\n        // 26-Feb-2017, tatu: And we need to handle unwrapped values\n        // 28-Feb-2017, tatu: And we need to handle unwrapped values\n        // 01-Mar-2017, tatu: And we need to handle unwrapped values\n        // 02-Mar-2017, tatu: And we need to handle unwrapped values\n        // 04-Mar-2017, tatu: And we need to handle unwrapped values\n        // 05-Mar-2017, tatu: And we need to handle unwrapped values\n}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n         // [databind#631]: Assign current value, to be accessible by custom deserializers\n         p.setCurrentValue(result);\n         \n         // Ok: must point to START_OBJECT or FIELD_NAME\n         JsonToken t = p.getCurrentToken();\n         if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n             return (Map<Object,Object>) ctxt.handleUnexpectedToken(getMapClass(), p);\n         }\n         // 21-Apr-2017, tatu: Need separate methods to do proper merging\n         if (_standardStringKey) {\n             _readAndUpdateStringKeyMap(p, ctxt, result);\n             return result;\n         }\n         _readAndUpdate(p, ctxt, result);\n         return result;\n     }\n\n     /*\n     /**********************************************************",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tswitch (t) {\n    \t\tcase START_OBJECT:\n    \t\t\treturn _deserializeFromObject(p, ctxt);\n    \t\tcase START_ARRAY:\n    \t\t\treturn _deserializeFromArray(p, ctxt);\n    \t\tcase VALUE_STRING:\n    \t\t\treturn p.getText();\n    \t\tcase VALUE_NUMBER_INT:\n    \t\t\treturn p.getIntValue();\n    \t\tcase VALUE_NUMBER_FLOAT:\n    \t\t\treturn p.getFloatValue();\n    \t\tcase VALUE_TRUE:\n    \t\t\treturn Boolean.TRUE;\n    \t\tcase VALUE_FALSE:\n    \t\t\treturn Boolean.FALSE;\n    \t\tcase VALUE_NULL:\n    \t\t\treturn _deserializeFromNull(p, ctxt);\n    \t\tdefault:\n    \t\t\treturn ctxt.handleUnexpectedToken(Object.class, p);\n    \t\t}\n    \t}",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n         if (t == JsonToken.START_OBJECT) {\n             return deserializeFromObject(p, ctxt);\n         }\n         if (t == JsonToken.VALUE_STRING) {\n             return p.getText();\n         }\n         if (t == JsonToken.VALUE_NUMBER_INT) {\n             return p.getIntValue();\n         }\n         if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n             return p.getFloatValue();\n         }\n         if (t == JsonToken.VALUE_TRUE) {\n             return Boolean.TRUE;\n         }\n         if (t == JsonToken.VALUE_FALSE) {\n             return Boolean.FALSE;\n         }\n         if (t == JsonToken.VALUE_NULL) {\n             return deserializeFromNull(p, ctxt);\n         }\n         return _missingToken(p, ctxt);\n     }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \t\tswitch (t) {\n    \t\tcase START_OBJECT:\n    \t\t\treturn _deserializeFromObject(p, ctxt);\n    \t\tcase START_ARRAY:\n    \t\t\treturn _deserializeFromArray(p, ctxt);\n    \t\tcase VALUE_STRING:\n    \t\t\treturn p.getText();\n    \t\tcase VALUE_NUMBER_INT:\n    \t\t\treturn p.getIntValue();\n    \t\tcase VALUE_NUMBER_FLOAT:\n    \t\t\treturn p.getFloatValue();\n    \t\tcase VALUE_TRUE:\n    \t\t\treturn Boolean.TRUE;\n    \t\tcase VALUE_FALSE:\n    \t\t\treturn Boolean.FALSE;\n    \t\tcase VALUE_NULL:\n    \t\t\treturn _deserializeFromNull(p, ctxt);\n    \t\tdefault:\n    \t\t\treturn _handleUnexpectedToken(p, ctxt, t);\n    \t\t}\n    \t}\n\n    /*\n    /**********************************************************\n    /* Concrete deserialization methods\n    /**********************************************************"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0d;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0d;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0d;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0 || sample2.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0d;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n        if (sample1.length != sample2.length) {\n            throw new DimensionMismatchException(sample1.length, sample2.length);\n        }\n        if (sample1.length == 0 || sample2.length == 0) {\n            throw new NoDataException();\n        }\n        double sum = 0d;\n        for (int i = 0; i < sample1.length; i++) {\n            sum += sample1[i] - sample2[i];\n        }\n        return sum;\n    }"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_head == null) {\n             _head = new LinkedNode<>(fullChunk);\n             _tail = _head;\n         } else {\n             LinkedNode<Object[]> newTail = new LinkedNode<>(fullChunk);\n             _tail.next = newTail;\n             _tail = newTail;\n         }\n         _size += fullChunk.length;\n         return _freeBuffer = new Object[SMALL_CHUNK];\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_head == null) {\n             _head = new LinkedNode<>(fullChunk);\n             _tail = _head;\n         } else {\n             LinkedNode<Object[]> newTail = new LinkedNode<>(fullChunk);\n             _tail.setNext(newTail);\n             _tail = newTail;\n         }\n         _size += fullChunk.length;\n         return fullChunk;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int chunkSize = fullChunk.length;\n        if ((_freeBuffer == null) || (_freeBuffer.length < chunkSize)) {\n            _freeBuffer = new Object[Math.max(12, chunkSize)];\n        }\n        System.arraycopy(fullChunk, 0, _freeBuffer, 0, chunkSize);\n        return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_head == null) {\n             _head = new LinkedNode<>(fullChunk);\n             _tail = _head;\n         } else {\n             _tail.next = new LinkedNode<>(fullChunk);\n             _tail = _tail.next;\n         }\n         _size += fullChunk.length;\n         return _freeBuffer = new Object[SMALL_CHUNK];\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int chunkSize = fullChunk.length;\n        if ((_freeBuffer == null) || (_freeBuffer.length < chunkSize)) {\n            _freeBuffer = new Object[Math.max(12, chunkSize)];\n        }\n        System.arraycopy(fullChunk, 0, _freeBuffer, 0, chunkSize);\n        return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         int chunkSize = fullChunk.length;\n         if ((_freeBuffer == null) || (_freeBuffer.length < chunkSize)) {\n             _freeBuffer = new Object[Math.max(12, chunkSize)];\n         }\n         System.arraycopy(fullChunk, 0, _freeBuffer, 0, chunkSize);\n         return _freeBuffer;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         // Check if the fullChunk is not null\n         if(fullChunk != null)\n         {\n             // Check if the _head is null\n             if(_head == null)\n             {\n                 // Set the _head and _tail to the fullChunk\n                 _head = new LinkedNode<>(fullChunk);\n                 _tail = _head;\n             }\n             else\n             {\n                 // Create a new LinkedNode with the fullChunk\n                 LinkedNode<Object[]> newNode = new LinkedNode<>(fullChunk);\n                 // Set the next node of the current _tail to the new node\n                 _tail.setNext(newNode);\n                 // Set the _tail to the new node\n                 _tail = newNode;\n             }\n             // Increment the size\n             _size += fullChunk.length;\n         }\n         // Return the fullChunk\n         return fullChunk;\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (_head == null) {\n            _head = new LinkedNode<>(fullChunk);\n            _tail = _head;\n        } else {\n            LinkedNode<Object[]> newTail = new LinkedNode<>(fullChunk);\n            _tail.next = newTail;\n            _tail = newTail;\n        }\n        _size += fullChunk.length;\n        return _freeBuffer = new Object[SMALL_CHUNK];\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_head == null) {\n             _head = new LinkedNode<>(fullChunk);\n             _tail = _head;\n         } else {\n             _tail.setNext(new LinkedNode<>(fullChunk));\n             _tail = _tail.getNext();\n         }\n         _size += fullChunk.length;\n         return new Object[SMALL_CHUNK];\n     }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_head == null) {\n             _head = new LinkedNode<>(fullChunk);\n             _tail = _head;\n         } else {\n             LinkedNode<Object[]> newTail = new LinkedNode<>(fullChunk);\n             _tail.setNext(newTail);\n             _tail = newTail;\n         }\n         _size += fullChunk.length;\n         return _freeBuffer = new Object[SMALL_CHUNK];\n     }"
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    if (pattern == null) {\n        throw new IllegalArgumentException(\"Pattern cannot be null\");\n    }\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    if (pattern == null) {\n        throw new IllegalArgumentException(\"Pattern cannot be null\");\n    }\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        appendPatternTo(builder, pattern);\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        appendPatternTo(builder, pattern);\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        appendPatternTo(builder, pattern);\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        appendPatternTo(builder, pattern);\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  throws IllegalArgumentException {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        appendPatternTo(builder, pattern);\n        return builder.toFormatter();\n    }"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) {\n      case ASTERISK:\n        return newNode(Token.ASTERISK);\n      case NULL:\n        return newNode(Token.NULL);\n      case UNDEFINED:\n        return newNode(Token.UNDEFINED);\n      case STRING:\n        return parseTypeName(token);\n      case LC:\n        return parseFunctionType(token);\n      case LB:\n        return parseArrayType(token);\n      case QMARK:\n        return newNode(Token.QMARK);\n      default:\n        return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) {\n      case ASTERISK:\n        return newNode(Token.ASTERISK);\n      case NULL:\n        return newNode(Token.NULL);\n      case UNDEFINED:\n        return newNode(Token.UNDEFINED);\n      case STRING:\n        return parseTypeName(token);\n      case LC:\n        return parseFunctionType(token);\n      case LB:\n        return parseArrayType(token);\n      case QMARK:\n        return newNode(Token.QMARK);\n      default:\n        return null;\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) {\n      case ASTERISK:\n        return newNode(Token.ASTERISK);\n      case NULL:\n        return newNode(Token.NULL);\n      case UNDEFINED:\n        return newNode(Token.UNDEFINED);\n      case STRING:\n        return parseTypeName(token);\n      case LC:\n        return parseFunctionType(token);\n      case LB:\n        return parseArrayType(token);\n      case QMARK:\n        return newNode(Token.QMARK);\n      default:\n        return null;\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) {\n      case ASTERISK:\n        return newNode(Token.ASTERISK);\n      case NULL:\n        return newNode(Token.NULL);\n      case UNDEFINED:\n        return newNode(Token.UNDEFINED);\n      case STRING:\n        return parseTypeName(token);\n      case LC:\n        return parseFunctionType(token);\n      case LB:\n        return parseArrayType(token);\n      case QMARK:\n        return newNode(Token.QMARK);\n      default:\n        return null;\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) {\n      case ASTERISK:\n        return newNode(Token.ASTERISK);\n      case NULL:\n        return newNode(Token.NULL);\n      case UNDEFINED:\n        return newNode(Token.UNDEFINED);\n      case STRING:\n        return parseTypeName(token);\n      case LC:\n        return parseFunctionType(token);\n      case LB:\n        return parseArrayType(token);\n      case QMARK:\n        return newNode(Token.QMARK);\n      default:\n        return null;\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) {\n      case ASTERISK:\n        return newNode(Token.ASTERISK);\n      case NULL:\n        return newNode(Token.NULL);\n      case UNDEFINED:\n        return newNode(Token.UNDEFINED);\n      case STRING:\n        return parseTypeName(token);\n      case LC:\n        return parseFunctionType(token);\n      case LB:\n        return parseArrayType(token);\n      case QMARK:\n        return newNode(Token.QMARK);\n      default:\n        return null;\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) {\n      case ASTERISK:\n        return newNode(Token.ASTERISK);\n      case NULL:\n        return newNode(Token.NULL);\n      case UNDEFINED:\n        return newNode(Token.UNDEFINED);\n      case STRING:\n        return parseTypeName(token);\n      case LC:\n        return parseFunctionType(token);\n      case LB:\n        return parseArrayType(token);\n      case QMARK:\n      case BANG:\n        return parseContextTypeExpression(token);\n      default:\n        return null;\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) \n    {\n        case ASTERISK:\n            return newNode(Token.ASTERISK);\n        case NULL:\n            return newNode(Token.NULL);\n        case UNDEFINED:\n            return newNode(Token.UNDEFINED);\n        case STRING:\n            return parseTypeName(token);\n        case LB:\n            return parseArrayType(token);\n        case LT:\n            return parseFunctionType(token);\n        case PIPE:\n            return parseUnionType(token);\n        case LC:\n            return parseRecordType(token);\n        default:\n            return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) {\n      case ASTERISK:\n        return newNode(Token.ASTERISK);\n      case NULL:\n        return newNode(Token.NULL);\n      case UNDEFINED:\n        return newNode(Token.UNDEFINED);\n      case STRING:\n        return parseTypeName(token);\n      case LB:\n        return parseArrayType(token);\n      case LT:\n        return parseFunctionType(token);\n      case PIPE:\n        return parseUnionType(token);\n      case LC:\n        return parseRecordType(token);\n      default:\n        return null;\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    switch (token) {\n      case ASTERISK:\n        return newNode(Token.ASTERISK);\n      case NULL:\n        return newNode(Token.NULL);\n      case UNDEFINED:\n        return newNode(Token.UNDEFINED);\n      case STRING:\n        return parseTypeName(token);\n      case LB:\n        return parseArrayType(token);\n      case LT:\n        return parseFunctionType(token);\n      case PIPE:\n        return parseUnionType(token);\n      case LC:\n        return parseRecordType(token);\n      default:\n        return null;\n    }\n}"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"Name may not be null.\");\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new IllegalArgumentException(\"Name must not be null\");\n    }\n    writeDeferredName();\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    if (name == null) {\n      throw new NullPointerException(\"Name may not be null.\");\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (deferredName != null) {\n      throw new IllegalStateException(\"Dangling name: \" + deferredName);\n    }\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new IllegalArgumentException(\"Name must not be null.\");\n    }\n    writeDeferredName();\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new IllegalArgumentException(\"Name must not be null\");\n    }\n    writeDeferredName();\n    deferredName = name;\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n      throw new NullPointerException(\"Name may not be null.\");\n    }\n    writeDeferredName();\n    deferredName = name;\n    return this;\n  }"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.MAX_VALUE;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element == null) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n        if (element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element == null) \n        {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n        if (element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element == null) \n        {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n        if (element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element != null && element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element == null) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n        if (element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element == null) \n        {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n        if (element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element == null) \n        {\n            throw new IllegalArgumentException(\"Array contains null\");\n        }\n        if (element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element == null) \n        {\n            throw new IllegalArgumentException(\"Array contains null\");\n        }\n        if (element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element == null) \n        {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n        if (element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    // Validates input\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element == null) {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n        if (element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (str.length() == 0) \n    {\n        return \"\";\n    }\n    StringBuilder sb = new StringBuilder();\n    char[] chars = str.toCharArray();\n    boolean isDelimiter = true;\n    for (char c : chars) \n    {\n        if (isDelimiter && !Character.isWhitespace(c)) \n        {\n            sb.append(c);\n            isDelimiter = false;\n        } \n        else if (delimiters != null && Arrays.binarySearch(delimiters, c) >= 0) \n        {\n            isDelimiter = true;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n\n    final StringBuilder sb = new StringBuilder();\n    final char[] chars = str.toCharArray();\n    boolean isDelimiter = true;\n    for (final char ch : chars) \n    {\n        if (isDelimiter && !Character.isWhitespace(ch)) \n        {\n            sb.append(Character.toUpperCase(ch));\n            isDelimiter = false;\n        } \n        else if (isDelimiters(ch, delimiters)) \n        {\n            isDelimiter = true;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) \n    {\n        return str;\n    }\n\n    final StringBuilder sb = new StringBuilder();\n    boolean nextUpper = true;\n    for (int i = 0; i < str.length(); i++) \n    {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) \n        {\n            nextUpper = true;\n        } \n        else if (nextUpper) \n        {\n            sb.append(Character.toUpperCase(ch));\n            nextUpper = false;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) \n    {\n        return null;\n    }\n    final StringBuilder sb = new StringBuilder();\n    final char[] chars = str.toCharArray();\n    boolean isDelim = true;\n    for (final char ch : chars) \n    {\n        if (isDelimiter(ch, delimiters)) \n        {\n            isDelim = true;\n        } \n        else if (isDelim) \n        {\n            sb.append(Character.toUpperCase(ch));\n            isDelim = false;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return \"\";\n    }\n    final StringBuilder sb = new StringBuilder(len);\n    char[] chars = str.toCharArray();\n    boolean isDelimiter = true;\n    for (char ch : chars) {\n        if (isDelimiter && !Character.isWhitespace(ch)) {\n            sb.append(Character.toUpperCase(ch));\n            isDelimiter = false;\n        } else if (isDelimiters(ch, delimiters)) {\n            isDelimiter = true;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n\n    final StringBuilder sb = new StringBuilder();\n    final char[] chars = str.toCharArray();\n    boolean isDelimiter = true;\n\n    for (char ch : chars) \n    {\n        if (isDelimiter && !Character.isWhitespace(ch)) \n        {\n            sb.append(Character.toUpperCase(ch));\n            isDelimiter = false;\n        } \n        else if (isDelimiters(ch, delimiters)) \n        {\n            isDelimiter = true;\n        }\n    }\n\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (str.isEmpty() || delimLen == 0) {\n        return \"\";\n    }\n    final StringBuilder sb = new StringBuilder();\n    final char[] chars = str.toCharArray();\n    boolean isDelim = true;\n    for (final char ch : chars) {\n        if (isDelim && !Character.isWhitespace(ch) && !isDelimiter(ch, delimiters)) {\n            sb.append(Character.toUpperCase(ch));\n            isDelim = false;\n        } else if (Character.isWhitespace(ch) || isDelimiter(ch, delimiters)) {\n            isDelim = true;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.isEmpty())\n        return str;\n\n    final char[] buffer = str.toCharArray();\n    final StringBuilder sb = new StringBuilder();\n    boolean addNext = true;\n\n    for (char c : buffer) \n    {\n        if (addNext && Character.isLetter(c)) \n        {\n            sb.append(c);\n            addNext = false;\n        }\n        else if (isDelimiter(c, delimiters)) \n        {\n            addNext = true;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) \n    {\n        return null;\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean isDelimiter = true;\n    for (char c : str.toCharArray()) \n    {\n        if (isDelimiter && !Character.isWhitespace(c) && !isDelimiter(c, delimiters)) \n        {\n            sb.append(Character.toUpperCase(c));\n            isDelimiter = false;\n        } \n        else if (Character.isWhitespace(c) || isDelimiter(c, delimiters)) \n        {\n            isDelimiter = true;\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final StringBuilder sb = new StringBuilder();\n    boolean isDelimiter = true;\n    for (int i = 0; i < str.length(); i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter && !Character.isWhitespace(ch)) {\n            sb.append(Character.toUpperCase(ch));\n            isDelimiter = false;\n        } else if (isDelimiter && Character.isWhitespace(ch)) {\n            continue;\n        } else if (!isDelimiter && Character.isWhitespace(ch)) {\n            isDelimiter = true;\n        }\n    }\n    return sb.toString();\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / getScaleX();\n    double y = (screenPoint.y - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / getScaleX();\n    double y = (screenPoint.y - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / getScaleX();\n    double y = (screenPoint.y - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / getScaleX();\n    double y = (screenPoint.y - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) \n    {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / getScaleX();\n    double y = (screenPoint.y - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / getScaleX();\n    double y = (screenPoint.y - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / getScaleX();\n    double y = (screenPoint.y - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) \n    {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / getScaleX();\n    double y = (screenPoint.y - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) \n    {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / getScaleX();\n    double y = (screenPoint.y - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / getScaleX();\n    double y = (screenPoint.y - insets.top) / getScaleY();\n    return new Point2D.Double(x, y);\n}"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    list.clear();\n    list.addAll(set);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    list.clear();\n    list.addAll(set);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    list.clear();\n    list.addAll(set);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    list.clear();\n    list.addAll(set);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    list.clear();\n    list.addAll(set);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    list.clear();\n    list.addAll(set);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    list.clear();\n    list.addAll(set);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    ListOrderedSet<E> orderedSet = new ListOrderedSet<E>(set, list);\n    list.clear();\n    list.addAll(set);\n    return orderedSet;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    list.clear();\n    list.addAll(set);\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    list.clear();\n    list.addAll(set);\n    return new ListOrderedSet<E>(set, list);\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n        Range result = null;\n        if (this.subplots != null) {\n            Iterator iterator = this.subplots.iterator();\n            while (iterator.hasNext()) {\n                CategoryPlot plot = (CategoryPlot) iterator.next();\n                Range more = plot.getRange(axis);\n                if (result == null) {\n                    result = more;\n                } else {\n                    result = Range.combine(result, more);\n                }\n            }\n        }\n        return result;\n    }",
      "public Range getDataRange(ValueAxis axis)  {\n    double lower = Double.MAX_VALUE;\n    double upper = Double.MIN_VALUE;\n    if (this.subplots != null) \n    {\n        for (CategoryPlot subplot : this.subplots) \n        {\n            Range subplotRange = subplot.getRange(axis);\n            if (subplotRange != null) \n            {\n                lower = Math.min(lower, subplotRange.getLowerBound());\n                upper = Math.max(upper, subplotRange.getUpperBound());\n            }\n        }\n    }\n    if (lower == Double.MAX_VALUE && upper == Double.MIN_VALUE) \n    {\n        return null;\n    }\n    return new Range(lower, upper);\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    double lower = Double.POSITIVE_INFINITY;\n    double upper = Double.NEGATIVE_INFINITY;\n\n    if (this.subplots != null) \n    {\n        for (int i = 0; i < this.subplots.size(); i++) \n        {\n            CategoryPlot subplot = (CategoryPlot) this.subplots.get(i);\n            Range subplotRange = subplot.getRange(axis);\n            if (!subplotRange.isInfinite()) \n            {\n                lower = Math.min(lower, subplotRange.getLowerBound());\n                upper = Math.max(upper, subplotRange.getUpperBound());\n            }\n        }\n    }\n\n    if (lower == Double.POSITIVE_INFINITY || upper == Double.NEGATIVE_INFINITY) \n    {\n        return Range.getInfiniteInstance();\n    }\n    else \n    {\n        return new Range(lower, upper);\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    double lower = Double.POSITIVE_INFINITY;\n    double upper = Double.NEGATIVE_INFINITY;\n    for (CategoryPlot subplot : subplots) \n    {\n        Range subplotRange = subplot.getRange(axis);\n        if (!subplotRange.isInfinite()) \n        {\n            lower = Math.min(lower, subplotRange.getLowerBound());\n            upper = Math.max(upper, subplotRange.getUpperBound());\n        }\n    }\n    if (lower == Double.POSITIVE_INFINITY || upper == Double.NEGATIVE_INFINITY) \n    {\n        return new Range(Double.NaN, Double.NaN);\n    }\n    else \n    {\n        return new Range(lower, upper);\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n        if (this.subplots == null) {\n            return null;\n        }\n        Range result = null;\n        for (Iterator iterator = this.subplots.iterator(); iterator.hasNext();) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range range = plot.getRange(axis);\n            if (range != null) {\n                if (result == null) {\n                    result = range;\n                } else {\n                    result = Range.combine(result, range);\n                }\n            }\n        }\n        return result;\n    }",
      "public Range getDataRange(ValueAxis axis)  {\n    double lower = Double.POSITIVE_INFINITY;\n    double upper = Double.NEGATIVE_INFINITY;\n\n    for (CategoryPlot subplot : subplots) \n    {\n        Range range = subplot.getRange(axis);\n        if (range != null) \n        {\n            double subLower = range.getLowerBound();\n            double subUpper = range.getUpperBound();\n\n            if (subLower < lower) \n            {\n                lower = subLower;\n            }\n\n            if (subUpper > upper) \n            {\n                upper = subUpper;\n            }\n        }\n    }\n\n    if (lower == Double.POSITIVE_INFINITY || upper == Double.NEGATIVE_INFINITY) \n    {\n        return null;\n    } \n    else \n    {\n        return new Range(lower, upper);\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    double lower = Double.MAX_VALUE;\n    double upper = Double.MIN_VALUE;\n    boolean first = true;\n    for (CategoryPlot subplot : subplots) \n    {\n        Range range = subplot.getRange(axis);\n        if (range != null) \n        {\n            if (first) \n            {\n                lower = range.getLowerBound();\n                upper = range.getUpperBound();\n                first = false;\n            } \n            else \n            {\n                lower = Math.min(lower, range.getLowerBound());\n                upper = Math.max(upper, range.getUpperBound());\n            }\n        }\n    }\n    if (first) \n    {\n        return null;\n    } \n    else \n    {\n        return new Range(lower, upper);\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis == null) \n    {\n        throw new IllegalArgumentException(\"Null 'axis' argument.\");\n    }\n\n    if (this.subplots == null) \n    {\n        return null;\n    }\n\n    Iterator iterator = this.subplots.iterator();\n    Range result = null;\n    while (iterator.hasNext()) \n    {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        Range range = plot.getRange(axis);\n        if (range != null) \n        {\n            if (result == null) \n            {\n                result = range;\n            } \n            else \n            {\n                result = Range.combine(result, range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  [CONTEXT]\n     * Sets the size (width or height, depending on the orientation of the\n     * plot) for the domain axis of each subplot.\n     *\n     * @param space  the space.\n     */\nprotected void setFixedDomainAxisSpaceForSubplots(AxisSpace space) {\n    Iterator iterator = this.subplots.iterator();\n    while (iterator.hasNext()) {\n        CategoryPlot plot = (CategoryPlot) iterator.next();\n        plot.setFixedDomainAxisSpace(space, false);\n    }\n}\n[CODE]\n[CONTEXT]\n     * Returns a collection of legend items for the plot.\n     *\n     * @return The legend items.",
      "public Range getDataRange(ValueAxis axis)  {\n    double lower = Double.MAX_VALUE;\n    double upper = Double.MIN_VALUE;\n    if (this.subplots != null) \n    {\n        for (CategoryPlot subplot : this.subplots) \n        {\n            Range range = subplot.getRange(axis);\n            if (range != null) \n            {\n                double subLower = range.getLowerBound();\n                double subUpper = range.getUpperBound();\n                if (subLower < lower) \n                {\n                    lower = subLower;\n                }\n                if (subUpper > upper) \n                {\n                    upper = subUpper;\n                }\n            }\n        }\n    }\n    return new Range(lower, upper);\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.log(val * 10 + 1) - LOG10_VALUE) / LOG10_VALUE; //invert adjustLog10\n    }\n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = (Math.log(val * 10.0 + 1.0) - LOG10_VALUE) / LOG10_VALUE; //invert adjustPow10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.log(val * 10.0 + 1.0) - LOG10_VALUE) / LOG10_VALUE; //invert adjustLog10\n    }\n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.log10(val + 1.0) - 1.0) / LOG10_VALUE; //invert adjustPow10\n    }\n    else \n    {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = (Math.log(val * 10 + 1) - LOG10_VALUE) / LOG10_VALUE; //invert adjustPow10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.log(val * 10.0 + 1.0) / LOG10_VALUE) - 1.0; //invert adjustLog10\n    }\n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = (Math.log10(val + 1.0) - 1.0) / 9.0; //invert adjustLog10\n    }\n    else \n    {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = (Math.log10(val + 1) - 1.0) / 9.0; //invert adjustLog10\n    }\n    else \n    {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.log10(val + 1.0) - Math.log10(10.0)) / 9.0; //invert adjustLog10\n    }\n    else \n    {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) \n    {\n        res = (Math.log(val * 10 + 1) - LOG10_VALUE) / LOG10_VALUE; //invert adjustPow10\n    }\n    else \n    {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // Implement the logic here\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // Your code here\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // TODO: Implement this method.\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // Implement your code here\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // TODO: Implement this method.\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    if (cfg == null) {\n        return false;\n    }\n    Node returnNode = cfg.getImplicitReturn();\n    if (returnNode == null) {\n        return false;\n    }\n    Node entryNode = cfg.getEntry();\n    if (entryNode == null) {\n        return false;\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // Your code goes here\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // TODO: Implement this method\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // TODO: Implement this method.\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    // TODO: Implement this method.\n    return false;\n}"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] result = new Dfp[2];\n    Dfp[] temp = new Dfp[2];\n\n    /* Compute (a-1)/(a+1) */\n    splitSubtract(a, ONE, temp);\n    splitDivide(temp, a, result);\n\n    /* Compute ln((a-1)/(a+1))/2 */\n    splitDivide(result, TWO, result);\n\n    return result;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] result = new Dfp[2];\n    Dfp[] temp = new Dfp[2];\n    result[0] = a[0].newInstance();\n    result[1] = a[1].newInstance();\n    temp[0] = a[0].newInstance();\n    temp[1] = a[1].newInstance();\n\n    // x = (a-1)/(a+1)\n    splitMult(a, DfpMath.split(2), temp);\n    splitSubtract(temp, DfpMath.split(1), result);\n    splitDivide(result, temp, result);\n\n    // log(a) = 2 * (x + x^3/3 + x^5/5 + ...)\n    splitMult(result, result, temp);\n    splitAdd(result, splitMult(temp, result), result);\n    splitAdd(result, splitMult(splitMult(temp, temp), result), result);\n    splitAdd(result, splitMult(splitMult(splitMult(temp, temp), temp), result), result);\n    splitAdd(result, splitMult(splitMult(splitMult(splitMult(temp, temp), temp), temp), result), result);\n\n    return result;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] result = new Dfp[2];\n    result[0] = a[0].newInstance();\n    result[1] = a[1].newInstance();\n\n    // Compute x = (a-1)/(a+1)\n    Dfp[] x = new Dfp[2];\n    x[0] = a[0].add(a[1]);\n    x[1] = a[0].subtract(a[1]);\n\n    // Compute log(a) = 2 * x / (1 - x^2)\n    Dfp[] x2 = DfpMath.splitMult(x, x);\n    Dfp[] one_x2 = new Dfp[2];\n    one_x2[0] = x2[0].negate();\n    one_x2[1] = x2[1];\n    Dfp[] one_x2_add_one = new Dfp[2];\n    one_x2_add_one[0] = one_x2[0].add(a[0]);\n    one_x2_add_one[1] = one_x2[1];\n    Dfp[] log_a = DfpMath.splitDiv(x, one_x2_add_one);\n    result[0] = log_a[0].multiply(2);\n    result[1] = log_a[1].multiply(2);\n\n    return result;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] result = new Dfp[2];\n    result[0] = a[0].newInstance();\n    result[1] = a[1].newInstance();\n    Dfp temp = a[0].add(a[1]);\n    result[0] = temp.subtract(a[0].multiply(a[1]));\n    result[1] = temp.multiply(a[0]);\n    return result;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] result = new Dfp[2];\n    result[0] = a[0].newInstance();\n    result[1] = a[1].newInstance();\n    Dfp x = a[0].newInstance();\n    x.add(a[1]);\n    x.divide(x.subtract(a[0]).add(a[1]));\n    result[0].add(x.subtract(a[0]).divide(x.add(a[0])));\n    result[1].add(x.subtract(a[1]).divide(x.add(a[1])));\n    return result;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] result = new Dfp[2];\n    Dfp[] splitOne = new Dfp[2];\n    splitOne[0] = a[0].newInstance(1);\n    splitOne[1] = a[1].newInstance(0);\n    result[0] = splitPow(a, -1);\n    result[1] = splitDiv(splitOne, a)[0];\n    return result;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] result = new Dfp[2];\n    result[0] = a[0].newInstance();\n    result[1] = a[1].newInstance();\n    Dfp temp = a[0].add(a[1]);\n    temp = temp.reciprocal();\n    result[0] = result[0].subtract(a[0]);\n    result[1] = result[1].subtract(a[1]);\n    result[0] = result[0].multiply(temp);\n    result[1] = result[1].multiply(temp);\n    return result;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] result = new Dfp[2];\n    Dfp[] splitOne = new Dfp[2];\n    splitOne[0] = a[0].newInstance(1);\n    splitOne[1] = a[1].newInstance(1);\n    result[0] = a[0].subtract(splitOne[0]);\n    result[1] = a[1].subtract(splitOne[1]);\n    result[0] = result[0].divide(result[0].add(splitOne[0]));\n    result[1] = result[1].divide(result[1].add(splitOne[1]));\n    return result;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] result = new Dfp[2];\n    Dfp[] temp = new Dfp[2];\n\n    // Compute x = (a-1)/(a+1)\n    splitSubtract(a, DfpMath.ONE, temp);\n    splitDivide(temp, a, temp);\n\n    // Compute log(a) = 2 * x / (1-x^2)\n    splitMult(temp, temp, result);\n    splitSubtract(DfpMath.ONE, result, result);\n    splitDivide(temp, result, result);\n    splitMult(DfpMath.TWO, result, result);\n\n    return result;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] result = new Dfp[2];\n    Dfp[] temp = new Dfp[2];\n    Dfp[] temp2 = new Dfp[2];\n    Dfp[] temp3 = new Dfp[2];\n\n    temp[0] = a[0].add(a[1]);\n    temp[1] = a[0].subtract(a[1]);\n\n    temp2[0] = temp[0].multiply(temp[0]);\n    temp2[1] = temp[1].multiply(temp[1]);\n\n    temp3[0] = temp2[0].add(temp2[1]);\n    temp3[1] = temp2[0].subtract(temp2[1]);\n\n    result[0] = temp[0].multiply(temp3[0]);\n    result[1] = temp[1].multiply(temp3[1]);\n\n    return result;\n}"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> collection = getCollection(key);\n        if (collection != null && collection.remove(value)) \n        {\n            if (collection.isEmpty()) \n            {\n                remove(key);\n            }\n            return true;\n        } \n        else \n        {\n            return false;\n        }\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"Key and value cannot be null\");\n        }\n        Collection<V> collection = getCollection(key);\n        if (collection == null) {\n            return false;\n        }\n        boolean removed = collection.remove(value);\n        if (collection.isEmpty()) {\n            remove(key);\n        }\n        return removed;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (containsKey(key)) \n        {\n            Collection<V> collection = getCollection(key);\n            if (collection != null && collection.remove(value)) \n            {\n                if (collection.isEmpty()) \n                {\n                    remove(key);\n                }\n                return true;\n            }\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (!containsKey(key)) \n        {\n            return false;\n        }\n        Collection<V> collection = getCollection(key);\n        boolean removed = collection.remove(value);\n        if (collection.isEmpty()) \n        {\n            remove(key);\n        }\n        return removed;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"key and value cannot be null\");\n        }\n        Collection<V> collection = getCollection(key);\n        if (collection != null) {\n            return collection.remove(value);\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (containsKey(key)) \n        {\n            Collection<V> collection = getCollection(key);\n            if (collection != null && collection.remove(value)) \n            {\n                if (collection.isEmpty()) \n                {\n                    remove(key);\n                }\n                return true;\n            }\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> collection = getCollection(key);\n        if (collection != null && collection.remove(value)) \n        {\n            if (collection.isEmpty()) \n            {\n                remove(key);\n            }\n            return true;\n        } \n        else \n        {\n            return false;\n        }\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> collection = getCollection(key);\n        if (collection != null) {\n            return collection.remove(value);\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> collection = getCollection((K) key);\n        if (collection != null) {\n            return collection.remove(value);\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null || value == null) {\n            throw new NullPointerException(\"key and value cannot be null\");\n        }\n        Collection<V> collection = getCollection(key);\n        if (collection != null) {\n            return collection.remove(value);\n        }\n        return false;\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n        node.setString(\"\\\"\" + node.getString() + \"\\\"\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n      Node node = transform(n);\n      if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n        node.setString(\"\\\"\" + node.getString() + \"\\\"\");\n      }\n      return node;\n    }",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n        node.setString(\"\\\"\" + node.getString() + \"\\\"\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n      Node node = transform(n);\n      if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n        node.setString(\"\\\"\" + node.getString() + \"\\\"\");\n      }\n      return node;\n    }",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n      node.setType(Token.STRING);\n      node.setString(\"\\\"\" + node.getString() + \"\\\"\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) \n    {\n        node.setType(Token.STRING);\n        node.setString(\"\\\"\" + node.getString() + \"\\\"\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) \n    {\n        node.setType(Token.STRING);\n        node.setString(\"\\\"\" + node.getString() + \"\\\"\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n        node.setType(Token.STRING);\n        node.setString(\"\\\"\" + node.getString() + \"\\\"\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) {\n      node.setType(Token.STRING);\n      node.setString(\"\\\"\" + node.getString() + \"\\\"\");\n    }\n    return node;\n}",
      "private Node transformAsString(AstNode n)  {\n    Node node = transform(n);\n    if (node.getType() == Token.NAME) \n    {\n        node.setType(Token.STRING);\n        node.setString(\"\\\"\" + node.getString() + \"\\\"\");\n    }\n    return node;\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        Number value = dataset.getValue(row, category);\n        if (value != null) {\n            double v = value.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            total += v;\n            result.add(new Double(total));\n        }\n        else {\n            result.add(new Double(total));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n        List result = new ArrayList();\n        int rowCount = dataset.getRowCount();\n        double total = 0.0;\n        if (asPercentages) {\n            for (int i = 0; i < rowCount; i++) {\n                Number n = dataset.getValue(i, category);\n                if (n != null) {\n                    total += n.doubleValue();\n                }\n            }\n        }\n\n        double previous = 0.0;\n        for (int i = 0; i < rowCount; i++) {\n            if (ArrayUtils.contains(includedRows, i)) {\n                Number n = dataset.getValue(i, category);\n                double value = n != null ? n.doubleValue() : 0.0;\n                if (asPercentages) {\n                    value = value / total;\n                }\n                double current = previous + value;\n                result.add(new Double(current));\n                previous = current;\n            }\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    int seriesCount = dataset.getSeriesCount();\n    double total = 0.0;\n    if (asPercentages) {\n        for (int i = 0; i < seriesCount; i++) {\n            Number n = dataset.getValue(i, category);\n            if (n != null) {\n                total += n.doubleValue();\n            }\n        }\n    }\n    double previous = 0.0;\n    for (int i = 0; i < seriesCount; i++) {\n        if (ArrayUtils.contains(includedRows, i)) {\n            Number n = dataset.getValue(i, category);\n            double value = (n != null) ? n.doubleValue() : 0.0;\n            if (asPercentages) {\n                value = value / total;\n            }\n            result.add(new Double(previous + value));\n            previous += value;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        Number n = dataset.getValue(includedRows[i], category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            base += v;\n            result.add(new Double(base));\n        }\n        else {\n            result.add(new Double(base));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    int column = dataset.getColumnIndex(category);\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        int row = includedRows[i];\n        Number n = dataset.getValue(row, column);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            total += v;\n            result.add(new Double(total + base));\n        }\n        else {\n            result.add(new Double(total + base));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n\n        List result = new ArrayList();\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n\n        for (int i = 0; i < includedRows.length; i++) {\n            int row = includedRows[i];\n            Number n = dataset.getValue(row, category);\n            double v = n != null ? n.doubleValue() : 0.0;\n            if (asPercentages) {\n                v = v / total;\n            }\n            total += v;\n            result.add(new Double(total));\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            Number n = dataset.getValue(includedRows[i], category);\n            if (n != null) {\n                double v = n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n                total += v;\n                result.add(new Double(total + base));\n            }\n            else {\n                result.add(new Double(total + base));\n            }\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, category);\n    }\n    for (int i = 0; i < includedRows.length; i++) {\n        Number n = dataset.getValue(includedRows[i], category);\n        if (n != null) {\n            double v = n.doubleValue();\n            if (asPercentages) {\n                v = v / total;\n            }\n            total += v;\n            result.add(new Double(total + base));\n        }\n        else {\n            result.add(new Double(total + base));\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            Number n = dataset.getValue(includedRows[i], category);\n            if (n != null) {\n                double v = n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n                total += v;\n                result.add(new Double(total + base));\n            }\n            else {\n                result.add(new Double(total + base));\n            }\n        }\n        return result;\n    }",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n        List result = new ArrayList();\n        double total = 0.0;\n        if (asPercentages) {\n            total = DataUtilities.calculateColumnTotal(dataset, category);\n        }\n        for (int i = 0; i < includedRows.length; i++) {\n            Number n = dataset.getValue(includedRows[i], category);\n            if (n != null) {\n                double v = n.doubleValue();\n                if (asPercentages) {\n                    v = v / total;\n                }\n                total += v;\n                result.add(new Double(total + base));\n            }\n            else {\n                result.add(new Double(total + base));\n            }\n        }\n        return result;\n    }"
    ],
    [
      "private List<Element> childElementsList()  {\n        if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n            List<Element> elements = new ArrayList<>();\n            for (Node node : childNodes) {\n                if (node instanceof Element) {\n                    elements.add((Element) node);\n                }\n            }\n            shadowChildrenRef = new WeakReference<>(elements);\n        }\n        return shadowChildrenRef.get();\n    }",
      "private List<Element> childElementsList()  {\n        if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n            List<Element> elements = new ArrayList<>();\n            for (Node node : childNodes) {\n                if (node instanceof Element) {\n                    elements.add((Element) node);\n                }\n            }\n            shadowChildrenRef = new WeakReference<>(elements);\n        }\n        return shadowChildrenRef.get();\n    }",
      "private List<Element> childElementsList()  {\n        if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n            List<Element> elements = new ArrayList<>();\n            for (Node node : childNodes) {\n                if (node instanceof Element) {\n                    elements.add((Element) node);\n                }\n            }\n            shadowChildrenRef = new WeakReference<>(elements);\n        }\n        return shadowChildrenRef.get();\n    }",
      "private List<Element> childElementsList()  {\n        if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n            List<Element> elements = new ArrayList<>();\n            for (Node node : childNodes) {\n                if (node instanceof Element) {\n                    elements.add((Element) node);\n                }\n            }\n            shadowChildrenRef = new WeakReference<>(elements);\n        }\n        return shadowChildrenRef.get();\n    }",
      "private List<Element> childElementsList()  {\n        if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n            List<Element> elements = new ArrayList<>();\n            for (Node node : childNodes) {\n                if (node instanceof Element) {\n                    elements.add((Element) node);\n                }\n            }\n            shadowChildrenRef = new WeakReference<>(elements);\n        }\n        return shadowChildrenRef.get();\n    }",
      "private List<Element> childElementsList()  {\n        List<Element> elements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        return elements;\n    }",
      "private List<Element> childElementsList()  {\n        List<Element> elements = new ArrayList<>();\n        for (Node node : ensureChildNodes()) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        return elements;\n    }",
      "private List<Element> childElementsList()  {\n        List<Element> elements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        return elements;\n    }",
      "private List<Element> childElementsList()  {\n        if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n            List<Element> elements = new ArrayList<>();\n            for (Node node : childNodes) {\n                if (node instanceof Element) {\n                    elements.add((Element) node);\n                }\n            }\n            shadowChildrenRef = new WeakReference<>(elements);\n        }\n        return shadowChildrenRef.get();\n    }",
      "private List<Element> childElementsList()  {\n        if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n            List<Element> elements = new ArrayList<>();\n            for (Node node : childNodes) {\n                if (node instanceof Element) {\n                    elements.add((Element) node);\n                }\n            }\n            shadowChildrenRef = new WeakReference<>(elements);\n        }\n        return shadowChildrenRef.get();\n    }"
    ],
    [
      "private int getHash(final Object key)  {\n    int hash = key == null ? 0 : key.hashCode();\n    return Math.abs(hash % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash = hash < 0 ? -hash : hash;\n    return hash % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return Math.abs(hash) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash = hash < 0 ? -hash : hash;\n    return hash % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return Math.abs(hash) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash = hash < 0 ? -hash : hash;\n    return hash % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return Math.abs(hash) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hash = key == null ? 0 : key.hashCode();\n    return Math.abs(hash) % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash = hash < 0 ? -hash : hash;\n    return hash % buckets.length;\n}",
      "private int getHash(final Object key)  {\n    int hash = key == null ? 0 : key.hashCode();\n    return Math.abs(hash % buckets.length);\n}"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r <= c + k) \n            {\n                d[r][c] = m.getEntry(r, c);\n            } \n            else \n            {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if (r <= c + k) {\n                    d[r][c] = m.getEntry(r, c);\n                } else {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r <= c + k) \n            {\n                d[r][c] = m.getEntry(r, c);\n            } \n            else \n            {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r <= c + k) \n            {\n                d[r][c] = m.getEntry(r, c);\n            }\n            else \n            {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) \n    {\n        for (int c = 0; c < m.getColumnDimension(); c++) \n        {\n            if (r <= c + k) \n            {\n                d[r][c] = m.getEntry(r, c);\n            } \n            else \n            {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if (r <= c + k) {\n                    d[r][c] = m.getEntry(r, c);\n                } else {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if (r <= c + k) {\n                    d[r][c] = m.getEntry(r, c);\n                } else {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                if (r <= c + k) {\n                    d[r][c] = m.getEntry(r, c);\n                } else {\n                    d[r][c] = 0;\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) {\n            rotateCCW();\n            skew      = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n            return true;\n        } else if (right.skew == Skew.BALANCED) {\n            rotateCCW();\n            skew      = Skew.LEFT_HIGH;\n            left.skew = Skew.RIGHT_HIGH;\n            return false;\n        } else {\n            final Skew s = right.left.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        }\n    default:\n        skew = Skew.RIGHT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) \n            {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (right.skew == Skew.BALANCED) \n            {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) {\n            rotateCCW();\n            skew      = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n            return true;\n        } else if (right.skew == Skew.BALANCED) {\n            rotateCCW();\n            skew      = Skew.LEFT_HIGH;\n            left.skew = Skew.RIGHT_HIGH;\n            return false;\n        } else {\n            final Skew s = right.left.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        }\n    default:\n        skew = Skew.RIGHT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) {\n                rotateCCW();\n                skew = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCCW();\n                skew = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.left.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.RIGHT_HIGH;\n            return false;\n    }\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n        double small = epsilon * norm;\n        int idx = startIdx;\n        while (idx > 0 && FastMath.abs(matrixT[idx][idx - 1]) <= small) {\n            idx--;\n        }\n        return idx;\n    }",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    final double epsilon = this.epsilon * norm;\n    int idx = startIdx;\n    while (idx > 0 && FastMath.abs(matrixT[idx][idx - 1]) <= epsilon) {\n        idx--;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    double min = FastMath.abs(matrixT[idx][idx - 1]) / norm;\n    while (idx > 0 && min >= epsilon) {\n        idx--;\n        min = FastMath.abs(matrixT[idx][idx - 1]) / norm;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    final double threshold = epsilon * norm;\n    for (int idx = startIdx; idx > 0; idx--) \n    {\n        if (FastMath.abs(matrixT[idx][idx - 1]) < threshold) \n        {\n            return idx;\n        }\n    }\n    return 0;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double small = epsilon * norm;\n    int idx = startIdx;\n    while (idx > 0) \n    {\n        if (FastMath.abs(matrixT[idx][idx - 1]) <= small) \n        {\n            break;\n        }\n        idx--;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double min = norm;\n    int idx = startIdx;\n    for (int i = startIdx; i >= 0; i--) {\n        double sum = 0.0;\n        for (int j = i + 2; j <= startIdx; j++) {\n            sum += FastMath.abs(matrixT[j][i]);\n        }\n        if (i == startIdx || FastMath.abs(matrixT[i + 1][i]) <= epsilon * norm) {\n            if (sum <= epsilon * norm) {\n                return i;\n            }\n        } else {\n            double temp = sum / FastMath.abs(matrixT[i + 1][i]);\n            if (temp <= min) {\n                min = temp;\n                idx = i;\n            }\n        }\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    final double epsilon = this.epsilon * norm;\n    int idx = startIdx;\n    while (idx > 0) \n    {\n        if (FastMath.abs(matrixT[idx][idx - 1]) <= epsilon) \n        {\n            return idx;\n        }\n        idx--;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    double threshold = epsilon * norm;\n    for (int idx = startIdx; idx > 0; idx--) \n    {\n        if (FastMath.abs(matrixT[idx][idx - 1]) < threshold) \n        {\n            return idx;\n        }\n    }\n    return 0;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    final double threshold = epsilon * norm;\n    for (int idx = startIdx; idx > 0; idx--) \n    {\n        if (FastMath.abs(matrixT[idx][idx - 1]) < threshold) \n        {\n            return idx;\n        }\n    }\n    return 0;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  "
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    Node node = top;\n    while (node != null) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    Node node = top;\n    while (node != null) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    Node node = top;\n    while (node != null) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    Node node = top;\n    while (node != null) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    Node node = top;\n    while (node != null) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    Node node = top;\n    while (node != null) {\n        if (node.element.compareTo(reference) < 0) {\n            node = node.right;\n        } else {\n            candidate = node;\n            node = node.left;\n        }\n    }\n    return candidate;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    Node node = top;\n    while (node != null) {\n        if (node.element.compareTo(reference) < 0) {\n            node = node.right;\n        } else {\n            candidate = node;\n            node = node.left;\n        }\n    }\n    return candidate;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    Node node = top;\n    while (node != null) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n        final int len = (str == null ? 0 : str.length());\n        if (len > 0) {\n            final int index = indexOf(str, 0);\n            if (index >= 0) {\n                deleteImpl(index, index + len, len);\n            }\n        }\n        return this;\n    }",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) {\n        final int index = indexOf(str, 0);\n        if (index >= 0) {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = irNode.getJSDocInfo();\n    if (jsDocInfo != null && jsDocInfo.hasType()) \n    {\n        Node typeNode = newNode(Token.TYPE, jsDocInfo.getType());\n        irNode = newNode(Token.CAST, typeNode, irNode);\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (node.hasJSDocInfo()) {\n      JSDocInfo jsDocInfo = node.getJSDocInfo();\n      validateTypeAnnotations(jsDocInfo, node);\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = irNode.getJSDocInfo();\n    if (jsDocInfo != null) \n    {\n        validateTypeAnnotations(jsDocInfo, node);\n        if (node.getType() == com.google.javascript.rhino.head.Token.VAR) \n        {\n            for (Node name : node.children()) \n            {\n                jsDocInfo.addAlias(name.getString(), name);\n            }\n        } \n        else if (isPropAccess(node)) \n        {\n            AstNode target = ((PropertyGet) node).getTarget();\n            jsDocInfo.addAlias(target.getString(), target);\n        }\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = irNode.getJSDocInfo();\n    if (jsDocInfo != null && jsDocInfo.hasType()) \n    {\n        irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (node.hasJSDoc()) \n    {\n        JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n        if (jsDocInfo != null) \n        {\n            validateTypeAnnotations(jsDocInfo, node);\n            irNode.setJSDocInfo(jsDocInfo);\n        }\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = irNode.getJSDocInfo();\n    if (jsDocInfo != null) {\n        validateTypeAnnotations(jsDocInfo, node);\n        if (node instanceof Name) {\n            irNode = newNode(Token.NAME, ((Name) node).getString());\n        }\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (node.getType() == com.google.javascript.rhino.head.Token.NAME) \n    {\n        JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n        if (jsDocInfo != null) \n        {\n            validateTypeAnnotations(jsDocInfo, node);\n            irNode = maybeInjectCastNode(node, jsDocInfo, irNode);\n            irNode.setJSDocInfo(jsDocInfo);\n        }\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = irNode.getJSDocInfo();\n    if (jsDocInfo != null) {\n      validateTypeAnnotations(jsDocInfo, node);\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (node.hasJSDocInfo()) {\n        JSDocInfo jsDocInfo = node.getJSDocInfo();\n        validateTypeAnnotations(jsDocInfo, node);\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    JSDocInfo jsDocInfo = irNode.getJSDocInfo();\n    if (jsDocInfo != null && jsDocInfo.hasType()) {\n      JSType type = jsDocInfo.getType();\n      if (type instanceof JSType.JSTypeArray) {\n        JSType.JSTypeArray arrayType = (JSType.JSTypeArray) type;\n        if (arrayType.getSize() == 1 && arrayType.getType(0) instanceof JSType.JSTypeName) {\n          JSType.JSTypeName nameType = (JSType.JSTypeName) arrayType.getType(0);\n          if (nameType.getName().equals(\"string\")) {\n            irNode.setType(Token.STRING);\n          }\n        }\n      }\n    }\n    return irNode;\n  }"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = createSetBasedOnList(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    List<E> uniqueList = new ArrayList<E>(set);\n    return new SetUniqueList<E>(uniqueList, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = createSetBasedOnList(list);\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    return new SetUniqueList<E>(list, set);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = createSetBasedOnList(list);\n    return new SetUniqueList<E>(list, set);\n}"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.LB);\n\n    Node arrayType = newNode(Token.LB);\n\n    skipEOLs();\n    token = next();\n\n    if (token == JsDocToken.RB) {\n      // Empty array type.\n      return arrayType;\n    }\n\n    Node elementType = parseTypeExpression(token);\n    if (elementType == null) {\n      return null;\n    }\n\n    arrayType.addChildToBack(elementType);\n\n    while (match(JsDocToken.COMMA)) {\n      next();\n      skipEOLs();\n      token = next();\n\n      if (token == JsDocToken.ELLIPSIS) {\n        token = next();\n        elementType = parseTypeExpression(token);\n        if (elementType == null) {\n          return null;\n        }\n        elementType = wrapNode(Token.ELLIPSIS, elementType);\n      } else {\n        elementType = parseTypeExpression(token);\n        if (elementType == null) {\n          return null;\n        }\n      }\n\n      arrayType.addChildToBack(elementType);\n    }\n\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n\n    next();\n\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.LB);\n\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(next());\n\n    if (elementTypeList == null) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    arrayType.addChildToBack(elementTypeList);\n\n    skipEOLs();\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n\n    next();\n\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    if (token != JsDocToken.LB) {\n        return reportGenericTypeSyntaxWarning();\n    }\n    next();\n    skipEOLs();\n    token = next();\n    if (token == JsDocToken.RB) {\n        return arrayType;\n    }\n    Node elementTypeList = parseElementTypeList(token);\n    if (elementTypeList == null) {\n        return reportGenericTypeSyntaxWarning();\n    }\n    arrayType.addChildToBack(elementTypeList);\n    if (!match(JsDocToken.RB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n\n    if (token != JsDocToken.LB) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    next();\n    skipEOLs();\n    token = next();\n\n    if (token == JsDocToken.RB) {\n      return arrayType;\n    }\n\n    Node elementType = parseTypeExpression(token);\n    if (elementType == null) {\n      return null;\n    }\n\n    arrayType.addChildToBack(elementType);\n\n    while (match(JsDocToken.COMMA)) {\n      next();\n      skipEOLs();\n      token = next();\n\n      if (token == JsDocToken.ELLIPSIS) {\n        elementType = parseTypeExpression(next());\n        if (elementType == null) {\n          return null;\n        }\n        elementType = wrapNode(Token.ELLIPSIS, elementType);\n      } else {\n        elementType = parseTypeExpression(token);\n        if (elementType == null) {\n          return null;\n        }\n      }\n\n      arrayType.addChildToBack(elementType);\n    }\n\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n\n    next();\n\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n    next();\n    Node elementTypeList = parseElementTypeList(token);\n    if (elementTypeList == null) {\n      return null;\n    }\n    arrayType.addChildToBack(elementTypeList);\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n\n    if (token != JsDocToken.LB) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    next();\n    skipEOLs();\n    token = next();\n\n    if (token == JsDocToken.RB) {\n      return arrayType;\n    }\n\n    Node elementTypeList = parseElementTypeList(token);\n    if (elementTypeList == null) {\n      return null;\n    }\n\n    arrayType.addChildToBack(elementTypeList);\n\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n\n    next();\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n    next();\n    skipEOLs();\n    token = next();\n    if (token == JsDocToken.RB) {\n      // Empty array type.\n      return arrayType;\n    }\n    Node elementType = parseTypeExpression(token);\n    if (elementType == null) {\n      return null;\n    }\n    arrayType.addChildToBack(elementType);\n    while (match(JsDocToken.COMMA)) {\n      next();\n      skipEOLs();\n      token = next();\n      elementType = parseTypeExpression(token);\n      if (elementType == null) {\n        return null;\n      }\n      arrayType.addChildToBack(elementType);\n    }\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    if (!match(JsDocToken.LB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n    next();\n    skipEOLs();\n    token = next();\n    if (token == JsDocToken.RB) {\n      // empty array\n      return arrayType;\n    }\n    Node elementType = parseTypeExpression(token);\n    if (elementType == null) {\n      return null;\n    }\n    arrayType.addChildToBack(elementType);\n    while (match(JsDocToken.COMMA)) {\n      next();\n      skipEOLs();\n      token = next();\n      if (token == JsDocToken.RB) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.type\");\n      }\n      Node nextElementType = parseTypeExpression(token);\n      if (nextElementType == null) {\n        return null;\n      }\n      arrayType.addChildToBack(nextElementType);\n    }\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Preconditions.checkArgument(token == JsDocToken.LB);\n\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(next());\n    if (elementTypeList == null) {\n      return reportGenericTypeSyntaxWarning();\n    }\n    arrayType.addChildToBack(elementTypeList);\n\n    skipEOLs();\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n\n    return arrayType;\n  }",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Preconditions.checkArgument(token == JsDocToken.LB);\n    skipEOLs();\n    token = next();\n    if (token == JsDocToken.RB) {\n      return arrayType;\n    }\n    Node elementType = parseTypeExpression(token);\n    if (elementType == null) {\n      return null;\n    }\n    arrayType.addChildToBack(elementType);\n    while (match(JsDocToken.COMMA)) {\n      next();\n      skipEOLs();\n      elementType = parseTypeExpression(next());\n      if (elementType == null) {\n        return null;\n      }\n      arrayType.addChildToBack(elementType);\n    }\n    if (!match(JsDocToken.RB)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n  }"
    ],
    [
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n      if (q0 >= 0) {\n        return Vector3D.PLUS_I;\n      } else {\n        return Vector3D.MINUS_I;\n      }\n    } else if (q0 >= 0) {\n      return new Vector3D(q1, q2, q3).scalarMultiply(FastMath.sqrt(squaredSine));\n    } else {\n      return new Vector3D(-q1, -q2, -q3).scalarMultiply(FastMath.sqrt(squaredSine));\n    }\n  }",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n      if (q0 >= 0) {\n        return Vector3D.PLUS_I;\n      } else {\n        return Vector3D.MINUS_I;\n      }\n    } else if (q0 >= 0) {\n      return new Vector3D(q1, q2, q3).scalarMultiply(FastMath.sqrt(squaredSine));\n    } else {\n      return new Vector3D(-q1, -q2, -q3).scalarMultiply(FastMath.sqrt(squaredSine));\n    }\n  }",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) {\n      return Vector3D.ZERO;\n    } else if (q0 < 0) {\n      return new Vector3D(-q1 / norm, -q2 / norm, -q3 / norm);\n    }\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n  }",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) {\n      return new Vector3D(1, 0, 0);\n    }\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n  }",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) {\n      if (q0 >= 0) {\n        return Vector3D.PLUS_I;\n      } else {\n        return Vector3D.MINUS_I;\n      }\n    } else {\n      return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n    }\n  }",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n      if (q0 >= 0) {\n        return Vector3D.PLUS_I;\n      } else {\n        return Vector3D.MINUS_I;\n      }\n    } else if (q0 < 0) {\n      return new Vector3D(q1, q2, q3).scalarMultiply(-FastMath.sqrt(squaredSine));\n    }\n    return new Vector3D(q1, q2, q3).scalarMultiply(FastMath.sqrt(squaredSine));\n  }",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n      if (q0 >= 0) {\n        return Vector3D.PLUS_I;\n      } else {\n        return Vector3D.MINUS_I;\n      }\n    } else if (q0 >= 0) {\n      return new Vector3D(q1, q2, q3).scalarMultiply(FastMath.sqrt(squaredSine));\n    } else {\n      return new Vector3D(-q1, -q2, -q3).scalarMultiply(FastMath.sqrt(squaredSine));\n    }\n  }",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    if (norm == 0) {\n      return new Vector3D(1, 0, 0);\n    }\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n  }",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n      if (q0 >= 0) {\n        return Vector3D.PLUS_I;\n      } else {\n        return Vector3D.MINUS_I;\n      }\n    } else if (q0 < 0) {\n      return new Vector3D(q1, q2, q3).scalarMultiply(-FastMath.sqrt(squaredSine));\n    }\n    return new Vector3D(q1, q2, q3).scalarMultiply(FastMath.sqrt(squaredSine));\n  }",
      "public Vector3D getAxis()  {\n    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n    if (squaredSine == 0) {\n      if (q0 >= 0) {\n        return Vector3D.PLUS_I;\n      } else {\n        return Vector3D.MINUS_I;\n      }\n    } else if (q0 >= 0) {\n      return new Vector3D(q1, q2, q3).scalarMultiply(FastMath.sqrt(squaredSine));\n    } else {\n      return new Vector3D(-q1, -q2, -q3).scalarMultiply(FastMath.sqrt(squaredSine));\n    }\n  }"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    try {\n        for (int i = 0; i < bytes.length; i++) {\n            byte b = bytes[i];\n            if (b == '+') {\n                b = ' ';\n            } else if (b == '%') {\n                if (i + 2 >= bytes.length) {\n                    throw new DecoderException(\"Invalid URL encoding (% at end)\");\n                }\n                final char hex1 = Character.toLowerCase(bytes[i + 1]);\n                final char hex2 = Character.toLowerCase(bytes[i + 2]);\n                if (!(('0' <= hex1 && hex1 <= '9' || 'a' <= hex1 && hex1 <= 'f') && ('0' <= hex2 && hex2 <= '9' || 'a' <= hex2 && hex2 <= 'f'))) {\n                    throw new DecoderException(\"Invalid URL encoding (%HH expected)\");\n                }\n                b = (byte) Integer.parseInt(new String(new byte[] { hex1, hex2 }), 16);\n                i += 2;\n            }\n            buffer.write(b);\n        }\n    } catch (final NumberFormatException e) {\n        throw new DecoderException(e.getMessage(), e);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    try {\n        for (int i = 0; i < bytes.length; i++) {\n            if (bytes[i] == ESCAPE_CHAR) {\n                if (i + 2 >= bytes.length) {\n                    throw new DecoderException(\"Incomplete escape sequence\");\n                }\n                final byte high = (byte)Character.digit(new String(bytes, i + 1, 1).charAt(0), RADIX);\n                final byte low = (byte)Character.digit(new String(bytes, i + 2, 1).charAt(0), RADIX);\n                if (high < 0 || low < 0) {\n                    throw new DecoderException(\"Invalid escape sequence\");\n                }\n                buffer.write(high << 4 | low);\n                i += 2;\n            } else {\n                buffer.write(bytes[i]);\n            }\n        }\n    } catch (final UnsupportedEncodingException e) {\n        throw new DecoderException(e.getMessage(), e);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        if (bytes[i] == ESCAPE_CHAR) {\n            if (i + 2 >= bytes.length) {\n                throw new DecoderException(\"Invalid URL encoding\");\n            }\n            final byte high = (byte) Character.digit(new String(bytes, i + 1, 1), RADIX);\n            final byte low = (byte) Character.digit(new String(bytes, i + 2, 1), RADIX);\n            buffer.write((high << 4) + low);\n            i += 2;\n        } else {\n            buffer.write(bytes[i]);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final byte b = bytes[i];\n        if (b == '+') {\n            buffer.write(' ');\n        } else if (b == '%') {\n            if (i + 2 < bytes.length) {\n                final char hex1 = Character.toUpperCase(bytes[i + 1]);\n                final char hex2 = Character.toUpperCase(bytes[i + 2]);\n                if ((hex1 >= '0' && hex1 <= '9' || hex1 >= 'A' && hex1 <= 'F') && (hex2 >= '0' && hex2 <= '9' || hex2 >= 'A' && hex2 <= 'F')) {\n                    final byte hex = (byte) ((Character.digit(hex1, RADIX) << 4) + Character.digit(hex2, RADIX));\n                    buffer.write(hex);\n                    i += 2;\n                } else {\n                    throw new DecoderException(\"Invalid URL encoding (%HH)\");\n                }\n            } else {\n                throw new DecoderException(\"Invalid URL encoding (%)\");\n            }\n        } else {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        if (bytes[i] == ESCAPE_CHAR) {\n            if (i + 2 >= bytes.length) {\n                throw new DecoderException(\"Invalid URL encoding: trailing escape characters\");\n            }\n            final byte high = (byte)Character.digit((char)bytes[++i], RADIX);\n            final byte low = (byte)Character.digit((char)bytes[++i], RADIX);\n            if (high < 0 || low < 0) {\n                throw new DecoderException(\"Invalid URL encoding: non-hex input\");\n            }\n            buffer.write((high << 4) + low);\n        } else {\n            buffer.write(bytes[i]);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    try {\n        int i = 0;\n        while (i < bytes.length) {\n            final byte b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                if (i + 2 >= bytes.length) {\n                    throw new DecoderException(\"Invalid URL encoding: incomplete escape sequence\");\n                }\n                final byte high = bytes[i + 1];\n                final byte low = bytes[i + 2];\n                final byte decoded = (byte) ((Character.digit(high, RADIX) << 4) + Character.digit(low, RADIX));\n                buffer.write(decoded);\n                i += 3;\n            } else {\n                buffer.write(b);\n                i += 1;\n            }\n        }\n    } catch (final IOException e) {\n        throw new DecoderException(e.getMessage(), e);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    try {\n        for (int i = 0; i < bytes.length; i++) {\n            if (bytes[i] == ESCAPE_CHAR) {\n                if (i + 2 >= bytes.length) {\n                    throw new DecoderException(\"Invalid URL encoding: incomplete escape sequence\");\n                }\n                final byte high = (byte)Character.digit((char)bytes[++i], RADIX);\n                final byte low = (byte)Character.digit((char)bytes[++i], RADIX);\n                if (high < 0 || low < 0) {\n                    throw new DecoderException(\"Invalid URL encoding: non-hex input in escape sequence\");\n                }\n                buffer.write(high << 4 | low);\n            } else {\n                buffer.write(bytes[i]);\n            }\n        }\n    } catch (final IOException e) {\n        throw new DecoderException(e.getMessage(), e);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        byte b = bytes[i];\n        if (b == '+') {\n            b = ' ';\n        } else if (b == '%') {\n            if (i + 2 >= bytes.length) {\n                throw new DecoderException(\"Invalid URL encoding (expected two hexadecimal characters)\");\n            }\n            final int hex1 = Character.digit(bytes[i + 1], RADIX);\n            final int hex2 = Character.digit(bytes[i + 2], RADIX);\n            if (hex1 < 0 || hex2 < 0) {\n                throw new DecoderException(\"Invalid URL encoding (not a hexadecimal character)\");\n            }\n            b = (byte)((hex1 << 4) + hex2);\n            i += 2;\n        }\n        buffer.write(b);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    try {\n        for (int i = 0; i < bytes.length; i++) {\n            if (bytes[i] == ESCAPE_CHAR) {\n                if (i + 2 >= bytes.length) {\n                    throw new DecoderException(\"Invalid URL encoding\");\n                }\n                final String hex = new String(bytes, i + 1, 2);\n                final int b = Integer.parseInt(hex, RADIX);\n                buffer.write(b);\n                i += 2;\n            } else {\n                buffer.write(bytes[i]);\n            }\n        }\n    } catch (final NumberFormatException e) {\n        throw new DecoderException(e.getMessage(), e);\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    try {\n        int i = 0;\n        while (i < bytes.length) {\n            final byte b = bytes[i];\n            if (b == ESCAPE_CHAR) {\n                if (i + 2 >= bytes.length) {\n                    throw new DecoderException(\"Invalid URL encoding: not enough data\");\n                }\n                final byte high = bytes[i + 1];\n                final byte low = bytes[i + 2];\n                final byte decoded = (byte) ((Character.digit(high, RADIX) << 4) + Character.digit(low, RADIX));\n                buffer.write(decoded);\n                i += 3;\n            } else {\n                buffer.write(b);\n                i += 1;\n            }\n        }\n    } catch (final IOException e) {\n        throw new DecoderException(e.getMessage(), e);\n    }\n    return buffer.toByteArray();\n}"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n    checkAlterPeriodConverters();\n    if (converter == null) {\n        return null;\n    }\n    PeriodConverter[] removed = new PeriodConverter[1];\n    iPeriodConverters = iPeriodConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) {\n        if (!partial.getField(i).getRangeDurationField().equals(partial.getField(i + 1).getDurationField())) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) \n    {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) \n    {\n        DateTimeField fieldI = partial.getField(i);\n        DateTimeField fieldIPlusOne = partial.getField(i + 1);\n        if (fieldIPlusOne.getRangeDurationField() != fieldI.getDurationField()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) \n    {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) \n    {\n        DateTimeFieldType fieldType1 = partial.getFieldType(i);\n        DateTimeFieldType fieldType2 = partial.getFieldType(i + 1);\n        if (fieldType1.getRangeDurationField() != fieldType2.getDurationField()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) \n    {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) \n    {\n        if (!partial.getField(i).getRangeDurationField().equals(partial.getField(i + 1).getDurationField())) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) \n    {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) \n    {\n        DateTimeFieldType fieldType1 = partial.getFieldType(i);\n        DateTimeFieldType fieldType2 = partial.getFieldType(i + 1);\n\n        if (fieldType1.getRangeDurationField() != fieldType2.getDurationField()) \n        {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) \n    {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) \n    {\n        DateTimeField field = partial.getField(i);\n        DateTimeField nextField = partial.getField(i + 1);\n        if (field.getRangeDurationField() != nextField.getDurationField()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) \n    {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) \n    {\n        DateTimeField field = partial.getField(i);\n        DateTimeField nextField = partial.getField(i + 1);\n        if (field.getRangeDurationField() != nextField.getDurationField()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) \n    {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) \n    {\n        if (!partial.getField(i).getRangeDurationField().equals(partial.getField(i + 1).getDurationField())) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) {\n        if (!partial.getField(i).getRangeDurationField().equals(partial.getField(i + 1).getDurationField())) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) \n    {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) \n    {\n        if (!partial.getField(i).getRangeDurationField().equals(partial.getField(i + 1).getDurationField())) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Set<O> union = new HashSet<O>();\n    for (O element : a) {\n        union.add(element);\n    }\n    for (O element : b) {\n        union.add(element);\n    }\n    return union;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, Math.max(helper.freqA(obj), helper.freqB(obj)));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (O obj : helper) \n    {\n        helper.setCardinality(obj, Math.max(helper.freqA(obj), helper.freqB(obj)));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Set<O> unionSet = new HashSet<O>();\n    for (O element : a) \n    {\n        unionSet.add(element);\n    }\n    for (O element : b) \n    {\n        unionSet.add(element);\n    }\n    return unionSet;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (O obj : helper) \n    {\n        helper.setCardinality(obj, Math.max(helper.freqA(obj), helper.freqB(obj)));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, Math.max(helper.freqA(obj), helper.freqB(obj)));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, Math.max(helper.freqA(obj), helper.freqB(obj)));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, Math.max(helper.freqA(obj), helper.freqB(obj)));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    Set<O> union = new HashSet<O>();\n    for (O element : a) {\n        union.add(element);\n    }\n    for (O element : b) {\n        union.add(element);\n    }\n    return union;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, Math.max(helper.freqA(obj), helper.freqB(obj)));\n    }\n    return helper.list();\n}"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node param : params.children()) \n    {\n        if (param.isName()) \n        {\n            strings.add(Node.newString(param.getString()));\n        }\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    for (Node child : params.children()) {\n        if (child.isName()) {\n            result.add(new Node(Token.STRING, child.getString()));\n        }\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node current = params;\n    while (current != null) \n    {\n        Node nameNode = current.getFirstChild();\n        if (nameNode != null && nameNode.isName()) \n        {\n            result.add(nameNode);\n        }\n        current = current.getNext();\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    Node current = params;\n    while (current != null) \n    {\n        Node nameNode = current.getFirstChild();\n        if (nameNode != null && nameNode.isName()) \n        {\n            strings.add(nameNode);\n        }\n        current = current.getNext();\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node child = params.getFirstChild(); child != null; child = child.getNext()) {\n        if (child.isName()) {\n            strings.add(Node.newString(child.getString()));\n        }\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    for (Node param : params.children()) \n    {\n        result.add(Node.newString(param.getQualifiedName()));\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node current = params;\n    while (current != null) \n    {\n        Node paramName = current.getFirstChild();\n        if (paramName != null) \n        {\n            result.add(Node.newString(paramName.getString()));\n        }\n        current = current.getNext();\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    for (Node param : params.children()) {\n        if (param.isName()) {\n            result.add(Node.newString(param.getString()));\n        }\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node current = params;\n    while (current != null) \n    {\n        Node paramName = current.getFirstChild();\n        if (paramName != null) \n        {\n            result.add(Node.newString(paramName.getQualifiedName()));\n        }\n        current = current.getNext();\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    for (Node param : params.children()) {\n        if (param.isName()) {\n            result.add(Node.newString(param.getString()));\n        }\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } \n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n        else\n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n        else\n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n        else\n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } \n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n        else\n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n        else\n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } \n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } \n        else \n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) \n    {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n        else\n        {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<String, String>();\n    }\n    String convertedId = cZoneIdConversion.get(id);\n    if (convertedId == null) \n    {\n        convertedId = id;\n        cZoneIdConversion.put(id, convertedId);\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    String convertedId = cZoneIdConversion.get(id);\n    if (convertedId == null) \n    {\n        convertedId = id;\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) {\n        cZoneIdConversion = new HashMap<String, String>();\n    }\n    String convertedId = cZoneIdConversion.get(id);\n    if (convertedId == null) {\n        convertedId = id;\n        cZoneIdConversion.put(id, convertedId);\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<String, String>();\n    }\n\n    String convertedId = cZoneIdConversion.get(id);\n    if (convertedId == null) \n    {\n        convertedId = id;\n        cZoneIdConversion.put(id, convertedId);\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<String, String>();\n    }\n\n    String convertedId = cZoneIdConversion.get(id);\n    if (convertedId == null) \n    {\n        convertedId = id;\n        cZoneIdConversion.put(id, convertedId);\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"C\", \"Asia/Shanghai\");\n        cZoneIdConversion.put(\"E\", \"America/New_York\");\n        cZoneIdConversion.put(\"M\", \"Europe/Paris\");\n        cZoneIdConversion.put(\"P\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"Z\", \"UTC\");\n    }\n    return cZoneIdConversion.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) {\n        return id;\n    }\n    String convertedId = cZoneIdConversion.get(id);\n    if (convertedId == null) {\n        return id;\n    }\n    return convertedId;\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"GMT\", \"GMT\");\n        cZoneIdConversion.put(\"UTC\", \"UTC\");\n        cZoneIdConversion.put(\"PST\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"PDT\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"EST\", \"America/New_York\");\n        cZoneIdConversion.put(\"EDT\", \"America/New_York\");\n        cZoneIdConversion.put(\"CST\", \"America/Chicago\");\n        cZoneIdConversion.put(\"CDT\", \"America/Chicago\");\n        cZoneIdConversion.put(\"MST\", \"America/Denver\");\n        cZoneIdConversion.put(\"MDT\", \"America/Denver\");\n        cZoneIdConversion.put(\"Arizona\", \"US/Arizona\");\n        cZoneIdConversion.put(\"Mountain\", \"US/Mountain\");\n        cZoneIdConversion.put(\"Central\", \"US/Central\");\n        cZoneIdConversion.put(\"Eastern\", \"US/Eastern\");\n        cZoneIdConversion.put(\"Atlantic\", \"Atlantic\");\n        cZoneIdConversion.put(\"Canada\", \"Canada/Atlantic\");\n        cZoneIdConversion.put(\"Eire\", \"Europe/Dublin\");\n        cZoneIdConversion.put(\"Europe\", \"Europe/London\");\n        cZoneIdConversion.put(\"Australia\", \"Australia/Sydney\");\n        cZoneIdConversion.put(\"New Zealand\", \"Pacific/Auckland\");\n        cZoneIdConversion.put(\"Chile\", \"Chile/Continental\");\n        cZoneIdConversion.put(\"Turkey\", \"Turkey\");\n        cZoneIdConversion.put(\"Alaska\", \"US/Alaska\");\n}\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) \n    {\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"GMT\", \"UTC\");\n        cZoneIdConversion.put(\"WET\", \"WEST\");\n        cZoneIdConversion.put(\"CET\", \"CEST\");\n        cZoneIdConversion.put(\"EET\", \"EEST\");\n    }\n    return cZoneIdConversion.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (cZoneIdConversion == null) {\n        return id;\n    }\n    String convertedId = cZoneIdConversion.get(id);\n    if (convertedId == null) {\n        convertedId = id;\n    }\n    return convertedId;\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        // Get the Jacobian matrix\n        double[][] jacobian = computeJacobian(params);\n\n        // Get the weight matrix\n        RealMatrix weightMatrix = getWeight();\n\n        // Check if the dimensions of the weight matrix and the Jacobian match\n        if (weightMatrix.getRowDimension() != jacobian.length) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), jacobian.length);\n        }\n        if (weightMatrix.getColumnDimension() != jacobian[0].length) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), jacobian[0].length);\n        }\n\n        // Compute the weighted Jacobian\n        RealMatrix weightedJacobian = weightMatrix.scalarMultiply(0.5).multiply(weightMatrix.transpose()).multiply(weightMatrix.scalarMultiply(0.5)).multiply(weightMatrix.transpose());\n        weightedJacobian = weightedJacobian.add(weightMatrix.scalarMultiply(0.5).multiply(weightMatrix.transpose()));\n\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        // compute the Jacobian matrix\n        final double[][] jacobian = computeJacobian(params);\n\n        // get the weight matrix\n        final RealMatrix weightMatrix = getWeight();\n\n        // check dimensions\n        if (weightMatrix.getRowDimension() != jacobian.length) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), jacobian.length);\n        }\n        if (weightMatrix.getColumnDimension() != jacobian[0].length) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), jacobian[0].length);\n        }\n\n        // compute the weighted Jacobian\n        final RealMatrix weightedJacobian = weightMatrix.scalarMultiply(0.5).multiply(weightMatrix.transpose()).add(weightMatrix.scalarMultiply(0.5));\n        weightedJacobian.setData(jacobian);\n\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        // Compute the Jacobian matrix.\n        RealMatrix jacobian = jF.gradient(params);\n        int jacobianRows = jacobian.getRowDimension();\n        int jacobianCols = jacobian.getColumnDimension();\n\n        // Check if the Jacobian dimension matches problem dimension.\n        if (jacobianRows != rows || jacobianCols != cols) {\n            throw new DimensionMismatchException(jacobianRows * jacobianCols, rows * cols);\n        }\n\n        // Compute the square root of the weight matrix.\n        RealMatrix weightMatrixSqrt = this.weightMatrixSqrt;\n\n        // Compute the weighted Jacobian: W^(1/2) J.\n        RealMatrix weightedJacobian = weightMatrixSqrt.preMultiply(jacobian);\n\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        // Get the Jacobian matrix.\n        double[][] jacobian = computeJacobian(params);\n\n        // Get the weight matrix.\n        RealMatrix weightMatrix = getWeight();\n\n        // Check the dimensions of the weight matrix.\n        if (weightMatrix.getRowDimension() != jacobian.length) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), jacobian.length);\n        }\n        if (weightMatrix.getColumnDimension() != jacobian[0].length) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), jacobian[0].length);\n        }\n\n        // Compute the weighted Jacobian.\n        RealMatrix weightedJacobian = weightMatrix.scalarMultiply(0.5).multiply(weightMatrix.transpose()).multiply(weightMatrix.scalarMultiply(0.5)).add(weightMatrix.scalarMultiply(0.5));\n        weightedJacobian = weightedJacobian.multiply(weightMatrix.scalarMultiply(0.5).multiply(weightMatrix.transpose()).multiply(weightMatrix.scalarMultiply(0.5)).add(weightMatrix.scalarMultiply(0.5)));\n\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        // Evaluate the Jacobian matrix\n        final double[][] jacobian = computeJacobian(params);\n\n        // Compute the square root of the weight matrix\n        final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n\n        // Compute the weighted Jacobian\n        final int nR = jacobian.length;\n        final int nC = jacobian[0].length;\n        final RealMatrix weightedJacobian = weightMatrixSqrt.createMatrix(nR, nC);\n        for (int i = 0; i < nR; i++) {\n            for (int j = 0; j < nC; j++) {\n                weightedJacobian.setEntry(i, j, jacobian[i][j] * weightMatrixSqrt.getEntry(i, j));\n            }\n        }\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Implement your code here\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    // Implement the method here\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        // Compute the Jacobian matrix\n        final double[][] jacobian = computeJacobian(params);\n        final int nR = jacobian.length;\n        final int nC = jacobian[0].length;\n\n        // Weight matrix square root\n        final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n        if (weightMatrixSqrt.getRowDimension() != nR) {\n            throw new DimensionMismatchException(weightMatrixSqrt.getRowDimension(), nR);\n        }\n        if (weightMatrixSqrt.getColumnDimension() != nC) {\n            throw new DimensionMismatchException(weightMatrixSqrt.getColumnDimension(), nC);\n        }\n\n        // Weighted Jacobian: W^(1/2) J\n        final RealMatrix weightedJacobian = weightMatrixSqrt.multiply(jacobian);\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        if (params == null) {\n            throw new IllegalArgumentException(\"Parameters vector cannot be null\");\n        }\n\n        // Compute Jacobian matrix\n        final DifferentiableMultivariateVectorFunction jF = getObjectiveFunction();\n        final DerivativeStructure[] point = new DerivativeStructure[params.length];\n        for (int i = 0; i < params.length; ++i) {\n            point[i] = new DerivativeStructure(params[i], i, 1);\n        }\n\n        final DerivativeStructure[] jacobian = jF.value(point);\n        final int rows = jacobian.length;\n        final int cols = point.length;\n        final RealMatrix weightedJacobian = MatrixUtils.createRealMatrix(rows, cols);\n\n        // Compute weighted Jacobian\n        for (int i = 0; i < rows; ++i) {\n            final double[] row = jacobian[i].getDerivatives();\n            for (int j = 0; j < cols; ++j) {\n                weightedJacobian.setEntry(i, j, row[j] * Math.sqrt(residualsWeights[i]));\n            }\n        }\n\n        return weightedJacobian;\n    }",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n        // Compute the Jacobian matrix\n        final double[][] jacobian = computeJacobian(params);\n\n        // Get the weight matrix\n        final RealMatrix weightMatrix = getWeight();\n\n        // Check that the weight matrix dimensions match the Jacobian dimensions\n        if (weightMatrix.getRowDimension() != jacobian.length) {\n            throw new DimensionMismatchException(weightMatrix.getRowDimension(), jacobian.length);\n        }\n        if (weightMatrix.getColumnDimension() != jacobian[0].length) {\n            throw new DimensionMismatchException(weightMatrix.getColumnDimension(), jacobian[0].length);\n        }\n\n        // Compute the weighted Jacobian\n        final RealMatrix weightedJacobian = weightMatrix.scalarMultiply(0.5).multiply(weightMatrix.transpose());\n        weightedJacobian.walkInOptimizedOrder(new RealMatrixChangingVisitor() {\n}\n}"
    ],
    [
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator is not set\");\n    }\n    int least = -1;\n    E min = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (min == null || comparator.compare(values.get(i), min) < 0) {\n                min = values.get(i);\n                least = i;\n            }\n        }\n    }\n    if (least == -1) {\n        throw new NoSuchElementException(\"No next element\");\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = -1;\n    E min = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (min == null || comparator.compare(values.get(i), min) < 0) {\n                min = values.get(i);\n                least = i;\n            }\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator is null\");\n    }\n    int least = -1;\n    E min = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (!valueSet.get(i)) {\n            if (min == null || comparator.compare(values.get(i), min) < 0) {\n                least = i;\n                min = values.get(i);\n            }\n        }\n    }\n    if (least == -1) {\n        throw new NoSuchElementException(\"No next element\");\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator is not set\");\n    }\n    int least = -1;\n    E minValue = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (minValue == null || comparator.compare(values.get(i), minValue) < 0) {\n                minValue = values.get(i);\n                least = i;\n            }\n        }\n    }\n    if (least == -1) {\n        throw new NoSuchElementException(\"No next element\");\n    }\n    return least;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator is null\");\n    }\n    int least = -1;\n    E leastValue = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (!valueSet.get(i)) {\n            if (!set(i)) {\n                continue;\n            }\n        } else if (leastValue == null || comparator.compare(values.get(i), leastValue) < 0) {\n            least = i;\n            leastValue = values.get(i);\n        }\n    }\n    if (least == -1) {\n        throw new NoSuchElementException(\"No more elements\");\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator is not set\");\n    }\n    int least = -1;\n    E minValue = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (!valueSet.get(i)) {\n            if (minValue == null || comparator.compare(values.get(i), minValue) < 0) {\n                minValue = values.get(i);\n                least = i;\n            }\n        }\n    }\n    if (least != -1) {\n        set(least);\n    }\n    return least;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = -1;\n    E min = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (min == null || comparator.compare(values.get(i), min) < 0) {\n                min = values.get(i);\n                least = i;\n            }\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    checkNotStarted();\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator is not set\");\n    }\n    int least = -1;\n    E leastValue = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (!valueSet.get(i)) {\n            if (!set(i)) {\n                return i;\n            }\n        }\n        E value = values.get(i);\n        if (least == -1 || comparator.compare(value, leastValue) < 0) {\n            least = i;\n            leastValue = value;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator is not set\");\n    }\n    int least = -1;\n    E leastValue = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (least == -1 || comparator.compare(values.get(i), leastValue) < 0) {\n                least = i;\n                leastValue = values.get(i);\n            }\n        }\n    }\n    if (least == -1) {\n        throw new NoSuchElementException(\"No next element\");\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = -1;\n    E min = null;\n    for (int i = 0; i < values.size(); i++) {\n        if (valueSet.get(i)) {\n            if (min == null || comparator.compare(values.get(i), min) < 0) {\n                min = values.get(i);\n                least = i;\n            }\n        }\n    }\n    if (least == -1) {\n        throw new NoSuchElementException(\"No next element\");\n    }\n    return least;\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodeTest nodeTest = step.getNodeTest();\n        if (nodeTest instanceof NodeNameTest) {\n            NodeNameTest nodeNameTest = (NodeNameTest) nodeTest;\n            QName nodeName = nodeNameTest.getNodeName();\n            return parentPointer.createNodePointer(nodeName);\n        } else if (nodeTest instanceof NodeClassTest) {\n            NodeClassTest nodeClassTest = (NodeClassTest) nodeTest;\n            return parentPointer.createNodePointer(nodeClassTest.getType());\n        } else {\n            throw new IllegalArgumentException(\"Unknown node test type: \" + nodeTest);\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodeTest nodeTest = step.getNodeTest();\n        if (nodeTest instanceof NodeNameTest) {\n            QName name = ((NodeNameTest) nodeTest).getNodeName();\n            return parentPointer.createNodePointer(name, parentPointer.getImmediateNode(), parentPointer.getLocale());\n        } else if (nodeTest instanceof NodeClassTest) {\n            return parentPointer.createNodePointer(((NodeClassTest) nodeTest).getNodeClass(), parentPointer.getImmediateNode(), parentPointer.getLocale());\n        } else if (nodeTest instanceof NodeTypeTest) {\n            return parentPointer.createNodePointer(((NodeTypeTest) nodeTest).getNodeType(), parentPointer.getImmediateNode(), parentPointer.getLocale());\n        } else {\n            throw new IllegalArgumentException(\"Unknown node test: \" + nodeTest);\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    NodeTest nodeTest = step.getNodeTest();\n    if (nodeTest instanceof NodeNameTest) {\n        QName name = ((NodeNameTest) nodeTest).getNodeName();\n        return parentPointer.createNodePointer(name, parentPointer.getLocale());\n    }\n    return parentPointer.createNodePointer(nodeTest.getName(), parentPointer.getLocale());\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodeTest nodeTest = step.getNodeTest();\n        if (nodeTest instanceof NodeNameTest) {\n            QName name = ((NodeNameTest) nodeTest).getNodeName();\n            return parentPointer.createNodePointer(name, parentPointer.getImmediateNode(), parentPointer.getLocale());\n        } else if (nodeTest instanceof NodeClassTest) {\n            return parentPointer.createNodePointer((QName) null, ((NodeClassTest) nodeTest).getNodeClass(), parentPointer.getLocale());\n        } else {\n            throw new IllegalArgumentException(\"Unsupported node test: \" + nodeTest);\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodeTest nodeTest = step.getNodeTest();\n        if (nodeTest instanceof NodeNameTest) {\n            QName name = ((NodeNameTest) nodeTest).getNodeName();\n            return parentPointer.createNodePointer(name, parentPointer.getImmediateNode(), parentPointer.getLocale());\n        } else if (nodeTest instanceof NodeClassTest) {\n            return parentPointer.createNodePointer((QName) null, ((NodeClassTest) nodeTest).getNodeClass(), parentPointer.getLocale());\n        } else {\n            throw new IllegalArgumentException(\"Unknown node test: \" + nodeTest);\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodeTest nodeTest = step.getNodeTest();\n        if (nodeTest instanceof NodeNameTest) {\n            QName name = ((NodeNameTest) nodeTest).getNodeName();\n            return parentPointer.createNodePointer(name, parentPointer, parentPointer.getLocale());\n        } else if (nodeTest instanceof NodeClassTest) {\n            return parentPointer.createNodePointer(((NodeClassTest) nodeTest).getNodeClass(), parentPointer, parentPointer.getLocale());\n        } else {\n            throw new IllegalArgumentException(\"Unknown node test: \" + nodeTest);\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodeTest nodeTest = step.getNodeTest();\n        if (nodeTest instanceof NodeNameTest) {\n            QName name = ((NodeNameTest) nodeTest).getNodeName();\n            return parentPointer.createNodePointer(name, parentPointer.getImmediateNode(), parentPointer.getLocale());\n        } else if (nodeTest instanceof NodeClassTest) {\n            return parentPointer.createNodePointer(parentPointer.getName(), parentPointer.getImmediateNode(), parentPointer.getLocale());\n        } else {\n            throw new IllegalArgumentException(\"Unsupported node test: \" + nodeTest);\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodeTest nodeTest = step.getNodeTest();\n        if (nodeTest instanceof NodeNameTest) {\n            QName name = ((NodeNameTest) nodeTest).getNodeName();\n            return parentPointer.createNodePointer(name, parentPointer.getImmediateNode(), parentPointer.getLocale());\n        } else if (nodeTest instanceof NodeClassTest) {\n            return parentPointer.createNodePointer(((NodeClassTest) nodeTest).getNodeClass(), parentPointer.getImmediateNode(), parentPointer.getLocale());\n        } else {\n            throw new IllegalArgumentException(\"Unsupported node test: \" + nodeTest);\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodeTest nodeTest = step.getNodeTest();\n        if (nodeTest instanceof NodeNameTest) {\n            QName name = ((NodeNameTest) nodeTest).getNodeName();\n            return parentPointer.createNodePointer(name, parentPointer, parentPointer.getLocale());\n        } else if (nodeTest instanceof NodeClassTest) {\n            return parentPointer.createNodePointer(((NodeClassTest) nodeTest).getNodeClass(), parentPointer, parentPointer.getLocale());\n        } else {\n            throw new IllegalArgumentException(\"Unsupported node test: \" + nodeTest);\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        NodeTest nodeTest = step.getNodeTest();\n        if (nodeTest instanceof NodeNameTest) {\n            QName name = ((NodeNameTest) nodeTest).getNodeName();\n            return parentPointer.createNodePointer(name, parentPointer.getImmediateNode(), parentPointer.getLocale());\n        } else if (nodeTest instanceof NodeClassTest) {\n            return parentPointer.createNodePointer(((NodeClassTest) nodeTest).getNodeClass(), parentPointer.getImmediateNode(), parentPointer.getLocale());\n        } else {\n            throw new IllegalArgumentException(\"Unsupported node test: \" + nodeTest);\n        }\n    }"
    ],
    [
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double inf = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf = op.getLocation().getX();\n            node = op.isDirect() ? node.getMinus() : node.getPlus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }",
      "public double getInf()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double inf = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf = op.getLocation().getX();\n            node = op.isDirect() ? node.getMinus() : node.getPlus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }",
      "public double getInf()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double inf = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf = op.getLocation().getX();\n            node = op.isDirect() ? node.getMinus() : node.getPlus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n        BSPTree<Euclidean1D> node = getTree(false);\n        double  inf  = Double.POSITIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            inf  = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n    }",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        cache.putIfAbsent(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if(strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        cache.put(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        cache.put(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n        ConcurrentMap<Locale, Strategy> cache= getCache(field);\n        Strategy strategy= cache.get(locale);\n        if(strategy==null) {\n            strategy= new TextStrategy(field, definingCalendar, locale);\n            cache.putIfAbsent(locale, strategy);\n        }\n        return strategy;\n    }",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= new TextStrategy(field, definingCalendar, locale);\n        cache.put(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if(strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        cache.put(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if (strategy == null) \n    {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        cache.put(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if(strategy == null) \n    {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        cache.putIfAbsent(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if (strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        cache.putIfAbsent(locale, strategy);\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if(strategy == null) {\n        strategy = new TextStrategy(field, definingCalendar, locale);\n        cache.put(locale, strategy);\n    }\n    return strategy;\n}"
    ],
    [
      "private boolean setNextObject()  {\n        boolean rval = false;\n        if (iterator != null && iterator.hasNext()) {\n            nextObject = iterator.next();\n            while (predicate != null && !predicate.evaluate(nextObject) && iterator.hasNext()) {\n                nextObject = iterator.next();\n            }\n            nextObjectSet = true;\n            if (predicate == null || predicate.evaluate(nextObject)) {\n                rval = true;\n            }\n        }\n        return rval;\n    }",
      "private boolean setNextObject()  {\n        boolean rval = false;\n        while (iterator.hasNext()) {\n            nextObject = iterator.next();\n            if (predicate.evaluate(nextObject)) {\n                nextObjectSet = true;\n                rval = true;\n                break;\n            }\n        }\n        nextObjectSet = false;\n        return rval;\n    }",
      "private boolean setNextObject()  {\n        boolean rval = false;\n        Iterator<? extends E> iterator = getIterator();\n        Predicate<? super E> predicate = getPredicate();\n        while (iterator.hasNext()) {\n            E object = iterator.next();\n            if (predicate.evaluate(object)) {\n                nextObject = object;\n                nextObjectSet = true;\n                rval = true;\n                break;\n            }\n        }\n        return rval;\n    }",
      "private boolean setNextObject()  {\n        boolean rval = false;\n        if (iterator != null) {\n            while (iterator.hasNext()) {\n                nextObject = iterator.next();\n                if (predicate == null || predicate.evaluate(nextObject)) {\n                    nextObjectSet = true;\n                    rval = true;\n                    break;\n                }\n            }\n            if (!rval) {\n                nextObject = null;\n                nextObjectSet = false;\n            }\n        }\n        return rval;\n    }",
      "private boolean setNextObject()  {\n        boolean rval = false;\n        while (iterator.hasNext()) {\n            nextObject = iterator.next();\n            if (predicate.evaluate(nextObject)) {\n                nextObjectSet = true;\n                rval = true;\n                break;\n            }\n        }\n        if (!rval) {\n            nextObject = null;\n            nextObjectSet = false;\n        }\n        return rval;\n    }",
      "private boolean setNextObject()  {\n        boolean rval = false;\n        Iterator<? extends E> iterator = getIterator();\n        Predicate<? super E> predicate = getPredicate();\n        while (iterator.hasNext()) {\n            E object = iterator.next();\n            if (predicate.evaluate(object)) {\n                nextObject = object;\n                nextObjectSet = true;\n                rval = true;\n                break;\n            }\n        }\n        return rval;\n    }",
      "private boolean setNextObject()  {\n        boolean rval = false;\n        if (iterator != null && iterator.hasNext()) {\n            nextObject = iterator.next();\n            while (predicate != null && !predicate.evaluate(nextObject) && iterator.hasNext()) {\n                nextObject = iterator.next();\n            }\n            nextObjectSet = true;\n            if (predicate == null || predicate.evaluate(nextObject)) {\n                rval = true;\n            }\n        }\n        return rval;\n    }",
      "private boolean setNextObject()  {\n        boolean rval = false;\n        while (iterator.hasNext()) {\n            nextObject = iterator.next();\n            if (predicate.evaluate(nextObject)) {\n                nextObjectSet = true;\n                rval = true;\n                break;\n            }\n        }\n        if (!rval) {\n            nextObject = null;\n            nextObjectSet = false;\n        }\n        return rval;\n    }",
      "private boolean setNextObject()  {\n        boolean rval = false;\n        while (iterator.hasNext()) {\n            nextObject = iterator.next();\n            if (predicate.evaluate(nextObject)) {\n                nextObjectSet = true;\n                rval = true;\n                break;\n            }\n        }\n        if (!rval) {\n            nextObject = null;\n            nextObjectSet = false;\n        }\n        return rval;\n    }",
      "private boolean setNextObject()  {\n        boolean rval = false;\n        while (iterator.hasNext()) {\n            nextObject = iterator.next();\n            if (predicate.evaluate(nextObject)) {\n                nextObjectSet = true;\n                rval = true;\n                break;\n            }\n        }\n        if (!rval) {\n            nextObject = null;\n            nextObjectSet = false;\n        }\n        return rval;\n    }"
    ],
    [
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) \n    {\n        if (x[i] < lB[i]) \n        {\n            repaired[i] = lB[i];\n        } \n        else if (x[i] > uB[i]) \n        {\n            repaired[i] = uB[i];\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        repaired[i] = Math.max(lB[i], Math.min(uB[i], x[i]));\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) \n    {\n        repaired[i] = Math.max(lB[i], Math.min(uB[i], x[i]));\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) \n    {\n        repaired[i] = Math.max(lB[i], Math.min(uB[i], x[i]));\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        repaired[i] = Math.max(lB[i], Math.min(uB[i], x[i]));\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        repaired[i] = Math.max(lB[i], Math.min(uB[i], x[i]));\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                repaired[i] = Math.max(lB[i], Math.min(uB[i], x[i]));\n            }\n            return repaired;\n        }",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    for (int i = 0; i < x.length; i++) {\n        repaired[i] = Math.max(lB[i], Math.min(uB[i], x[i]));\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n\n    for (int i = 0; i < x.length; i++) {\n        repaired[i] = Math.max(lB[i], Math.min(uB[i], x[i]));\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n\n    for (int i = 0; i < x.length; i++) {\n        repaired[i] = Math.max(lB[i], Math.min(uB[i], x[i]));\n    }\n    return repaired;\n}"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    realEigenvalues = transformer.getT().getData();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    main = transformer.getT().getData();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    realEigenvalues = transformer.getT().getData();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    realEigenvalues = transformer.getT().getData();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    main = transformer.getT().getData();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    realEigenvalues = transformer.getT().getData();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    main = transformer.getT().getData();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    realEigenvalues = transformer.getT().getData();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    realEigenvalues = transformer.getT().getData();\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    realEigenvalues = transformer.getT().getData();\n    return transformer;\n}"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) \n    {\n        long value = values[i];\n        for (int j = 0; j < 64; j++) \n        {\n            if ((value & (1L << j)) != 0) \n            {\n                result.add(enumClass.getEnumConstants()[i * 64 + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) \n    {\n        long value = values[i];\n        for (int j = 0; j < 64 && (value & 1) != 0; j++, value >>>= 1) \n        {\n            if ((value & 1) != 0) \n            {\n                result.add(enumClass.getEnumConstants()[i * 64 + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (int i = 0; i < Long.SIZE; i++) {\n            if ((value & (1 << i)) != 0) {\n                result.add(enumClass.getEnumConstants()[i]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) \n    {\n        long value = values[i];\n        for (int j = 0; j < Long.SIZE; j++) \n        {\n            if ((value & (1 << j)) != 0) \n            {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    long[] reversed = new long[values.length];\n    for (int i = 0; i < values.length; i++) \n    {\n        reversed[i] = Long.reverseBytes(values[i]);\n    }\n    ArrayUtils.reverse(reversed);\n    for (int i = 0; i < reversed.length; i++) \n    {\n        for (int j = 0; j < Long.SIZE; j++) \n        {\n            if ((reversed[i] & (1 << j)) != 0) \n            {\n                result.add(enumClass.getEnumConstants()[Long.SIZE * i + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    long[] reversed = new long[values.length];\n    for (int i = 0; i < values.length; i++) \n    {\n        reversed[i] = Long.reverseBytes(values[i]);\n    }\n    ArrayUtils.reverse(reversed);\n    for (int i = 0; i < reversed.length; i++) \n    {\n        for (int j = 0; j < Long.SIZE; j++) \n        {\n            if ((reversed[i] & (1 << j)) != 0) \n            {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((value & (1 << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    EnumSet<E> result = EnumSet.noneOf(enumClass);\n    E[] constants = enumClass.getEnumConstants();\n    ArrayUtils.reverse(values);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((value & (1 << j)) != 0) {\n                result.add(constants[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    final E[] constants = enumClass.getEnumConstants();\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((value & 1) != 0) {\n                result.add(constants[i * Long.SIZE + j]);\n            }\n            value >>>= 1;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n        asEnum(enumClass);\n        Validate.notNull(values);\n        EnumSet<E> result = EnumSet.noneOf(enumClass);\n        for (int i = 0; i < values.length; i++) {\n            long value = values[i];\n            for (int j = 0; j < Long.SIZE; j++) {\n                if ((value & (1 << j)) != 0) {\n                    result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n                }\n            }\n        }\n        return result;\n    }"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    int oldOffset = getOffset(oldInstant);\n    long newInstant = oldInstant + oldOffset;\n    int newOffset = newZone.getOffset(newInstant);\n    return newInstant + newOffset;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    int oldOffset = getOffset(oldInstant);\n    long newInstant = oldInstant + oldOffset;\n    int newOffset = newZone.getOffset(newInstant);\n    return newInstant + newOffset;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    int oldOffset = getOffset(oldInstant);\n    long newInstant = oldInstant + oldOffset;\n    int newOffset = newZone.getOffset(newInstant);\n    return newInstant + newOffset;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    long newInstant = oldInstant + getOffset(oldInstant);\n    return newZone.convertUTCToLocal(newInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    long instantLocal = oldInstant + getOffset(oldInstant);\n    long instantNewZone = newZone.convertLocalToUTC(instantLocal, true, oldInstant);\n    return instantNewZone;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    long instantLocal = convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    long newInstant = convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(newInstant, true, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    long instantLocal = oldInstant + getOffset(oldInstant);\n    return newZone.convertLocalToUTC(instantLocal, true, oldInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offsetOld = getOffset(oldInstant);\n    long newInstant = oldInstant + offsetOld;\n    int offsetNew = newZone.getOffset(newInstant);\n    return newInstant + offsetNew;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) \n    {\n        newZone = DateTimeZone.getDefault();\n    }\n    int offsetOld = getOffset(oldInstant);\n    long newInstant = oldInstant + offsetOld;\n    int offsetNew = newZone.getOffset(newInstant);\n    return newInstant + offsetNew;\n}"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    if (unit == null) \n    {\n        throw new IllegalArgumentException(\"Null 'unit' argument.\");\n    }\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count) / count);\n\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    if (unit == null) \n    {\n        throw new IllegalArgumentException(\"Null 'unit' argument.\");\n    }\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count) / count);\n\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count) / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count) / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count) / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    if (unit == null) \n    {\n        throw new IllegalArgumentException(\"Null 'unit' argument.\");\n    }\n    if (date == null) \n    {\n        throw new IllegalArgumentException(\"Null 'date' argument.\");\n    }\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count) / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    if (date == null) \n    {\n        throw new IllegalArgumentException(\"Null 'date' argument.\");\n    }\n    if (unit == null) \n    {\n        throw new IllegalArgumentException(\"Null 'unit' argument.\");\n    }\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count) / count);\n\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    if (date == null) \n    {\n        throw new IllegalArgumentException(\"Null 'date' argument.\");\n    }\n    if (unit == null) \n    {\n        throw new IllegalArgumentException(\"Null 'unit' argument.\");\n    }\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count) / count);\n\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count) / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count) / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver == null) {\n        return null;\n    }\n    return variableResolver.lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver != null) \n    {\n        return variableResolver.lookup(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver == null) {\n        return null;\n    }\n    return variableResolver.lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver == null) {\n        return null;\n    }\n    return variableResolver.lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (getVariableResolver() == null) {\n        return null;\n    }\n    return getVariableResolver().lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver != null) {\n        return variableResolver.lookup(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver != null) \n    {\n        return variableResolver.lookup(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String value = null;\n    if (variableResolver != null) {\n        value = variableResolver.lookup(variableName);\n    }\n    if (value == null && enableSubstitutionInVariables) {\n        value = variableName;\n    }\n    if (value != null) {\n        buf.delete(startPos, endPos);\n        buf.insert(startPos, value);\n    }\n    return value;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver != null) \n    {\n        return variableResolver.lookup(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    String result = null;\n    if (getVariableResolver() != null) \n    {\n        result = getVariableResolver().lookup(variableName);\n    }\n    if (result == null && isEnableSubstitutionInVariables()) \n    {\n        // Try to resolve variable in the variable name itself\n        result = variableName;\n    }\n    if (result != null) \n    {\n        buf.delete(startPos, endPos);\n        buf.insert(startPos, result);\n    }\n    return result;\n}"
    ],
    [
      "public String soundex(String str)  {\n    // your code here\n}",
      "public String soundex(String str)  {\n    // Your code here\n}",
      "public String soundex(String str)  {\n    // Your code here\n}",
      "public String soundex(String str)  {\n    // Your code here\n}",
      "public String soundex(String str)  {\n    // your code here\n}",
      "public String soundex(String str)  {\n    // Your code goes here\n}",
      "public String soundex(String str)  {\n    str = str.toUpperCase();\n    StringBuilder code = new StringBuilder();\n    code.append(str.charAt(0));\n    for (int i = 1; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if (c >= 'A' && c <= 'Z') {\n            char mapped = map(c);\n            if (mapped != '0') {\n                code.append(mapped);\n            }\n        }\n    }\n    while (code.length() < 6) {\n        code.append('0');\n    }\n    return code.toString();\n}",
      "public String soundex(String str)  {\n    str = str.toUpperCase();\n    StringBuilder result = new StringBuilder();\n    result.append(str.charAt(0));\n    for (int i = 1; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if (c >= 'A' && c <= 'Z') {\n            result.append(map(c));\n        }\n    }\n    while (result.length() < 6) {\n        result.append('0');\n    }\n    return result.toString();\n}",
      "public String soundex(String str)  {\n    // your code here\n}",
      "public String soundex(String str)  {\n    // Your code goes here\n}"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n        if (clz == CLS_STRING) {\n            return CORE_TYPE_STRING;\n        }\n        if (clz == CLS_OBJECT) {\n            return CORE_TYPE_OBJECT;\n        }\n        if (clz == CLS_COMPARABLE) {\n            return CORE_TYPE_COMPARABLE;\n        }\n        if (clz == CLS_CLASS) {\n            return CORE_TYPE_CLASS;\n        }\n        if (clz == CLS_ENUM) {\n            return CORE_TYPE_ENUM;\n        }\n        if (clz == CLS_BOOL) {\n            return CORE_TYPE_BOOL;\n        }\n        if (clz == CLS_INT) {\n            return CORE_TYPE_INT;\n        }\n        if (clz == CLS_LONG) {\n            return CORE_TYPE_LONG;\n        }\n        return null;\n    }",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n        if (clz == CLS_STRING) {\n            return CORE_TYPE_STRING;\n        }\n        if (clz == CLS_OBJECT) {\n            return CORE_TYPE_OBJECT;\n        }\n        if (clz == CLS_COMPARABLE) {\n            return CORE_TYPE_COMPARABLE;\n        }\n        if (clz == CLS_CLASS) {\n            return CORE_TYPE_CLASS;\n        }\n        if (clz == CLS_ENUM) {\n            return CORE_TYPE_ENUM;\n        }\n        if (clz == CLS_BOOL) {\n            return CORE_TYPE_BOOL;\n        }\n        if (clz == CLS_INT) {\n            return CORE_TYPE_INT;\n        }\n        if (clz == CLS_LONG) {\n            return CORE_TYPE_LONG;\n        }\n        return null;\n    }",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n        if (clz == CLS_STRING) {\n            return CORE_TYPE_STRING;\n        }\n        if (clz == CLS_OBJECT) {\n            return CORE_TYPE_OBJECT;\n        }\n        if (clz == CLS_COMPARABLE) {\n            return CORE_TYPE_COMPARABLE;\n        }\n        if (clz == CLS_CLASS) {\n            return CORE_TYPE_CLASS;\n        }\n        if (clz == CLS_ENUM) {\n            return CORE_TYPE_ENUM;\n        }\n        if (clz == CLS_BOOL) {\n            return CORE_TYPE_BOOL;\n        }\n        if (clz == CLS_INT) {\n            return CORE_TYPE_INT;\n        }\n        if (clz == CLS_LONG) {\n            return CORE_TYPE_LONG;\n        }\n        return null;\n    }",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    }\n    if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    }\n    if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    }\n    if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    }\n    if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    }\n    if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    }\n    if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    }\n    if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n        if (clz == CLS_STRING) {\n            return CORE_TYPE_STRING;\n        }\n        if (clz == CLS_OBJECT) {\n            return CORE_TYPE_OBJECT;\n        }\n        if (clz == CLS_COMPARABLE) {\n            return CORE_TYPE_COMPARABLE;\n        }\n        if (clz == CLS_CLASS) {\n            return CORE_TYPE_CLASS;\n        }\n        if (clz == CLS_ENUM) {\n            return CORE_TYPE_ENUM;\n        }\n        if (clz == CLS_BOOL) {\n            return CORE_TYPE_BOOL;\n        }\n        if (clz == CLS_INT) {\n            return CORE_TYPE_INT;\n        }\n        if (clz == CLS_LONG) {\n            return CORE_TYPE_LONG;\n        }\n        return null;\n    }",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n        if (clz == CLS_STRING) {\n            return CORE_TYPE_STRING;\n        }\n        if (clz == CLS_OBJECT) {\n            return CORE_TYPE_OBJECT;\n        }\n        if (clz == CLS_COMPARABLE) {\n            return CORE_TYPE_COMPARABLE;\n        }\n        if (clz == CLS_CLASS) {\n            return CORE_TYPE_CLASS;\n        }\n        if (clz == CLS_ENUM) {\n            return CORE_TYPE_ENUM;\n        }\n        if (clz == CLS_BOOL) {\n            return CORE_TYPE_BOOL;\n        }\n        if (clz == CLS_INT) {\n            return CORE_TYPE_INT;\n        }\n        if (clz == CLS_LONG) {\n            return CORE_TYPE_LONG;\n        }\n        return null;\n    }",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    } \n    else if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    } \n    else if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    } \n    else if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    } \n    else if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    } \n    else if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    } \n    else if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    } \n    else if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLS_STRING) {\n        return CORE_TYPE_STRING;\n    } \n    else if (clz == CLS_OBJECT) {\n        return CORE_TYPE_OBJECT;\n    } \n    else if (clz == CLS_COMPARABLE) {\n        return CORE_TYPE_COMPARABLE;\n    } \n    else if (clz == CLS_CLASS) {\n        return CORE_TYPE_CLASS;\n    } \n    else if (clz == CLS_ENUM) {\n        return CORE_TYPE_ENUM;\n    } \n    else if (clz == CLS_BOOL) {\n        return CORE_TYPE_BOOL;\n    } \n    else if (clz == CLS_INT) {\n        return CORE_TYPE_INT;\n    } \n    else if (clz == CLS_LONG) {\n        return CORE_TYPE_LONG;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n        if (clz == CLS_STRING) {\n            return CORE_TYPE_STRING;\n        }\n        if (clz == CLS_OBJECT) {\n            return CORE_TYPE_OBJECT;\n        }\n        if (clz == CLS_COMPARABLE) {\n            return CORE_TYPE_COMPARABLE;\n        }\n        if (clz == CLS_CLASS) {\n            return CORE_TYPE_CLASS;\n        }\n        if (clz == CLS_ENUM) {\n            return CORE_TYPE_ENUM;\n        }\n        if (clz == CLS_BOOL) {\n            return CORE_TYPE_BOOL;\n        }\n        if (clz == CLS_INT) {\n            return CORE_TYPE_INT;\n        }\n        if (clz == CLS_LONG) {\n            return CORE_TYPE_LONG;\n        }\n        return null;\n    }"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n      if (n.isAssign() && n.getFirstChild().isGetProp()) {\n        Node lhs = n.getFirstChild().getFirstChild();\n        if (NodeUtil.isPrototypeProperty(lhs)) {\n          return new PrototypeMemberDeclaration(lhs, n);\n        }\n      }\n      return null;\n    }\n  }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign() && n.getFirstChild().isGetProp()) {\n        Node lhs = n.getFirstChild().getFirstChild();\n        if (lhs.isName() && lhs.getString().equals(\"prototype\")) {\n            return new PrototypeMemberDeclaration(lhs, n);\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign() && n.getFirstChild().isGetProp()) \n    {\n        Node lhs = n.getFirstChild().getFirstChild();\n        if (lhs.isName() && lhs.getString().equals(\"prototype\")) \n        {\n            return new PrototypeMemberDeclaration(lhs, n);\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.getType() != Node.ASSIGN) {\n        return null;\n    }\n    Node lhs = n.getFirstChild();\n    if (!lhs.isGetProp() || lhs.getFirstChild().getType() != Node.NAME) {\n        return null;\n    }\n    Node nameNode = lhs.getFirstChild();\n    if (!nameNode.getString().equals(\"prototype\")) {\n        return null;\n    }\n    Node parent = lhs.getParent();\n    if (parent == null || parent.getType() != Node.DOT) {\n        return null;\n    }\n    return new PrototypeMemberDeclaration(lhs, n);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n      if (n.isAssign() && n.getFirstChild().isGetProp()) {\n        Node lhs = n.getFirstChild().getFirstChild();\n        if (NodeUtil.isPrototypeProperty(lhs)) {\n          return new PrototypeMemberDeclaration(lhs, n);\n        }\n      }\n      return null;\n    }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n      if (!n.isAssign()) {\n        return null;\n      }\n      Node lhs = n.getFirstChild().getFirstChild();\n      if (!lhs.isName() && !lhs.isQualifiedName()) {\n        return null;\n      }\n      if (!NodeUtil.isPrototypeMember(lhs)) {\n        return null;\n      }\n      return new PrototypeMemberDeclaration(lhs, n);\n    }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (!n.isAssign()) \n    {\n        return null;\n    }\n    Node child = n.getFirstChild();\n    if (!child.isName() && !child.isGetProp() && !child.isGetElem()) \n    {\n        return null;\n    }\n    Node lhs = child;\n    Node rhs = n.getNext();\n    if (rhs == null || !rhs.isExprResult()) \n    {\n        return null;\n    }\n    return new PrototypeMemberDeclaration(lhs, n);\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n      if (n.isAssign() && n.getChildCount() == 2) {\n        Node lhs = n.getFirstChild();\n        if (lhs.isGetProp() && lhs.getChildCount() == 2) {\n          Node prop = lhs.getFirstChild();\n          if (prop.isName() && prop.getString().equals(\"prototype\")) {\n            Node parent = lhs.getParent();\n            if (parent.isName() || parent.isQualifiedName()) {\n              return new PrototypeMemberDeclaration(lhs, n);\n            }\n          }\n        }\n      }\n      return null;\n    }\n  }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n      if (!n.hasChildren()) {\n        return null;\n      }\n      Node firstChild = n.getFirstChild();\n      if (!firstChild.isAssign()) {\n        return null;\n      }\n      Node lhs = firstChild.getFirstChild();\n      if (!lhs.isName() && !lhs.isGetProp() && !lhs.isGetElem()) {\n        return null;\n      }\n      return new PrototypeMemberDeclaration(lhs, n);\n    }\n  }",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n      if (n.isAssign() && n.getFirstChild().isGetProp()) {\n        Node lhs = n.getFirstChild().getFirstChild();\n        if (NodeUtil.getPrototypeClassName(lhs) != null) {\n          return new PrototypeMemberDeclaration(lhs, n);\n        }\n      }\n      return null;\n    }"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    double[][] data = mat.getData();\n    double[][] repData = new double[n * data.length][m * data[0].length];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int k = 0; k < data.length; k++) {\n                System.arraycopy(data[k], 0, repData[i * data.length + k], j * data[0].length, data[0].length);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(repData, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    double[][] data = mat.getData();\n    double[][] repData = new double[n * data.length][m * data[0].length];\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            for (int k = 0; k < data.length; k++) \n            {\n                System.arraycopy(data[k], 0, repData[i * data.length + k], j * data[0].length, data[0].length);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(repData, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    double[][] data = mat.getData();\n    double[][] repData = new double[n * data.length][m * data[0].length];\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int k = 0; k < data.length; k++) {\n                System.arraycopy(data[k], 0, repData[i * data.length + k], j * data[0].length, data[0].length);\n            }\n        }\n    }\n\n    return new Array2DRowRealMatrix(repData, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    double[][] data = mat.getData();\n    double[][] repData = new double[n * data.length][m * data[0].length];\n\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            for (int k = 0; k < data.length; k++) \n            {\n                System.arraycopy(data[k], 0, repData[i * data.length + k], j * data[0].length, data[0].length);\n            }\n        }\n    }\n\n    return new Array2DRowRealMatrix(repData, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    double[][] data = mat.getData();\n    double[][] repData = new double[n * data.length][m * data[0].length];\n\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            for (int k = 0; k < data.length; k++) \n            {\n                System.arraycopy(data[k], 0, repData[i * data.length + k], j * data[0].length, data[0].length);\n            }\n        }\n    }\n\n    return new Array2DRowRealMatrix(repData, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    double[][] data = mat.getData();\n    double[][] repData = new double[n * data.length][m * data[0].length];\n\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            for (int k = 0; k < data.length; k++) \n            {\n                System.arraycopy(data[k], 0, repData[i * data.length + k], j * data[0].length, data[0].length);\n            }\n        }\n    }\n\n    return new Array2DRowRealMatrix(repData, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    double[][] data = mat.getData();\n    double[][] repData = new double[n * data.length][m * data[0].length];\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int k = 0; k < data.length; k++) {\n                System.arraycopy(data[k], 0, repData[i * data.length + k], j * data[0].length, data[0].length);\n            }\n        }\n    }\n\n    return new Array2DRowRealMatrix(repData, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    double[][] data = mat.getData();\n    double[][] repData = new double[n * data.length][m * data[0].length];\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int k = 0; k < data.length; k++) {\n                System.arraycopy(data[k], 0, repData[i * data.length + k], j * data[0].length, data[0].length);\n            }\n        }\n    }\n\n    return new Array2DRowRealMatrix(repData, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    double[][] data = mat.getData();\n    double[][] repmatData = new double[n * data.length][m * data[0].length];\n\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            for (int k = 0; k < data.length; k++) \n            {\n                System.arraycopy(data[k], 0, repmatData[i * data.length + k], j * data[0].length, data[0].length);\n            }\n        }\n    }\n\n    return new Array2DRowRealMatrix(repmatData, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    double[][] data = mat.getData();\n    double[][] repData = new double[n * data.length][m * data[0].length];\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            for (int k = 0; k < data.length; k++) \n            {\n                System.arraycopy(data[k], 0, repData[i * data.length + k], j * data[0].length, data[0].length);\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(repData, false);\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesRead();\n    if (bytesInflated > current.bytesRead) {\n        bytesInflated = current.bytesRead;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    return inf.getTotalIn() & 0x7fffffff;\n}",
      "private long getBytesInflated()  {\n    return current.bytesRead - inf.getBytesRead();\n}",
      "private long getBytesInflated()  {\n    long inflated = inf.getBytesInflated();\n    if (inflated > current.bytesRead) {\n        inflated = current.bytesRead;\n    }\n    return inflated;\n}",
      "private long getBytesInflated()  {\n    return inf.getBytesRead();\n}",
      "private long getBytesInflated()  {\n    long inflated = inf.getBytesRead();\n    if (inflated < 0) {\n        inflated = TWO_EXP_32 + inflated;\n    }\n    return inflated;\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesRead();\n    if (bytesInflated > current.bytesReadFromStream) {\n        bytesInflated = current.bytesReadFromStream;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    return inf.getTotalIn() & 0x7fffffff;\n}",
      "private long getBytesInflated()  {\n    return current.bytesRead - inf.getBytesRead();\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesRead();\n    if (bytesInflated > current.bytesReadFromStream) {\n        bytesInflated = current.bytesReadFromStream;\n    }\n    return bytesInflated;\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    if (object instanceof Dictionary) {\n        return ((Dictionary<?, ?>) object).isEmpty();\n    }\n    if (object.getClass().isArray()) {\n        return Array.getLength(object) == 0;\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Iterable<?>) {\n        return !IterableUtils.iterator((Iterable<?>) object).hasNext();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    if (object.getClass().isArray()) {\n        return Array.getLength(object) == 0;\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Iterable<?>) {\n        return !IterableUtils.iterator((Iterable<?>) object).hasNext();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    if (object.getClass().isArray()) {\n        return Array.getLength(object) == 0;\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Iterable<?>) {\n        return !((Iterable<?>) object).iterator().hasNext();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    if (object.getClass().isArray()) {\n        return Array.getLength(object) == 0;\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Iterable<?>) {\n        return !IterableUtils.iterator((Iterable<?>) object).hasNext();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    if (object.getClass().isArray()) {\n        return Array.getLength(object) == 0;\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Iterable<?>) {\n        return !((Iterable<?>) object).iterator().hasNext();\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    if (object.getClass().isArray()) {\n        return Array.getLength(object) == 0;\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    if (object instanceof NodeList) {\n        return ((NodeList) object).getLength() == 0;\n    }\n    if (object instanceof Node) {\n        return ((Node) object).getChildNodes().getLength() == 0;\n    }\n    if (object instanceof Dictionary) {\n        return ((Dictionary<?, ?>) object).isEmpty();\n    }\n    if (object.getClass().isArray()) {\n        return Array.getLength(object) == 0;\n    }\n    try {\n        return Array.getLength(object) == 0;\n    } catch (final IllegalArgumentException ex) {\n        throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    return size(object) == 0;\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    }\n    if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    }\n    if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    }\n    if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    }\n    if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    }\n    if (object.getClass().isArray()) {\n        return Array.getLength(object) == 0;\n    }\n    throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    return size(object) == 0;\n}"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.isEmpty()) \n    {\n        return false;\n    }\n\n    int dotCount = 0;\n    for (int i = 0; i < name.length(); i++) \n    {\n        char c = name.charAt(i);\n        if (c == '.') \n        {\n            dotCount++;\n        } \n        else if (!isValidSimpleName(name.substring(i))) \n        {\n            return false;\n        }\n    }\n\n    return dotCount > 0;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // The check is done on the assumption that a valid simple name is a valid\n    // qualified name. This may not be the case in ES3.\n    if (isValidSimpleName(name)) {\n      return true;\n    }\n\n    // A qualified name is a string of simple names separated by dots.\n    // A simple name is a valid identifier that is not a reserved word.\n    // A reserved word is a keyword in the language.\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n      if (!isValidSimpleName(part)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    // A qualified name must have at least one dot.\n    if (!name.contains(\".\")) {\n      return false;\n    }\n\n    // Split the name into segments.\n    String[] segments = name.split(\"\\\\.\");\n\n    // Check each segment.\n    for (String segment : segments) {\n      // A segment must be a valid simple name.\n      if (!isValidSimpleName(segment)) {\n        return false;\n      }\n    }\n\n    // If we've made it here, the name is a valid qualified name.\n    return true;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name == null) {\n      return false;\n    }\n    int dotCount = 0;\n    int len = name.length();\n    for (int i = 0; i < len; i++) {\n      char c = name.charAt(i);\n      if (c == '.') {\n        dotCount++;\n      } else if (!isValidSimpleName(name.substring(i))) {\n        return false;\n      }\n    }\n    return dotCount > 0;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // Note that by this point, Unicode escapes have been converted\n    // to UTF-16 characters, so we're only searching for character\n    // values, not escapes.\n    return isLatin(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return name.contains(\".\") && isValidSimpleName(name.substring(0, name.lastIndexOf(\".\"))) && isValidSimpleName(name.substring(name.lastIndexOf(\".\") + 1));\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name.isEmpty()) {\n      return false;\n    }\n    int dotIndex = name.indexOf('.');\n    if (dotIndex == -1) {\n      return isValidSimpleName(name);\n    }\n    return isValidSimpleName(name.substring(0, dotIndex)) &&\n        isValidQualifiedName(name.substring(dotIndex + 1));\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // The name must contain at least one dot.\n    if (!name.contains(\".\")) {\n      return false;\n    }\n\n    // The name must be valid simple name.\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n      if (!isValidSimpleName(part)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name == null || name.isEmpty()) {\n        return false;\n    }\n\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n        if (!isValidSimpleName(part)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name == null || name.length() == 0) {\n        return false;\n    }\n\n    String[] parts = name.split(\"\\\\.\");\n    for (String part : parts) {\n        if (!isValidSimpleName(part)) {\n            return false;\n        }\n    }\n\n    return true;\n}"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // the initial houseHolder vector for the QR step\n    final double[] hVec = new double[3];\n\n    // compute shift\n    computeShift(il, iu, 0, shift);\n\n    // compute initial householder vector\n    double z = (matrixT[iu][iu] - shift.x) / 2.0;\n    double t = Math.sqrt(z * z + matrixT[iu][iu - 1] * matrixT[iu - 1][iu - 1]);\n    if (z <= 0.0) {\n        t = -t;\n    }\n    hVec[0] = z + t;\n    hVec[1] = -matrixT[iu - 1][iu - 1] * (z / (z + t));\n    hVec[2] = hVec[0] * hVec[1] - matrixT[iu][iu - 1];\n\n    // scale householder vector\n    double h1 = hVec[0] * hVec[0] + hVec[1] * hVec[1] + hVec[2] * hVec[2];\n    hVec[0] = hVec[0] / Math.sqrt(h1);\n    hVec[1] = hVec[1] / Math.sqrt(h1);\n    hVec[2] = hVec[2] / Math.sqrt(h1);\n\n    // apply householder transformation to T\n    for (int k = iu; k >= il; k--) {\n        double d = matrixT[k][k];\n        double e = matrixT[k - 1][k - 1];\n        double f = hVec[0] * d + hVec[1] * e;\n        matrixT[k][k] = f;\n        matrixT[k - 1][k] = 0.0;\n        if (k - 2 >= il) {\n            double g = matrixT[k - 2][k - 2];\n            double h = hVec[0] * e + hVec[1] * g;\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = il;\n    double scale = 0.0;\n    double h = 0.0;\n    for (int k = im; k <= iu; k++) {\n        scale += Math.abs(matrixT[k][k - 1]);\n    }\n    if (scale != 0.0) {\n        double s1 = Math.abs(matrixT[im][im - 1]) / scale;\n        double s2 = Math.sqrt(s1 * s1 + 1.0);\n        h = s1 * s2;\n        hVec[0] = h;\n        hVec[1] = (matrixT[im][im - 1] > 0.0) ? (s1 + scale / h) : (s1 - scale / h);\n        hVec[2] = -h * matrixT[im][im - 1];\n        matrixT[im][im - 1] = -s2;\n        for (int k = im; k <= iu; k++) {\n            matrixT[k][k - 1] /= h;\n        }\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = il;\n    if (il == iu) \n    {\n        // One root found\n        double h = matrixT[iu][iu];\n        hVec[0] = h;\n        hVec[1] = 0.0;\n        hVec[2] = 0.0;\n        matrixT[iu][iu] = 1.0;\n        for (int k = 0; k <= iu - 1; k++) \n        {\n            matrixT[k][iu] = 0.0;\n        }\n    } \n    else \n    {\n        // Two roots found\n        double g = matrixT[iu - 1][iu - 1] - matrixT[iu][iu];\n        double p = matrixT[iu - 1][iu];\n        double r = matrixT[iu][iu - 1];\n        double f = ((g * g) + (p * p)) / 2.0;\n        double t = p * p;\n\n        for (int k = 0; k <= iu - 1; k++) \n        {\n            t += (matrixT[k][iu - 1] * matrixT[k][iu - 1]);\n        }\n\n        if (f > 0.0) \n        {\n            double tmp1 = (g * g) - ((matrixT[iu - 1][iu - 1] - matrixT[iu][iu]) * (matrixT[iu - 1][iu - 1] + matrixT[iu][iu]));\n            double tmp2 = FastMath.sqrt(f * f + r * r + p * p);\n            g = matrixT[iu - 1][iu - 1] - (matrixT[iu][iu] + tmp1 / (g + FastMath.signum(g) * tmp2));\n            shift.exShift = g;\n            hVec[0] = g;\n            hVec[1] = r;\n            hVec[2] = p;\n            matrixT[iu - 1][iu - 1] = g;\n            matrixT[iu - 1][iu] = r;\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu;\n    if (il != 0) \n    {\n        im = il - 1;\n    }\n    double h = 0.0;\n    double scale = 0.0;\n    double hh = 0.0;\n    for (int i = im; i <= iu; i++) \n    {\n        scale = scale + FastMath.abs(matrixT[i][i - 1]);\n    }\n    if (scale == 0.0) \n    {\n        hVec[0] = hVec[1] = hVec[2] = 0.0;\n    } \n    else \n    {\n        double sx = (scale / FastMath.abs(matrixT[im][im - 1])) / scale;\n        h = matrixT[im][im - 1] * sx;\n        hh = h * h;\n        hVec[0] = hh;\n        hVec[1] = -2.0 * h * sx;\n        hVec[2] = (sx * sx) * (scale / scale - h * h);\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // the initial houseHolder vector for the QR step\n    final double[] hVec = new double[3];\n\n    // compute the houseHolder vector\n    double h = 0.0;\n    double f = 0.0;\n    double g = 0.0;\n    for (int i = il; i <= iu; i++) {\n        h += matrixT[i][i - 1] * matrixT[i][i - 1];\n    }\n    if (h != 0.0) {\n        double scale = Math.sqrt(h);\n        double hh = Math.abs(matrixT[il][il - 1]);\n        if (hh != 0.0) {\n            if (h / hh > scale) {\n                scale = h / hh;\n            }\n        }\n        h = hh * scale;\n        hVec[0] = h;\n        f = hVec[0] * matrixT[il][il - 1];\n        g = -scale * scale * matrixT[il][il - 1] * matrixT[il][il - 1];\n        hVec[1] = g;\n        hVec[2] = f;\n        for (int i = il; i <= iu; i++) {\n            matrixT[i][i - 1] = matrixT[i][i - 1] * scale;\n        }\n        shift.x = Math.sqrt(f * f + g * g);\n        if (f > 0.0) {\n            shift.x = -shift.x;\n        }\n        shift.exShift += h;\n        hVec[0] = h + shift.x;\n        hVec[1] = f / hVec[0];\n        hVec[2] = g / hVec[0];\n    }\n    return il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    // the initial houseHolder vector for the QR step\n    final double[] hVec = new double[3];\n\n    // compute the norm of the column\n    double norm = 0.0;\n    for (int i = il; i <= iu; i++) {\n        norm += matrixT[i][iu] * matrixT[i][iu];\n    }\n    norm = FastMath.sqrt(norm);\n\n    // compute the householder vector\n    if (matrixT[iu][iu] < 0.0) {\n        hVec[0] = matrixT[iu][iu] - norm;\n    } else {\n        hVec[0] = -norm;\n    }\n    hVec[1] = matrixT[il][iu];\n    hVec[2] = norm;\n\n    // normalize the householder vector\n    double length = FastMath.sqrt(hVec[0] * hVec[0] + hVec[1] * hVec[1]);\n    hVec[0] /= length;\n    hVec[1] /= length;\n    hVec[2] /= length;\n\n    // compute the shift\n    computeShift(il, iu, 0, shift);\n\n    return il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    double scale = 0.0;\n    double h = 0.0;\n    int im = iu;\n    for (int k = il; k <= iu; k++) {\n        scale = scale + FastMath.abs(matrixT[k][k - 1]);\n    }\n    if (scale != 0.0) {\n        double s = (matrixT[iu][iu - 1] / scale) / 2.0;\n        h = scale * FastMath.sqrt(s * s + 1.0);\n        h = (h > 0.0) ? h : -h;\n        if (h != 0.0) {\n            for (int k = il; k <= iu; k++) {\n                matrixT[k][k - 1] = (matrixT[k][k - 1] / h) / 2.0;\n            }\n            for (int j = il; j < iu; j++) {\n                double s = 0.0;\n                for (int k = j; k <= iu; k++) {\n                    s += matrixT[k][j] * matrixT[k][k - 1];\n                }\n                for (int k = j; k <= iu; k++) {\n                    matrixT[k][j] -= s * matrixT[k][k - 1];\n                }\n            }\n            for (int k = il; k <= iu; k++) {\n                matrixT[k][k - 1] = h;\n            }\n            matrixT[iu][iu - 1] = 0.0;\n            if (iu != im) {\n                for (int k = im + 1; k <= iu; k++) {\n                    matrixT[k][k - 1] = 0.0;\n                }\n            }\n            hVec[0] = h;\n            hVec[1] = scale;\n            hVec[2] = s;\n        }\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = il;\n    double dSum = 0.0;\n    for (int i = il; i <= iu; i++) {\n        dSum += FastMath.abs(matrixT[i][il - 1]);\n    }\n    double dScale = dSum / (iu - il + 1.0);\n    double dSqrSum = 0.0;\n    for (int i = il; i <= iu; i++) {\n        double dAbs = FastMath.abs(matrixT[i][il - 1]);\n        double dDiff = dAbs - dScale;\n        hVec[i - il] = dDiff;\n        dSqrSum += dDiff * dDiff;\n    }\n    double dShrink = FastMath.sqrt(dSqrSum) / (iu - il + 1.0);\n    for (int i = il; i <= iu; i++) {\n        hVec[i - il] /= (dScale * (dScale + dShrink));\n    }\n    hVec[0] += 1.0;\n    double dTmp = 0.0;\n    for (int i = il; i <= iu; i++) {\n        dTmp += hVec[i - il] * matrixT[i][il - 1];\n    }\n    dTmp /= hVec[0];\n    for (int i = il; i <= iu; i++) {\n        matrixT[i][il - 1] -= hVec[i - il] * dTmp;\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = il;\n    double scale = 0.0;\n    double h = 0.0;\n    for (int k = im; k <= iu; k++) {\n        scale += Math.abs(matrixT[k][k - 1]);\n    }\n    if (scale == 0.0) {\n        hVec[0] = hVec[1] = hVec[2] = 0.0;\n    } else {\n        for (int k = im; k <= iu; k++) {\n            double f = matrixT[k][k - 1] / scale;\n            h += f * f;\n            matrixT[k][k - 1] = f;\n        }\n        double g = Math.sqrt(h);\n        if (matrixT[im][im - 1] > 0) {\n            g = -g;\n        }\n        h = h - g;\n        matrixT[im][im - 1] = scale * g;\n        hVec[0] = scale * g;\n        hVec[1] = h;\n        hVec[2] = scale * g;\n        for (int k = im; k <= iu; k++) {\n            matrixT[k][k - 1] = matrixT[k][k - 1] / g;\n        }\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    double f, g, h;\n    hVec[1] = hVec[2] = h = 0.0;\n    for (int i = il; i <= iu; i++) {\n        hVec[0] = matrixT[i][i - 1];\n        if (i == il) {\n            hVec[1] = 0.0;\n        } else {\n            h = hVec[0] * hVec[1] + matrixT[i - 1][i - 1] * hVec[2];\n            hVec[2] = hVec[1];\n            hVec[1] = h;\n        }\n        f = hVec[1] * hVec[1] + matrixT[i][i] * hVec[2] * hVec[2];\n        if (f == 0.0) {\n            hVec[0] = 0.0;\n            hVec[1] = 0.0;\n            hVec[2] = 0.0;\n        } else {\n            g = -(matrixT[i][i] + matrixT[i - 1][i - 1]) / f;\n            h = g * hVec[1] * hVec[1] + 2.0 * hVec[0] * hVec[2];\n            hVec[0] = matrixT[i][i] - g * hVec[1];\n            hVec[1] = hVec[0] / h;\n            hVec[2] = hVec[2] / h;\n        }\n        hVec[0] = hVec[0] * hVec[1] * hVec[2];\n    }\n    return il;\n}"
    ],
    [
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode) \n        {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) \n    {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode)\n            textNodes.add((TextNode) node);\n    }\n    return Collections.unmodifiableList(textNodes);\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null || zeroInstance == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = zeroInstance.getFieldType(0).getField(chrono).getDifference(\n            end.get(zeroInstance.getFieldType(0).getType()), \n            start.get(zeroInstance.getFieldType(0).getType()));\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null || zeroInstance == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) \n    {\n        throw new IllegalArgumentException(\"Partials must have the same number of fields\");\n    }\n    int size = start.size();\n    int[] startValues = new int[size];\n    int[] endValues = new int[size];\n    int[] zeroValues = new int[size];\n    for (int i = 0; i < size; i++) \n    {\n        startValues[i] = start.getValue(i);\n        endValues[i] = end.getValue(i);\n        zeroValues[i] = zeroInstance.getValue(i);\n    }\n    int period = 0;\n    for (int i = 0; i < size; i++) \n    {\n        int startValue = startValues[i];\n        int endValue = endValues[i];\n        int zeroValue = zeroValues[i];\n        if (endValue < startValue) \n        {\n            endValue += zeroValue;\n        }\n        period += endValue - startValue;\n    }\n    return period;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null || zeroInstance == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (!start.getChronology().equals(end.getChronology())) \n    {\n        throw new IllegalArgumentException(\"The two partials must be in the same chronology\");\n    }\n    int startVal = 0;\n    int endVal = 0;\n    for (int i = 0; i < start.size(); i++) \n    {\n        startVal += start.getValue(i) * zeroInstance.get(start.getFieldType(i).getType());\n        endVal += end.getValue(i) * zeroInstance.get(end.getFieldType(i).getType());\n    }\n    return endVal - startVal;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null || zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = zeroInstance.getValue(start.getFieldType(0));\n    for (int i = 0; i < start.size(); i++) {\n        amount = chrono.get(start.getFieldType(i)).getDifference(end.getValue(i), start.getValue(i));\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null || zeroInstance == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int startInstant = start.toDateTime(chrono.dateTime()).getMillis();\n    int endInstant = end.toDateTime(chrono.dateTime()).getMillis();\n    int amount = zeroInstance.get(zeroInstance.getFieldType(0)).getDifference(endInstant, startInstant);\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null || zeroInstance == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = zeroInstance.getValue(start.getFieldType(0));\n    for (int i = 0; i < start.size(); i++) \n    {\n        DateTimeField field = start.getField(i);\n        amount += field.getDifference(end.get(field.getType()), start.get(field.getType()));\n    }\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null || zeroInstance == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = zeroInstance.getFieldType(0).getField(chrono).getDifference(end.get(zeroInstance.getFieldType(0)), start.get(zeroInstance.getFieldType(0)));\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null || zeroInstance == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int startMillis = start.toDateTime(chrono.dateTime()).getMillis();\n    int endMillis = end.toDateTime(chrono.dateTime()).getMillis();\n    int period = zeroInstance.get(zeroInstance.getFieldType(0));\n    return (endMillis - startMillis) / period;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null || zeroInstance == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int amount = zeroInstance.getFieldType(0).getField(chrono).getDifference(\n            end.get(zeroInstance.getFieldType(0).getType()), start.get(zeroInstance.getFieldType(0).getType()));\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null || zeroInstance == null) \n    {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n    int startMillis = start.toDateTime(DateTimeUtils.getInstant(0, chrono)).getMillis();\n    int endMillis = end.toDateTime(DateTimeUtils.getInstant(0, chrono)).getMillis();\n    int amount = zeroInstance.get(zeroInstance.getFieldType(0)) - zeroInstance.get(zeroInstance.getFieldType(1));\n    amount = (endMillis - startMillis) / (amount * 1000 * 60 * 60 * 24);\n    return amount;\n}"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    List subtitles = getSubtitles();\n    if (subtitles != null && index >= 0 && index < subtitles.size()) \n    {\n        return (LegendTitle) subtitles.get(index);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    List subtitles = getSubtitles();\n    if (subtitles != null && index >= 0 && index < subtitles.size()) \n    {\n        return (LegendTitle) subtitles.get(index);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    List subtitles = getSubtitles();\n    if (subtitles != null && index >= 0 && index < subtitles.size()) \n    {\n        return (LegendTitle) subtitles.get(index);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    List subtitles = getSubtitles();\n    if (subtitles != null && index >= 0 && index < subtitles.size()) \n    {\n        return (LegendTitle) subtitles.get(index);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    List subtitles = getSubtitles();\n    if (subtitles != null && index >= 0 && index < subtitles.size()) \n    {\n        return (LegendTitle) subtitles.get(index);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    List subtitles = getSubtitles();\n    if (subtitles != null && index >= 0 && index < subtitles.size()) \n    {\n        return (LegendTitle) subtitles.get(index);\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    List subtitles = getSubtitles();\n    if (subtitles != null && index >= 0 && index < subtitles.size()) \n    {\n        return (LegendTitle) subtitles.get(index);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    List subtitles = getSubtitles();\n    if (subtitles != null && index >= 0 && index < subtitles.size()) \n    {\n        return (LegendTitle) subtitles.get(index);\n    }\n    else \n    {\n        return null;\n    }\n}",
      "public LegendTitle getLegend(int index)  {\n    List subtitles = getSubtitles();\n    if (subtitles != null && index >= 0 && index < subtitles.size()) \n    {\n        return (LegendTitle) subtitles.get(index);\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    List subtitles = getSubtitles();\n    if (subtitles != null && index >= 0 && index < subtitles.size()) \n    {\n        return (LegendTitle) subtitles.get(index);\n    }\n    else \n    {\n        return null;\n    }\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    // Sort the entries by their offset in the archive\n    Collections.sort(entries, offsetComparator);\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    // Sort the entries by their offset in the archive\n    Collections.sort(entries, offsetComparator);\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    // sort entries by offset\n    Collections.sort(entries, offsetComparator);\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        List<ZipArchiveEntry> sortedEntries = new ArrayList<>(entries);\n        sortedEntries.sort(offsetComparator);\n        return Collections.enumeration(sortedEntries);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        List<ZipArchiveEntry> sortedEntries = new ArrayList<>(entries);\n        sortedEntries.sort(offsetComparator);\n        return Collections.enumeration(sortedEntries);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        // Sort the entries by offset\n        Collections.sort(entries, offsetComparator);\n        return Collections.enumeration(entries);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    // Sort the entries by offset\n    Collections.sort(entries, offsetComparator);\n    return Collections.enumeration(entries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        // Sort the entries by their offset in the archive\n        Collections.sort(entries, offsetComparator);\n        return Collections.enumeration(entries);\n    }",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    List<ZipArchiveEntry> sortedEntries = new ArrayList<>(entries);\n    Collections.sort(sortedEntries, offsetComparator);\n    return Collections.enumeration(sortedEntries);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n        List<ZipArchiveEntry> sortedEntries = new ArrayList<>(entries);\n        sortedEntries.sort(offsetComparator);\n        return Collections.enumeration(sortedEntries);\n    }"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      token = next();\n      if (match(JsDocToken.ELLIPSIS)) {\n        Node ellipsis = wrapNode(Token.ELLIPSIS, parseTopLevelTypeExpression(next()));\n        if (ellipsis != null) {\n          skipEOLs();\n          if (!match(JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          } else {\n            next();\n          }\n        }\n        return ellipsis;\n      } else {\n        Node optionalParameterType = parseTopLevelTypeExpression(token);\n        if (optionalParameterType != null) {\n          skipEOLs();\n          if (!match(JsDocToken.EQ)) {\n            return optionalParameterType;\n          }\n          next();\n          skipEOLs();\n          token = next();\n          Node defaultValue = parseTopLevelTypeExpression(token);\n          if (defaultValue != null) {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) {\n              reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } else {\n              next();\n            }\n            return wrapNode(Token.OPTIONAL_PARAMETER_TYPE, optionalParameterType, defaultValue);\n          }\n        }\n      }\n    }\n    return null;\n  }",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      token = next();\n      if (token == JsDocToken.ELLIPSIS) {\n        skipEOLs();\n        token = next();\n        Node typeNode = parseTopLevelTypeExpression(token);\n        if (typeNode != null) {\n          skipEOLs();\n          if (!match(JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          } else {\n            next();\n          }\n        }\n        return wrapNode(Token.ELLIPSIS, typeNode);\n      } else {\n        Node typeNode = parseTopLevelTypeExpression(token);\n        if (typeNode != null) {\n          skipEOLs();\n          if (match(JsDocToken.ASSIGN)) {\n            next();\n            skipEOLs();\n            token = next();\n            return wrapNode(Token.OPTIONAL_PARAM, typeNode);\n          }\n          if (!match(JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          } else {\n            next();\n          }\n        }\n      }\n    }\n    return null;\n  }",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      token = next();\n      if (match(JsDocToken.ELLIPSIS)) {\n        next();\n        Node typeNode = parseTopLevelTypeExpression(token);\n        if (typeNode != null) {\n          skipEOLs();\n          if (!match(JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          } else {\n            next();\n          }\n          return wrapNode(Token.ELLIPSIS, typeNode);\n        }\n      } else {\n        Node typeNode = parseTopLevelTypeExpression(token);\n        if (typeNode != null) {\n          skipEOLs();\n          if (match(JsDocToken.ASSIGN)) {\n            next();\n            skipEOLs();\n            token = next();\n            return newNode(Token.OPTIONAL_PARAMETER_TYPE, typeNode, parseTypeExpression(token));\n          } else if (!match(JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          } else {\n            next();\n          }\n          return typeNode;\n        }\n      }\n    }\n    return null;\n  }",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      token = next();\n      if (token == JsDocToken.ELLIPSIS) {\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) {\n          skipEOLs();\n          if (!match(JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          } else {\n            next();\n          }\n          return wrapNode(Token.ELLIPSIS, typeNode);\n        }\n      } else {\n        Node typeNode = parseTopLevelTypeExpression(token);\n        if (typeNode != null) {\n          skipEOLs();\n          if (!match(JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          } else {\n            next();\n          }\n          return typeNode;\n        }\n      }\n    }\n    return null;\n  }",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      token = next();\n      if (token == JsDocToken.ELLIPSIS) {\n        skipEOLs();\n        token = next();\n        Node typeNode = parseTopLevelTypeExpression(token);\n        if (typeNode != null) {\n          skipEOLs();\n          if (!match(JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          } else {\n            next();\n          }\n        }\n        return wrapNode(Token.ELLIPSIS, typeNode);\n      } else {\n        Node typeNode = parseTopLevelTypeExpression(token);\n        if (typeNode != null) {\n          skipEOLs();\n          if (match(JsDocToken.ASSIGN)) {\n            next();\n            skipEOLs();\n            token = next();\n            return newNode(Token.OPTIONAL_PARAMETER_TYPE, typeNode, parseTypeExpression(token));\n          } else if (!match(JsDocToken.RC)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          } else {\n            next();\n          }\n        }\n        return typeNode;\n      }\n    } else {\n      return parseTypeExpression(token);\n    }\n  }",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (match(JsDocToken.EQUALS)) \n            {\n                next();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                    return wrapNode(Token.OPTIONAL_PARAM, typeNode);\n                }\n            } \n            else if (match(JsDocToken.ELLIPSIS)) \n            {\n                next();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                    return wrapNode(Token.REST_PARAM, typeNode);\n                }\n            } \n            else if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n                return typeNode;\n            }\n        }\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n    return null;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        token = next();\n        if (match(JsDocToken.ELLIPSIS)) \n        {\n            next();\n            Node typeNode = parseTopLevelTypeExpression(token);\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                }\n            }\n            return typeNode;\n        } \n        else \n        {\n            Node typeNode = parseTopLevelTypeExpression(token);\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                }\n            }\n            return typeNode;\n        }\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        token = next();\n        if (match(JsDocToken.ELLIPSIS)) \n        {\n            next();\n            Node typeNode = parseTopLevelTypeExpression(token);\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                }\n                return wrapNode(Token.ELLIPSIS, typeNode);\n            }\n        } \n        else \n        {\n            Node typeNode = parseTopLevelTypeExpression(token);\n            if (typeNode != null) \n            {\n                skipEOLs();\n                if (!match(JsDocToken.RC)) \n                {\n                    reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n                } \n                else \n                {\n                    next();\n                }\n                return typeNode;\n            }\n        }\n    } \n    else \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lc\");\n    }\n    return null;\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackFrames = new ArrayList<String>();\n    for (StackTraceElement ste : t.getStackTrace()) \n    {\n        stackFrames.add(ste.toString());\n    }\n    return stackFrames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackFrames = new ArrayList<String>();\n    for (StackTraceElement ste : t.getStackTrace()) \n    {\n        stackFrames.add(ste.toString());\n    }\n    return stackFrames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackTraceList = new ArrayList<String>();\n    StackTraceElement[] stackTraceElements = t.getStackTrace();\n    for(StackTraceElement element : stackTraceElements)\n    {\n        stackTraceList.add(element.toString());\n    }\n    return stackTraceList;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> list = new ArrayList<String>();\n    for (StackTraceElement element : t.getStackTrace()) \n    {\n        list.add(element.toString());\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackTraceList = new ArrayList<String>();\n    StackTraceElement[] stackTraceElements = t.getStackTrace();\n    for(StackTraceElement element : stackTraceElements)\n    {\n        stackTraceList.add(element.toString());\n    }\n    return stackTraceList;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> list = new ArrayList<String>();\n    for (StackTraceElement ste : t.getStackTrace()) \n    {\n        list.add(ste.toString());\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackTraceList = new ArrayList<String>(Arrays.asList(getStackFrames(getStackTrace(t))));\n    Throwable cause = getCause(t);\n    while (cause != null) \n    {\n        stackTraceList.removeAll(Arrays.asList(getStackFrames(getStackTrace(cause))));\n        cause = getCause(cause);\n    }\n    return stackTraceList;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackFrames = new ArrayList<String>();\n    for (StackTraceElement ste : t.getStackTrace()) \n    {\n        stackFrames.add(ste.toString());\n    }\n    return stackFrames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackTraceList = new ArrayList<String>();\n    StackTraceElement[] stackTraceElements = t.getStackTrace();\n    for(StackTraceElement element : stackTraceElements)\n    {\n        stackTraceList.add(element.toString());\n    }\n    return stackTraceList;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> stackTraceList = new ArrayList<String>();\n    StackTraceElement[] stackTraceElements = t.getStackTrace();\n    for(StackTraceElement element : stackTraceElements)\n    {\n        stackTraceList.add(element.toString());\n    }\n    return stackTraceList;\n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected boolean but was \" + peek() + locationString());\n    }\n  }"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node argList = call.getFirstChild().getNext();\n    for (Node arg : argList.children()) {\n      if (compiler.hasSideEffects(arg)) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node args = call.getFirstChild();\n    while (args != null) \n    {\n        Node arg = args.getFirstChild();\n        if (argMayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n        args = args.getNext();\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node args = call.getFirstChild().getNext();\n    while (args != null) {\n      if (compiler.hasSideEffects(args)) {\n        return true;\n      }\n      args = args.getNext();\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node args = call.getFirstChild().getNext();\n    while (args != null) {\n      if (compiler.hasSideEffects(args)) {\n        return true;\n      }\n      args = args.getNext();\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node argList = call.getFirstChild().getNext();\n    while (argList != null) {\n      Node arg = argList.getFirstChild();\n      if (NodeUtil.hasSideEffects(arg, compiler.getTypeRegistry())) {\n        return true;\n      }\n      argList = argList.getNext();\n    }\n    return false;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node args = call.getFirstChild().getNext();\n    while (args != null) {\n        if (NodeUtil.hasSideEffects(args)) {\n            return true;\n        }\n        args = args.getNext();\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node args = call.getFirstChild().getNext();\n    while (args != null) \n    {\n        if (compiler.hasSideEffects(args)) \n        {\n            return true;\n        }\n        args = args.getNext();\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node args = call.getFirstChild().getNext();\n    while (args != null) \n    {\n        if (compiler.getSideEffectAnalyzer().hasSideEffects(args)) \n        {\n            return true;\n        }\n        args = args.getNext();\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node args = call.getFirstChild();\n    while (args != null) \n    {\n        Node arg = args.getFirstChild();\n        if (argMayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n        args = args.getNext();\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node args = call.getFirstChild().getNext();\n    while (args != null) \n    {\n        if (NodeUtil.hasSideEffects(args)) \n        {\n            return true;\n        }\n        args = args.getNext();\n    }\n    return false;\n}"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = field.createMatrix(m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = field.createMatrix(m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = field.createMatrix(m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = field.createMatrix(m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = field.createMatrix(m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = field.createMatrix(m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getLocalFileDataLength().getValue();\n        }\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] local = data[i].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n                start += local.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] local = data[data.length - 1].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        int sum = ZipExtraField.EXTRAFIELD_HEADER_SIZE * data.length;\n        for (final ZipExtraField element : data) {\n            sum += element.getLocalFileDataLength().getValue();\n        }\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (final ZipExtraField element : data) {\n            System.arraycopy(element.getHeaderId().getBytes(), 0, result, start, 2);\n            System.arraycopy(element.getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);\n            start += ZipExtraField.EXTRAFIELD_HEADER_SIZE;\n            final byte[] local = element.getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n                start += local.length;\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int sum = WORD * data.length;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < data.length; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int sum = ZipExtraField.EXTRAFIELD_HEADER_SIZE * data.length;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (final ZipExtraField element : data) \n    {\n        System.arraycopy(element.getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(element.getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);\n        start += ZipExtraField.EXTRAFIELD_HEADER_SIZE;\n        final byte[] local = element.getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        int sum = WORD * data.length;\n        for (final ZipExtraField element : data) {\n            sum += element.getLocalFileDataLength().getValue();\n        }\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (final ZipExtraField element : data) {\n            System.arraycopy(element.getHeaderId().getBytes(), 0, result, start, 2);\n            System.arraycopy(element.getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);\n            start += WORD;\n            final byte[] local = element.getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n                start += local.length;\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int sum = ZipExtraField.EXTRAFIELD_HEADER_SIZE * data.length;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (final ZipExtraField element : data) {\n        System.arraycopy(element.getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(element.getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);\n        start += ZipExtraField.EXTRAFIELD_HEADER_SIZE;\n        final byte[] local = element.getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    int sum = WORD * data.length;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < data.length; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getLocalFileDataLength().getValue();\n        }\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] local = data[i].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n                start += local.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] local = data[data.length - 1].getLocalFileDataData();\n            if (local != null) {\n                System.arraycopy(local, 0, result, start, local.length);\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double getSup()  {\n        BSPTree<Euclidean1D> node = getTree(true);\n        double sup = Double.NEGATIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            sup = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n    }",
      "public double getSup()  {\n        BSPTree<Euclidean1D> node = getTree(true);\n        double sup  = Double.NEGATIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            sup  = op.getLocation().getX();\n            node = op.isDirect() ? node.getMinus() : node.getPlus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n    }",
      "public double getSup()  {\n        BSPTree<Euclidean1D> node = getTree(true);\n        double sup  = Double.NEGATIVE_INFINITY;\n        while (node.getCut() != null) {\n            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n            sup  = op.getLocation().getX();\n            node = op.isDirect() ? node.getPlus() : node.getMinus();\n        }\n        return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n    }",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(true);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(true);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(true);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        while (true) {\n            if (isEndOfFile(ch)) {\n                token.type = Token.Type.EOF;\n                break;\n            } else if (isEndOfLine(ch)) {\n                token.type = Token.Type.EORECORD;\n                break;\n            } else if (isDelimiter(ch)) {\n                token.type = Token.Type.TOKEN;\n                break;\n            } else {\n                token.content.append((char) ch);\n                ch = reader.read();\n            }\n        }\n        token.isReady = true;\n        return token;\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        boolean eol = false;\n        while (!eol) {\n            if (isEndOfFile(ch)) {\n                token.type = Token.Type.EOF;\n                token.isReady = true;\n                break;\n            } else if (isEscape(ch)) {\n                ch = readEscape();\n                if (isEndOfFile(ch)) {\n                    throw new IOException(\"EOF reached while trying to escape a character\");\n                }\n                token.content.append((char) ch);\n            } else if (isDelimiter(ch)) {\n                token.type = Token.Type.TOKEN;\n                break;\n            } else if (isEndOfLine(ch)) {\n                eol = true;\n                token.type = Token.Type.EORECORD;\n                break;\n            } else {\n                token.content.append((char) ch);\n            }\n            ch = reader.read();\n        }\n        return token;\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        // save current line number in case needed for IOE\n        final long startLineNumber = getCurrentLineNumber();\n        while (true) {\n            // ignore whitespaces at beginning of a token\n            if (ignoreSurroundingSpaces && isWhitespace(ch)) {\n                ch = reader.read();\n                continue;\n            }\n\n            // ok, start of token reached: encapsulated, or token\n            if (isDelimiter(ch)) {\n                // empty token return TOKEN(\"\")\n                token.type = Token.Type.TOKEN;\n                return token;\n            } else if (readEndOfLine(ch)) {\n                // empty token return EORECORD(\"\")\n                token.type = Token.Type.EORECORD;\n                return token;\n            } else if (isQuoteChar(ch)) {\n                // consume encapsulated token\n                return parseEncapsulatedToken(token);\n            } else if (isEndOfFile(ch)) {\n                // end of file return EOF()\n                token.type = Token.Type.EOF;\n                token.isReady = true; // there is data at EOF\n                return token;\n            } else {\n                // add char to token content\n                token.content.append((char) ch);\n                ch = reader.read();\n            }\n        }\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        while (true) {\n            if (ch == -1 || isEndOfFile(ch) || isDelimiter(ch) || isEscape(ch) || isQuoteChar(ch) || isCommentStart(ch)) {\n                token.type = Token.Type.TOKEN;\n                break;\n            } else if (isStartOfLine(ch) || isEndOfLine(ch)) {\n                token.type = Token.Type.EORECORD;\n                break;\n            } else {\n                token.content.append((char) ch);\n                ch = reader.read();\n            }\n        }\n        return token;\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        // save current line number in case needed for IOE\n        final long startLineNumber = getCurrentLineNumber();\n        while (true) {\n            if (isEndOfFile(ch)) {\n                // end of file return EOF()\n                token.type = Token.Type.EOF;\n                token.isReady = true; // there is data at EOF\n                break;\n            } else if (isEscape(ch)) {\n                // escape next char\n                ch = readEscape();\n                if (isEndOfFile(ch)) {\n                    throw new IOException(\"EOF reached while reading escape character\");\n                }\n                token.content.append((char) ch);\n            } else if (isDelimiter(ch)) {\n                // end of token\n                token.type = Token.Type.TOKEN;\n                break;\n            } else if (isEndOfLine(ch)) {\n                // end of record\n                token.type = Token.Type.EORECORD;\n                break;\n            } else {\n                token.content.append((char) ch);\n            }\n            ch = reader.read();\n        }\n        return token;\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        boolean eol = false;\n        while (!eol) {\n            if (isEndOfFile(ch)) {\n                token.type = Token.Type.EOF;\n                token.isReady = true;\n                break;\n            } else if (isEscape(ch)) {\n                ch = readEscape();\n                if (isEndOfFile(ch)) {\n                    throw new IOException(\"EOF while reading escape character\");\n                }\n                token.content.append((char) ch);\n            } else if (isDelimiter(ch)) {\n                token.type = Token.Type.TOKEN;\n                break;\n            } else if (isEndOfLine(ch)) {\n                eol = true;\n                token.type = Token.Type.EORECORD;\n                break;\n            } else {\n                token.content.append((char) ch);\n            }\n            ch = reader.read();\n        }\n        return token;\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        // save current line number in case needed for IOE\n        final long startLineNumber = getCurrentLineNumber();\n        while (true) {\n            if (isEndOfFile(ch)) {\n                // end of file return EOF()\n                token.type = Token.Type.EOF;\n                token.isReady = true; // there is data at EOF\n                break;\n            } else if (isEscape(ch)) {\n                // escape next character\n                ch = readEscape();\n                if (isEndOfFile(ch)) {\n                    throw new IOException(\"Unexpected end of file after escape character\");\n                }\n                token.content.append((char) ch);\n            } else if (isDelimiter(ch)) {\n                // end of token return TOKEN\n                token.type = Token.Type.TOKEN;\n                break;\n            } else if (isWhitespace(ch)) {\n                // end of token return TOKEN\n                token.type = Token.Type.TOKEN;\n                break;\n            } else if (isCommentStart(ch)) {\n                // consume comment\n                while (ch != '\\n' && ch != '\\r' && ch != -1) {\n                    ch = reader.read();\n                }\n                token.type = Token.Type.COMMENT;\n                token.content.append(ch);\n                break;\n            } else if (isStartOfLine(ch)) {\n                // end of token return EORECORD\n                token.type = Token.Type.EORECORD;\n                break;\n            } else {\n                // add character to token content\n                token.content.append((char) ch);\n            }\n            ch = reader.read();\n        }\n        return token;\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        // save current line number in case needed for IOE\n        final long startLineNumber = getCurrentLineNumber();\n        int c;\n        while (true) {\n            c = reader.read();\n            // important: make sure a new char gets consumed in each iteration\n            while (token.type == INVALID) {\n                // ignore whitespaces at beginning of a token\n                if (ignoreSurroundingSpaces) {\n                    while (isWhitespace(c) && !eol) {\n                        c = reader.read();\n                        eol = readEndOfLine(c);\n                    }\n                }\n\n                // ok, start of token reached: encapsulated, or token\n                if (isDelimiter(c)) {\n                    // empty token return TOKEN(\"\")\n                    token.type = TOKEN;\n                } else if (eol) {\n                    // empty token return EORECORD(\"\")\n                    // noop: token.content.append(\"\");\n                    token.type = EORECORD;\n                } else if (isQuoteChar(c)) {\n                    // consume encapsulated token\n                    parseEncapsulatedToken(token);\n                } else if (isEndOfFile(c)) {\n                    // end of file return EOF()\n                    // noop: token.content.append(\"\");\n                    token.type = EOF;\n                    token.isReady = true; // there is data at EOF\n                } else {\n                    // next token must be a simple token\n                    // add removed blanks when not ignoring whitespace chars...\n                    parseSimpleToken(token, c);\n                }\n            }\n            return token;\n        }\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        boolean eol = false;\n        while (true) {\n            if (isEndOfFile(ch)) {\n                token.type = Token.Type.EOF;\n                token.isReady = true;\n                break;\n            } else if (readEndOfLine(ch)) {\n                eol = true;\n                token.type = Token.Type.EORECORD;\n                break;\n            } else if (isDelimiter(ch)) {\n                token.type = Token.Type.TOKEN;\n                break;\n            } else {\n                token.content.append((char) ch);\n                ch = reader.read();\n            }\n        }\n        return token;\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        // save current line number in case needed for IOE\n        final long startLineNumber = getCurrentLineNumber();\n        while (true) {\n            if (ch == -1 || isEndOfFile(ch) || isEol(ch)) {\n                token.type = (ch == -1) ? EOF : EORECORD;\n                break;\n            } else if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                break;\n            } else {\n                token.content.append((char) ch);\n                ch = reader.read();\n            }\n        }\n        return token;\n    }"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    counts[last] = index;\n    for (int i = last - 1; i >= 0; i--) {\n        int remainder = index % uniCounterOffset[i];\n        counts[i] = remainder / uniCounterOffset[i + 1];\n        index = remainder;\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n\n    int[] counts = new int[dimension];\n    counts[last] = index;\n\n    for (int i = last - 1; i >= 0; i--) {\n        counts[i] = (index - counts[i + 1]) / uniCounterOffset[i + 1];\n        index = counts[i + 1] * uniCounterOffset[i + 1];\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    counts[last] = index;\n    for (int i = last - 1; i >= 0; i--) {\n        int remainder = index % uniCounterOffset[i];\n        counts[i] = remainder / uniCounterOffset[i + 1];\n        index = remainder;\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    for (int i = last; i >= 0; i--) {\n        counts[i] = index % size[i];\n        index /= size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] counts = new int[dimension];\n    counts[last] = index;\n    for (int i = last - 1; i >= 0; i--) {\n        int remainder = index % uniCounterOffset[i];\n        counts[i] = remainder / uniCounterOffset[i + 1];\n        index = remainder;\n    }\n\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize - 1);\n        }\n\n        int[] counts = new int[dimension];\n        counts[last] = index;\n\n        for (int i = last - 1; i >= 0; i--) {\n            counts[i] = (index - counts[i + 1]) / uniCounterOffset[i + 1];\n            index = counts[i + 1] % uniCounterOffset[i + 1];\n        }\n\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n\n        int[] counts = new int[dimension];\n        counts[last] = index;\n\n        for (int i = last - 1; i >= 0; i--) {\n            counts[i] = (index - counts[i + 1]) / uniCounterOffset[i + 1];\n            index = counts[i + 1] % uniCounterOffset[i + 1];\n        }\n\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize - 1);\n        }\n\n        int[] counts = new int[dimension];\n        counts[last] = index;\n        for (int i = last - 1; i >= 0; i--) {\n            counts[i] = (index - counts[i + 1]) / uniCounterOffset[i + 1];\n            index = counts[i + 1];\n        }\n\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize - 1);\n        }\n\n        int[] counts = new int[dimension];\n        for (int i = last; i >= 0; i--) {\n            counts[i] = index % size[i];\n            index /= size[i];\n        }\n        return counts;\n    }",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n        if (index < 0 || index >= totalSize) {\n            throw new OutOfRangeException(index, 0, totalSize);\n        }\n        int[] counts = new int[dimension];\n        for (int i = last; i >= 0; i--) {\n            counts[i] = index % size[i];\n            index /= size[i];\n        }\n        return counts;\n    }"
    ],
    [
      "public JsonPointer last()  {\n    JsonPointer tail = this;\n    while (tail._nextSegment != null) {\n        tail = tail._nextSegment;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = this;\n    while (tail._nextSegment != null) {\n        tail = tail._nextSegment;\n    }\n    return tail;\n}",
      "public JsonPointer last()  {\n    JsonPointer tail = this;\n    while (tail._nextSegment != null) {\n        tail = tail._nextSegment;\n    }\n    return tail;\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int bytesRead;\n    while ((bytesRead = data.read(buffer)) != -1) \n    {\n        digest.update(buffer, 0, bytesRead);\n    }\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    try {\n        return (T) obj.clone();\n    } catch (CloneNotSupportedException e) {\n        // This should never happen as Cloneable is a marker interface\n        throw new RuntimeException(e);\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    try {\n        return (T) obj.clone();\n    } catch (CloneNotSupportedException e) {\n        throw new CloneFailedException(\"Cloning not allowed for \" + obj.getClass().getName(), e);\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    try {\n        return (T) obj.clone();\n    } catch (CloneNotSupportedException e) {\n        // This should never happen, since the Object class is cloneable\n        throw new InternalError(e.toString());\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    try {\n        return (T) obj.clone();\n    } catch (CloneNotSupportedException e) {\n        // This should never happen as long as we implement Cloneable\n        throw new CloneFailedException(e);\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    try {\n        return (T) obj.clone();\n    } catch (CloneNotSupportedException e) {\n        // This should never happen as Cloneable is a marker interface\n        throw new RuntimeException(e);\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    try {\n        return (T) obj.clone();\n    } catch (CloneNotSupportedException e) {\n        // This should never happen, since we're the one implementing Cloneable\n        throw new RuntimeException(e);\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    try {\n        return (T) obj.clone();\n    } catch (CloneNotSupportedException e) {\n        throw new CloneFailedException(\"Clone operation failed for \" + obj, e);\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    try {\n        return (T) obj.clone();\n    } catch (CloneNotSupportedException e) {\n        // This should never happen, as Cloneable is a marker interface\n        throw new AssertionError(e);\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    try {\n        return (T) obj.clone();\n    } catch (CloneNotSupportedException e) {\n        throw new CloneFailedException(e);\n    }\n}",
      "public static <T> T clone(final T obj)  {\n    if (obj == null) {\n        return null;\n    }\n    try {\n        return (T) obj.clone();\n    } catch (CloneNotSupportedException e) {\n        // This should never happen, since we're the one implementing Cloneable\n        throw new RuntimeException(e);\n    }\n}"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n        return null;\n    }\n    Symbol paramSymbol = scope.getQualifiedSlot(paramName);\n    if (paramSymbol == null) {\n        return null;\n    }\n    return paramSymbol;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n        return null;\n    }\n    return scope.getQualifiedSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n      return null;\n    }\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n      return null;\n    }\n    Symbol parameter = scope.getQualifiedSlot(paramName);\n    if (parameter == null) {\n      return null;\n    }\n    return parameter;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n        return null;\n    }\n    Symbol parameterSymbol = scope.getQualifiedSlot(paramName);\n    if (parameterSymbol == null) {\n        return null;\n    }\n    return parameterSymbol;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope != null) \n    {\n        Symbol parameter = scope.getQualifiedSlot(paramName);\n        if (parameter != null && parameter.getDeclaration() != null) \n        {\n            return parameter;\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope != null) {\n        return scope.getQualifiedSlot(paramName);\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n      return null;\n    }\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n      return null;\n    }\n    Symbol paramSymbol = scope.getQualifiedSlot(paramName);\n    if (paramSymbol == null) {\n      return null;\n    }\n    return paramSymbol;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n        return null;\n    }\n    Symbol parameter = scope.getQualifiedSlot(paramName);\n    if (parameter == null) {\n        return null;\n    }\n    return parameter;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n        return null;\n    }\n    Symbol parameterSymbol = scope.getQualifiedSlot(paramName);\n    if (parameterSymbol == null) {\n        return null;\n    }\n    return parameterSymbol;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    FunctionType type = sym.getFunctionType();\n    if (type == null) {\n        return null;\n    }\n\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n        return null;\n    }\n\n    Symbol parameter = scope.getQualifiedSlot(paramName);\n    if (parameter == null) {\n        return null;\n    }\n\n    return parameter;\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        // Your code here\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getRowDimension();\n        double[][] data = matrix.getData();\n        double[][] covarianceMatrix = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                double cov = 0.0;\n                for (int k = 0; k < data.length; k++) {\n                    cov += (data[k][i] - mean(data[k])) * (data[k][j] - mean(data[k]));\n                }\n                cov /= (data.length - (biasCorrected ? 1 : 0));\n                covarianceMatrix[i][j] = cov;\n                covarianceMatrix[j][i] = cov;\n            }\n        }\n        return new Array2DRowRealMatrix(covarianceMatrix);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        // Check if the matrix has sufficient data\n        checkSufficientData(matrix);\n\n        // Get the number of observations\n        n = matrix.getRowDimension();\n\n        // Compute the covariance matrix\n        RealMatrix covarianceMatrix = matrix.transpose().multiply(matrix);\n        covarianceMatrix.scalarDivide(n);\n\n        // If bias correction is required, adjust the covariance matrix\n        if (biasCorrected) {\n            for (int i = 0; i < covarianceMatrix.getRowDimension(); i++) {\n                for (int j = 0; j < covarianceMatrix.getColumnDimension(); j++) {\n                    covarianceMatrix.addToEntry(i, j, (i == j) ? 1.0 / n : -1.0 / (n - 1));\n                }\n            }\n        }\n\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getRowDimension();\n        double[][] data = matrix.getData();\n        double[][] covarianceMatrix = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                double cov = 0.0;\n                for (int k = 0; k < n; k++) {\n                    cov += (data[k][i] - mean(data[k])) * (data[k][j] - mean(data[k]));\n                }\n                cov /= n;\n                if (biasCorrected && n > 1) {\n                    cov *= (n - 1.0) / (n - 2.0);\n                }\n                covarianceMatrix[i][j] = cov;\n                covarianceMatrix[j][i] = cov;\n            }\n        }\n        return new Array2DRowRealMatrix(covarianceMatrix);\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getRowDimension();\n        RealMatrix covarianceMatrix = matrix.copy();\n        RealMatrix meanVector = matrix.getRowMatrix(0).scalarMultiply(1.0 / n);\n        covarianceMatrix = covarianceMatrix.subtract(meanVector.multiply(n));\n        covarianceMatrix = covarianceMatrix.transpose().multiply(covarianceMatrix);\n        if (biasCorrected) {\n            covarianceMatrix = covarianceMatrix.scalarMultiply(n / (n - 1));\n        }\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        // Implement the covariance matrix computation here\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        checkSufficientData(matrix);\n        int n = matrix.getRowDimension();\n        RealMatrix covarianceMatrix = matrix.copy();\n        covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / n);\n        RealMatrix meanVector = matrix.getRowMatrix(0).scalarMultiply(-1.0);\n        covarianceMatrix = covarianceMatrix.add(meanVector.multiply(meanVector.transpose()).scalarMultiply(1.0 / (n - (biasCorrected ? 1 : 0))));\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        // Your code here\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        // Check if matrix has sufficient data\n        checkSufficientData(matrix);\n\n        // Get number of observations\n        n = matrix.getRowDimension();\n\n        // Compute covariance matrix\n        RealMatrix covarianceMatrix = matrix.transpose().multiply(matrix);\n        covarianceMatrix.scalarMultiply(1.0 / n);\n\n        // If bias correction is required, adjust the covariance matrix\n        if (biasCorrected) {\n            for (int i = 0; i < covarianceMatrix.getRowDimension(); i++) {\n                for (int j = 0; j < covarianceMatrix.getColumnDimension(); j++) {\n                    covarianceMatrix.addToEntry(i, j, -1.0 / (n - 1));\n                }\n            }\n        }\n\n        return covarianceMatrix;\n    }",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n        // Check if the matrix has at least two rows and one column\n        if (matrix.getRowDimension() < 2 || matrix.getColumnDimension() < 1) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA, matrix.getRowDimension(), 2, matrix.getColumnDimension(), 1);\n        }\n\n        // Compute the covariance matrix\n        RealMatrix covarianceMatrix = matrix.transpose().multiply(matrix);\n        if (biasCorrected) {\n            int n = matrix.getRowDimension();\n            covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / (n - 1));\n        } else {\n            covarianceMatrix = covarianceMatrix.scalarMultiply(1.0 / n);\n        }\n\n        return covarianceMatrix;\n    }"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n        if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n            throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n        }\n        if (!ensureCache(count)) {\n            return -1;\n        }\n        long result;\n        if (count <= bitsCachedSize) {\n            result = bitsCached & MASKS[count];\n            bitsCached >>= count;\n            bitsCachedSize -= count;\n        } else {\n            result = bitsCached;\n            bitsCached = 0;\n            bitsCachedSize = 0;\n            if (count > 64) {\n                result |= processBitsGreater57(count);\n            } else {\n                bitsCached = IOUtils.readFullyAsLong(in, byteOrder);\n                bitsCachedSize = 64;\n            }\n            result &= MASKS[count];\n            bitsCachedSize -= count;\n        }\n        return result;\n    }",
      "public long readBits(final int count) throws IOException  {\n        if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n            throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n        }\n        if (!ensureCache(count)) {\n            return -1;\n        }\n        long result;\n        if (count <= bitsCachedSize) {\n            // We have enough bits in the cache\n            result = bitsCached & MASKS[count];\n            bitsCached >>= count;\n            bitsCachedSize -= count;\n        } else {\n            // We have less than count bits in the cache, read more\n            result = bitsCached;\n            bitsCachedSize = 0;\n            bitsCached = 0;\n            int toRead = count;\n            while (toRead > 0) {\n                int read = in.read();\n                if (read == -1) {\n                    return -1;\n                }\n                bitsCached |= (read & 0xFF) << (64 - bitsCachedSize - toRead * 8);\n                bitsCachedSize += Byte.SIZE;\n                toRead -= Byte.SIZE;\n            }\n            result |= bitsCached & MASKS[count];\n            bitsCached >>= count;\n            bitsCachedSize -= count;\n        }\n        return byteOrder == ByteOrder.BIG_ENDIAN ? Long.reverseBytes(result) : result;\n    }",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (!ensureCache(count)) {\n        return -1;\n    }\n    if (count <= bitsCachedSize) {\n        long result = bitsCached & MASKS[count];\n        bitsCached >>= count;\n        bitsCachedSize -= count;\n        return result;\n    }\n    return processBitsGreater57(count);\n}",
      "public long readBits(final int count) throws IOException  {\n        if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n            throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n        }\n        if (!ensureCache(count)) {\n            return -1;\n        }\n        long result;\n        if (count <= bitsCachedSize) {\n            result = bitsCached & MASKS[count];\n            bitsCached >>= count;\n            bitsCachedSize -= count;\n        } else {\n            result = bitsCached;\n            bitsCached = 0;\n            bitsCachedSize = 0;\n            result <<= count - bitsCachedSize;\n            if (!ensureCache(count - bitsCachedSize)) {\n                return result;\n            }\n            result |= bitsCached & MASKS[count - bitsCachedSize];\n            bitsCached >>= count - bitsCachedSize;\n            bitsCachedSize -= count;\n        }\n        if (byteOrder == ByteOrder.BIG_ENDIAN) {\n            return Long.reverseBytes(result);\n        } else {\n            return result;\n        }\n    }",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (!ensureCache(count)) {\n        return -1;\n    }\n    if (count <= bitsCachedSize) {\n        long result = bitsCached & MASKS[count];\n        bitsCached >>= count;\n        bitsCachedSize -= count;\n        return result;\n    }\n    return processBitsGreater57(count);\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n        throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n    }\n    if (!ensureCache(count)) {\n        return -1;\n    }\n    long result;\n    if (count <= bitsCachedSize) {\n        // We have enough bits in the cache.\n        result = bitsCached & MASKS[count];\n        bitsCached >>= count;\n        bitsCachedSize -= count;\n    } else {\n        result = bitsCached;\n        bitsCachedSize = 0;\n        bitsCached = 0;\n        result |= processBitsGreater57(count - bitsCachedSize);\n    }\n    return byteOrder == ByteOrder.BIG_ENDIAN ? Long.reverseBytes(result) : result;\n}",
      "public long readBits(final int count) throws IOException  {\n        if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n            throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n        }\n        if (!ensureCache(count)) {\n            return -1;\n        }\n        long result;\n        if (count <= bitsCachedSize) {\n            // the result is entirely in the cache\n            result = bitsCached & MASKS[count];\n            bitsCached >>= count;\n            bitsCachedSize -= count;\n        } else {\n            // the result crosses the byte boundary\n            result = bitsCached & MASKS[bitsCachedSize];\n            bitsCachedSize = 0;\n            bitsCached = 0;\n            result <<= count - bitsCachedSize;\n            if (!ensureCache(count - bitsCachedSize)) {\n                return result;\n            }\n            result |= bitsCached & MASKS[count - bitsCachedSize];\n            bitsCached >>= count - bitsCachedSize;\n            bitsCachedSize -= count;\n        }\n        if (byteOrder == ByteOrder.BIG_ENDIAN) {\n            // reverse the bits\n            long r = 0;\n            for (int i = 0; i < count; i++) {\n                r <<= 1;\n                r |= result & 1;\n                result >>= 1;\n            }\n            return r;\n        } else {\n            return result;\n        }\n    }",
      "public long readBits(final int count) throws IOException  {\n        if (count < 0 || count > MAXIMUM_CACHE_SIZE) {\n            throw new IllegalArgumentException(\"count must be between 0 and \" + MAXIMUM_CACHE_SIZE);\n        }\n        if (!ensureCache(count)) {\n            return -1;\n        }\n        long result;\n        if (count <= bitsCachedSize) {\n            // We have enough bits in the cache\n            result = bitsCached & MASKS[count];\n            bitsCached >>= count;\n            bitsCachedSize -= count;\n        } else {\n            // We need to read more bits from the input stream\n            result = bitsCached;\n            int bitsStillNeeded = count - bitsCachedSize;\n            if (bitsStillNeeded >= 64) {\n                // We need to read a whole long from the input stream\n                result |= (in.read() & 0xFF) << bitsCachedSize;\n                bitsCached = in.read();\n                bitsCachedSize = 8;\n            } else {\n                // We need to read a partial long from the input stream\n                result |= (in.read() & 0xFF) << bitsCachedSize;\n                bitsCached = in.read();\n                bitsCachedSize = 8;\n            }\n            result &= MASKS[bitsStillNeeded];\n            bitsCachedSize -= bitsStillNeeded;\n        }\n        if (byteOrder == ByteOrder.BIG_ENDIAN) {\n            // We need to reverse the bits\n            long reverse = 0;\n            for (int i = 0; i < count; i++) {\n                reverse <<= 1;\n                reverse |= (result & 1);\n                result >>= 1;\n            }\n            result = reverse;\n        }\n        return result;\n    }",
      "public long readBits(final int count) throws IOException  {\n        if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n            throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n        }\n        if (!ensureCache(count)) {\n            return -1;\n        }\n        long result;\n        if (count <= bitsCachedSize) {\n            result = bitsCached & MASKS[count];\n            bitsCached >>= count;\n            bitsCachedSize -= count;\n        } else {\n            result = bitsCached;\n            bitsCached = 0;\n            bitsCachedSize = 0;\n            if (count > 63) {\n                result |= processBitsGreater57(count);\n            } else {\n                result |= in.read() << bitsCachedSize;\n                bitsCachedSize += 8;\n            }\n            result &= MASKS[count];\n        }\n        return byteOrder == ByteOrder.BIG_ENDIAN ? Long.reverseBytes(result) : result;\n    }",
      "public long readBits(final int count) throws IOException  {\n        if (count < 1 || count > MAXIMUM_CACHE_SIZE) {\n            throw new IllegalArgumentException(\"count must be between 1 and \" + MAXIMUM_CACHE_SIZE);\n        }\n        if (!ensureCache(count)) {\n            return -1;\n        }\n        long result;\n        if (count <= bitsCachedSize) {\n            // enough bits in the cache\n            result = bitsCached & MASKS[count];\n            bitsCached >>= count;\n            bitsCachedSize -= count;\n        } else {\n            // not enough bits in the cache, but enough to fill the result\n            result = bitsCached;\n            bitsCached = 0;\n            bitsCachedSize = 0;\n            // read more bytes\n            long b = in.read();\n            if (b == -1) {\n                return -1;\n            }\n            if (byteOrder == ByteOrder.BIG_ENDIAN) {\n                // flip byte order\n                b = (b & 0xFF) << 24 | (b & 0xFF00) << 8 | (b & 0xFF0000) >> 8 | (b & 0xFF000000) >> 24;\n            }\n            bitsCached = b;\n            bitsCachedSize = 8;\n            result |= (bitsCached & MASKS[count - 8]) << 8 - count;\n            bitsCached >>= count - 8;\n            bitsCachedSize -= count - 8;\n        }\n        return result;\n    }"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws NullArgumentException, DimensionMismatchException {\n    if (v == null) {\n        throw new NullArgumentException();\n    }\n    if (v.getDimension() != getDimension()) {\n        throw new DimensionMismatchException();\n    }\n    FieldMatrix<T> result = new Array2DRowFieldMatrix<T>(field, getDimension(), v.getDimension());\n    for (int i = 0; i < getDimension(); i++) {\n        for (int j = 0; j < v.getDimension(); j++) {\n            result.setEntry(i, j, getEntry(i).multiply(v.getEntry(j)));\n        }\n    }\n    return result;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws NullArgumentException, ZeroException {\n    if (v == null) {\n        throw new NullArgumentException(\"Vector cannot be null\");\n    }\n    if (v.getDimension() == 0) {\n        throw new ZeroException(\"Vector cannot be zero-dimensional\");\n    }\n    int m = this.getDimension();\n    int n = v.getDimension();\n    FieldMatrix<T> product = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            product.setEntry(i, j, this.getEntry(i).multiply(v.getEntry(j)));\n        }\n    }\n    return product;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws NullArgumentException, DimensionMismatchException {\n    if (v == null) {\n        throw new NullArgumentException();\n    }\n    if (getDimension() != v.getDimension()) {\n        throw new DimensionMismatchException();\n    }\n    FieldMatrix<T> result = new Array2DRowFieldMatrix<T>(field, getDimension(), v.getDimension());\n    for (int i = 0; i < getDimension(); i++) {\n        for (int j = 0; j < v.getDimension(); j++) {\n            result.setEntry(i, j, getEntry(i).multiply(v.getEntry(j)));\n        }\n    }\n    return result;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    FieldMatrix<T> product = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) \n    {\n        for (int j = 0; j < n; j++) \n        {\n            product.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return product;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws NullArgumentException, ZeroException {\n    if (v == null) {\n        throw new NullArgumentException(\"ArrayFieldVector v is null\");\n    }\n    if (v.getDimension() == 0) {\n        throw new ZeroException(\"ArrayFieldVector v is zero\");\n    }\n    final int m = this.getDimension();\n    final int n = v.getDimension();\n    FieldMatrix<T> product = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            product.setEntry(i, j, this.getEntry(i).multiply(v.getEntry(j)));\n        }\n    }\n    return product;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException {\n        checkVectorDimensions(v.getDimension());\n        int m = getDimension();\n        int n = v.getDimension();\n        FieldMatrix<T> product = new Array2DRowFieldMatrix<T>(field, m, n);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                product.setEntry(i, j, getEntry(i).multiply(v.getEntry(j)));\n            }\n        }\n        return product;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws DimensionMismatchException, NullArgumentException {\n        if (v == null) {\n            throw new NullArgumentException();\n        }\n        checkVectorDimensions(v.getDimension());\n        FieldMatrix<T> res = new Array2DRowFieldMatrix<T>(field, getDimension(), v.getDimension());\n        for (int i = 0; i < getDimension(); i++) {\n            for (int j = 0; j < v.getDimension(); j++) {\n                res.setEntry(i, j, getEntry(i).multiply(v.getEntry(j)));\n            }\n        }\n        return res;\n    }",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws NullArgumentException, ZeroException {\n    if (v == null) {\n        throw new NullArgumentException(\"ArrayFieldVector v is null\");\n    }\n    if (v.getDimension() == 0) {\n        throw new ZeroException(\"ArrayFieldVector v is zero-dimensional\");\n    }\n    final int m = this.getDimension();\n    final int n = v.getDimension();\n    FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, this.getEntry(i).multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws NullArgumentException, DimensionMismatchException {\n    if (v == null) {\n        throw new NullArgumentException(\"v\");\n    }\n    if (getDimension() != v.getDimension()) {\n        throw new DimensionMismatchException(getDimension(), v.getDimension());\n    }\n    FieldMatrix<T> result = new Array2DRowFieldMatrix<T>(field, getDimension(), v.getDimension());\n    for (int i = 0; i < getDimension(); i++) {\n        for (int j = 0; j < v.getDimension(); j++) {\n            result.setEntry(i, j, getEntry(i).multiply(v.getEntry(j)));\n        }\n    }\n    return result;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  throws NullArgumentException, DimensionMismatchException {\n    if (v == null) {\n        throw new NullArgumentException(\"ArrayFieldVector v is null\");\n    }\n    if (getDimension() != v.getDimension()) {\n        throw new DimensionMismatchException(\"Dimension mismatch\");\n    }\n    FieldMatrix<T> result = new Array2DRowFieldMatrix<T>(field, getDimension(), v.getDimension());\n    for (int i = 0; i < getDimension(); i++) {\n        for (int j = 0; j < v.getDimension(); j++) {\n            result.setEntry(i, j, getEntry(i).multiply(v.getEntry(j)));\n        }\n    }\n    return result;\n}"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node labelNode = getNextSiblingOfType(target, Token.LABEL);\n    return labelNode != null && label.equals(labelNode.getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node labelNode = getNextSiblingOfType(target, Token.LABEL);\n    return labelNode != null && label.equals(labelNode.getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node labelNode = getNextSiblingOfType(target, Token.LABEL);\n    return labelNode != null && label.equals(labelNode.getFirstChild().getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node labelNode = getNextSiblingOfType(target, Token.LABEL);\n    return labelNode != null && label.equals(labelNode.getFirstChild().getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n      return true;\n    }\n    Node labelNode = target.getFirstChild();\n    return labelNode != null && labelNode.getType() == Token.LABEL &&\n           labelNode.getString().equals(label);\n  }",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node labelNode = getNextSiblingOfType(target, Token.LABEL);\n    return labelNode != null && label.equals(labelNode.getFirstChild().getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node labelNode = target.getFirstChild();\n    return labelNode != null && labelNode.getType() == Token.LABEL &&\n           labelNode.getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node labelNode = getNextSiblingOfType(target, Token.LABEL);\n    return labelNode != null && label.equals(labelNode.getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node labelNode = getNextSiblingOfType(target, Token.LABEL);\n    return labelNode != null && label.equals(labelNode.getFirstChild().getString());\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node labelNode = getNextSiblingOfType(target, Token.LABEL);\n    return labelNode != null && label.equals(labelNode.getString());\n}"
    ],
    [
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null && item < urls.size()) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n    String result = null;\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null && item < urls.size()) {\n        result = (String) urls.get(item);\n    }\n    return result;\n}",
      "public String getURL(int series, int item)  {\n        if (series < getListCount() && item < getURLCount(series)) {\n            List urls = (List) urlSeries.get(series);\n            return (String) urls.get(item);\n        }\n        return null;\n    }",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null && item < urls.size()) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null && item < urls.size()) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n        if (series < 0 || series >= getListCount() || item < 0 || item >= getURLCount(series)) {\n            return null;\n        }\n        List urls = (List) this.urlSeries.get(series);\n        return (String) urls.get(item);\n    }",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null && item < urls.size()) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null && item < urls.size()) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null && item < urls.size()) {\n        return (String) urls.get(item);\n    }\n    return null;\n}",
      "public String getURL(int series, int item)  {\n    List urls = (List) this.urlSeries.get(series);\n    if (urls != null && item < urls.size()) {\n        return (String) urls.get(item);\n    }\n    return null;\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len < 2 || str.charAt(0) != '#') {\n        throw new IllegalArgumentException(\"Invalid index: \" + str);\n    }\n    try {\n        return Integer.parseInt(str.substring(1));\n    } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Invalid index: \" + str);\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len < 1 || len > 4) {\n        throw new IllegalArgumentException(\"Invalid index: \" + str + \"; must be 1-4 characters\");\n    }\n    int result = 0;\n    for (int i = 0; i < len; i++) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Invalid index: \" + str + \"; contains non-digit character\");\n        }\n        result = result * 10 + (c - '0');\n    }\n    return result;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len < 1 || len > 4) {\n        throw new IllegalArgumentException(\"Invalid index: '\" + str + \"', must be between 1 and 4 characters long\");\n    }\n    int index = 0;\n    for (int i = 0; i < len; i++) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Invalid index: '\" + str + \"', contains non-digit character\");\n        }\n        index = index * 10 + (c - '0');\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int value = 0;\n    int index = 0;\n\n    while (index < len) {\n        char ch = str.charAt(index);\n        if (ch < '0' || ch > '9') {\n            break;\n        }\n        value = (value * 10) + (ch - '0');\n        index++;\n    }\n\n    return value;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int value = 0;\n    for (int i = 0; i < len; i++) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Invalid index: \" + str);\n        }\n        value = value * 10 + (c - '0');\n    }\n    return value;\n}",
      "private final static int _parseIndex(String str)  {\n    if (str == null || str.length() == 0) {\n        return -1;\n    }\n    int index = 0;\n    try {\n        index = Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    if (str.length() < 2 || str.charAt(0) != '#') {\n        throw new IllegalArgumentException(\"Invalid index: \" + str);\n    }\n    try {\n        return Integer.parseInt(str.substring(1));\n    } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Invalid index: \" + str);\n    }\n}\n\nprotected static JsonPointer _parseTail(String input) \n{\n    if (input.isEmpty()) {\n        return EMPTY;\n    }\n    int slash = input.indexOf('/');\n    if (slash < 0) {\n        return new JsonPointer(input, input, -1, null);\n    }\n    return new JsonPointer(input.substring(0, slash), input.substring(slash + 1), -1, _parseTail(input.substring(slash + 1)));\n}\n\nprotected static JsonPointer _parseQuotedTail(String input, int i) \n{\n    if (i >= input.length()) {\n        throw new IllegalArgumentException(\"Invalid pointer: \" + input);\n    }\n    if (input.charAt(i) != '\"') {\n        throw new IllegalArgumentException(\"Invalid pointer: \" + input);\n    }\n    int end = input.indexOf('\"', i + 1);\n    if (end < 0) {\n        throw new IllegalArgumentException(\"Invalid pointer: \" + input);\n    }\n    String segment = input.substring(i + 1, end);\n    return _parseTail(input.substring(end + 1));\n}\n\nprotected JsonPointer _constructHead() \n{\n    JsonPointer head = _constructHead(0, null);\n    _head = head;\n    return head;\n}\n\nprotected JsonPointer _constructHead(int suffixLength, JsonPointer last) \n{\n    if (_nextSegment == null) {\n        return new JsonPointer(_asString, _matchingPropertyName, _matchingElementIndex, last);\n    }\n    return new JsonPointer(_nextSegment._asString, _nextSegment._matchingPropertyName, _nextSegment._matchingElementIndex, _constructHead(suffixLength + 1, last));\n}",
      "private final static int _parseIndex(String str)  {\n    if (str == null || str.length() == 0) {\n        return -1;\n    }\n    int index = 0;\n    try {\n        index = Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int val = 0;\n    for (int i = 0; i < len; ++i) {\n        char ch = str.charAt(i);\n        if (ch < '0' || ch > '9') {\n            break;\n        }\n        val = (val * 10) + (ch - '0');\n    }\n    return val;\n}",
      "private final static int _parseIndex(String str)  {\n    if (str.length() < 2 || str.charAt(0) != '$') {\n        throw new IllegalArgumentException(\"Invalid JSON Pointer: \" + str);\n    }\n    try {\n        return Integer.parseInt(str.substring(1));\n    } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(\"Invalid JSON Pointer: \" + str);\n    }\n}\n\nprotected static JsonPointer _parseTail(String input) \n{\n    if (input.isEmpty()) {\n        return EMPTY;\n    }\n    int slashIndex = input.indexOf('/');\n    if (slashIndex == -1) {\n        return new JsonPointer(input, input, -1, null);\n    }\n    String segment = input.substring(0, slashIndex);\n    String remaining = input.substring(slashIndex + 1);\n    return new JsonPointer(input, segment, _parseTail(remaining));\n}\n\nprotected static JsonPointer _parseQuotedTail(String input, int i) \n{\n    if (input.isEmpty()) {\n        return EMPTY;\n    }\n    int slashIndex = input.indexOf('/', i);\n    if (slashIndex == -1) {\n        return new JsonPointer(input, input, -1, null);\n    }\n    String segment = input.substring(i + 1, slashIndex);\n    String remaining = input.substring(slashIndex + 1);\n    return new JsonPointer(input, segment, _parseQuotedTail(input, slashIndex));\n}\n\nprotected JsonPointer _constructHead() \n{\n    JsonPointer head = _constructHead(0, this);\n    _head = head;\n    return head;\n}\n\nprotected JsonPointer _constructHead(int suffixLength, JsonPointer last) \n{\n    if (last == null) {\n        return this;\n    }\n    return new JsonPointer(_asString, last._matchingPropertyName, last._matchingElementIndex, _constructHead(suffixLength + last._asString.length() + 1, last._nextSegment));\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    if (k > n) {\n        throw new NumberIsTooLargeException(\"Sample size is larger than collection size.\");\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(\"Sample size must be positive.\");\n    }\n\n    int[] permutation = nextPermutation(n, k);\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (int index : permutation) {\n        sample[i++] = new ArrayList<>(c).get(index);\n    }\n\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    if (k > n) {\n        throw new NumberIsTooLargeException(\"Sample size cannot be larger than collection size.\");\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(\"Sample size must be positive.\");\n    }\n\n    int[] permutation = nextPermutation(n, k);\n    Object[] sample = new Object[k];\n    int i = 0;\n    for (int index : permutation) {\n        sample[i++] = new ArrayList<>(c).get(index);\n    }\n\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(\"k is larger than the size of the collection\", k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(\"k must be positive\", k);\n    }\n\n    Object[] array = c.toArray();\n    int[] permutation = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n\n    for (int i = 0; i < k; i++) {\n        sample[i] = array[permutation[i]];\n    }\n\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        if (k > c.size()) {\n            throw new NumberIsTooLargeException(\"k is larger than the size of the collection\", k, c.size(), true);\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(\"k must be a positive integer\", k);\n        }\n\n        List<?> list = new ArrayList<>(c);\n        int[] permutation = nextPermutation(list.size(), k);\n        Object[] sample = new Object[k];\n        for (int i = 0; i < k; i++) {\n            sample[i] = list.get(permutation[i]);\n        }\n        return sample;\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        int n = c.size();\n        if (k > n) {\n            throw new NumberIsTooLargeException(\"Sample size is larger than collection size\");\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(\"Sample size must be positive\");\n        }\n\n        int[] perm = nextPermutation(n, k);\n        Object[] sample = new Object[k];\n        int i = 0;\n        for (int index : perm) {\n            sample[i++] = new ArrayList<>(c).get(index);\n        }\n        return sample;\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(\"Sample size exceeds collection size\", k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(\"Sample size must be positive\", k);\n    }\n\n    Object[] collectionArray = c.toArray();\n    int[] permutation = nextPermutation(c.size(), k);\n    Object[] sample = new Object[k];\n\n    for (int i = 0; i < k; i++) {\n        sample[i] = collectionArray[permutation[i]];\n    }\n\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        if (k > c.size()) {\n            throw new NumberIsTooLargeException(\"k is larger than the size of the collection\", k, c.size(), true);\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(\"k should be positive\", k);\n        }\n\n        List<?> list = new ArrayList<>(c);\n        return nextPermutation(list.size(), k);\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        int n = c.size();\n        if (k > n) {\n            throw new NumberIsTooLargeException(\"k is larger than the size of the collection\", k, n, true);\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(\"k should be positive\", k);\n        }\n\n        int[] permutation = nextPermutation(n, k);\n        Object[] sample = new Object[k];\n        int i = 0;\n        for (Object obj : c) {\n            if (Arrays.binarySearch(permutation, i) >= 0) {\n                sample[i++] = obj;\n            }\n        }\n        return sample;\n    }",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(\"Sample size is larger than collection size\");\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(\"Sample size should be positive\");\n    }\n\n    List<Object> list = new ArrayList<>(c);\n    int[] permutation = nextPermutation(list.size(), k);\n    Object[] sample = new Object[k];\n\n    for (int i = 0; i < k; i++) {\n        sample[i] = list.get(permutation[i]);\n    }\n\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n        int n = c.size();\n        if (k > n) {\n            throw new NumberIsTooLargeException(\"k is larger than the size of the collection\", k, n, true);\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(\"k must be a positive integer\", k);\n        }\n\n        int[] permutation = nextPermutation(n, k);\n        Object[] sample = new Object[k];\n        int i = 0;\n        for (int index : permutation) {\n            sample[i++] = new ArrayList<>(c).get(index);\n        }\n        return sample;\n    }"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node call = new Node(Node.CALL, srcref);\n    Node method = new Node(Node.NAME, methodName, srcref);\n    call.addChildToBack(method);\n    call.addChildToBack(argumentNode);\n    return call;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Node(Node.CALL, srcref);\n    Node methodNode = new Node(Node.NAME, methodName, srcref);\n    callNode.addChildrenToBack(methodNode);\n    callNode.addChildrenToBack(argumentNode);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node call = new Node(Node.CALL, srcref);\n    Node callee = new Node(Node.NAME, methodName, srcref);\n    call.addChildrenToBack(callee, argumentNode);\n    return call;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node call = new Node(Node.CALL, srcref);\n    Node callee = new Node(Node.NAME, methodName, srcref);\n    call.addChildToBack(callee);\n    call.addChildToBack(argumentNode);\n    return call;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Node(Node.CALL, srcref);\n    Node methodNode = new Node(Node.NAME, methodName, srcref);\n    callNode.addChildrenToBack(methodNode);\n    callNode.addChildrenToBack(argumentNode);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node call = new Node(Node.CALL, srcref);\n    Node method = new Node(Node.NAME, methodName, srcref);\n    call.addChildrenToBack(method, argumentNode);\n    return call;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Node(Node.CALL, srcref);\n    Node methodNode = new Node(Node.NAME, methodName, srcref);\n    Node argsNode = new Node(Node.ARG_LIST, argumentNode, srcref);\n    callNode.addChildrenToBack(methodNode);\n    callNode.addChildrenToBack(argsNode);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Node(Node.CALL, srcref);\n    Node methodNode = new Node(Node.NAME, methodName, srcref);\n    callNode.addChildToBack(methodNode);\n    callNode.addChildToBack(argumentNode);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Node(Node.CALL, srcref);\n    Node methodNode = new Node(Node.NAME, methodName, srcref);\n    Node argsNode = new Node(Node.ARG_LIST, argumentNode, srcref);\n    callNode.addChildrenToBack(methodNode);\n    callNode.addChildrenToBack(argsNode);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node call = new Node(Node.CALL, srcref);\n    Node method = new Node(Node.NAME, methodName, srcref);\n    call.addChildToBack(method);\n    call.addChildToBack(argumentNode);\n    return call;\n}"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] indexed = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) \n    {\n        indexed[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indexed);\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) \n    {\n        indices[i] = indexed[i].index;\n    }\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    int[] sortedIndices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        sortedIndices[i] = indices[i].index;\n    }\n    return sortedIndices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] indexArray = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indexArray[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indexArray);\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = indexArray[i].index;\n    }\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] doubleIndices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        doubleIndices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(doubleIndices);\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubleIndices.length; i++) {\n        indices[i] = doubleIndices[i].index;\n    }\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] indexed = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indexed[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indexed);\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = indexed[i].index;\n    }\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] doubleIndices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        doubleIndices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(doubleIndices);\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = doubleIndices[i].index;\n    }\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] doubleIndices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        doubleIndices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(doubleIndices);\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = doubleIndices[i].index;\n    }\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] doubleIndices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        doubleIndices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(doubleIndices);\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubleIndices.length; i++) {\n        indices[i] = doubleIndices[i].index;\n    }\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final DoubleIndex[] indices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(indices);\n    final int[] sortedIndices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        sortedIndices[i] = indices[i].index;\n    }\n    return sortedIndices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    DoubleIndex[] doubleIndices = new DoubleIndex[doubles.length];\n    for (int i = 0; i < doubles.length; i++) \n    {\n        doubleIndices[i] = new DoubleIndex(doubles[i], i);\n    }\n    Arrays.sort(doubleIndices);\n    int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) \n    {\n        indices[i] = doubleIndices[i].index;\n    }\n    return indices;\n}"
    ],
    [
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        cachedQt = MatrixUtils.createRealMatrix(householderVectors);\n    }\n    return cachedQt;\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable result = (Comparable) this.keyToGroupMap.get(key);\n    if (result == null) {\n        result = this.defaultGroup;\n    }\n    return result;\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer) {\n        @Override\n        protected E transformElement(E element) {\n            return transformer.transform(element);\n        }\n    };\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer) \n    {\n        @Override\n        protected E transformElement(E element) \n        {\n            return transformer.transform(element);\n        }\n    };\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer) {\n        @Override\n        protected E transformElement(E element) {\n            return transformer.transform(element);\n        }\n    };\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer) \n    {\n        @Override\n        protected E transformElement(E element) \n        {\n            return transformer.transform(element);\n        }\n    };\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer) {\n        @Override\n        protected E transformElement(E element) {\n            return transformer.transform(element);\n        }\n    };\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer) \n    {\n        @Override\n        protected E transformElement(E element) \n        {\n            return transformer.transform(element);\n        }\n    };\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer) \n    {\n        @Override\n        protected E transformElement(E element) \n        {\n            return transformer.transform(element);\n        }\n    };\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n        if (set == null || transformer == null) \n        {\n            throw new NullPointerException();\n        }\n        return new TransformedSet<E>(set, transformer) \n        {\n            @Override\n            protected E transformElement(E element) \n            {\n                return transformer.transform(element);\n            }\n        };\n    }",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer) {\n        @Override\n        protected E transformElement(E element) {\n            return transformer.transform(element);\n        }\n    };\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n        if (set == null || transformer == null) \n        {\n            throw new NullPointerException();\n        }\n        return new TransformedSet<E>(set, transformer) \n        {\n            @Override\n            protected E transformElement(E element) \n            {\n                return transformer.transform(element);\n            }\n        };\n    }"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) \n    {\n        double seriesTotal = 0.0;\n        int itemCount = dataset.getItemCount(seriesIndex);\n        for (int itemIndex = 0; itemIndex < itemCount; itemIndex++) \n        {\n            double value = dataset.getYValue(seriesIndex, itemIndex).doubleValue();\n            seriesTotal += value;\n            if (seriesTotal < minimum) \n            {\n                minimum = seriesTotal;\n            }\n            if (seriesTotal > maximum) \n            {\n                maximum = seriesTotal;\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) \n    {\n        double total = 0.0;\n        int itemCount = dataset.getItemCount(s);\n        for (int i = 0; i < itemCount; i++) \n        {\n            double value = dataset.getValue(s, i).doubleValue();\n            total += value;\n            if (total < minimum) \n            {\n                minimum = total;\n            }\n            if (total > maximum) \n            {\n                maximum = total;\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int series = 0; series < seriesCount; series++) \n    {\n        double total = 0.0;\n        int itemCount = dataset.getItemCount(series);\n        for (int item = 0; item < itemCount; item++) \n        {\n            double value = dataset.getYValue(series, item).doubleValue();\n            total += value;\n            if (total < minimum) \n            {\n                minimum = total;\n            }\n            if (total > maximum) \n            {\n                maximum = total;\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) \n    {\n        double total = 0.0;\n        int itemCount = dataset.getItemCount(s);\n        for (int i = 0; i < itemCount; i++) \n        {\n            double value = dataset.getValue(s, i).doubleValue();\n            total += value;\n            if (total < minimum) \n            {\n                minimum = total;\n            }\n            if (total > maximum) \n            {\n                maximum = total;\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) \n    {\n        double total = 0.0;\n        int itemCount = dataset.getItemCount(s);\n        for (int i = 0; i < itemCount; i++) \n        {\n            double value = dataset.getValue(s, i).doubleValue();\n            total += value;\n            if (total < minimum) \n            {\n                minimum = total;\n            }\n            if (total > maximum) \n            {\n                maximum = total;\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int series = 0; series < seriesCount; series++) \n    {\n        double total = 0.0;\n        int itemCount = dataset.getItemCount(series);\n        for (int item = 0; item < itemCount; item++) \n        {\n            double value = dataset.getValue(series, item).doubleValue();\n            total += value;\n            if (total < minimum) \n            {\n                minimum = total;\n            }\n            if (total > maximum) \n            {\n                maximum = total;\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) \n    {\n        double total = 0.0;\n        int itemCount = dataset.getItemCount(s);\n        for (int i = 0; i < itemCount; i++) \n        {\n            double value = dataset.getYValue(s, i);\n            if (!Double.isNaN(value)) \n            {\n                total += value;\n                if (total < minimum) \n                {\n                    minimum = total;\n                }\n                if (total > maximum) \n                {\n                    maximum = total;\n                }\n            }\n        }\n    }\n    if (minimum == Double.POSITIVE_INFINITY || maximum == Double.NEGATIVE_INFINITY) \n    {\n        return null;\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int series = 0; series < seriesCount; series++) \n    {\n        double total = 0.0;\n        int itemCount = dataset.getItemCount(series);\n        for (int item = 0; item < itemCount; item++) \n        {\n            double value = dataset.getValue(series, item).doubleValue();\n            total += value;\n            if (total < minimum) \n            {\n                minimum = total;\n            }\n            if (total > maximum) \n            {\n                maximum = total;\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int series = 0; series < seriesCount; series++) \n    {\n        double total = 0.0;\n        int itemCount = dataset.getItemCount(series);\n        for (int item = 0; item < itemCount; item++) \n        {\n            double value = dataset.getYValue(series, item);\n            if (!Double.isNaN(value)) \n            {\n                total += value;\n                if (total < minimum) \n                {\n                    minimum = total;\n                }\n                if (total > maximum) \n                {\n                    maximum = total;\n                }\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getSeriesCount();\n    for (int seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) \n    {\n        double seriesTotal = 0.0;\n        int itemCount = dataset.getItemCount(seriesIndex);\n        for (int itemIndex = 0; itemIndex < itemCount; itemIndex++) \n        {\n            double value = dataset.getYValue(seriesIndex, itemIndex).doubleValue();\n            seriesTotal += value;\n            if (seriesTotal < minimum) \n            {\n                minimum = seriesTotal;\n            }\n            if (seriesTotal > maximum) \n            {\n                maximum = seriesTotal;\n            }\n        }\n    }\n    return new Range(minimum, maximum);\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours offset must be between -23 and 23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes offset must be between -59 and 59\");\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes offset cannot be negative when hours offset is positive\");\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes < -1439 || totalMinutes > 1439) {\n        throw new IllegalArgumentException(\"Resulting offset exceeds +/- 23:59\");\n    }\n    return fixedOffsetZone(String.valueOf(totalMinutes), totalMinutes * DateTimeConstants.MILLIS_PER_MINUTE);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Hour offset out of range: \" + hoursOffset);\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minute offset out of range: \" + minutesOffset);\n        }\n        if (minutesOffset < 0 && hoursOffset > 0) {\n            throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive: \" + hoursOffset + \":\" + minutesOffset);\n        }\n        int millisOffset = (hoursOffset * 60 + minutesOffset) * 60 * 1000;\n        if (millisOffset < -23*60*60*1000 || millisOffset > 23*60*60*1000) {\n            throw new IllegalArgumentException(\"Resulting offset exceeds +/- 23:59:59.000: \" + hoursOffset + \":\" + minutesOffset);\n        }\n        return forOffsetMillis(millisOffset);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours offset must be in the range -23 to +23\");\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes offset must be in the range -59 to +59\");\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    int totalMinutes = (hoursOffset * 60) + minutesOffset;\n    if (totalMinutes < -1439 || totalMinutes > 1439) {\n        throw new IllegalArgumentException(\"Resulting offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(String.valueOf(totalMinutes), totalMinutes * 60 * 1000);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Hours offset must be between -23 and 23\");\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes offset must be between -59 and 59\");\n        }\n        int totalMinutes = hoursOffset * 60 + minutesOffset;\n        if (totalMinutes < -1439 || totalMinutes > 1439) {\n            throw new IllegalArgumentException(\"Total offset must be between -23:59 and +23:59\");\n        }\n        String id = printOffset(totalMinutes);\n        return fixedOffsetZone(id, totalMinutes * DateTimeConstants.MILLIS_PER_MINUTE);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Hour offset out of range: \" + hoursOffset);\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minute offset out of range: \" + minutesOffset);\n        }\n        if (minutesOffset < 0 && hoursOffset > 0) {\n            throw new IllegalArgumentException(\"Minute offset cannot be negative when hour offset is positive\");\n        }\n        int totalMinutes = (hoursOffset * 60) + minutesOffset;\n        if (totalMinutes < -1439 || totalMinutes > 1439) {\n            throw new IllegalArgumentException(\"Total offset exceeds +/- 23:59:59.000\");\n        }\n        return fixedOffsetZone(String.valueOf(totalMinutes), totalMinutes * 60 * 1000);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour offset out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute offset out of range: \" + minutesOffset);\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minute offset cannot be negative when hour offset is positive\");\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes < -1439 || totalMinutes > 1439) {\n        throw new IllegalArgumentException(\"Resulting offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(hoursOffset + \":\" + (minutesOffset < 0 ? \"0\" : \"\") + minutesOffset, totalMinutes);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n        if (hoursOffset < -23 || hoursOffset > 23) {\n            throw new IllegalArgumentException(\"Hours offset out of range: \" + hoursOffset);\n        }\n        if (minutesOffset < -59 || minutesOffset > 59) {\n            throw new IllegalArgumentException(\"Minutes offset out of range: \" + minutesOffset);\n        }\n        if (minutesOffset < 0 && hoursOffset > 0) {\n            throw new IllegalArgumentException(\"Minutes offset cannot be negative when hours offset is positive\");\n        }\n        int totalOffset = (hoursOffset * 60) + minutesOffset;\n        if (totalOffset < -1439 || totalOffset > 1439) {\n            throw new IllegalArgumentException(\"Total offset exceeds +/- 23:59\");\n        }\n        return fixedOffsetZone(hoursOffset + \":\" + (minutesOffset < 0 ? \"0\" + -minutesOffset : minutesOffset), totalOffset);\n    }",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours offset out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes offset out of range: \" + minutesOffset);\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes offset cannot be negative when hours offset is positive\");\n    }\n    int totalMinutes = (hoursOffset * 60) + minutesOffset;\n    if (totalMinutes < -1439 || totalMinutes > 1439) {\n        throw new IllegalArgumentException(\"Total offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(hoursOffset + \":\" + (minutesOffset < 0 ? \"0\" + -minutesOffset : minutesOffset), totalMinutes);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour offset out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute offset out of range: \" + minutesOffset);\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes < -1439 || totalMinutes > 1439) {\n        throw new IllegalArgumentException(\"Resulting offset exceeds +/- 23:59:59.000\");\n    }\n    return fixedOffsetZone(hoursOffset + \":\" + (minutesOffset < 0 ? \"0\" : \"\") + minutesOffset, totalMinutes);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23)\n    {\n        throw new IllegalArgumentException(\"Hour offset out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59)\n    {\n        throw new IllegalArgumentException(\"Minute offset out of range: \" + minutesOffset);\n    }\n    if (minutesOffset < 0 && hoursOffset > 0)\n    {\n        throw new IllegalArgumentException(\"Minute offset cannot be negative when hour offset is positive\");\n    }\n    int totalMinutes = hoursOffset * 60 + minutesOffset;\n    if (totalMinutes < -1439 || totalMinutes > 1439)\n    {\n        throw new IllegalArgumentException(\"Resulting offset exceeds +/- 23:59:59.000\");\n    }\n    return new DateTimeZone(\"Offset \" + totalMinutes) {\n}\n}"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    int level = 0;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (c == open) \n        {\n            level++;\n        } \n        else if (c == close) \n        {\n            if (level == 0) \n            {\n                break;\n            }\n            level--;\n        }\n        sb.append(c);\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder result = new StringBuilder();\n    int balance = 0;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (c == open) \n        {\n            balance++;\n        } \n        else if (c == close) \n        {\n            balance--;\n            if (balance == 0) \n            {\n                break;\n            }\n        }\n        result.append(c);\n    }\n    return result.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    int level = 0;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (c == open) \n        {\n            level++;\n        } \n        else if (c == close) \n        {\n            level--;\n            if (level == 0) \n            {\n                break;\n            }\n        }\n        sb.append(c);\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    boolean inQuote = false;\n    boolean escapeNext = false;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (c == ESC && !inQuote) \n        {\n            escapeNext = true;\n            continue;\n        }\n        if (escapeNext) \n        {\n            sb.append(c);\n            escapeNext = false;\n            continue;\n        }\n        if (c == '\\\"' || c == '\\'') \n        {\n            inQuote = !inQuote;\n            continue;\n        }\n        if (c == open) \n        {\n            sb.append(c);\n            String inner = chompBalanced(open, close);\n            sb.append(inner);\n            continue;\n        }\n        if (c == close && !inQuote) \n        {\n            sb.append(c);\n            break;\n        }\n        sb.append(c);\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    boolean inEscape = false;\n    boolean inBalance = false;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (c == ESC) \n        {\n            inEscape = !inEscape;\n            if (!inEscape) \n                sb.append(c);\n        } \n        else if (inEscape) \n        {\n            sb.append(c);\n            inEscape = false;\n        } \n        else if (c == open) \n        {\n            inBalance = true;\n            sb.append(c);\n        } \n        else if (c == close) \n        {\n            if (inBalance) \n            {\n                sb.append(c);\n                return sb.toString();\n            } \n            else \n                sb.append(c);\n        } \n        else \n        {\n            sb.append(c);\n            if (!inBalance) \n                inBalance = true;\n        }\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder result = new StringBuilder();\n    int level = 0;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (c == open) \n        {\n            level++;\n        } \n        else if (c == close) \n        {\n            level--;\n            if (level == 0) \n            {\n                break;\n            }\n        }\n        result.append(c);\n    }\n    return result.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder result = new StringBuilder();\n    int balance = 0;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (c == open) \n        {\n            balance++;\n        } \n        else if (c == close) \n        {\n            balance--;\n            if (balance == 0) \n            {\n                break;\n            }\n        }\n        result.append(c);\n    }\n    return result.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    int level = 0;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (c == open) \n        {\n            level++;\n        } \n        else if (c == close) \n        {\n            level--;\n            if (level == 0) \n            {\n                break;\n            }\n        }\n        sb.append(c);\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    boolean escaped = false;\n    boolean balanced = false;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (c == ESC) \n        {\n            escaped = true;\n            continue;\n        }\n        if (escaped) \n        {\n            sb.append(c);\n            escaped = false;\n            continue;\n        }\n        if (c == open) \n        {\n            balanced = true;\n        } \n        else if (c == close) \n        {\n            if (balanced) \n            {\n                return sb.toString();\n            } \n            else \n            {\n                addFirst(close);\n                continue;\n            }\n        }\n        if (balanced) \n        {\n            sb.append(c);\n        } \n        else \n        {\n            addFirst(c);\n        }\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    int level = 0;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (c == open) \n        {\n            level++;\n        } \n        else if (c == close) \n        {\n            level--;\n            if (level == 0) \n            {\n                break;\n            }\n        }\n        sb.append(c);\n    }\n    return sb.toString();\n}"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix hatMatrix = calculateHat();\n        int p = hatMatrix.getRowDimension();\n        RealMatrix R = qr.getR();\n        RealMatrix RInv = R.subMatrix(0, p-1, 0, p-1).solve(R.getSubMatrix(0, p-1, 0, p-1).getInverse());\n        return RInv.multiply(hatMatrix);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix hatMatrix = calculateHat();\n        RealMatrix identity = MatrixUtils.createRealIdentityMatrix(hatMatrix.getRowDimension());\n        RealMatrix betaVariance = identity.subtract(hatMatrix).solve(identity);\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix hatMatrix = calculateHat();\n        RealMatrix identity = MatrixUtils.createRealIdentityMatrix(hatMatrix.getRowDimension());\n        return identity.subtract(hatMatrix).inverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix hatMatrix = calculateHat();\n        RealMatrix identity = MatrixUtils.createRealIdentityMatrix(hatMatrix.getRowDimension());\n        return identity.subtract(hatMatrix).inverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix hatMatrix = calculateHat();\n        RealMatrix identity = new Array2DRowRealMatrix(hatMatrix.getRowDimension(), hatMatrix.getColumnDimension());\n        for (int i = 0; i < identity.getRowDimension(); i++) {\n            for (int j = 0; j < identity.getColumnDimension(); j++) {\n                if (i == j) {\n                    identity.setEntry(i, j, 1);\n                } else {\n                    identity.setEntry(i, j, 0);\n                }\n            }\n        }\n        return identity.subtract(hatMatrix).inverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix hatMatrix = calculateHat();\n        RealMatrix identity = new Array2DRowRealMatrix(hatMatrix.getRowDimension(), hatMatrix.getColumnDimension());\n        for (int i = 0; i < identity.getRowDimension(); i++) {\n            for (int j = 0; j < identity.getColumnDimension(); j++) {\n                if (i == j) {\n                    identity.setEntry(i, j, 1);\n                } else {\n                    identity.setEntry(i, j, 0);\n                }\n            }\n        }\n        try {\n            return identity.subtract(hatMatrix).inverse();\n        } catch (NonInvertibleMatrixException e) {\n            throw new MathIllegalArgumentException(e);\n        }\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix hatMatrix = calculateHat();\n        RealMatrix identity = MatrixUtils.createRealIdentityMatrix(hatMatrix.getRowDimension());\n        return identity.subtract(hatMatrix).inverse();\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix hatMatrix = calculateHat();\n        RealMatrix identity = new Array2DRowRealMatrix(hatMatrix.getRowDimension(), hatMatrix.getColumnDimension());\n        RealMatrix betaVariance = identity.subtract(hatMatrix).solve(identity);\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix hatMatrix = calculateHat();\n        int n = hatMatrix.getRowDimension();\n        int p = hatMatrix.getColumnDimension();\n\n        // Create augmented identity matrix\n        Array2DRowRealMatrix augI = new Array2DRowRealMatrix(n, n);\n        double[][] augIData = augI.getDataRef();\n        for (int i = 0; i < n; i++) {\n            for (int j =0; j < n; j++) {\n                if (i >= p) {\n                    augIData[i][j] = 0d;\n                } else if (i == j) {\n                    augIData[i][j] = 1d;\n                } else {\n                    augIData[i][j] = 0d;\n                }\n            }\n        }\n\n        // Compute and return Beta Variance matrix\n        // No DME advertised - args valid if we get here\n        return augI.subtract(hatMatrix).solve(hatMatrix).scalarMultiply(n / (n - p));\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix hatMatrix = calculateHat();\n        int p = hatMatrix.getRowDimension();\n        RealMatrix rMatrix = qr.getR();\n        RealMatrix rtMatrix = rMatrix.transpose();\n        RealMatrix rInv = rtMatrix.multiply(rtMatrix).inverse();\n        return rInv.multiply(hatMatrix);\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n        return offsetFormatter().print(offset);\n    }",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n        return offsetFormatter().print(offset);\n    }",
      "private static String printOffset(int offset)  {\n    return offsetFormatter().print(offset);\n}",
      "private static String printOffset(int offset)  {\n        return offsetFormatter().print(offset);\n    }",
      "private static String printOffset(int offset)  {\n        return offsetFormatter().print(offset);\n    }",
      "private static String printOffset(int offset)  {\n        if (offset == 0) {\n            return \"Z\";\n        }\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        int minutes = (offset % DateTimeConstants.MILLIS_PER_HOUR) / DateTimeConstants.MILLIS_PER_MINUTE;\n        return (hours < 0 ? \"-\" : \"+\") + String.format(\"%02d:%02d\", Math.abs(hours), minutes);\n    }",
      "private static String printOffset(int offset)  {\n        return offsetFormatter().print(offset);\n    }",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    int absOffset = Math.abs(offset);\n    int hours = absOffset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (absOffset % DateTimeConstants.MILLIS_PER_HOUR) / DateTimeConstants.MILLIS_PER_MINUTE;\n    return (offset < 0 ? \"-\" : \"+\") + String.format(\"%02d:%02d\", hours, minutes);\n}"
    ],
    [
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key must not be null\");\n    }\n    int index = this.keys.indexOf(key);\n    if (index >= 0) {\n        return index;\n    }\n    return -1;  // we didn't find the key\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    return this.keys.indexOf(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null keys are not permitted\");\n    }\n    return keys.indexOf(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    return keys.indexOf(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key must not be null\");\n    }\n    int index = keys.indexOf(key);\n    if (index == -1) {\n        return -1;\n    }\n    return index;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Key cannot be null\");\n    }\n    int index = keys.indexOf(key);\n    if (index == -1) {\n        return -1;\n    }\n    return index;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Key must not be null\");\n    }\n    return this.keys.indexOf(key);\n}",
      "public int getIndex(Comparable key)  {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Key cannot be null\");\n        }\n        return keys.indexOf(key);\n    }",
      "public int getIndex(Comparable key)  {\n        if (key == null) {\n            throw new IllegalArgumentException(\"Key cannot be null\");\n        }\n        int index = this.keys.indexOf(key);\n        if (index != -1) {\n            return index;\n        }\n        return -1;  // we didn't find the key\n    }",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null keys are not permitted\");\n    }\n\n    int index = this.keys.indexOf(key);\n    if (index >= 0 && index < this.values.size()) \n    {\n        return index;\n    }\n    else \n    {\n        return -1;\n    }\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n    LinkedFlowScope current = this;\n    while (current != null) {\n      for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : current.cache.symbols.entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n          slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n      }\n      current = current.parent;\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n\n    LinkedFlowScope current = this;\n    while (current != null) {\n      for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : current.cache.symbols.entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n          slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n      }\n      current = current.parent;\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n\n    LinkedFlowScope current = this;\n    while (current != null) {\n      for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : current.cache.symbols.entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n          slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n      }\n      current = current.parent;\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    LinkedFlowScope current = this;\n    while (current != null) {\n      for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : current.cache.symbols.entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n          slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n      }\n      current = current.parent;\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    LinkedFlowScope current = this;\n    while (current != null) {\n      for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : current.cache.symbols.entrySet()) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n      current = current.parent;\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    LinkedFlowScope current = this;\n    while (current != null) {\n      for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : current.cache.symbols.entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n          slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n      }\n      current = current.parent;\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = Maps.newHashMap();\n\n    LinkedFlowScope current = this;\n    while (current != null) {\n      for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : current.cache.symbols.entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n          slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n      }\n      current = current.parent;\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n\n    // Add the slots from the parent scope.\n    if (parent != null) {\n      Map<String, StaticSlot<JSType>> parentSlots = parent.allFlowSlots();\n      for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : parentSlots.entrySet()) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    // Add the slots from the cache.\n    for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : cache.symbols.entrySet()) {\n      if (!slots.containsKey(symbolEntry.getKey())) {\n        slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n      }\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    LinkedFlowScope current = this;\n    while (current != null) {\n      for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : current.cache.symbols.entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n          slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n      }\n      current = current.parent;\n    }\n\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    LinkedFlowScope current = this;\n    while (current != null) {\n      for (Map.Entry<String, StaticSlot<JSType>> symbolEntry : current.cache.symbols.entrySet()) {\n        if (!slots.containsKey(symbolEntry.getKey())) {\n          slots.put(symbolEntry.getKey(), symbolEntry.getValue());\n        }\n      }\n      current = current.parent;\n    }\n\n    return slots;\n  }"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
    ],
    [
      "public static double atanh(double a)  {\n    if (a <= -1.0 || a >= 1.0) {\n        throw new IllegalArgumentException(\"atanh is undefined for |a| >= 1\");\n    }\n    return 0.5 * FastMath.log((1.0 + a) / (1.0 - a));\n}",
      "public static double atanh(double a)  {\n    if (a <= -1.0 || a >= 1.0) {\n        if (a == Double.POSITIVE_INFINITY) {\n            return 0.0;\n        }\n        if (a == Double.NEGATIVE_INFINITY) {\n            return 0.0;\n        }\n        throw new IllegalArgumentException(\"atanh out of domain: \" + a);\n    }\n\n    double result;\n    if (Math.abs(a) < 0.1) {\n        double a2 = a * a;\n        result = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2;\n    } else {\n        result = 0.5 * FastMath.log((1 + a) / (1 - a));\n    }\n\n    return result;\n}",
      "public static double atanh(double a)  {\n    if (a <= -1.0 || a >= 1.0) {\n        throw new IllegalArgumentException(\"atanh(\" + a + \") is not defined\");\n    }\n    if (a == 1.0) {\n        return 0.0;\n    }\n    if (a == -1.0) {\n        return -0.0;\n    }\n    double result = a;\n    double absa = Math.abs(a);\n    if (absa < 0.167) {\n        double a2 = a * a;\n        if (absa > 0.036) {\n            result += a * (a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (absa > 0.0036) {\n            result += a * (a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else {\n            result += a * (a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        }\n}\n}",
      "public static double atanh(double a)  {\n    if (a <= -1.0 || a >= 1.0) {\n        throw new IllegalArgumentException(\"Atanh is undefined for |a| >= 1\");\n    }\n    return 0.5 * FastMath.log((1.0 + a) / (1.0 - a));\n}",
      "public static double atanh(double a)  {\n    if (a <= -1.0 || a >= 1.0) {\n        throw new IllegalArgumentException(\"atanh is not defined for |a| >= 1\");\n    }\n\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    double a2 = a * a;\n    double result;\n    if (a > 0.167) {\n        result = FastMath.log((1 + a) / (1 - a)) / 2;\n    } else {\n        result = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2;\n    }\n\n    return negative ? -result : result;\n}",
      "public static double atanh(double a)  {\n    if (a > 1.0 || a < -1.0) {\n        throw new IllegalArgumentException(\"|a| must be less than 1\");\n    }\n\n    if (a == 1.0) {\n        return 0.5 * Math.PI;\n    }\n    if (a == -1.0) {\n        return -0.5 * Math.PI;\n    }\n\n    final double a2 = a * a;\n    final double a4 = a2 * a2;\n    final double a6 = a4 * a2;\n    final double a8 = a4 * a4;\n    final double a10 = a8 * a2;\n    final double a12 = a8 * a4;\n    final double a14 = a12 * a2;\n\n    // atanh(x) = x * (1 + x^2 * (3 + x^2 * (5 + x^2 * (7 + x^2 * (9 + x^2 * (11 + x^2 * (13 + x^2 * (15 + x^2 * 17)))))))) / (1 - x^2)\n    return a * (1 + a2 * (3 + a4 * (5 + a6 * (7 + a8 * (9 + a10 * (11 + a12 * (13 + a14 * 15)))))));\n}",
      "public static double atanh(double a)  {\n    if (a <= -1.0 || a >= 1.0) {\n        throw new IllegalArgumentException(\"atanh(\" + a + \") is not defined\");\n    }\n    return 0.5 * FastMath.log((1.0 + a) / (1.0 - a));\n}",
      "public static double atanh(double a)  {\n    if (a <= -1.0 || a >= 1.0) {\n        throw new IllegalArgumentException(\"The argument must be between -1 and 1 exclusive\");\n    }\n    return 0.5 * FastMath.log((1 + a) / (1 - a));\n}",
      "public static double atanh(double a)  {\n    if (a <= -1.0 || a >= 1.0) {\n        if (a == Double.POSITIVE_INFINITY) {\n            return 0.0;\n        }\n        if (a == Double.NEGATIVE_INFINITY) {\n            return 0.0;\n        }\n        throw new IllegalArgumentException(\"atanh(\" + a + \") is not defined\");\n    }\n\n    double absAtanh;\n    if (a > 0.167) {\n        absAtanh = FastMath.log((1 + a) / (1 - a)) / 2;\n    } else {\n        final double a2 = a * a;\n        if (a > 0.097) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.036) {\n            absAtanh = a * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n        } else if (a > 0.0036) {\n}\n}\n}",
      "public static double atanh(double a)  {\n    if (a > 1.0 || a < -1.0) {\n        throw new IllegalArgumentException(\"|a| must be less than 1\");\n    }\n\n    if (a == 1.0) {\n        return 0.5 * Math.PI;\n    }\n\n    if (a == -1.0) {\n        return -0.5 * Math.PI;\n    }\n\n    // atanh(x) = 0.5 * log((1 + x) / (1 - x))\n    double absAtanh = 0.5 * Math.log((1 + a) / (1 - a));\n\n    return (a < 0) ? -absAtanh : absAtanh;\n}"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM, normalizedSum);\n        }\n        double sum = 0.0;\n        for (double value : values) {\n            if (!Double.isNaN(value) && !Double.isInfinite(value)) {\n                sum += value;\n            }\n        }\n        if (sum == 0.0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_SUM);\n        }\n        double[] normalizedValues = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                normalizedValues[i] = Double.NaN;\n            } else if (Double.isInfinite(values[i])) {\n                throw new MathArithmeticException(LocalizedFormats.INFINITE_ELEMENT, values[i]);\n            } else {\n                normalizedValues[i] = values[i] * normalizedSum / sum;\n            }\n        }\n        return normalizedValues;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_ARRAY_INVALID_SUM, normalizedSum);\n        }\n        double sum = 0.0;\n        for (double value : values) {\n            if (!Double.isNaN(value)) {\n                sum += value;\n            }\n        }\n        if (sum == 0.0) {\n            throw new MathArithmeticException(LocalizedFormats.NORMALIZE_ARRAY_ZERO_SUM);\n        }\n        double[] normalizedValues = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                normalizedValues[i] = values[i];\n            } else {\n                normalizedValues[i] = values[i] * normalizedSum / sum;\n            }\n        }\n        return normalizedValues;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM, normalizedSum);\n        }\n        double sum = 0.0;\n        for (double value : values) {\n            if (!Double.isNaN(value)) {\n                sum += value;\n            }\n        }\n        if (sum == 0.0) {\n            throw new MathArithmeticException(LocalizedFormats.SUM_ZERO);\n        }\n        double[] normalizedValues = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                normalizedValues[i] = Double.NaN;\n            } else {\n                normalizedValues[i] = values[i] * normalizedSum / sum;\n            }\n        }\n        return normalizedValues;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_ARRAY_INVALID_SUM, normalizedSum);\n    }\n    double sum = 0.0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (sum == 0.0) {\n        throw new MathArithmeticException(LocalizedFormats.NORMALIZE_ARRAY_ZERO_SUM);\n    }\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i];\n        } else {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        double sum = 0;\n        int count = 0;\n        for (double value : values) {\n            if (!Double.isNaN(value)) {\n                sum += value;\n                count++;\n            }\n        }\n        if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_ARRAY_INVALID_SUM, normalizedSum);\n        }\n        if (sum == 0) {\n            throw new MathArithmeticException(LocalizedFormats.NORMALIZE_ARRAY_ZERO_SUM);\n        }\n        double[] result = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                result[i] = values[i];\n            } else {\n                result[i] = values[i] * normalizedSum / sum;\n            }\n        }\n        return result;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = 0.0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_INVALID, normalizedSum);\n    }\n    if (sum == 0.0) {\n        throw new MathArithmeticException(LocalizedFormats.NORMALIZED_ARRAY_ZERO_SUM);\n    }\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            normalizedValues[i] = Double.NaN;\n        } else {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_ARRAY_INVALID_SUM, normalizedSum);\n    }\n    double sum = 0.0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (sum == 0.0) {\n        throw new MathArithmeticException(LocalizedFormats.NORMALIZE_ARRAY_ZERO_SUM);\n    }\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            normalizedValues[i] = Double.NaN;\n        } else {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_ARRAY_INVALID_SUM, normalizedSum);\n        }\n        double sum = 0.0;\n        for (double value : values) {\n            if (!Double.isNaN(value) && !Double.isInfinite(value)) {\n                sum += value;\n            }\n        }\n        if (sum == 0.0) {\n            throw new MathArithmeticException(LocalizedFormats.NORMALIZE_ARRAY_ZERO_SUM);\n        }\n        double[] normalizedValues = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                normalizedValues[i] = Double.NaN;\n            } else if (Double.isInfinite(values[i])) {\n                throw new MathArithmeticException(LocalizedFormats.NORMALIZE_ARRAY_INFINITE_ELEMENT);\n            } else {\n                normalizedValues[i] = values[i] * normalizedSum / sum;\n            }\n        }\n        return normalizedValues;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n\n        if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM, normalizedSum);\n        }\n\n        double sum = 0.0;\n        for (double value : values) {\n            if (!Double.isNaN(value) && !Double.isInfinite(value)) {\n                sum += value;\n            }\n        }\n\n        if (sum == 0.0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_SUM);\n        }\n\n        double[] normalizedValues = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                normalizedValues[i] = Double.NaN;\n            } else if (Double.isInfinite(values[i])) {\n                throw new MathArithmeticException(LocalizedFormats.INFINITE_VALUES);\n            } else {\n                normalizedValues[i] = values[i] * normalizedSum / sum;\n            }\n        }\n\n        return normalizedValues;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM, normalizedSum);\n    }\n\n    double sum = 0.0;\n    for (double value : values) {\n        if (!Double.isNaN(value) && !Double.isInfinite(value)) {\n            sum += value;\n        }\n    }\n\n    if (sum == 0.0) {\n        throw new MathArithmeticException(LocalizedFormats.SUM_ZERO);\n    }\n\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            normalizedValues[i] = Double.NaN;\n        } else if (Double.isInfinite(values[i])) {\n            throw new MathArithmeticException(LocalizedFormats.INFINITE_VALUES);\n        } else {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        }\n    }\n\n    return normalizedValues;\n}"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (str.length() == 0) \n    {\n        return \"\";\n    }\n    if (delimiters == null || delimiters.length == 0) \n    {\n        return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < str.length(); i++) \n    {\n        char c = str.charAt(i);\n        if (isDelimiter(c, delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            c = Character.toUpperCase(c);\n            capitalizeNext = false;\n        } \n        else \n        {\n            c = Character.toLowerCase(c);\n        }\n        sb.append(c);\n    }\n    return sb.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if (isDelimiter(c, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            c = Character.toUpperCase(c);\n            capitalizeNext = false;\n        } else {\n            c = Character.toLowerCase(c);\n        }\n        sb.append(c);\n    }\n    return sb.toString();\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    if (str.length() == 0) {\n        return \"\";\n    }\n    if (delimiters == null || delimiters.length == 0) {\n        return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();\n    }\n\n    char[] chars = str.toCharArray();\n    boolean capitalizeNext = true;\n\n    for (int i = 0; i < chars.length; i++) {\n        if (isDelimiter(chars[i], delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            chars[i] = Character.toUpperCase(chars[i]);\n            capitalizeNext = false;\n        } else {\n            chars[i] = Character.toLowerCase(chars[i]);\n        }\n    }\n\n    return new String(chars);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (str.length() == 0) \n    {\n        return str;\n    }\n    if (delimiters == null || delimiters.length == 0) \n    {\n        return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();\n    }\n\n    char[] chars = str.toCharArray();\n    boolean capitalizeNext = true;\n\n    for (int i = 0; i < chars.length; i++) \n    {\n        if (isDelimiter(chars[i], delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            chars[i] = Character.toUpperCase(chars[i]);\n            capitalizeNext = false;\n        } \n        else \n        {\n            chars[i] = Character.toLowerCase(chars[i]);\n        }\n    }\n    return new String(chars);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) \n    {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) \n        {\n            uncapitalizeNext = true;\n        } \n        else if (uncapitalizeNext) \n        {\n            buffer[i] = Character.toTitleCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (str.length() == 0) \n    {\n        return \"\";\n    }\n    if (delimiters == null || delimiters.length == 0) \n    {\n        return str.substring(0, 1).toUpperCase() + str.substring(1).toLowerCase();\n    }\n\n    char[] chars = str.toCharArray();\n    boolean capitalizeNext = true;\n\n    for (int i = 0; i < chars.length; i++) \n    {\n        if (isDelimiter(chars[i], delimiters)) \n        {\n            capitalizeNext = true;\n        } \n        else if (capitalizeNext) \n        {\n            chars[i] = Character.toUpperCase(chars[i]);\n            capitalizeNext = false;\n        } \n        else \n        {\n            chars[i] = Character.toLowerCase(chars[i]);\n        }\n    }\n\n    return new String(chars);\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                MutableDateTime dt = new MutableDateTime(millis, chrono);\n                if (iZone != null) {\n                    dt = dt.withZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(iChrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt = dt.withZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOI = getX().transpose().multiply(OI);\n        RealMatrix XTOIX = XTOI.multiply(getX());\n        RealMatrix XTOIY = XTOI.multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOI = getX().transpose().multiply(OI);\n        RealMatrix XTOIX = XTOI.multiply(getX());\n        RealMatrix XTOIY = XTOI.multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOI = getX().transpose().multiply(OI);\n        RealMatrix XTOIX = XTOI.multiply(getX());\n        RealMatrix XTOIY = XTOI.multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOI = getX().transpose().multiply(OI);\n        return XTOI.multiply(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOI = getX().transpose().multiply(OI);\n        RealMatrix XTOIX = XTOI.multiply(getX());\n        RealMatrix XTOIY = XTOI.multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOI = getX().transpose().multiply(OI);\n        RealMatrix XTOIX = XTOI.multiply(getX());\n        RealMatrix XTOIY = XTOI.multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOI = getX().transpose().multiply(OI);\n        RealMatrix XTOIX = XTOI.multiply(getX());\n        RealMatrix XTOIY = XTOI.multiply(getY());\n        return new LUDecomposition(XTOIX).getSolver().solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOI = getX().transpose().multiply(OI);\n        return XTOI.multiply(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOI = getX().transpose().multiply(OI);\n        return XTOI.multiply(getY());\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.collect(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.collect(new Evaluator.Id(id), this);\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder sb = new StringBuilder(pattern.length() + customPatterns.size() * 10);\n    final ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) \n    {\n        final int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        final int text = pos.getIndex();\n        if (text > start && pattern.charAt(text - 1) == '%') \n        {\n            final String desc = parseFormatDescription(pattern, pos);\n            final Format format = getFormat(desc);\n            if (format != null) \n            {\n                sb.append(format.toPattern());\n            } \n            else \n            {\n                final String customPattern = customPatterns.get(Integer.parseInt(desc));\n                if (customPattern != null) \n                {\n                    sb.append(customPattern);\n                } \n                else \n                {\n                    sb.append(pattern.substring(start, text));\n                }\n            }\n        } \n        else \n        {\n            sb.append(pattern.substring(start, text));\n            sb.append(pattern.charAt(text));\n            pos.setIndex(text + 1);\n        }\n    }\n    return sb.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder(pattern.length());\n    ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) \n    {\n        if (pattern.charAt(pos.getIndex()) == START_FMT) \n        {\n            String formatDesc = parseFormatDescription(pattern, pos);\n            Format format = getFormat(formatDesc);\n            if (format != null) \n            {\n                result.append(format.format(null));\n            } \n            else \n            {\n                customPatterns.add(formatDesc);\n                result.append(formatDesc);\n            }\n        } \n        else \n        {\n            result.append(pattern.charAt(pos.getIndex()));\n            pos.setIndex(pos.getIndex() + 1);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder(pattern.length() + 10);\n    ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) \n    {\n        result.append(pattern.substring(pos.getIndex()));\n        break;\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length() + customPatterns.size() * 5);\n    final ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) \n    {\n        final int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        final int text = pos.getIndex();\n        if (text > start && pattern.charAt(text - 1) == '{') \n        {\n            final String desc = parseFormatDescription(pattern, pos);\n            final Format format = getFormat(desc);\n            if (format != null) \n            {\n                result.append(pattern.substring(start, text - 1));\n                result.append(format.toPattern());\n                continue;\n            }\n        }\n        result.append(pattern.substring(start, text));\n    }\n    return result.toString();\n}\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder(pattern.length() + 20 * customPatterns.size());\n    ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) \n    {\n        result.append(pattern, pos.getIndex(), pattern.length());\n        break;\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder sb = new StringBuilder(pattern.length() + customPatterns.size() * 2);\n    ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) \n    {\n        sb.append(pattern.substring(pos.getIndex()));\n        break;\n    }\n    return sb.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder sb = new StringBuilder(pattern.length() + 16 * customPatterns.size());\n    final char[] buffer = pattern.toCharArray();\n    ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < buffer.length) \n    {\n        if (buffer[pos.getIndex()] == START_FMT) \n        {\n            pos.setIndex(pos.getIndex() + 1);\n            final String desc = parseFormatDescription(pattern, pos);\n            final Format fmt = getFormat(desc);\n            if (fmt != null) \n            {\n                sb.append(fmt.format(null));\n            } \n            else \n            {\n                sb.append(START_FMT).append(desc).append(END_FE);\n                customPatterns.add(desc);\n            }\n        } \n        else \n        {\n            sb.append(buffer[pos.getIndex()]);\n            pos.setIndex(pos.getIndex() + 1);\n        }\n    }\n    return sb.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length() + 16 * customPatterns.size());\n    final StringBuilder appendTo = new StringBuilder(16);\n    ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) \n    {\n        final int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        final int text = pos.getIndex();\n        if (text > start && pattern.charAt(text - 1) == START_FMT) \n        {\n            appendTo.setLength(0);\n            appendTo.append(pattern.substring(start, text - 1));\n            final String desc = parseFormatDescription(pattern, pos);\n            final Format format = getFormat(desc);\n            if (format != null) \n            {\n                appendTo.append(START_FMT);\n                appendTo.append(desc);\n                appendTo.append(END_FE);\n            } \n            else \n            {\n                for (final String customPattern : customPatterns) \n                {\n                    if (customPattern.startsWith(appendTo.toString())) \n                    {\n                        appendTo.append(customPattern.substring(appendTo.length()));\n                        break;\n                    }\n                }\n            }\n            result.append(appendTo);\n        } \n        else \n        {\n            result.append(pattern.substring(start, text));\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder sb = new StringBuilder(pattern.length() + customPatterns.size() * 10);\n    final ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) \n    {\n        final String desc = parseFormatDescription(pattern, pos);\n        if (desc.startsWith(\"{\") && desc.endsWith(\"}\")) \n        {\n            final String key = desc.substring(1, desc.length() - 1);\n            final Format format = getFormat(key);\n            if (format != null) \n            {\n                sb.append(format.format(null));\n            } \n            else \n            {\n                final String customPattern = customPatterns.get(Integer.parseInt(key));\n                if (customPattern != null) \n                {\n                    sb.append(customPattern);\n                } \n                else \n                {\n                    sb.append(desc);\n                }\n            }\n        } \n        else \n        {\n            sb.append(pattern.substring(pos.getIndex() - 1, pos.getIndex() + desc.length()));\n            pos.setIndex(pos.getIndex() + desc.length());\n        }\n    }\n    return sb.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder(pattern.length() + customPatterns.size() * 5);\n    final ParsePosition pos = new ParsePosition(0);\n    while (pos.getIndex() < pattern.length()) \n    {\n        final int start = pos.getIndex();\n        seekNonWs(pattern, pos);\n        final int text = pos.getIndex();\n        if (text > start && pattern.charAt(text - 1) == '{') \n        {\n            final String desc = parseFormatDescription(pattern, pos);\n            final Format format = getFormat(desc);\n            if (format != null) \n            {\n                result.append(format.format(null));\n            } \n            else \n            {\n                final String customPattern = customPatterns.get(Integer.parseInt(desc));\n                if (customPattern != null) \n                {\n                    result.append(customPattern);\n                } \n                else \n                {\n                    throw new IllegalArgumentException(\"No format or custom pattern for \" + desc);\n                }\n            }\n        } \n        else \n        {\n            result.append(pattern.substring(start));\n            break;\n        }\n    }\n    return result.toString();\n}\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        \n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // Check if they are the same type.\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    // Check if they have the same number of type arguments.\n    if (from.getActualTypeArguments().length != to.getActualTypeArguments().length) {\n      return false;\n    }\n\n    // Check if they have the same type arguments.\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n        return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n        return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n        if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    // Check if they are exactly equal.\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    // Check if they have the same number of type arguments.\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    // Check if each type argument is assignable from the corresponding\n    // type argument in the other type.\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n        return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n        return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) \n    {\n        if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) \n        {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n        return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n        return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n        if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n        return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n        return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n        if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n\n    if (from == null || to == null) {\n      return from == to;\n    }\n\n    // Check if they are the same type\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    // Check if they have the same number of type arguments\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n\n    // Check if they have the same type arguments\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n        return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    if (fromArgs.length != toArgs.length) {\n        return false;\n    }\n\n    for (int i = 0; i < fromArgs.length; i++) {\n        if (!isAssignableFrom(fromArgs[i], toArgs[i], typeVarMap)) {\n            return false;\n        }\n    }\n\n    return true;\n}"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter != null) {\n            ConverterSet removed = iPeriodConverters.remove(converter, new Converter[0]);\n            if (removed.size() == 0) {\n                return null;\n            }\n            if (removed.size() > 1) {\n                throw new IllegalStateException(\"Multiple converters match the type: \" +\n                    converter.getClass().getName());\n            }\n            return (PeriodConverter) removed.select(null);\n        }\n        return null;\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter != null) {\n            return (PeriodConverter) iPeriodConverters.add(converter, new Converter[0]);\n        }\n        return null;\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter != null) {\n            return (PeriodConverter) iPeriodConverters.add(converter, new Converter[0]);\n        }\n        return null;\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter != null) {\n            ConverterSet removed = iPeriodConverters.remove(converter, new Converter[0]);\n            if (removed != null) {\n                return (PeriodConverter) removed.select(converter.getClass());\n            }\n        }\n        return null;\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        return (PeriodConverter) iPeriodConverters.add(converter, new Converter[0]);\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        Converter[] converters = new Converter[iPeriodConverters.size() + 1];\n        iPeriodConverters.copyInto(converters);\n        converters[converters.length - 1] = converter;\n        ConverterSet newSet = new ConverterSet(converters);\n        ConverterSet oldSet = iPeriodConverters;\n        iPeriodConverters = newSet;\n        return (PeriodConverter) oldSet.select(converter.getClass());\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        return (PeriodConverter) iPeriodConverters.add(converter, new Converter[0]);\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter != null) {\n            return (PeriodConverter) iPeriodConverters.add(converter, null);\n        }\n        return null;\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        return (PeriodConverter) iPeriodConverters.add(converter, new Converter[0]);\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        Converter[] converters = new Converter[iPeriodConverters.size() + 1];\n        iPeriodConverters.copyInto(converters);\n        converters[converters.length - 1] = converter;\n        ConverterSet newSet = new ConverterSet(converters);\n        PeriodConverter oldConverter = (PeriodConverter) iPeriodConverters.select(converter.getClass());\n        iPeriodConverters = newSet;\n        return oldConverter;\n    }"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n    for (N n : colorToNodeMap) {\n      if (graph.getNode(n).equals(node)) {\n        return n;\n      }\n    }\n    return null;\n  }",
      "public N getPartitionSuperNode(N node)  {\n    Iterator<? extends GraphNode<N, E>> nodes = graph.getNodes().iterator();\n    while (nodes.hasNext()) \n    {\n        GraphNode<N, E> currentNode = nodes.next();\n        if (currentNode.getAnnotation() instanceof Color) \n        {\n            if (((Color) currentNode.getAnnotation()).value == ((Color) node.getAnnotation()).value) \n            {\n                return currentNode.getValue();\n            }\n        }\n    }\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    Iterator<GraphNode<N, E>> nodes = graph.getNodes().iterator();\n    while (nodes.hasNext()) {\n      GraphNode<N, E> currentNode = nodes.next();\n      if (currentNode.getAnnotation() instanceof Color) {\n        if (((Color) currentNode.getAnnotation()).value == ((Color) node.getAnnotation()).value) {\n          return currentNode.getValue();\n        }\n      }\n    }\n    return null;\n  }",
      "public N getPartitionSuperNode(N node)  {\n  int color = ((Color) graph.getNode(node).getAnnotation()).value;\n  return colorToNodeMap[color];\n}",
      "public N getPartitionSuperNode(N node)  {\n  Iterator<GraphNode<N, E>> nodes = graph.getNodes().iterator();\n  while(nodes.hasNext())\n  {\n    GraphNode<N, E> currentNode = nodes.next();\n    if(currentNode.getAnnotation() instanceof Color && ((Color)currentNode.getAnnotation()).value == ((Color)graph.getNode(node).getAnnotation()).value)\n    {\n      return currentNode.getValue();\n    }\n  }\n  return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    Iterator<? extends GraphNode<N, E>> nodes = graph.getNodes().iterator();\n    while (nodes.hasNext()) \n    {\n        GraphNode<N, E> currentNode = nodes.next();\n        if (currentNode.getAnnotation() != null && currentNode.getAnnotation().equals(colorToNodeMap[node])) \n        {\n            return (N) currentNode.getValue();\n        }\n    }\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    Iterator<GraphNode<N, E>> nodes = graph.getNodes().iterator();\n    while (nodes.hasNext()) {\n      GraphNode<N, E> currentNode = nodes.next();\n      if (currentNode.getAnnotation() instanceof Color) {\n        Color color = (Color) currentNode.getAnnotation();\n        if (colorToNodeMap[color.value] == node) {\n          return node;\n        }\n      }\n    }\n    return null;\n  }",
      "public N getPartitionSuperNode(N node)  {\n    Iterator<GraphNode<N, E>> nodes = graph.getNodes().iterator();\n    while (nodes.hasNext()) {\n      GraphNode<N, E> graphNode = nodes.next();\n      if (graphNode.getAnnotation() instanceof Color &&\n          ((Color) graphNode.getAnnotation()).value ==\n          ((Color) graph.getNode(node).getAnnotation()).value) {\n        return graphNode.getValue();\n      }\n    }\n    return null;\n  }",
      "public N getPartitionSuperNode(N node)  {\n  Iterator<GraphNode<N, E>> nodes = graph.getNodes().iterator();\n  while(nodes.hasNext())\n  {\n    GraphNode<N, E> currentNode = nodes.next();\n    if(currentNode.getAnnotation() instanceof Color)\n    {\n      if(((Color)currentNode.getAnnotation()).value == ((Color)node.getAnnotation()).value)\n      {\n        return currentNode.getValue();\n      }\n    }\n  }\n  return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    Iterator<? extends GraphNode<N, E>> nodes = graph.getNodes().iterator();\n    while (nodes.hasNext()) \n    {\n        GraphNode<N, E> currentNode = nodes.next();\n        if (currentNode.getAnnotation() != null && currentNode.getAnnotation().equals(colorToNodeMap[node])) \n        {\n            return currentNode.getValue();\n        }\n    }\n    return null;\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(ranks[i].getPosition());\n        }\n    }\n    return nanPositions;\n}"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double integral = 0.0;\n    for (int i = 0; i < points.length; i++) \n    {\n        integral += weights[i] * f.value(points[i]);\n    }\n    return integral;\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) \n    {\n        return true;\n    }\n    if ((map1 == null) || (map2 == null)) \n    {\n        return false;\n    }\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Paint value1 = (Paint) entry.getValue();\n        Paint value2 = (Paint) map2.get(key);\n        if ((value1 == null) != (value2 == null)) \n        {\n            return false;\n        }\n        if ((value1 != null) && !value1.equals(value2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) \n    {\n        return true;\n    }\n    if ((map1 == null) || (map2 == null)) \n    {\n        return false;\n    }\n    if (map1.size() != map2.size())\n    {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        if (!map2.containsKey(key)) \n        {\n            return false;\n        }\n        if (!map1.get(key).equals(map2.get(key))) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) \n    {\n        return true;\n    }\n    if ((map1 == null) || (map2 == null)) \n    {\n        return false;\n    }\n    if (map1.size() != map2.size())\n    {\n        return false;\n    }\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Paint value1 = (Paint) entry.getValue();\n        Paint value2 = (Paint) map2.get(key);\n        if ((value1 == null) != (value2 == null)) \n        {\n            return false;\n        }\n        if ((value1 != null) && !value1.equals(value2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if ((map1 == null) || (map2 == null)) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        if (!map2.containsKey(key)) {\n            return false;\n        }\n        if (!SerialUtilities.equalPaints((Paint) map1.get(key), (Paint) map2.get(key))) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        if (!map2.containsKey(key)) {\n            return false;\n        }\n        if (!((Paint) map1.get(key)).equals((Paint) map2.get(key))) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) \n    {\n        return true;\n    }\n    if ((map1 == null) || (map2 == null)) \n    {\n        return false;\n    }\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        if (!map2.containsKey(key)) \n        {\n            return false;\n        }\n        if (!((Paint) map1.get(key)).equals((Paint) map2.get(key))) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if (map1 == null || map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n\n    Iterator iterator = map1.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Comparable key = (Comparable) entry.getKey();\n        Paint value1 = (Paint) entry.getValue();\n        Paint value2 = (Paint) map2.get(key);\n        if (value1 == null) {\n            if (value2 != null) {\n                return false;\n            }\n        } else if (!value1.equals(value2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) \n    {\n        return true;\n    }\n    if ((map1 == null) || (map2 == null)) \n    {\n        return false;\n    }\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        if (!map2.containsKey(key)) \n        {\n            return false;\n        }\n        if (!((Paint) map1.get(key)).equals((Paint) map2.get(key))) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if ((map1 == null) || (map2 == null)) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        if (!map2.containsKey(key)) {\n            return false;\n        }\n        if (!SerialUtilities.equalPaints((Paint) map1.get(key), (Paint) map2.get(key))) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if ((map1 == null) || (map2 == null)) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n\n    Iterator iterator = map1.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        if (!map2.containsKey(key)) {\n            return false;\n        }\n        if (!SerialUtilities.equalPaints((Paint) map1.get(key), (Paint) map2.get(key))) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String key = expr.getString();\n        String replacement = getReplacement(key);\n        if (replacement != null) \n        {\n            Node replacementNode = IR.string(replacement);\n            recordReplacement(expr, key);\n            parent.replaceChild(expr, replacementNode);\n            return replacementNode;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String key = expr.getString();\n        String replacement = getReplacement(key);\n        if (replacement != null) \n        {\n            Node replacementNode = IR.string(replacement);\n            recordReplacement(expr, key);\n            parent.replaceChild(expr, replacementNode);\n            return replacementNode;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    StringBuilder keyBuilder = new StringBuilder();\n    Node prefix = buildReplacement(expr, IR.string(\"\"), keyBuilder);\n    String key = keyBuilder.toString();\n\n    String replacement = getReplacement(key);\n    if (replacement != null) {\n        recordReplacement(expr, key);\n        Node replacementNode = IR.string(replacement);\n        parent.replaceChild(expr, replacementNode);\n        return replacementNode;\n    }\n\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    String key = getReplacement(expr.getString());\n    if (key != null) \n    {\n        // Replace the expression with a short encoded string expression.\n        Node replacement = IR.string(key);\n        recordReplacement(expr, key);\n        parent.replaceChild(expr, replacement);\n        return replacement;\n    } \n    else \n    {\n        return expr;\n    }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    Preconditions.checkState(\n        expr.isString() || expr.isName());\n\n    String key = expr.getString();\n    String replacement = getReplacement(key);\n\n    if (replacement != null) {\n      // Replace the node in parent.\n      Node replacementNode = IR.string(replacement);\n      replacementNode.copyInformationFromForTree(expr);\n      parent.replaceChild(expr, replacementNode);\n      recordReplacement(expr, key);\n      return replacementNode;\n    } else {\n      return expr;\n    }\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String key = expr.getString();\n        String replacement = getReplacement(key);\n        if (replacement != null) \n        {\n            Node replacementNode = IR.string(replacement);\n            recordReplacement(expr, key);\n            parent.replaceChild(expr, replacementNode);\n            return replacementNode;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String key = expr.getString();\n        String replacement = getReplacement(key);\n        if (replacement != null) \n        {\n            Node replacementNode = IR.string(replacement);\n            recordReplacement(expr, key);\n            parent.replaceChild(expr, replacementNode);\n            return replacementNode;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String key = expr.getString();\n        String replacement = getReplacement(key);\n        if (replacement != null) \n        {\n            Node replacementNode = IR.string(replacement);\n            recordReplacement(expr, key);\n            parent.replaceChild(expr, replacementNode);\n            return replacementNode;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    StringBuilder keyBuilder = new StringBuilder();\n    Node prefix = IR.string(\"\");\n    Node replacement = buildReplacement(expr, prefix, keyBuilder);\n\n    String key = keyBuilder.toString();\n    String replacementString = getReplacement(key);\n\n    if (replacementString != null) {\n        // Replace the expression with the replacement string.\n        Node replacementNode = IR.string(replacementString);\n        replacementNode.copyInformationFromForTree(expr);\n        parent.replaceChild(expr, replacementNode);\n\n        // Record the replacement.\n        recordReplacement(expr, key);\n\n        return replacementNode;\n    }\n\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) \n    {\n        String key = expr.getString();\n        String replacement = getReplacement(key);\n        if (replacement != null) \n        {\n            Node replacementNode = IR.string(replacement);\n            recordReplacement(expr, key);\n            parent.replaceChild(expr, replacementNode);\n            return replacementNode;\n        }\n    }\n    return expr;\n}"
    ],
    [
      "public double[] getCoefficients()  {\n    double[] out = new double[y.length];\n    System.arraycopy(y, 0, out, 0, y.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[y.length];\n    System.arraycopy(y, 0, out, 0, y.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[y.length];\n    System.arraycopy(y, 0, out, 0, y.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[y.length];\n    System.arraycopy(y, 0, out, 0, y.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[y.length];\n    System.arraycopy(y, 0, out, 0, y.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[y.length];\n    System.arraycopy(y, 0, out, 0, y.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[y.length];\n    System.arraycopy(y, 0, out, 0, y.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[y.length];\n    System.arraycopy(y, 0, out, 0, y.length);\n    return out;\n}"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo == null) {\n        return false;\n    }\n\n    String desc = docInfo.getDescription();\n    if (desc != null) {\n        builder.setDesc(desc);\n        return true;\n    }\n\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo == null) {\n        return false;\n    }\n\n    String desc = docInfo.getDescription();\n    if (desc != null && !desc.isEmpty()) {\n        builder.setDesc(desc);\n        return true;\n    }\n\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo != null) {\n      String desc = docInfo.getDescription();\n      if (desc != null && !desc.isEmpty()) {\n        builder.setDesc(desc);\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo != null) {\n      String desc = docInfo.getDescription();\n      if (desc != null && !desc.isEmpty()) {\n        builder.setDesc(desc);\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo != null) {\n      String desc = docInfo.getDescription();\n      if (desc != null && !desc.isEmpty()) {\n        builder.setDesc(desc);\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo != null) {\n      String desc = docInfo.getDescription();\n      if (desc != null) {\n        builder.setDesc(desc);\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo == null) {\n        return false;\n    }\n\n    String desc = docInfo.getDescription();\n    if (desc == null) {\n        return false;\n    }\n\n    if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n    } else {\n        builder.setDesc(desc);\n    }\n\n    return true;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo == null) {\n        return false;\n    }\n\n    String desc = docInfo.getDescription();\n    if (desc != null && !desc.isEmpty()) {\n        builder.setDesc(desc);\n        return true;\n    }\n\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo == null) {\n        return false;\n    }\n    String desc = docInfo.getDescription();\n    if (desc != null && !desc.isEmpty()) {\n        builder.setDesc(desc);\n        return true;\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    if (docInfo != null) {\n      String desc = docInfo.getDescription();\n      if (desc != null) {\n        builder.setDesc(desc);\n        return true;\n      }\n    }\n    return false;\n  }"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            Cluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n\n        CentroidCluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            Cluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            Cluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            Cluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) \n    {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) \n        {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n\n            Cluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n\n        return assignedDifferently;\n    }"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n        if (xArray.length != yArray.length) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTH, xArray.length, yArray.length);\n        }\n        if (xArray.length < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION, xArray.length, 2);\n        }\n\n        double sumX = 0.0, sumY = 0.0;\n        double sumXSq = 0.0, sumYSq = 0.0;\n        double sumCross = 0.0;\n\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXSq += xArray[i] * xArray[i];\n            sumYSq += yArray[i] * yArray[i];\n            sumCross += xArray[i] * yArray[i];\n        }\n\n        double cov;\n        if (biasCorrected) {\n            int n = xArray.length;\n            cov = (n * sumCross - sumX * sumY) / (n * (n - 1));\n        } else {\n            cov = sumCross - sumX * sumY / xArray.length;\n        }\n\n        return cov;\n    }",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTHS_MISMATCH, xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION, xArray.length, 2);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    double sumXY = 0.0;\n    double sumXX = 0.0;\n    double sumYY = 0.0;\n    int n = xArray.length;\n\n    for (int i = 0; i < n; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumXX += xArray[i] * xArray[i];\n        sumYY += yArray[i] * yArray[i];\n    }\n\n    double denominator = n * (sumXX + sumYY) - sumX * sumX - sumY * sumY;\n\n    if (biasCorrected) {\n        denominator -= n * (sumX * sumX + sumY * sumY);\n    }\n\n    return (n * sumXY - sumX * sumY) / denominator;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTHS_MISMATCH,\n                                               xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, 2);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    double sumXY = 0.0;\n    double sumX2 = 0.0;\n    double sumY2 = 0.0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumX2 += xArray[i] * xArray[i];\n        sumY2 += yArray[i] * yArray[i];\n    }\n\n    int n = xArray.length;\n    double denominator = n * (sumX2 - Math.pow(sumX, 2) / n) * (sumY2 - Math.pow(sumY, 2) / n);\n\n    if (denominator <= 0.0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.COVARIANCE_ZERO_DENOMINATOR);\n    }\n\n    double covariance = (n * sumXY - sumX * sumY) / Math.sqrt(denominator);\n\n    if (biasCorrected) {\n        covariance *= n / (n - 1.0);\n    }\n\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTHS_MISMATCH,\n                                               xArray.length, yArray.length);\n    } else if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                               xArray.length, 2);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    double sumXY = 0.0;\n    double sumX2 = 0.0;\n    double sumY2 = 0.0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumX2 += xArray[i] * xArray[i];\n        sumY2 += yArray[i] * yArray[i];\n    }\n\n    int n = xArray.length;\n    double covariance = (n * sumXY - sumX * sumY) / (n * (n - 1));\n\n    if (biasCorrected) {\n        covariance = covariance * n / (n - 1);\n    }\n\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTHS_MISMATCH,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                xArray.length, 2);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    double sumXY = 0.0;\n    double sumX2 = 0.0;\n    double sumY2 = 0.0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumX2 += xArray[i] * xArray[i];\n        sumY2 += yArray[i] * yArray[i];\n    }\n\n    int n = xArray.length;\n    double covariance = (n * sumXY - sumX * sumY) / (n * (n - 1));\n\n    if (biasCorrected) {\n        covariance = covariance * n / (n - 1);\n    }\n\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n        if (xArray.length != yArray.length) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTHS_MISMATCH,\n                    xArray.length, yArray.length);\n        }\n\n        if (xArray.length < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    xArray.length, 2);\n        }\n\n        double sumX = 0.0;\n        double sumY = 0.0;\n        double sumXY = 0.0;\n        double sumXX = 0.0;\n        double sumYY = 0.0;\n        int n = xArray.length;\n\n        for (int i = 0; i < n; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n            sumXX += xArray[i] * xArray[i];\n            sumYY += yArray[i] * yArray[i];\n        }\n\n        double denominator = n * (sumXX + sumYY) - sumX * sumX - sumY * sumY;\n\n        if (denominator <= 0.0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.COVARIANCE_SINGULAR_MATRIX);\n        }\n\n        double covariance = (n * sumXY - sumX * sumY) / denominator;\n\n        if (biasCorrected) {\n            covariance *= n / (n - 1.0);\n        }\n\n        return covariance;\n    }",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n        if (xArray.length != yArray.length) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTH, xArray.length, yArray.length);\n        }\n        if (xArray.length < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION, xArray.length, 2);\n        }\n\n        double sumX = 0.0, sumY = 0.0, sumXY = 0.0;\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n        }\n\n        double meanX = sumX / xArray.length;\n        double meanY = sumY / yArray.length;\n        double covariance = sumXY / xArray.length - meanX * meanY;\n\n        if (biasCorrected) {\n            covariance *= xArray.length / (xArray.length - 1);\n        }\n\n        return covariance;\n    }",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n        if (xArray.length != yArray.length) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTHS_MISMATCH,\n                    xArray.length, yArray.length);\n        }\n\n        if (xArray.length < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                    xArray.length, 2);\n        }\n\n        double sumX = 0.0;\n        double sumY = 0.0;\n        double sumXY = 0.0;\n        double sumX2 = 0.0;\n        double sumY2 = 0.0;\n\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n            sumX2 += xArray[i] * xArray[i];\n            sumY2 += yArray[i] * yArray[i];\n        }\n\n        int n = xArray.length;\n        double denominator = n * (sumX2 - Math.pow(sumX, 2) / n) * (sumY2 - Math.pow(sumY, 2) / n);\n\n        if (denominator <= 0.0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.COVARIANCE_NOT_DEFINED, denominator);\n        }\n\n        double covariance = (n * sumXY - sumX * sumY) / Math.sqrt(denominator);\n\n        if (biasCorrected) {\n            covariance *= n / (n - 1.0);\n        }\n\n        return covariance;\n    }",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n        if (xArray.length != yArray.length) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTHS_MISMATCH,\n                                                   xArray.length, yArray.length);\n        }\n        if (xArray.length < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION,\n                                                   xArray.length, 2);\n        }\n\n        double sumX = 0.0;\n        double sumY = 0.0;\n        double sumXY = 0.0;\n        double sumXX = 0.0;\n        double sumYY = 0.0;\n\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXY += xArray[i] * yArray[i];\n            sumXX += xArray[i] * xArray[i];\n            sumYY += yArray[i] * yArray[i];\n        }\n\n        double n = xArray.length;\n        double denominator = n * (sumXX + sumYY) - (sumX * sumX + sumY * sumY);\n\n        if (denominator <= 0.0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.COVARIANCE_ZERO_DENOMINATOR);\n        }\n\n        double covariance = (n * sumXY - sumX * sumY) / denominator;\n\n        if (biasCorrected) {\n            covariance *= n / (n - 1.0);\n        }\n\n        return covariance;\n    }",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_LENGTH, xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DIMENSION, xArray.length, 2);\n    }\n\n    double sumX = 0.0;\n    double sumY = 0.0;\n    double sumXY = 0.0;\n    double sumXX = 0.0;\n    double sumYY = 0.0;\n    int n = xArray.length;\n\n    for (int i = 0; i < n; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumXX += xArray[i] * xArray[i];\n        sumYY += yArray[i] * yArray[i];\n    }\n\n    double denominator = n * (sumXX + sumYY) - sumX * sumX - sumY * sumY;\n    if (denominator == 0.0) {\n        throw new MathIllegalArgumentException(LocalizedFormats.ZERO_DENOMINATOR);\n    }\n\n    double covariance = (n * sumXY - sumX * sumY) / denominator;\n\n    if (biasCorrected) {\n        covariance *= n / (n - 1.0);\n    }\n\n    return covariance;\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long n = in.skip(remaining);\n        if (n < 0) {\n            throw new EOFException(\"End of stream reached\");\n        }\n        count((int) n);\n        remaining -= n;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"Negative value not allowed\");\n    }\n    if (currentEntryHasOutstandingBytes()) {\n        // If there are bytes left in the current entry, we need to read them first.\n        final long toSkip = Math.min(value, current.entry.getCompressedSize() - current.bytesReadFromStream);\n        read(skipBuf, 0, (int) toSkip);\n        value -= toSkip;\n    }\n    while (value > 0) {\n        // Skip to the next entry.\n        final ZipArchiveEntry nextEntry = getNextZipEntry();\n        if (nextEntry == null) {\n            // If there are no more entries, we can't skip any more bytes.\n            return;\n        }\n        // Skip the bytes of the current entry.\n        final long toSkip = Math.min(value, nextEntry.getCompressedSize());\n        value -= toSkip;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"Negative value not allowed\");\n    }\n    if (currentEntryHasOutstandingBytes()) {\n        drainCurrentEntryData();\n    }\n    in.skip(value);\n    entriesRead++;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long n = in.skip(remaining);\n        if (n < 0) {\n            throw new EOFException(\"Unexpected EOF while skipping\");\n        }\n        count(n);\n        remaining -= n;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long n = in.skip(remaining);\n        if (n < 0) {\n            throw new EOFException(\"Unexpected EOF while skipping\");\n        }\n        count((int) n);\n        remaining -= n;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"Negative skip length\");\n    }\n    if (value == 0) {\n        return;\n    }\n    if (currentEntryHasOutstandingBytes()) {\n        drainCurrentEntryData();\n    }\n    while (value > Integer.MAX_VALUE) {\n        in.skip(Integer.MAX_VALUE);\n        value -= Integer.MAX_VALUE;\n    }\n    in.skip(value);\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"Negative skip length\");\n    }\n    if (currentEntryHasOutstandingBytes()) {\n        drainCurrentEntryData();\n    }\n    while (value > TWO_EXP_32) {\n        in.skip(TWO_EXP_32);\n        value -= TWO_EXP_32;\n    }\n    in.skip(value);\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long n = in.skip(remaining);\n        if (n < 0) {\n            throw new EOFException(\"Truncated ZIP entry: \"\n                                   + ArchiveUtils.sanitize(current.entry.getName()));\n        }\n        count(n);\n        remaining -= n;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value <= 0) {\n        return;\n    }\n    final long remaining = current.entry.getCompressedSize() - current.bytesReadFromStream;\n    if (value >= remaining) {\n        current.bytesReadFromStream += remaining;\n        drainCurrentEntryData();\n    } else {\n        final long n = in.skip(value);\n        if (n < value) {\n            throw new EOFException(\"Truncated ZIP entry: \"\n                                   + ArchiveUtils.sanitize(current.entry.getName()));\n        }\n        current.bytesReadFromStream += n;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long remaining = value;\n    while (remaining > 0) {\n        final long n = in.skip(remaining);\n        if (n < 0) {\n            throw new EOFException(\"Reached end of stream before skipping \" + value + \" bytes\");\n        }\n        count(n);\n        remaining -= n;\n    }\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    long fingerprint = FP.fingerprint(sb.toString());\n    return Long.toHexString(fingerprint).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n        StringBuilder sb = new StringBuilder();\n        for (CharSequence part : messageParts) {\n            if (part instanceof PlaceholderReference) {\n                sb.append(CaseFormat.LOWER_CAMEL.to(\n                        CaseFormat.UPPER_UNDERSCORE,\n                        ((PlaceholderReference) part).getName()));\n            } else {\n                sb.append(part);\n            }\n        }\n        String tcValue = sb.toString();\n        long fingerprint = FP.fingerprint(tcValue);\n        return Long.toHexString(fingerprint).toUpperCase();\n    }",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n        StringBuilder sb = new StringBuilder();\n        for (CharSequence part : messageParts) {\n            if (part instanceof PlaceholderReference) {\n                sb.append(CaseFormat.LOWER_CAMEL.to(\n                        CaseFormat.UPPER_UNDERSCORE,\n                        ((PlaceholderReference) part).getName()));\n            } else {\n                sb.append(part);\n            }\n        }\n        String tcValue = sb.toString();\n        long fingerprint = FP.fingerprint(tcValue);\n        return Long.toHexString(fingerprint).toUpperCase();\n    }",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    long fingerprint = FP.fingerprint(sb.toString());\n    return Long.toHexString(fingerprint).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    long fingerprint = FP.fingerprint(sb.toString());\n    return Long.toHexString(fingerprint).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n        StringBuilder sb = new StringBuilder();\n        for (CharSequence part : messageParts) {\n            if (part instanceof PlaceholderReference) {\n                sb.append(CaseFormat.LOWER_CAMEL.to(\n                        CaseFormat.UPPER_UNDERSCORE,\n                        ((PlaceholderReference) part).getName()));\n            } else {\n                sb.append(part);\n            }\n        }\n        long fingerprint = FP.fingerprint(sb.toString());\n        return Long.toHexString(fingerprint).toUpperCase();\n    }",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    long fingerprint = FP.fingerprint(sb.toString());\n    return Long.toHexString(fingerprint).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    long fingerprint = FP.fingerprint(tcValue);\n    return Long.toHexString(fingerprint).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) \n    {\n        if (part instanceof PlaceholderReference) \n        {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                CaseFormat.UPPER_UNDERSCORE,\n                ((PlaceholderReference) part).getName()));\n        } \n        else \n        {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    long fingerprint = FP.fingerprint(tcValue);\n    return Long.toHexString(fingerprint).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n        StringBuilder sb = new StringBuilder();\n        for (CharSequence part : messageParts) {\n            if (part instanceof PlaceholderReference) {\n                sb.append(CaseFormat.LOWER_CAMEL.to(\n                        CaseFormat.UPPER_UNDERSCORE,\n                        ((PlaceholderReference) part).getName()));\n            } else {\n                sb.append(part);\n            }\n        }\n        long fingerprint = FP.fingerprint(sb.toString());\n        return Long.toHexString(fingerprint).toUpperCase();\n    }"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.size();\n    final long minDistance = minDistanceFromEnd;\n    final long maxDistance = maxDistanceFromEnd;\n    final int sigLength = sig.length;\n    final byte[] buffer = new byte[sigLength];\n\n    while (currentPosition >= minDistance) {\n        final long seekPosition = currentPosition - maxDistance;\n        if (seekPosition < 0) {\n            seekPosition = 0;\n        }\n        archive.position(seekPosition);\n        IOUtils.readFully(archive, buffer, 0, sigLength);\n        if (Arrays.equals(sig, 0, sigLength, buffer, 0, sigLength)) {\n            archive.position(currentPosition);\n            return true;\n        }\n        currentPosition -= maxDistance;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long pos = archive.size() - minDistanceFromEnd;\n    if (pos < maxDistanceFromEnd) {\n        pos = maxDistanceFromEnd;\n    }\n    final long startPos = pos;\n    final int sigLen = sig.length;\n    final byte[] buffer = new byte[sigLen];\n    while (pos >= sigLen) {\n        archive.position(pos);\n        IOUtils.readFully(archive, buffer, 0, sigLen);\n        if (Arrays.equals(sig, 0, sigLen, buffer, 0, sigLen)) {\n            archive.position(pos - sigLen + 1);\n            return true;\n        }\n        pos--;\n    }\n    archive.position(startPos);\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long archiveSize = archive.size();\n    final int sigLen = sig.length;\n    final long minDistance = Math.max(minDistanceFromEnd, sigLen);\n    final long maxDistance = Math.min(maxDistanceFromEnd, archiveSize - sigLen);\n    final long start = archiveSize - minDistance;\n    final long end = archiveSize - maxDistance;\n    final byte[] buffer = new byte[(int) maxDistance];\n    archive.position(start);\n    IOUtils.readFully(archive, buffer, 0, (int) maxDistance);\n    for (long pos = start; pos >= end; pos--) {\n        if (Arrays.equals(sig, 0, sigLen, buffer, (int) (pos - end), sigLen)) {\n            archive.position(pos);\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.size();\n    if (currentPosition < minDistanceFromEnd) {\n        return false;\n    }\n    byte[] buffer = new byte[(int) maxDistanceFromEnd];\n    archive.position(currentPosition - minDistanceFromEnd);\n    archive.read(buffer);\n    archive.position(currentPosition);\n    return ArrayUtils.indexOfSubArray(buffer, sig) != -1;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        final long start = Math.max(archive.size() - maxDistanceFromEnd, 0);\n        final long end = Math.max(archive.size() - minDistanceFromEnd, 0);\n        byte[] buffer = new byte[(int) (end - start)];\n        archive.position(end);\n        IOUtils.readFully(archive, buffer, (int) start, (int) (end - start));\n        int foundAt = ArrayUtils.indexOf(buffer, sig);\n        if (foundAt >= 0) {\n            archive.position(end - (buffer.length - foundAt) - sig.length);\n            return true;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.size();\n    long endPosition = currentPosition - minDistanceFromEnd;\n    long startPosition = currentPosition - maxDistanceFromEnd;\n    if (startPosition < 0) {\n        startPosition = 0;\n    }\n    byte[] buffer = new byte[(int) (currentPosition - startPosition)];\n    archive.position(startPosition);\n    IOUtils.readFully(archive, buffer);\n    int sigLen = sig.length;\n    for (int i = 0; i <= buffer.length - sigLen; i++) {\n        if (Arrays.equals(sig, 0, sigLen, buffer, i, sigLen)) {\n            archive.position(startPosition + i);\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.size();\n    int sigLength = sig.length;\n    byte[] buffer = new byte[sigLength];\n    boolean found = false;\n    while (currentPosition >= minDistanceFromEnd) {\n        long seekPosition = currentPosition - maxDistanceFromEnd;\n        if (seekPosition < 0) {\n            seekPosition = 0;\n        }\n        archive.position(seekPosition);\n        IOUtils.readFully(archive, buffer, 0, sigLength);\n        if (Arrays.equals(sig, 0, sigLength, buffer, 0, sigLength)) {\n            found = true;\n            break;\n        }\n        currentPosition -= maxDistanceFromEnd;\n    }\n    return found;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long end = archive.size();\n    final long minDistance = Math.max(minDistanceFromEnd, sig.length);\n    final long maxDistance = Math.min(maxDistanceFromEnd, end - sig.length);\n    for (long pos = end - minDistance; pos >= maxDistance; pos--) {\n        archive.position(pos);\n        if (archive.read(sig, 0, sig.length) == sig.length) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long pos = archive.size();\n    final int sigLen = sig.length;\n    final byte[] buffer = new byte[sigLen];\n    final int bufferLen = buffer.length;\n    for (long i = 0; i < maxDistanceFromEnd; i++) {\n        if (pos < minDistanceFromEnd) {\n            return false;\n        }\n        archive.position(pos);\n        IOUtils.readFully(archive, buffer, 0, bufferLen);\n        if (Arrays.equals(sig, 0, sigLen, buffer, 0, bufferLen)) {\n            return true;\n        }\n        pos--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long currentPosition = archive.size();\n    final long minDistance = Math.min(minDistanceFromEnd, currentPosition);\n    final long maxDistance = Math.min(maxDistanceFromEnd, currentPosition);\n    final int sigLength = sig.length;\n    byte[] buffer = new byte[sigLength];\n    for (long distance = minDistance; distance >= maxDistance; distance--) {\n        archive.position(currentPosition - distance);\n        IOUtils.readFully(archive, buffer, 0, sigLength);\n        if (Arrays.equals(sig, 0, sigLength, buffer, 0, sigLength)) {\n            archive.position(currentPosition - distance + sigLength);\n            return true;\n        }\n    }\n    return false;\n}"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    PartialConverter[] removed = new PartialConverter[1];\n    iPartialConverters = iPartialConverters.remove(converter, removed);\n    return removed[0];\n}"
    ],
    [
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n}",
      "public InputStream getDataStream()  {\n        if (_originalStream == null) {\n            return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n        }\n        return new BufferedInputStream(_originalStream) {\n}\n}",
      "public InputStream getDataStream()  {\n        if (_bufferedData != null) {\n            return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n        }\n        return _originalStream;\n    }",
      "public InputStream getDataStream()  {\n    return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }",
      "public InputStream getDataStream()  {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }",
      "public InputStream getDataStream()  {\n        return new InputStream() {\n            int _index = _bufferedStart;\n            int _count = _bufferedLength;\n\n}\n}",
      "public InputStream getDataStream()  {\n        if (_originalStream == null) {\n            return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n        }\n        return new InputStream() {\n            int _index = _bufferedStart;\n            int _count = _bufferedLength;\n            final InputStream _in = _originalStream;\n\n}\n}",
      "public InputStream getDataStream()  {\n    return new InputStream() {\n        int _index = _bufferedStart;\n        int _count = _bufferedLength;\n\n}\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    // null argument check delegated...\n    return this.dataset.getKey(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= getDataset().getItemCount()) \n    {\n        throw new IllegalArgumentException(\"Section index out of range: \" + section);\n    }\n    return getDataset().getKey(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= getDataset().getItemCount()) {\n        throw new IllegalArgumentException(\"Invalid section index: \" + section);\n    }\n    return getDataset().getKey(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    List keys = new ArrayList(this.dataset.getKeys());\n    if (section < keys.size())\n    {\n        return (Comparable) keys.get(section);\n    }\n    else\n    {\n        return Integer.toString(section);\n    }\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= getDataset().getItemCount()) {\n        throw new IllegalArgumentException(\"Section index out of range: \" + section);\n    }\n    return getDataset().getKey(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    // null argument check delegated...\n    return this.dataset.getKey(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    // null argument check delegated...\n    return this.dataset.getKey(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= getDataset().getItemCount()) \n    {\n        throw new IllegalArgumentException(\"Invalid section index: \" + section);\n    }\n\n    List keys = new ArrayList(getDataset().getKeys());\n    return keys.get(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    if (section < 0 || section >= getDataset().getItemCount()) {\n        throw new IllegalArgumentException(\"Section index out of range: \" + section);\n    }\n    return getDataset().getKey(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    List keys = new ArrayList(this.dataset.getKeys());\n    if (section < keys.size()) \n    {\n        return (Comparable) keys.get(section);\n    } \n    else \n    {\n        return Integer.valueOf(section);\n    }\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                try {\n                    return Float.isNaN(_floatValue());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                try {\n                    return false; // int is never NaN\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                try {\n                    return Float.isNaN(getFloatValue());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                try {\n                    return false; // Not NaN for ints\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                try {\n                    return Float.isNaN(getFloatValue());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            } else if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                try {\n                    return false; // No equivalent to Double.isNaN for int/long\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) \n            {\n                double d = getDoubleValue();\n                return Double.isNaN(d);\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) \n            {\n                double d = getDoubleValue();\n                return Double.isNaN(d);\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                try {\n                    return Float.isNaN(_floatValue());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                return false;\n            }\n            return true;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) \n            {\n                double d = getDoubleValue();\n                return Double.isNaN(d);\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                try {\n                    return Float.isNaN(getFloatValue());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                try {\n                    return false; // Integer is never NaN\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) \n            {\n                double d = getDoubleValue();\n                return Double.isNaN(d);\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n                try {\n                    return Float.isNaN(getFloatValue());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n                try {\n                    return false; // always false for integers\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return false;\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}"
    ],
    [
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    String result;\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    String result;\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      return nextUnquotedValue();\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      return nextUnquotedValue();\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    String result;\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    String result;\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    String result;\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      return nextUnquotedValue();\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    String result;\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      result = nextUnquotedValue();\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n      return nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } else if (p == PEEKED_UNQUOTED) {\n      return nextUnquotedValue();\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (offset + maxWidth > str.length()) {\n        maxWidth = str.length() - offset;\n    }\n    StringBuilder sb = new StringBuilder(maxWidth);\n    // Abbreviate middle. Number of characters to abbreviate is:\n    // maxWidth - 3 (for the ellipses). Subtract 1 in case of an odd number.\n    int middle = maxWidth - 3;\n    if (middle < 1) {\n        middle = 1;\n    }\n    // Insert into StringBuilder in 3 steps:\n    // 1. The part before the offset.\n    // 2. The abbreviated middle part.\n    // 3. The part after the offset + middle.\n    sb.append(str, 0, offset);\n    sb.append(\"...\");\n    sb.append(str, offset + middle, str.length());\n    return sb.toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (offset + maxWidth > str.length()) {\n        maxWidth = str.length() - offset;\n    }\n    StringBuilder sb = new StringBuilder(maxWidth);\n    // Abbreviate middle with \"...\"\n    sb.append(str, 0, offset);\n    sb.append(\"...\");\n    sb.append(str, offset + maxWidth - 3, str.length());\n    return sb.toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (offset + maxWidth > str.length()) {\n        maxWidth = str.length() - offset;\n    }\n    int midWidth = maxWidth / 2;\n    if (offset < midWidth) {\n        midWidth = offset;\n    }\n    int offsetRight = str.length() - maxWidth + midWidth + 3;\n    if (offsetRight < 0) {\n        offsetRight = 0;\n    }\n    return new StringBuilder(maxWidth)\n        .append(str, 0, offset)\n        .append(\"...\")\n        .append(str.substring(offsetRight))\n        .toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (offset + maxWidth > str.length()) {\n        maxWidth = str.length() - offset;\n    }\n    StringBuilder sb = new StringBuilder(maxWidth);\n    // handle left edge\n    if (offset > maxWidth - 3) {\n        offset = maxWidth - 3;\n    }\n    if (offset > 0) {\n        sb.append(str.substring(0, offset));\n    }\n    // handle middle\n    sb.append(\"...\");\n    // handle right edge\n    if (offset + maxWidth < str.length()) {\n        sb.append(str.substring(offset + maxWidth));\n    }\n    return sb.toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (offset + maxWidth > str.length()) {\n        maxWidth = str.length() - offset;\n    }\n    StringBuilder sb = new StringBuilder(maxWidth);\n    // handle left edge\n    if (offset > maxWidth - 3) {\n        sb.append(str.substring(0, maxWidth - 3));\n        sb.append(\"...\");\n    } else {\n        // handle left edge\n        sb.append(str.substring(0, offset));\n        // handle middle\n        sb.append(\"...\");\n        sb.append(str.substring(offset + maxWidth - 3));\n    }\n    return sb.toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset <= 3) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (offset >= str.length()) {\n        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n    }\n    StringBuilder abbrev = new StringBuilder(maxWidth);\n    abbrev.append(\"...\");\n    abbrev.append(str.substring(offset - 1, offset + 1));\n    abbrev.append(str.substring(str.length() - (maxWidth - abbrev.length())));\n    return abbrev.toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset <= 3) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (offset >= str.length()) {\n        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n    }\n    return str.substring(0, offset) + \"...\" + str.substring(offset + maxWidth - 3);\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset <= 3) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (offset >= str.length()) {\n        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n    }\n    String leftStripped = str.substring(offset);\n    int lengthOfLeftStripped = leftStripped.length();\n    if (lengthOfLeftStripped <= maxWidth - 3) {\n        return str.substring(0, offset) + \"...\" + leftStripped;\n    }\n    return str.substring(0, offset + (lengthOfLeftStripped - (maxWidth - 3)) - 1) + \"...\" + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (offset + maxWidth > str.length()) {\n        maxWidth = str.length() - offset;\n    }\n    if (offset <= 2) {\n        return \"...\" + str.substring(offset + 3);\n    }\n    if (offset + maxWidth >= str.length()) {\n        return str.substring(0, offset - 1) + \"...\";\n    }\n    return str.substring(0, offset - 1) + \"...\" + str.substring(offset + maxWidth + 3);\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset <= 3) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (offset >= str.length()) {\n        return \"...\" + str.substring(str.length() - (maxWidth - 3));\n    }\n    StringBuilder sb = new StringBuilder(maxWidth);\n    sb.append(\"...\");\n    sb.append(str.substring(offset - 1, offset + 2));\n    sb.append(str.substring(str.length() - (maxWidth - sb.length())));\n    return sb.toString();\n}"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;  // already know 's1' isn't null\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;  // already know 's1' isn't null\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;  // already know 's1' isn't null\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;  // already know 's1' isn't null\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;  // already know 's1' isn't null\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;  // already know 's1' isn't null\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;  // already know 's1' isn't null\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;  // already know 's1' isn't null\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;  // already know 's1' isn't null\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) \n    {\n        return (s2 == null);\n    }\n    if (s2 == null) \n    {\n        return false;  // already know 's1' isn't null\n    }\n    if (s1.length != s2.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) \n    {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        return index;\n      } else {\n        index = originalNameMap.size();\n        originalNameMap.put(symbolName, index);\n        return index;\n      }\n    }\n    return UNMAPPED;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n      Integer index = originalNameMap.get(symbolName);\n      if (index == null) {\n        index = originalNameMap.size();\n        originalNameMap.put(symbolName, index);\n      }\n      return index;\n    }\n    return UNMAPPED;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        return index;\n      } else {\n        index = originalNameMap.size();\n        originalNameMap.put(symbolName, index);\n        return index;\n      }\n    }\n    return UNMAPPED;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        return index;\n      } else {\n        index = originalNameMap.size();\n        originalNameMap.put(symbolName, index);\n        return index;\n      }\n    }\n    return UNMAPPED;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        return index;\n      } else {\n        index = originalNameMap.size();\n        originalNameMap.put(symbolName, index);\n        return index;\n      }\n    } else {\n      return UNMAPPED;\n    }\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n      Integer index = originalNameMap.get(symbolName);\n      if (index == null) {\n        index = originalNameMap.size();\n        originalNameMap.put(symbolName, index);\n      }\n      return index;\n    }\n    return UNMAPPED;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        return index;\n      } else {\n        index = originalNameMap.size();\n        originalNameMap.put(symbolName, index);\n        return index;\n      }\n    }\n    return UNMAPPED;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        return index;\n      } else {\n        index = originalNameMap.size();\n        originalNameMap.put(symbolName, index);\n        return index;\n      }\n    } else {\n      return UNMAPPED;\n    }\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n      Integer index = originalNameMap.get(symbolName);\n      if (index == null) {\n        index = originalNameMap.size();\n        originalNameMap.put(symbolName, index);\n      }\n      return index;\n    }\n    return UNMAPPED;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != null) {\n      Integer index = originalNameMap.get(symbolName);\n      if (index != null) {\n        return index;\n      } else {\n        index = originalNameMap.size();\n        originalNameMap.put(symbolName, index);\n        return index;\n      }\n    }\n    return UNMAPPED;\n  }"
    ],
    [
      "public double nextDouble() throws IOException  {\n    String value = nextString();\n    try {\n      return Double.parseDouble(value);\n    } catch (NumberFormatException e) {\n      throw new NumberFormatException(\"Expected a double but was \" + value + locationString());\n    }\n  }",
      "public double nextDouble() throws IOException  {\n    String value = nextString();\n    try {\n      return Double.parseDouble(value);\n    } catch (NumberFormatException e) {\n      throw new NumberFormatException(\"Expected a double but was \" + value + locationString());\n    }\n  }",
      "public double nextDouble() throws IOException  {\n    String value = nextString();\n    try {\n        return Double.parseDouble(value);\n    } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Invalid double: \" + value);\n    }\n}",
      "public double nextDouble() throws IOException  {\n    String value = nextString();\n    try {\n      return Double.parseDouble(value);\n    } catch (NumberFormatException e) {\n      throw new NumberFormatException(\"Expected a double but was \" + value + locationString());\n    }\n  }",
      "public double nextDouble() throws IOException  {\n    String value = nextString();\n    try {\n      return Double.parseDouble(value);\n    } catch (NumberFormatException e) {\n      throw new NumberFormatException(\"Invalid double: \" + value + locationString());\n    }\n  }",
      "public double nextDouble() throws IOException  {\n    String value = nextString();\n    try {\n      return Double.parseDouble(value);\n    } catch (NumberFormatException e) {\n      throw new NumberFormatException(\"Expected a double but was \" + value + locationString());\n    }\n  }",
      "public double nextDouble() throws IOException  {\n    String str = nextString();\n    try {\n      return Double.parseDouble(str);\n    } catch (NumberFormatException e) {\n      throw new NumberFormatException(\"Expected a double but was \" + str + locationString());\n    }\n  }",
      "public double nextDouble() throws IOException  {\n    String str = nextString();\n    try {\n      return Double.parseDouble(str);\n    } catch (NumberFormatException e) {\n      throw new NumberFormatException(\"Expected a double but was \" + str + locationString());\n    }\n  }",
      "public double nextDouble() throws IOException  {\n    String str = nextString();\n    try {\n        return Double.parseDouble(str);\n    } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Expected a double but was \" + str + locationString());\n    }\n}",
      "public double nextDouble() throws IOException  {\n    String value = nextString();\n    try {\n        return Double.parseDouble(value);\n    } catch (NumberFormatException e) {\n        throw new NumberFormatException(\"Expected a double but was \" + value + locationString());\n    }\n}"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n    if(str == null) {\n        return null;\n    }\n    if(repeat <= 0) {\n        return \"\";\n    }\n    StringBuilder builder = new StringBuilder(str.length() * repeat);\n    for(int i = 0; i < repeat; i++) {\n        builder.append(str);\n    }\n    return builder.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if(str == null) {\n        return null;\n    }\n    if(repeat <= 0) {\n        return \"\";\n    }\n    StringBuilder builder = new StringBuilder(str.length() * repeat);\n    for(int i = 0; i < repeat; i++) {\n        builder.append(str);\n    }\n    return builder.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if(str == null) {\n        return null;\n    }\n    if(repeat <= 0) {\n        return \"\";\n    }\n    StringBuilder builder = new StringBuilder(str.length() * repeat);\n    for(int i = 0; i < repeat; i++) {\n        builder.append(str);\n    }\n    return builder.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    StringBuilder builder = new StringBuilder(str.length() * repeat);\n    for (int i = 0; i < repeat; i++) {\n        builder.append(str);\n    }\n    return builder.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if(str == null) {\n        return null;\n    }\n    if(repeat <= 0) {\n        return \"\";\n    }\n    StringBuilder builder = new StringBuilder(str.length() * repeat);\n    for(int i = 0; i < repeat; i++) {\n        builder.append(str);\n    }\n    return builder.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    StringBuilder sb = new StringBuilder(str.length() * repeat);\n    for (int i = 0; i < repeat; i++) {\n        sb.append(str);\n    }\n    return sb.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (inputLength == 0 || repeat == Integer.MAX_VALUE) {\n        return str;\n    }\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder b = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                b.append(str);\n            }\n            return b.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (inputLength == 0 || repeat == Integer.MAX_VALUE) {\n        return str;\n    }\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder b = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                b.append(str);\n            }\n            return b.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if(str == null) {\n        return null;\n    }\n    if(repeat <= 0) {\n        return \"\";\n    }\n    StringBuilder sb = new StringBuilder(str.length() * repeat);\n    for(int i = 0; i < repeat; i++) {\n        sb.append(str);\n    }\n    return sb.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final int inputLength = str.length();\n    if (inputLength == 0 || repeat == Integer.MAX_VALUE) {\n        return str;\n    }\n    final int outputLength = inputLength * repeat;\n    switch (inputLength) {\n        case 1 :\n            return repeat(str.charAt(0), repeat);\n        case 2 :\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[outputLength];\n            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default :\n            final StringBuilder b = new StringBuilder(outputLength);\n            for (int i = 0; i < repeat; i++) {\n                b.append(str);\n            }\n            return b.toString();\n    }\n}"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> clazz = implementations.get(headerId);\n        if (clazz == null) {\n            return new UnrecognizedExtraField();\n        }\n        return (ZipExtraField) clazz.newInstance();\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> clazz = implementations.get(headerId);\n        if (clazz == null) {\n            return new UnrecognizedExtraField();\n        }\n        return (ZipExtraField) clazz.newInstance();\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> clazz = implementations.get(headerId);\n        if (clazz == null) {\n            return new UnrecognizedExtraField();\n        }\n        return (ZipExtraField) clazz.newInstance();\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> c = implementations.get(headerId);\n        if (c == null) {\n            return new UnrecognizedExtraField();\n        }\n        return (ZipExtraField) c.newInstance();\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> c = implementations.get(headerId);\n        if (c == null) {\n            return new UnrecognizedExtraField();\n        }\n        return (ZipExtraField) c.newInstance();\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> clazz = implementations.get(headerId);\n        if (clazz == null) {\n            return new UnrecognizedExtraField();\n        }\n        return (ZipExtraField) clazz.newInstance();\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> clazz = implementations.get(headerId);\n        if (clazz == null) {\n            return new UnrecognizedExtraField();\n        }\n        return (ZipExtraField) clazz.newInstance();\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> clazz = implementations.get(headerId);\n        if (clazz == null) {\n            return new UnrecognizedExtraField();\n        }\n        return (ZipExtraField) clazz.newInstance();\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> c = implementations.get(headerId);\n        if (c == null) {\n            return new UnrecognizedExtraField();\n        }\n        return (ZipExtraField) c.newInstance();\n    }",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n        Class<?> clazz = implementations.get(headerId);\n        if (clazz == null) {\n            return new UnrecognizedExtraField();\n        }\n        return (ZipExtraField) clazz.newInstance();\n    }"
    ],
    [
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iter = map.keySet().iterator();\n    while (iter.hasNext()) {\n        Comparable key = (Comparable) iter.next();\n        List markers = (List) ((List) map.get(key)).clone();\n        clone.put(key, markers);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iterator = map.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        List markers = (List) map.get(key);\n        List cloneMarkers = new ArrayList();\n        Iterator iterator2 = markers.iterator();\n        while (iterator2.hasNext()) {\n            CategoryMarker marker = (CategoryMarker) iterator2.next();\n            CategoryMarker cloneMarker = (CategoryMarker) marker.clone();\n            cloneMarkers.add(cloneMarker);\n        }\n        clone.put(key, cloneMarkers);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Object key = entry.getKey();\n        List value = (List) entry.getValue();\n        List cloneValue = new ArrayList();\n        Iterator valueIterator = value.iterator();\n        while (valueIterator.hasNext()) {\n            Marker marker = (Marker) valueIterator.next();\n            Marker cloneMarker = (Marker) marker.clone();\n            cloneValue.add(cloneMarker);\n        }\n        clone.put(key, cloneValue);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iter = map.keySet().iterator();\n    while (iter.hasNext()) {\n        Object key = iter.next();\n        List markers = (List) map.get(key);\n        List cloneMarkers = new ArrayList();\n        Iterator iter2 = markers.iterator();\n        while (iter2.hasNext()) {\n            CategoryMarker marker = (CategoryMarker) iter2.next();\n            CategoryMarker cloneMarker = (CategoryMarker) marker.clone();\n            cloneMarkers.add(cloneMarker);\n        }\n        clone.put(key, cloneMarkers);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iter = map.entrySet().iterator();\n    while (iter.hasNext()) {\n        Map.Entry entry = (Map.Entry) iter.next();\n        Object key = entry.getKey();\n        List markers = (List) entry.getValue();\n        List cloneMarkers = new ArrayList();\n        for (int i = 0; i < markers.size(); i++) {\n            CategoryMarker marker = (CategoryMarker) markers.get(i);\n            CategoryMarker cloneMarker = (CategoryMarker) marker.clone();\n            cloneMarkers.add(cloneMarker);\n        }\n        clone.put(key, cloneMarkers);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iter = map.entrySet().iterator();\n    while (iter.hasNext()) {\n        Map.Entry entry = (Map.Entry) iter.next();\n        Object key = entry.getKey();\n        List markers = (List) entry.getValue();\n        List cloneMarkers = new ArrayList();\n        Iterator iterMarkers = markers.iterator();\n        while (iterMarkers.hasNext()) {\n            Marker marker = (Marker) iterMarkers.next();\n            Marker cloneMarker = (Marker) marker.clone();\n            cloneMarkers.add(cloneMarker);\n        }\n        clone.put(key, cloneMarkers);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iter = map.entrySet().iterator();\n    while (iter.hasNext()) {\n        Map.Entry entry = (Map.Entry) iter.next();\n        CategoryMarker marker = (CategoryMarker) entry.getValue();\n        CategoryMarker cloneMarker = (CategoryMarker) marker.clone();\n        clone.put(entry.getKey(), cloneMarker);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iterator = map.keySet().iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        List markers = (List) map.get(key);\n        List cloneMarkers = new ArrayList();\n        Iterator iterator2 = markers.iterator();\n        while (iterator2.hasNext()) {\n            Marker marker = (Marker) iterator2.next();\n            Marker cloneMarker = (Marker) marker.clone();\n            cloneMarkers.add(cloneMarker);\n        }\n        clone.put(key, cloneMarkers);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iterator = map.entrySet().iterator();\n    while (iterator.hasNext()) {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        CategoryMarker marker = (CategoryMarker) entry.getValue();\n        CategoryMarker cloneMarker = (CategoryMarker) marker.clone();\n        clone.put(entry.getKey(), cloneMarker);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iter = map.keySet().iterator();\n    while (iter.hasNext()) {\n        Comparable key = (Comparable) iter.next();\n        List markers = (List) ((ArrayList) map.get(key)).clone();\n        clone.put(key, markers);\n    }\n    return clone;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    int sum = WORD * data.length;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < data.length; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n        int sum = 0;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (final ZipExtraField element : data) {\n            System.arraycopy(element.getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(element.getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += 4;\n            final byte[] central = element.getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n                start += central.length;\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final int sum = WORD * data.length;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (final ZipExtraField element : data) {\n        System.arraycopy(element.getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(element.getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = element.getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    int sum = 0;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (final ZipExtraField element : data) \n    {\n        System.arraycopy(element.getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(element.getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        final byte[] central = element.getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start + 4, central.length);\n        }\n        start += element.getCentralDirectoryLength().getValue();\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n        final int sum = ZipExtraField.EXTRAFIELD_HEADER_SIZE * data.length;\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (final ZipExtraField element : data) {\n            System.arraycopy(element.getHeaderId().getBytes(), 0, result, start, 2);\n            System.arraycopy(element.getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n            start += ZipExtraField.EXTRAFIELD_HEADER_SIZE;\n            final byte[] central = element.getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n                start += central.length;\n            }\n        }\n        return result;\n    }",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    int sum = WORD * data.length;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < data.length; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    int sum = WORD * data.length;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < data.length; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(), 0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(), 0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) \n        {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n        final boolean lastIsUnparseableHolder = data.length > 0\n            && data[data.length - 1] instanceof UnparseableExtraFieldData;\n        final int regularExtraFieldCount =\n            lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n        int sum = WORD * regularExtraFieldCount;\n        for (final ZipExtraField element : data) {\n            sum += element.getCentralDirectoryLength().getValue();\n        }\n\n        final byte[] result = new byte[sum];\n        int start = 0;\n        for (int i = 0; i < regularExtraFieldCount; i++) {\n            System.arraycopy(data[i].getHeaderId().getBytes(),\n                             0, result, start, 2);\n            System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                             0, result, start + 2, 2);\n            start += WORD;\n            final byte[] central = data[i].getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n                start += central.length;\n            }\n        }\n        if (lastIsUnparseableHolder) {\n            final byte[] central = data[data.length - 1].getCentralDirectoryData();\n            if (central != null) {\n                System.arraycopy(central, 0, result, start, central.length);\n            }\n        }\n        return result;\n    }"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E element : coll) \n        {\n            if (set.contains(element)) \n            {\n                continue;\n            }\n            super.add(index, element);\n            set.add(element);\n            changed = true;\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E element : coll) {\n            if (set.contains(element)) {\n                continue;\n            }\n            add(index, element);\n            changed = true;\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E element : coll) {\n            if (!set.contains(element)) {\n                super.add(index, element);\n                set.add(element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E element : coll) \n        {\n            if (!set.contains(element)) \n            {\n                super.add(index, element);\n                set.add(element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E element : coll) {\n            if (!set.contains(element)) {\n                super.add(index, element);\n                set.add(element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E element : coll) \n        {\n            if (!set.contains(element)) \n            {\n                super.add(index, element);\n                set.add(element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E element : coll) {\n            if (!set.contains(element)) {\n                super.add(index, element);\n                set.add(element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E element : coll) {\n            if (!set.contains(element)) {\n                super.add(index, element);\n                set.add(element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E element : coll) \n        {\n            if (set.contains(element) == false) \n            {\n                super.add(index, element);\n                set.add(element);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        for (final E element : coll) \n        {\n            if (set.contains(element)) \n            {\n                continue;\n            }\n            super.add(index, element);\n            set.add(element);\n            changed = true;\n        }\n        return changed;\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  {\n    //TODO: implement the method\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    // TODO: Implement the method\n    try {\n        return f.value(x);\n    } catch (IllegalArgumentException e) {\n        e.printStackTrace();\n    }\n    return 0;\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    evaluations.incrementCount();\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  {\n    // TODO: Implement this method.\n    try {\n        return f.value(x);\n    } catch (IllegalArgumentException e) {\n        e.printStackTrace();\n    }\n    return 0;\n}"
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (bin.getUpperBound() < this.lowerBound) {\n        return false;\n    }\n    if (bin.getLowerBound() > this.upperBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (bin.getUpperBound() < this.lowerBound) \n    {\n        return false;\n    }\n    if (bin.getLowerBound() > this.upperBound) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (bin.getUpperBound() < this.lowerBound) \n    {\n        return false;\n    }\n    if (bin.getLowerBound() > this.upperBound) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return !(bin.getUpperBound() < this.lowerBound || bin.getLowerBound() > this.upperBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return !(bin.getUpperBound() < this.lowerBound || bin.getLowerBound() > this.upperBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound || this.upperBound < bin.lowerBound) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return this.upperBound > bin.lowerBound && bin.upperBound > this.lowerBound;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (bin.getUpperBound() < this.lowerBound) {\n        return false;\n    }\n    if (bin.getLowerBound() > this.upperBound) {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return !(bin.getUpperBound() < this.lowerBound || bin.getLowerBound() > this.upperBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return !(bin.getUpperBound() < this.lowerBound || bin.getLowerBound() > this.upperBound);\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if(str == null) {\n        return null;\n    }\n\n    List<String> list = new ArrayList<>();\n    int len = str.length();\n    int start = 0;\n    int type = Character.getType(str.charAt(0));\n    for(int i = 1; i < len; i++) \n    {\n        int newType = Character.getType(str.charAt(i));\n        if(camelCase && newType == Character.UPPERCASE_LETTER && type == Character.LOWERCASE_LETTER) \n        {\n            list.add(str.substring(start, i));\n            start = i;\n        } \n        else if(newType != type) \n        {\n            list.add(str.substring(start, i));\n            start = i;\n        }\n        type = newType;\n    }\n    list.add(str.substring(start, len));\n    return list.toArray(new String[0]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if(str == null) \n    {\n        return null;\n    }\n\n    List<String> list = new ArrayList<>();\n    int len = str.length();\n    int start = 0;\n    int type = Character.getType(str.charAt(0));\n\n    for(int i = 1; i < len; i++) \n    {\n        int newType = Character.getType(str.charAt(i));\n        if(camelCase && newType == Character.LOWERCASE_LETTER && type == Character.UPPERCASE_LETTER) \n        {\n            list.add(str.substring(start, i));\n            start = i;\n        } \n        else if(newType != type) \n        {\n            list.add(str.substring(start, i));\n            start = i;\n        }\n        type = newType;\n    }\n\n    list.add(str.substring(start, len));\n\n    return list.toArray(new String[0]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if(str == null) {\n        return null;\n    }\n    List<String> list = new ArrayList<String>();\n    char[] chars = str.toCharArray();\n    int len = chars.length;\n    int start = 0;\n    boolean lastWasUpper = Character.isUpperCase(chars[0]);\n    boolean lastWasLetter = Character.isLetter(chars[0]);\n    for(int i = 1; i < len; i++) \n    {\n        boolean currentIsLetter = Character.isLetter(chars[i]);\n        boolean currentIsUpper = Character.isUpperCase(chars[i]);\n        if(camelCase && lastWasLetter && lastWasUpper && currentIsLetter && !currentIsUpper) \n        {\n            list.add(new String(chars, start, i - start));\n            start = i;\n        } \n        else if(!currentIsLetter) \n        {\n            list.add(new String(chars, start, i - start + 1));\n            start = i + 1;\n        }\n        lastWasLetter = currentIsLetter;\n        lastWasUpper = currentIsUpper;\n    }\n    list.add(new String(chars, start, len - start));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if(str == null) \n    {\n        return null;\n    }\n\n    List<String> list = new ArrayList<String>();\n    int len = str.length();\n    int start = 0;\n    char c0, c1;\n    int type0, type1;\n    boolean match = false;\n\n    for(int i = 1; i < len; i++) \n    {\n        c0 = str.charAt(i - 1);\n        c1 = str.charAt(i);\n        type0 = Character.getType(c0);\n        type1 = Character.getType(c1);\n\n        if(camelCase && type0 == Character.UPPERCASE_LETTER && type1 == Character.LOWERCASE_LETTER) \n        {\n            continue;\n        }\n\n        if((type0 == type1) && match) \n        {\n            continue;\n        }\n\n        if(type0 != type1) \n        {\n            list.add(str.substring(start, i));\n            start = i;\n            match = false;\n        } \n        else if(type1 == Character.LOWERCASE_LETTER || type1 == Character.UPPERCASE_LETTER) \n        {\n            match = true;\n        }\n    }\n\n    list.add(str.substring(start, len));\n\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if(str == null) {\n        return null;\n    }\n    List<String> list = new ArrayList<String>();\n    int len = str.length();\n    int type = Character.getType(str.charAt(0));\n    StringBuilder sb = new StringBuilder();\n    sb.append(str.charAt(0));\n    for (int i = 1; i < len; i++) \n    {\n        char chr = str.charAt(i);\n        int newType = Character.getType(chr);\n        if (camelCase && newType == Character.UPPERCASE_LETTER && type == Character.LOWERCASE_LETTER) \n        {\n            list.add(sb.toString());\n            sb.setLength(0);\n        }\n        sb.append(chr);\n        type = newType;\n    }\n    list.add(sb.toString());\n    return list.toArray(new String[0]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if(str == null) {\n        return null;\n    }\n\n    List<String> list = new ArrayList<String>();\n    int len = str.length();\n    int i = 0;\n    while (i < len) {\n        int start = i;\n        int type = Character.getType(str.charAt(i));\n        while (++i < len) {\n            int newType = Character.getType(str.charAt(i));\n            if (camelCase && newType == Character.UPPERCASE_LETTER && type == Character.LOWERCASE_LETTER) {\n                break;\n            }\n            if (newType != type) {\n                break;\n            }\n        }\n        list.add(str.substring(start, i));\n    }\n\n    return list.toArray(new String[0]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if(str == null) {\n        return null;\n    }\n\n    List<String> list = new ArrayList<String>();\n    int len = str.length();\n    int start = 0;\n    int type = Character.getType(str.charAt(0));\n    for(int i = 1; i < len; i++) {\n        int newType = Character.getType(str.charAt(i));\n        if(camelCase && newType == Character.LOWERCASE_LETTER && type == Character.UPPERCASE_LETTER) {\n            list.add(str.substring(start, i));\n            start = i;\n        } else if(newType != type) {\n            list.add(str.substring(start, i));\n            start = i;\n            type = newType;\n        }\n    }\n    list.add(str.substring(start, len));\n\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if(str == null) {\n        return null;\n    }\n\n    List<String> list = new ArrayList<>();\n    int len = str.length();\n    int start = 0;\n    char prevCharType = 0;\n    char currCharType;\n\n    for(int i = 0; i < len; i++) {\n        currCharType = Character.getType(str.charAt(i));\n\n        // if camelCase is true and the current character type is uppercase and the previous character type is lowercase,\n        // we split the string at this point\n        if(camelCase && prevCharType == Character.LOWERCASE_LETTER && currCharType == Character.UPPERCASE_LETTER) {\n            list.add(str.substring(start, i));\n            start = i;\n        }\n\n        prevCharType = currCharType;\n    }\n\n    // add the remaining string\n    list.add(str.substring(start, len));\n\n    return list.toArray(new String[0]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if(str == null) \n    {\n        return null;\n    }\n\n    List<String> list = new ArrayList<>();\n    int len = str.length();\n    int start = 0;\n    char[] chars = str.toCharArray();\n    boolean lastWasUpper = Character.isUpperCase(chars[0]);\n    boolean lastWasLower = !lastWasUpper;\n\n    for(int i = 1; i < len; i++) \n    {\n        boolean currentIsUpper = Character.isUpperCase(chars[i]);\n        boolean currentIsLower = !currentIsUpper;\n\n        if(camelCase && lastWasLower && currentIsUpper) \n        {\n            list.add(str.substring(start, i));\n            start = i;\n        } \n        else if(lastWasUpper != currentIsUpper) \n        {\n            list.add(str.substring(start, i));\n            start = i;\n        }\n\n        lastWasUpper = currentIsUpper;\n        lastWasLower = currentIsLower;\n    }\n\n    list.add(str.substring(start, len));\n\n    return list.toArray(new String[0]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if(str == null) {\n        return null;\n    }\n    List<String> list = new ArrayList<String>();\n    char[] chars = str.toCharArray();\n    int len = chars.length;\n    int start = 0;\n    boolean lastWasUpper = Character.isUpperCase(chars[0]);\n    for(int i = 1; i < len; i++) {\n        boolean currentIsUpper = Character.isUpperCase(chars[i]);\n        if(camelCase && lastWasUpper && currentIsUpper) {\n            list.add(String.valueOf(chars, start, i - start));\n            start = i;\n        } else if(!currentIsUpper) {\n            list.add(String.valueOf(chars, start, i - start));\n            start = i;\n        }\n        lastWasUpper = currentIsUpper;\n    }\n    list.add(String.valueOf(chars, start, len - start));\n    return list.toArray(new String[list.size()]);\n}"
    ],
    [
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, iChrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                iChrono = iChrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                iChrono = iChrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(\"Invalid format at position \" + newPos + \": \" + text);\n    }\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(\"Invalid format at position \" + newPos + \": \" + text);\n    }\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, iChrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                iChrono = iChrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                iChrono = iChrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(\"Invalid format at position \" + newPos + \": \" + text);\n    }\n    throw new UnsupportedOperationException(\"Parsing not supported\");\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        throw new IllegalArgumentException(\"Invalid format: \" + text);\n    }\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(\"Invalid format at position \" + newPos + \": \" + text);\n    }\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(\"Invalid format at position \" + newPos + \": \" + text);\n    }\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, iChrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                iChrono = iChrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                iChrono = iChrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(\"Invalid format at position \" + newPos + \": \" + text);\n    }\n    throw new UnsupportedOperationException(\"Parsing not supported\");\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, iChrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            return bucket.computeMillis(true, text);\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(\"Invalid format at position \" + newPos + \": \" + text);\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, iChrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            return bucket.computeMillis(true, text);\n        }\n    } else {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(\"Invalid format at position \" + newPos + \": \" + text);\n    }\n    throw new UnsupportedOperationException(\"Parsing not supported\");\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, iChrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            return bucket.computeMillis(true, text);\n        }\n    } else {\n        newPos = ~newPos;\n        throw new IllegalArgumentException(\"Invalid format at index \" + newPos + \" for text \" + text);\n    }\n    throw new UnsupportedOperationException(\"Parsing not supported\");\n}"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n    Node placeholder = swapWithPlaceholderNode(n);\n    MeasuredNode positive = new MeasuredNode(n, MeasuredNode.estimateCostOneLevel(n), false);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT).srcref(n), Integer.MAX_VALUE, false);\n    return new MinimizedCondition(positive, negative).setPlaceholder(placeholder);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    Node placeholder = swapWithPlaceholderNode(n);\n    MeasuredNode positive = new MeasuredNode(n, MeasuredNode.estimateCostOneLevel(n), false);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT, Integer.MAX_VALUE), true);\n    return new MinimizedCondition(positive, negative).setPlaceholder(placeholder);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode positive = new MeasuredNode(n, n.getLength(), false);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT).srcref(n), \n        Integer.MAX_VALUE, false);\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode positive = new MeasuredNode(n, n.getLength(), false);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT).srcref(n),\n        Integer.MAX_VALUE, false);\n    return new MinimizedCondition(positive, negative);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode positive = new MeasuredNode(n, n.getLength(), false);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false);\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Node placeholder = swapWithPlaceholderNode(n);\n    MeasuredNode positive = computeMeasuredNode(n);\n    MeasuredNode negative = computeMeasuredNode(new Node(Token.SCRIPT).srcref(n))\n        .setLength(Integer.MAX_VALUE);\n    return new MinimizedCondition(positive, negative).setPlaceholder(placeholder);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode positive = new MeasuredNode(n, MeasuredNode.estimateCostOneLevel(n), false);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT).srcref(n), Integer.MAX_VALUE, false);\n    return new MinimizedCondition(positive, negative);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode positive = new MeasuredNode(n, MeasuredNode.estimateCostOneLevel(n), false);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT).srcref(n), Integer.MAX_VALUE, false);\n    return new MinimizedCondition(positive, negative);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    Node placeholder = swapWithPlaceholderNode(n);\n    return new MinimizedCondition(\n        new MeasuredNode(n, MeasuredNode.estimateCostOneLevel(n), false),\n        new MeasuredNode(new Node(Token.SCRIPT).srcref(n), Integer.MAX_VALUE, false))\n        .setPlaceholder(placeholder);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode positive = new MeasuredNode(n, MeasuredNode.estimateCostOneLevel(n), false);\n    MeasuredNode negative = new MeasuredNode(new Node(Token.SCRIPT).srcref(n), Integer.MAX_VALUE, false);\n    return new MinimizedCondition(positive, negative);\n  }"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) \n    {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) \n    {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) \n    {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) \n    {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) \n    {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) \n    {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) \n    {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        Validate.isTrue(value != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    if (converter == null) {\n        return null;\n    }\n    checkAlterPartialConverters();\n    Converter[] removed = new Converter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return (PartialConverter)removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        Converter[] removed = new Converter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return (PartialConverter) removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    Converter[] removed = new Converter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return (PartialConverter) removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n\n    Converter[] removed = new Converter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return (PartialConverter) removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        if (converter == null) {\n            return null;\n        }\n        checkAlterPartialConverters();\n        PartialConverter[] converters = getPartialConverters();\n        PartialConverter removed = null;\n        for (int i = 0; i < converters.length; i++) {\n            if (converters[i].getSupportedType() == converter.getSupportedType()) {\n                removed = converters[i];\n                converters[i] = converter;\n                break;\n            }\n        }\n        iPartialConverters = new ConverterSet(converters);\n        return removed;\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n\n        Converter[] removed = new Converter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return (PartialConverter) removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n    Converter[] removed = new Converter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return (PartialConverter) removed[0];\n}",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n\n        Converter[] removed = new Converter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return (PartialConverter) removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        Converter[] removed = new Converter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return (PartialConverter) removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n    checkAlterPartialConverters();\n    if (converter == null) {\n        return null;\n    }\n\n    Converter[] removed = new Converter[1];\n    iPartialConverters = iPartialConverters.add(converter, removed);\n    return (PartialConverter) removed[0];\n}"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isDocScope()) \n    {\n        return 0;\n    } \n    else if (scope.isPropertyScope()) \n    {\n        int depth = 0;\n        SymbolScope current = scope;\n        while (!current.isLexicalScope()) \n        {\n            current = current.getParentScope();\n            depth++;\n        }\n        return depth + getLexicalScopeDepth(current);\n    } \n    else \n    {\n        return scope.getScopeDepth();\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isDocScope()) {\n      return 0;\n    }\n\n    int depth = 0;\n    SymbolScope current = scope;\n    while (current != null) {\n      if (current.isLexicalScope()) {\n        return depth;\n      }\n      depth++;\n      current = current.getParentScope();\n    }\n\n    throw new IllegalArgumentException(\"Scope is not in any scope: \" + scope);\n  }",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isDocScope()) {\n      return 0;\n    }\n    int depth = 0;\n    SymbolScope s = scope;\n    while (!s.isLexicalScope()) {\n      s = s.getParentScope();\n      depth++;\n    }\n    return depth + getLexicalScopeDepth(s);\n  }",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isDocScope()) {\n      return 0;\n    }\n\n    int depth = 0;\n    SymbolScope s = scope;\n    while (s != null) {\n      if (s.isLexicalScope()) {\n        return depth;\n      }\n      depth++;\n      s = s.getParentScope();\n    }\n\n    throw new IllegalArgumentException(\"Not a lexical scope: \" + scope);\n  }",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isPropertyScope()) {\n      int depth = 0;\n      SymbolScope current = scope;\n      while (!current.isLexicalScope()) {\n        depth++;\n        current = current.getParentScope();\n      }\n      return depth + getLexicalScopeDepth(current);\n    } else if (scope.isDocScope()) {\n      return 0;\n    } else {\n      return scope.getScopeDepth();\n    }\n  }",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isPropertyScope()) {\n      int depth = 0;\n      SymbolScope current = scope;\n      while (!current.isLexicalScope()) {\n        depth++;\n        current = current.getParentScope();\n      }\n      return depth + getLexicalScopeDepth(current);\n    } else if (scope.isDocScope()) {\n      return 0;\n    } else {\n      return scope.getScopeDepth();\n    }\n  }",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isDocScope()) \n    {\n        return 0;\n    } \n    else if (scope.isPropertyScope()) \n    {\n        int depth = 0;\n        SymbolScope current = scope;\n        while (current != null && !current.isLexicalScope()) \n        {\n            current = current.getParentScope();\n            depth++;\n        }\n        return depth + getLexicalScopeDepth(current);\n    } \n    else \n    {\n        return scope.getScopeDepth();\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isDocScope()) {\n      return 0;\n    }\n\n    int depth = 0;\n    SymbolScope current = scope;\n    while (current != null) {\n      if (current.isLexicalScope()) {\n        return depth;\n      }\n      depth++;\n      current = current.getParentScope();\n    }\n\n    throw new IllegalStateException(\"Scope is not in a lexical scope\");\n  }",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isPropertyScope()) {\n        int depth = 0;\n        SymbolScope parent = scope.getParentScope();\n        while (parent != null && !parent.isLexicalScope()) {\n            depth++;\n            parent = parent.getParentScope();\n        }\n        return depth + (parent == null ? 0 : getLexicalScopeDepth(parent));\n    } else if (scope.isDocScope()) {\n        return 0;\n    } else {\n        return scope.getScopeDepth();\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isDocScope()) \n    {\n        return 0;\n    } \n    else if (scope.isPropertyScope()) \n    {\n        int depth = 0;\n        SymbolScope current = scope;\n        while (!current.isLexicalScope()) \n        {\n            current = current.getParentScope();\n            depth++;\n        }\n        return depth + getLexicalScopeDepth(current);\n    } \n    else \n    {\n        return scope.getScopeDepth();\n    }\n}"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        double[][] blocksData = new double[blockRows][];\n        for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n            blocksData[blockRow] = new double[blockColumns * BLOCK_SIZE];\n            for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n                copyBlockPart(rawData, columns, blockRow * BLOCK_SIZE, Math.min((blockRow + 1) * BLOCK_SIZE, rows), blockColumn * BLOCK_SIZE, Math.min((blockColumn + 1) * BLOCK_SIZE, columns), blocksData[blockRow], blockColumns * BLOCK_SIZE, 0, blockColumn * BLOCK_SIZE);\n            }\n        }\n        return blocksData;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        double[][] blockData = new double[blockRows][];\n        for (int blockRow = 0; blockRow < blockRows; blockRow++) {\n            blockData[blockRow] = new double[blockColumns * BLOCK_SIZE];\n            for (int blockColumn = 0; blockColumn < blockColumns; blockColumn++) {\n                for (int i = 0; i < BLOCK_SIZE; i++) {\n                    int row = blockRow * BLOCK_SIZE + i;\n                    if (row < rows) {\n                        for (int j = 0; j < BLOCK_SIZE; j++) {\n                            int column = blockColumn * BLOCK_SIZE + j;\n                            if (column < columns) {\n                                blockData[blockRow][blockColumn * BLOCK_SIZE + j] = rawData[row][column];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return blockData;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        double[][] blocksData = new double[blockRows][];\n        for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n            blocksData[blockRow] = new double[blockColumns * BLOCK_SIZE];\n            for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n                int startRow = blockRow * BLOCK_SIZE;\n                int endRow = (blockRow + 1) * BLOCK_SIZE;\n                if (endRow > rows) {\n                    endRow = rows;\n                }\n                int startColumn = blockColumn * BLOCK_SIZE;\n                int endColumn = (blockColumn + 1) * BLOCK_SIZE;\n                if (endColumn > columns) {\n                    endColumn = columns;\n                }\n                for (int row = startRow; row < endRow; ++row) {\n                    System.arraycopy(rawData[row], startColumn, blocksData[blockRow], (row - startRow) * BLOCK_SIZE + blockColumn * BLOCK_SIZE, endColumn - startColumn);\n                }\n            }\n        }\n        return blocksData;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        double[][] blockData = new double[blockRows][];\n        for (int blockRow = 0; blockRow < blockRows; blockRow++) {\n            blockData[blockRow] = new double[blockColumns * BLOCK_SIZE];\n            for (int blockColumn = 0; blockColumn < blockColumns; blockColumn++) {\n                int startRow = blockRow * BLOCK_SIZE;\n                int endRow = Math.min((blockRow + 1) * BLOCK_SIZE, rows);\n                int startColumn = blockColumn * BLOCK_SIZE;\n                int endColumn = Math.min((blockColumn + 1) * BLOCK_SIZE, columns);\n                for (int row = startRow; row < endRow; row++) {\n                    System.arraycopy(rawData[row], startColumn, blockData[blockRow], (row - startRow) * BLOCK_SIZE + blockColumn * BLOCK_SIZE, endColumn - startColumn);\n                }\n            }\n        }\n        return blockData;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    double[][] blocksData = new double[blockRows][];\n    for (int i = 0; i < blockRows; i++) {\n        blocksData[i] = new double[blockColumns * BLOCK_SIZE * BLOCK_SIZE];\n    }\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < columns; j++) {\n            final int blockRow = i / BLOCK_SIZE;\n            final int blockColumn = j / BLOCK_SIZE;\n            final int blockIndex = (i % BLOCK_SIZE) * BLOCK_SIZE + j % BLOCK_SIZE;\n            blocksData[blockRow][blockColumn * BLOCK_SIZE * BLOCK_SIZE + blockIndex] = rawData[i][j];\n        }\n    }\n\n    return blocksData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    double[][] blocksData = new double[blockRows][blockColumns];\n    for (int i = 0; i < blockRows; i++) {\n        for (int j = 0; j < blockColumns; j++) {\n            blocksData[i][j] = new double[BLOCK_SIZE][BLOCK_SIZE];\n            for (int k = 0; k < BLOCK_SIZE; k++) {\n                for (int l = 0; l < BLOCK_SIZE; l++) {\n                    int row = i * BLOCK_SIZE + k;\n                    int col = j * BLOCK_SIZE + l;\n                    if (row < rows && col < columns) {\n                        blocksData[i][j][k][l] = rawData[row][col];\n                    }\n                }\n            }\n        }\n    }\n    return blocksData;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        double[][] blocksData = new double[blockRows][blockColumns];\n        for (int i = 0; i < blockRows; i++) {\n            for (int j = 0; j < blockColumns; j++) {\n                blocksData[i][j] = new double[BLOCK_SIZE][BLOCK_SIZE];\n                for (int k = 0; k < BLOCK_SIZE; k++) {\n                    for (int l = 0; l < BLOCK_SIZE; l++) {\n                        int row = i * BLOCK_SIZE + k;\n                        int col = j * BLOCK_SIZE + l;\n                        if (row < rows && col < columns) {\n                            blocksData[i][j][k][l] = rawData[row][col];\n                        }\n                    }\n                }\n            }\n        }\n        return blocksData;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        double[][] blocksData = new double[blockRows][blockColumns];\n        for (int i = 0; i < blockRows; i++) {\n            for (int j = 0; j < blockColumns; j++) {\n                blocksData[i][j] = new double[BLOCK_SIZE][BLOCK_SIZE];\n                for (int k = 0; k < BLOCK_SIZE; k++) {\n                    for (int l = 0; l < BLOCK_SIZE; l++) {\n                        int row = i * BLOCK_SIZE + k;\n                        int col = j * BLOCK_SIZE + l;\n                        if (row < rows && col < columns) {\n                            blocksData[i][j][k][l] = rawData[row][col];\n                        }\n                    }\n                }\n            }\n        }\n        return blocksData;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        double[][] blockData = new double[blockRows][];\n        for (int blockRow = 0; blockRow < blockRows; ++blockRow) {\n            blockData[blockRow] = new double[blockColumns * BLOCK_SIZE];\n            for (int blockColumn = 0; blockColumn < blockColumns; ++blockColumn) {\n                int startRow = blockRow * BLOCK_SIZE;\n                int endRow = Math.min((blockRow + 1) * BLOCK_SIZE, rows);\n                int startColumn = blockColumn * BLOCK_SIZE;\n                int endColumn = Math.min((blockColumn + 1) * BLOCK_SIZE, columns);\n                for (int row = startRow; row < endRow; ++row) {\n                    System.arraycopy(rawData[row], startColumn, blockData[blockRow], (row - startRow) * BLOCK_SIZE + blockColumn * BLOCK_SIZE, endColumn - startColumn);\n                }\n            }\n        }\n        return blockData;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    double[][] blockData = new double[blockRows][];\n    for (int i = 0; i < blockRows; i++) {\n        blockData[i] = new double[blockColumns * BLOCK_SIZE * BLOCK_SIZE];\n    }\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < columns; j++) {\n            final int blockRow = i / BLOCK_SIZE;\n            final int blockColumn = j / BLOCK_SIZE;\n            final int blockIndex = (i % BLOCK_SIZE) * BLOCK_SIZE + j % BLOCK_SIZE;\n            blockData[blockRow][blockColumn * BLOCK_SIZE * BLOCK_SIZE + blockIndex] = rawData[i][j];\n        }\n    }\n\n    return blockData;\n}"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= (1 << value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= (1 << value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= (1 << value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= (1 << value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= (1 << value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= (1 << value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= (1 << value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) \n    {\n        result |= (1 << value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= (1 << value.ordinal());\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  throws NullPointerException, IllegalArgumentException {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= (1 << value.ordinal());\n    }\n    return result;\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getField().getOne();\n    Dfp term = a;\n    int n = 1;\n\n    while (true) \n    {\n        result = result.add(term);\n        if (term.equals(a.getField().getZero())) \n        {\n            break;\n        }\n        term = term.multiply(a);\n        n++;\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getField().getOne();\n    final Dfp two = one.add(one);\n    final Dfp half = one.divide(two);\n\n    Dfp r = one;\n    Dfp x = a;\n    Dfp fact = one;\n    Dfp py = new Dfp(r);\n\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(a);\n        fact = fact.divide((i-1)*i);  // 1 over fact\n        r = r.add(x.divide(fact));\n        if (r.equals(py)) {\n            break;\n        }\n        py = new Dfp(r);\n    }\n\n    return r;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getField().getOne();\n    Dfp term = a;\n    Dfp factorial = a.getField().getOne();\n\n    for (int i = 1; i < 90; i++) \n    {\n        result = result.add(term);\n        term = term.multiply(a).divide(factorial);\n        factorial = factorial.multiply(new Dfp(i+1));\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getField().getOne();\n    Dfp term = a;\n\n    for (int i = 1; i < 90; i++) \n    {\n        result = result.add(term);\n        term = term.multiply(a).divide(i);\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getField().getOne();\n    final Dfp two = one.add(one);\n    final Dfp half = one.divide(two);\n\n    Dfp x = one;\n    Dfp y = one;\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(a);\n        x = x.divide(fact);\n        y = y.add(x);\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n        fact = fact.multiply((i-1)*i);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getField().getOne();\n    Dfp term = a;\n    int n = 1;\n\n    while (true) {\n        result = result.add(term);\n        if (term.equals(a.getField().getZero())) {\n            break;\n        }\n        term = term.multiply(a).divide(new Dfp(n++));\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getField().getOne();\n    Dfp term = a;\n    int n = 1;\n\n    while (true) \n    {\n        result = result.add(term);\n        term = term.multiply(a).divide(n++);\n        if (term.equals(Dfp.getZero())) \n        {\n            break;\n        }\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getField().getOne();\n    Dfp term = a;\n    Dfp factorial = a.getField().getOne();\n\n    for (int i = 1; i < 100; i++) \n    {\n        result = result.add(term);\n        term = term.multiply(a).divide(factorial);\n        factorial = factorial.multiply(new Dfp(i+1));\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getField().getOne();\n    Dfp term = a;\n    int n = 1;\n\n    while (n < 90) \n    {\n        result = result.add(term);\n        term = term.multiply(a).divide(n++);\n    }\n\n    return result;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp result = a.getOne();\n    Dfp term = a;\n\n    for (int i = 2; i < 90; i++) {\n        term = term.multiply(a).divide(i);\n        result = result.add(term);\n    }\n\n    return result;\n}"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (FastMath.abs(x.getReal()) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(y.getReal() * y.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>((T) new RealFieldElement<T>(0), (T) new RealFieldElement<T>(inverse * z.getReal()), (T) new RealFieldElement<T>(-inverse * y.getReal()));\n    } \n    else if (FastMath.abs(y.getReal()) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>((T) new RealFieldElement<T>(-inverse * z.getReal()), (T) new RealFieldElement<T>(0), (T) new RealFieldElement<T>(inverse * x.getReal()));\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal());\n    return new FieldVector3D<T>((T) new RealFieldElement<T>(inverse * y.getReal()), (T) new RealFieldElement<T>(-inverse * x.getReal()), (T) new RealFieldElement<T>(0));\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    T[] instanceArray = this.toArray();\n    T x = instanceArray[0];\n    T y = instanceArray[1];\n    T z = instanceArray[2];\n\n    T norm = getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    T inverseNorm = norm.reciprocal();\n    T xOrtho = y.multiply(inverseNorm).multiply(z);\n    T yOrtho = x.multiply(inverseNorm).multiply(z);\n    T zOrtho = x.multiply(inverseNorm).multiply(y);\n\n    return new FieldVector3D<T>(xOrtho, yOrtho, zOrtho);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    T norm = getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n    if (x.getReal() != 0) {\n        return new FieldVector3D<T>(y.divide(norm), z.divide(norm));\n    } else if (y.getReal() != 0) {\n        return new FieldVector3D<T>(x.divide(norm), z.divide(norm));\n    } else {\n        return new FieldVector3D<T>(x.divide(norm), y.divide(norm));\n    }\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getReal() * y.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>((T) new RealFieldElement<T>(0), (T) new RealFieldElement<T>(inverse * z.getReal()), (T) new RealFieldElement<T>(-inverse * y.getReal()));\n    } else if (FastMath.abs(y.getReal()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<T>((T) new RealFieldElement<T>(-inverse * z.getReal()), (T) new RealFieldElement<T>(0), (T) new RealFieldElement<T>(inverse * x.getReal()));\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal());\n    return new FieldVector3D<T>((T) new RealFieldElement<T>(inverse * y.getReal()), (T) new RealFieldElement<T>(-inverse * x.getReal()), (T) new RealFieldElement<T>(0));\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (FastMath.abs(x.getReal()) <= threshold) {\n        T inverse  = (T) y.getNorm().reciprocal();\n        return new FieldVector3D<>(0, inverse.multiply(z), -inverse.multiply(y));\n    } else if (FastMath.abs(y.getReal()) <= threshold) {\n        T inverse  = (T) x.getNorm().reciprocal();\n        return new FieldVector3D<>(-inverse.multiply(z), 0, inverse.multiply(x));\n    }\n    T inverse  = (T) x.getNorm().reciprocal();\n    return new FieldVector3D<>(inverse.multiply(y), -inverse.multiply(x), 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (FastMath.abs(x.getReal()) <= threshold) {\n        T inverse  = T.ONE.divide(FastMath.sqrt(y.getReal() * y.getReal() + z.getReal() * z.getReal()));\n        return new FieldVector3D<>(T.ZERO, inverse.multiply(z), inverse.multiply(y));\n    } else if (FastMath.abs(y.getReal()) <= threshold) {\n        T inverse  = T.ONE.divide(FastMath.sqrt(x.getReal() * x.getReal() + z.getReal() * z.getReal()));\n        return new FieldVector3D<>(inverse.multiply(z), T.ZERO, inverse.multiply(x));\n    }\n    T inverse  = T.ONE.divide(FastMath.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal()));\n    return new FieldVector3D<>(inverse.multiply(y), inverse.multiply(x), T.ZERO);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (FastMath.abs(x.getReal()) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(y.getReal() * y.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<>(new T(0, 0), new T(inverse * z.getReal(), 0), new T(-inverse * y.getReal(), 0));\n    } \n    else if (FastMath.abs(y.getReal()) <= threshold) \n    {\n        double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<>(new T(-inverse * z.getReal(), 0), new T(0, 0), new T(inverse * x.getReal(), 0));\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal());\n    return new FieldVector3D<>(new T(inverse * y.getReal(), 0), new T(-inverse * x.getReal(), 0), new T(0, 0));\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    T norm = getNorm();\n    if (norm.getReal() == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (Math.abs(x.getReal()) <= norm.getReal()) {\n        double inverse  = 1 / Math.sqrt(y.getReal() * y.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<>(0, norm.multiply(z).multiply(inverse), -norm.multiply(y).multiply(inverse));\n    } else if (Math.abs(y.getReal()) <= norm.getReal()) {\n        double inverse  = 1 / Math.sqrt(x.getReal() * x.getReal() + z.getReal() * z.getReal());\n        return new FieldVector3D<>(-norm.multiply(z).multiply(inverse), 0, norm.multiply(x).multiply(inverse));\n    }\n    double inverse  = 1 / Math.sqrt(x.getReal() * x.getReal() + y.getReal() * y.getReal());\n    return new FieldVector3D<>(norm.multiply(y).multiply(inverse), -norm.multiply(x).multiply(inverse), 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    if (FastMath.abs(x.getReal()) <= threshold) {\n        T inverse  = (T) y.getNorm().reciprocal();\n        return new FieldVector3D<>(0, inverse.multiply(z), -inverse.multiply(y));\n    } else if (FastMath.abs(y.getReal()) <= threshold) {\n        T inverse  = (T) x.getNorm().reciprocal();\n        return new FieldVector3D<>(-inverse.multiply(z), 0, inverse.multiply(x));\n    }\n    T inverse  = (T) x.getNorm().reciprocal();\n    return new FieldVector3D<>(inverse.multiply(y), -inverse.multiply(x), 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    T threshold = getNorm().multiply(0.6);\n    if (threshold.isZero()) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (getX().abs().compareTo(threshold) <= 0) {\n        T inverse  = getY().multiply(getY()).add(getZ().multiply(getZ())).sqrt().reciprocal();\n        return new FieldVector3D<>(0, inverse.multiply(getZ()), -inverse.multiply(getY()));\n    } else if (getY().abs().compareTo(threshold) <= 0) {\n        T inverse  = getX().multiply(getX()).add(getZ().multiply(getZ())).sqrt().reciprocal();\n        return new FieldVector3D<>(-inverse.multiply(getZ()), 0, inverse.multiply(getX()));\n    }\n    T inverse  = getX().multiply(getX()).add(getY().multiply(getY())).sqrt().reciprocal();\n    return new FieldVector3D<>(inverse.multiply(getY()), -inverse.multiply(getX()), 0);\n}"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null || !isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"The other range does not overlap this range\");\n    }\n    T newMinimum = maximum;\n    T newMaximum = minimum;\n    if (other.getMinimum().compareTo(minimum) > 0) \n    {\n        newMinimum = other.getMinimum();\n    }\n    if (other.getMaximum().compareTo(maximum) < 0) \n    {\n        newMaximum = other.getMaximum();\n    }\n    return new Range<>(newMinimum, newMaximum, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null || !isOverlappedBy(other))\n    {\n        throw new IllegalArgumentException(\"The range does not overlap with the given range.\");\n    }\n\n    T newMinimum = maximum;\n    T newMaximum = minimum;\n\n    if (other.getMinimum().compareTo(minimum) > 0) \n    {\n        newMinimum = other.getMinimum();\n    }\n\n    if (other.getMaximum().compareTo(maximum) < 0) \n    {\n        newMaximum = other.getMaximum();\n    }\n\n    return new Range<>(newMinimum, newMaximum, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null || !isOverlappedBy(other))\n    {\n        throw new IllegalArgumentException(\"The other range must overlap this range\");\n    }\n\n    T newMinimum = maximum;\n    T newMaximum = minimum;\n\n    if (other.getMinimum().compareTo(minimum) > 0)\n    {\n        newMinimum = other.getMinimum();\n    }\n\n    if (other.getMaximum().compareTo(maximum) < 0)\n    {\n        newMaximum = other.getMaximum();\n    }\n\n    return new Range<T>(newMinimum, newMaximum, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Other range does not overlap this range\");\n    }\n    T min = maximum(getMinimum(), other.getMinimum());\n    T max = minimum(getMaximum(), other.getMaximum());\n    return Range.between(min, max, getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"The ranges do not overlap\");\n    }\n    T min = maximum;\n    T max = minimum;\n    if (other.getMinimum().compareTo(minimum) > 0) \n    {\n        min = other.getMinimum();\n    }\n    if (other.getMaximum().compareTo(maximum) < 0) \n    {\n        max = other.getMaximum();\n    }\n    return Range.between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null || !isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"The range is not overlapped by the specified range\");\n    }\n    T min = maximum;\n    T max = minimum;\n    if (other.getMinimum().compareTo(minimum) > 0) {\n        min = other.getMinimum();\n    }\n    if (other.getMaximum().compareTo(maximum) < 0) {\n        max = other.getMaximum();\n    }\n    return Range.between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null || !isOverlappedBy(other)) \n    {\n        throw new IllegalArgumentException(\"The other range does not overlap with this range\");\n    }\n\n    T newMinimum = maximum;\n    T newMaximum = minimum;\n\n    if (other.getMinimum().compareTo(minimum) > 0) \n    {\n        newMinimum = other.getMinimum();\n    }\n\n    if (other.getMaximum().compareTo(maximum) < 0) \n    {\n        newMaximum = other.getMaximum();\n    }\n\n    return Range.between(newMinimum, newMaximum, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"The range is not overlapped by the specified range.\");\n    }\n    T min = maximum;\n    T max = minimum;\n    if (other.getMinimum().compareTo(minimum) > 0) {\n        min = other.getMinimum();\n    }\n    if (other.getMaximum().compareTo(maximum) < 0) {\n        max = other.getMaximum();\n    }\n    return Range.between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null || !isOverlappedBy(other))\n    {\n        throw new IllegalArgumentException(\"The range does not overlap with the given range.\");\n    }\n\n    T newMinimum = maximum;\n    T newMaximum = minimum;\n\n    if (other.getMinimum().compareTo(minimum) > 0) \n    {\n        newMinimum = other.getMinimum();\n    }\n\n    if (other.getMaximum().compareTo(maximum) < 0) \n    {\n        newMaximum = other.getMaximum();\n    }\n\n    return Range.between(newMinimum, newMaximum, getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"The range does not overlap with the specified range.\");\n    }\n    T min = maximum;\n    T max = minimum;\n    if (other.getMinimum().compareTo(minimum) > 0) {\n        min = other.getMinimum();\n    }\n    if (other.getMaximum().compareTo(maximum) < 0) {\n        max = other.getMaximum();\n    }\n    return Range.between(min, max, comparator);\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    Writer writer = new OutputStreamWriter(out, StandardCharsets.UTF_8);\n    return new WriterBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, writer);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    Writer writer = new OutputStreamWriter(out, StandardCharsets.UTF_8);\n    return new WriterBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, writer);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, new OutputStreamWriter(out, \"UTF-8\"));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, new OutputStreamWriter(out, StandardCharsets.UTF_8));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    Writer writer = new OutputStreamWriter(out, StandardCharsets.UTF_8);\n    return new WriterBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, writer);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new OutputStreamBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec,\n            new OutputStreamWriter(out, StandardCharsets.UTF_8));\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new OutputStreamBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    Writer writer = new OutputStreamWriter(out, StandardCharsets.UTF_8);\n    return new WriterBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, writer);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    WriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, new OutputStreamWriter(out, StandardCharsets.UTF_8));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new OutputStreamBasedJsonGenerator(ctxt, _generatorFeatures, _objectCodec, out, JsonEncoding.UTF8);\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) \n    {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) \n    {\n        return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) \n    {\n        return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) \n    {\n        return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) \n    {\n        return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) \n    {\n        return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) \n    {\n        return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) \n    {\n        return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) \n    {\n        return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) \n    {\n        return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) \n    {\n        return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    }\n    return type;\n}"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) \n    {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) \n    {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) \n    {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) \n    {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n\n    if (!match(JsDocToken.IDENT, \"function\")) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.function\");\n    }\n    next();\n\n    // Parse TypeParameters\n    if (match(JsDocToken.LT)) {\n        Node typeParameters = parseTypeExpressionList(next());\n        functionType.addChildToBack(typeParameters);\n    }\n\n    // Skip '('\n    if (!match(JsDocToken.LP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n\n    // Parse 'this'\n    if (!match(JsDocToken.IDENT, \"this\")) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n\n    // Skip ':'\n    if (!match(JsDocToken.COLON)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n\n    // Parse TypeName\n    Node typeName = parseTypeName(next());\n    if (typeName == null) {\n        return null;\n    }\n    functionType.addChildToBack(typeName);\n\n    // Skip ','\n    if (!match(JsDocToken.COMMA)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n    }\n    next();\n\n    // Parse ParametersType\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n        return null;\n    }\n    functionType.addChildToBack(parametersType);\n\n    // Skip ')'\n    if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n\n    // Parse ResultType\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n        return null;\n    }\n    functionType.addChildToBack(resultType);\n\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    if (!match(JsDocToken.IDENT, \"function\")) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.expected.function\");\n    }\n    next();\n\n    // Skip over the 'function' keyword.\n    skipEOLs();\n    token = next();\n\n    // Parse the type parameters.\n    if (match(JsDocToken.LT)) {\n      Node typeParameters = parseTypeExpressionList(token);\n      if (typeParameters == null) {\n        return null;\n      }\n      functionType.addChildToBack(typeParameters);\n    }\n\n    // Skip over the '<' or '('\n    skipEOLs();\n    token = next();\n\n    // Parse the 'this' parameter.\n    if (!match(JsDocToken.IDENT, \"this\")) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.expected.this\");\n    }\n    next();\n\n    // Skip over the ':'\n    skipEOLs();\n    token = next();\n\n    // Parse the type name.\n    Node typeName = parseTypeName(token);\n    if (typeName == null) {\n      return null;\n    }\n    functionType.addChildToBack(typeName);\n\n    // Skip over the ':'\n    skipEOLs();\n    token = next();\n\n    // Parse the parameters type.\n    Node parametersType = parseParametersType(token);\n    if (parametersType == null) {\n      return null;\n    }\n    functionType.addChildToBack(parametersType);\n\n    // Skip over the ')'\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n\n    // Parse the result type.\n    Node resultType = parseResultType(token);\n    if (resultType != null) {\n      functionType.addChildToBack(resultType);\n    }\n\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n\n    if (!match(JsDocToken.IDENT, \"function\")) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.expected.function\");\n    }\n    next();\n\n    // Skip over the 'function' keyword.\n    skipEOLs();\n    token = next();\n\n    // Parse the function signature type.\n    Node signatureType = parseFunctionSignatureType(token);\n    if (signatureType == null) {\n      return null;\n    }\n\n    functionType.addChildToBack(signatureType);\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    token = next();\n\n    if (token == JsDocToken.IDENT && match(\"this\")) {\n        next();\n        skipEOLs();\n        token = next();\n        if (token != JsDocToken.COLON) {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n        }\n        next();\n        skipEOLs();\n        Node typeName = parseTypeName(next());\n        if (typeName == null) {\n            return null;\n        }\n        functionType.addChildToFront(typeName);\n\n        token = next();\n    }\n\n    if (token != JsDocToken.LP) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n        return null;\n    }\n    functionType.addChildToFront(parametersType);\n\n    token = next();\n    if (token != JsDocToken.GT) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n    }\n    next();\n\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n        return null;\n    }\n    functionType.addChildToFront(resultType);\n\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n\n    if (!match(JsDocToken.IDENT, \"function\")) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.function\");\n    }\n    next();\n\n    // Parse type parameters\n    Node typeParameters = parseTypeParameters();\n    if (typeParameters != null) {\n      functionType.addChildToBack(typeParameters);\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n\n    // Parse 'this' type\n    if (!match(JsDocToken.IDENT, \"this\")) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n\n    Node thisType = parseTypeExpression(next());\n    if (thisType == null) {\n      return null;\n    }\n    functionType.addChildToBack(thisType);\n\n    // Parse parameters type\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n      return null;\n    }\n    functionType.addChildToBack(parametersType);\n\n    // Parse result type\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    }\n    functionType.addChildToBack(resultType);\n\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    if (!match(JsDocToken.IDENTIFIER, \"function\")) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.function\");\n    }\n    next();\n\n    // TypeParameters\n    if (match(JsDocToken.LT)) {\n      Node typeParameters = parseTypeExpressionList(next());\n      if (typeParameters != null) {\n        functionType.addChildToFront(typeParameters);\n      } else {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.type.parameters\");\n      }\n    }\n\n    // '('\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n\n    // 'this' ':' TypeName\n    if (!match(JsDocToken.IDENTIFIER, \"this\")) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n\n    Node typeName = parseTypeExpression(next());\n    if (typeName == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.type.name\");\n    }\n    functionType.addChildToFront(typeName);\n\n    // ParametersType\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.parameters.type\");\n    }\n    functionType.addChildToFront(parametersType);\n\n    // ')'\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n\n    // ResultType\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.result.type\");\n    }\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    if (!match(JsDocToken.IDENT, \"function\")) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.function\");\n    }\n    next();\n\n    // TypeParameters\n    if (match(JsDocToken.LT)) {\n        Node typeParameters = parseTypeExpressionList(next());\n        if (typeParameters != null) {\n            functionType.addChildToBack(typeParameters);\n        } else {\n            return null;\n        }\n    }\n\n    // '('\n    if (!match(JsDocToken.LP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n\n    // 'this' ':' TypeName\n    if (!match(JsDocToken.IDENT, \"this\")) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n    if (!match(JsDocToken.COLON)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    Node typeName = parseTypeExpression(next());\n    if (typeName == null) {\n        return null;\n    }\n    functionType.addChildToBack(typeName);\n\n    // ParametersType\n    Node parametersType = parseParametersType(next());\n    if (parametersType != null) {\n        functionType.addChildToBack(parametersType);\n    } else {\n        return null;\n    }\n\n    // ')'\n    if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n\n    // ResultType\n    Node resultType = parseResultType(next());\n    if (resultType != null) {\n        functionType.addChildToBack(resultType);\n    } else {\n        return null;\n    }\n\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n\n    if (!match(JsDocToken.IDENT, \"function\")) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.function\");\n    }\n    next();\n\n    // Parse type parameters\n    if (match(JsDocToken.LT)) {\n      Node typeParameters = parseTypeExpressionList(next());\n      if (typeParameters != null) {\n        functionType.addChildToFront(typeParameters);\n      } else {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.type.parameters\");\n      }\n    }\n\n    // Parse '('\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n\n    // Parse 'this'\n    if (!match(JsDocToken.IDENT, \"this\")) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n\n    // Parse ':'\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n\n    // Parse TypeName\n    Node typeName = parseTypeName(next());\n    if (typeName == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.type.name\");\n    }\n    functionType.addChildToBack(typeName);\n\n    // Parse ParametersType\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.parameters.type\");\n    }\n    functionType.addChildToBack(parametersType);\n\n    // Parse ResultType\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.invalid.result.type\");\n    }\n    functionType.addChildToBack(resultType);\n\n    // Parse ')'\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n\n    if (!match(JsDocToken.IDENT, \"function\")) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.function\");\n    }\n    next();\n\n    if (match(JsDocToken.LT)) \n    {\n        next();\n        Node typeParameters = parseTypeExpressionList(next());\n        if (typeParameters != null) \n        {\n            functionType.addChildToFront(typeParameters);\n        } \n        else \n        {\n            return reportGenericTypeSyntaxWarning();\n        }\n\n        skipEOLs();\n        if (!match(JsDocToken.GT)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n        next();\n    }\n\n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n\n    if (!match(JsDocToken.IDENT, \"this\")) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n\n    if (!match(JsDocToken.COLON)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n\n    Node thisType = parseTypeExpression(next());\n    if (thisType == null) \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n    functionType.addChildToBack(thisType);\n\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n    functionType.addChildToBack(parametersType);\n\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n\n    Node resultType = parseResultType(next());\n    if (resultType == null) \n    {\n}\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    if (!match(JsDocToken.IDENT, \"function\")) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.function\");\n    }\n    next();\n\n    if (match(JsDocToken.LT)) \n    {\n        next();\n        Node typeParameters = parseTypeExpressionList(next());\n        if (typeParameters != null) \n        {\n            functionType.addChildToFront(typeParameters);\n        }\n\n        skipEOLs();\n        if (!match(JsDocToken.GT)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n        next();\n    }\n\n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n\n    if (!match(JsDocToken.IDENT, \"this\")) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n\n    if (!match(JsDocToken.COLON)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n\n    Node typeName = parseTypeExpression(next());\n    if (typeName == null) \n    {\n        return null;\n    }\n    functionType.addChildToFront(typeName);\n\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) \n    {\n        return null;\n    }\n    functionType.addChildToFront(parametersType);\n\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n\n    Node resultType = parseResultType(next());\n    if (resultType != null) \n    {\n        functionType.addChildToFront(resultType);\n    }\n\n    return functionType;\n}"
    ],
    [
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final StringBuilder out = new StringBuilder(len);\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final StringBuilder out = new StringBuilder(len);\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final StringBuilder out = new StringBuilder(len);\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final StringBuilder out = new StringBuilder(len);\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final StringBuilder out = new StringBuilder(len);\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final StringBuilder out = new StringBuilder(len);\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final StringBuilder out = new StringBuilder(len);\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final StringBuilder out = new StringBuilder(len);\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final StringBuilder out = new StringBuilder(len);\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    final StringBuilder out = new StringBuilder(len);\n    for (int i = 0; i < len; i++) {\n        final char c = str.charAt(i);\n        if (!Character.isWhitespace(c)) {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    long n = 0;\n    double sum = 0.0;\n    double sumsq = 0.0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n\n    for (SummaryStatistics stat : statistics) {\n        n += stat.getN();\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n    }\n\n    double mean = sum / n;\n    double variance = (sumsq / n) - (mean * mean);\n    double stdDev = Math.sqrt(variance);\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    long n = 0;\n    double sum = 0.0;\n    double sumsq = 0.0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n\n    for (SummaryStatistics stat : statistics) {\n        n += stat.getN();\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n    }\n\n    double mean = n > 0 ? sum / n : Double.NaN;\n    double variance = n > 1 ? (sumsq / n - mean * mean) : Double.NaN;\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0;\n    double sumsq = 0;\n    long n = 0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        n += stat.getN();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n    }\n\n    double mean = sum / n;\n    double variance = (sumsq / n) - (mean * mean);\n    double stdDev = Math.sqrt(variance);\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    long n = 0;\n    double sum = 0.0;\n    double sumsq = 0.0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n\n    for (SummaryStatistics stat : statistics) {\n        n += stat.getN();\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n    }\n\n    double mean = n > 0 ? sum / n : 0.0;\n    double variance = n > 1 ? (sumsq - n * mean * mean) / (n - 1) : 0.0;\n    double stdDev = Math.sqrt(variance);\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0.0;\n    double sumsq = 0.0;\n    double min = Double.MAX_VALUE;\n    double max = Double.MIN_VALUE;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n        n += stat.getN();\n    }\n\n    double mean = sum / n;\n    double variance = (sumsq / n) - (mean * mean);\n    double stdDev = Math.sqrt(variance);\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0.0;\n    double sumsq = 0.0;\n    long n = 0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        n += stat.getN();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n    }\n\n    double mean = sum / n;\n    double variance = (sumsq / n) - (mean * mean);\n    double stdDev = Math.sqrt(variance);\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0;\n    double sumsq = 0;\n    long n = 0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        n += stat.getN();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n    }\n\n    double mean = sum / n;\n    double variance = (sumsq / n) - (mean * mean);\n    double stdDev = Math.sqrt(variance);\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    long n = 0;\n    double sum = 0.0;\n    double sumsq = 0.0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n\n    for (SummaryStatistics stat : statistics) {\n        n += stat.getN();\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n    }\n\n    double mean = sum / n;\n    double variance = (sumsq / n) - (mean * mean);\n    double stdDev = Math.sqrt(variance);\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    long n = 0;\n    double sum = 0.0;\n    double sumsq = 0.0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n\n    for (SummaryStatistics stat : statistics) {\n        n += stat.getN();\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n    }\n\n    double mean = n > 0 ? sum / n : Double.NaN;\n    double variance = n > 1 ? (sumsq - n * mean * mean) / (n - 1) : Double.NaN;\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    double sum = 0;\n    double sumsq = 0;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    long n = 0;\n\n    for (SummaryStatistics stat : statistics) {\n        sum += stat.getSum();\n        sumsq += stat.getSumsq();\n        min = Math.min(min, stat.getMin());\n        max = Math.max(max, stat.getMax());\n        n += stat.getN();\n    }\n\n    double mean = sum / n;\n    double variance = (sumsq / n) - (mean * mean);\n    double stdDev = Math.sqrt(variance);\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double sum = 0;\n        for (int i = 0; i < n; i++) {\n            double diff = sample1[i] - sample2[i] - meanDifference;\n            sum += diff * diff;\n        }\n        return sum / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 0) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 0) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 0) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 0) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 1) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 0) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 0) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n <= 0) {\n            throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_DIMENSION, n, 2);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            result += Math.pow(sample1[i] - sample2[i] - meanDifference, 2);\n        }\n        return result / (n - 1);\n    }"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    Iterator iterator = dataset.getKeys().iterator();\n    while (iterator.hasNext()) \n    {\n        Number value = (Number) dataset.getValue(iterator.next());\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double total = 0.0;\n    for (Comparable key : dataset.getKeys()) \n    {\n        Number value = dataset.getValue(key);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    Iterator iterator = dataset.keys();\n    while (iterator.hasNext()) \n    {\n        Number value = (Number) dataset.getValue(iterator.next());\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    for (Comparable key : dataset.getKeys()) {\n        Number value = dataset.getValue(key);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double total = 0.0;\n    for (Comparable key : dataset.getKeys()) \n    {\n        Number value = dataset.getValue(key);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    Iterator iterator = dataset.keys().iterator();\n    while (iterator.hasNext()) \n    {\n        Number value = (Number) dataset.getValue(iterator.next());\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double total = 0.0;\n    for (Comparable key : dataset.getKeys()) \n    {\n        Number value = dataset.getValue(key);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double total = 0.0;\n    for (Comparable key : dataset.getKeys()) {\n        Number value = dataset.getValue(key);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n\n    double total = 0.0;\n    for (Comparable key : dataset.getKeys()) \n    {\n        Number value = dataset.getValue(key);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    Iterator iterator = dataset.getKeys().iterator();\n    while (iterator.hasNext()) {\n        Number value = (Number) dataset.getValue(iterator.next());\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a property name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a property name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a property name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a property name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a property name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED_NAME) {\n      result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n      result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n      result = nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n      result = peekedString;\n      peekedString = null;\n    } else {\n      throw new IllegalStateException(\"Expected a property name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n            if (read != -1) {\n                uncompressedBytesRemaining -= read;\n            }\n            return read;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n            uncompressedBytesRemaining -= read;\n            return read;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n            uncompressedBytesRemaining -= read;\n            if (uncompressedBytesRemaining == 0) {\n                inUncompressedChunk = false;\n            }\n            return read;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n            if (read != -1) {\n                uncompressedBytesRemaining -= read;\n            }\n            return read;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n            uncompressedBytesRemaining -= read;\n            return read;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n            uncompressedBytesRemaining -= read;\n            if (uncompressedBytesRemaining == 0) {\n                inUncompressedChunk = false;\n            }\n            return read;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n            if (read != -1) {\n                uncompressedBytesRemaining -= read;\n            }\n            return read;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n            uncompressedBytesRemaining -= read;\n            if (uncompressedBytesRemaining == 0) {\n                inUncompressedChunk = false;\n            }\n            return read;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n            uncompressedBytesRemaining -= read;\n            if (uncompressedBytesRemaining == 0) {\n                inUncompressedChunk = false;\n            }\n            return read;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n        if (inUncompressedChunk) {\n            int read = in.read(b, off, Math.min(len, uncompressedBytesRemaining));\n            uncompressedBytesRemaining -= read;\n            return read;\n        } else if (currentCompressedChunk != null) {\n            return currentCompressedChunk.read(b, off, len);\n        }\n        return -1;\n    }"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (NodeUtil.isCallOrNew(node)) \n    {\n        return NodeUtil.getArgumentForCallOrNew(node, argIndex);\n    } \n    else if (NodeUtil.isDotOrBracket(node)) \n    {\n        Node parent = node.getParent();\n        if (parent != null && parent.isCall() && parent.getFirstChild() == node) \n        {\n            return NodeUtil.getArgumentForCallOrNew(parent, argIndex);\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (NodeUtil.isCallOrNew(node)) {\n        return NodeUtil.getArgumentForCallOrNew(node, argIndex);\n    } else if (NodeUtil.isDot(node)) {\n        Node parent = node.getParent();\n        if (parent != null && NodeUtil.isCallOrNew(parent)) {\n            return NodeUtil.getArgumentForCallOrNew(parent, argIndex);\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (NodeUtil.isCallOrNew(node)) {\n      return NodeUtil.getArgumentForCallOrNew(node, argIndex);\n    } else if (NodeUtil.isDotCall(node)) {\n      Node parent = node.getParent();\n      if (parent != null && parent.isGetterDef() && argIndex == 0) {\n        return node;\n      }\n    }\n    return null;\n  }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n        Node node = site.node;\n        if (NodeUtil.isCallOrNew(node)) {\n            return NodeUtil.getArgumentForCallOrNew(node, argIndex);\n        } else if (NodeUtil.isDotCall(node)) {\n            Node receiver = node.getFirstChild();\n            Node prop = receiver.getLastChild();\n            if (prop.isString() && \"arguments\".equals(prop.getString())) {\n                return NodeUtil.getArgumentForCallOrNew(receiver, argIndex);\n            }\n        }\n        return null;\n    }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (node.isCall() || node.isNew()) {\n        return getArgumentForCallOrNew(node, argIndex);\n    } else if (node.isDot()) {\n        Node parent = node.getParent();\n        if (parent != null && parent.isCall() && parent.getFirstChild() == node) {\n            Node afterParent = parent.getNext();\n            if (afterParent != null && afterParent.isString() &&\n                    afterParent.getString().equals(\"call\")) {\n                return getArgumentForCallOrNew(parent, argIndex);\n            }\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (NodeUtil.isCallOrNew(node)) {\n        return NodeUtil.getArgumentForCallOrNew(node, argIndex);\n    } else if (NodeUtil.isDot(node)) {\n        Node parent = node.getParent();\n        if (parent != null && parent.isCall()) {\n            Node grandParent = parent.getParent();\n            if (grandParent != null && grandParent.isDot()) {\n                return NodeUtil.getArgumentForCallOrNew(grandParent, argIndex);\n            }\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (node.isCall() || node.isNew()) {\n        return NodeUtil.getArgumentForCallOrNew(node, argIndex);\n    } else if (node.isDot()) {\n        Node parent = node.getParent();\n        if (parent != null && parent.isCall() && parent.getFirstChild() == node) {\n            Node call = parent;\n            Node prop = node.getLastChild();\n            if (prop.isString()) {\n                String propName = prop.getString();\n                if (\"call\".equals(propName) || \"apply\".equals(propName)) {\n                    return NodeUtil.getArgumentForCallOrNew(call, argIndex);\n                }\n            }\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (node.isCall() || node.isNew()) {\n        return getArgumentForCallOrNew(node, argIndex);\n    } else if (node.isDot()) {\n        Node receiver = node.getFirstChild();\n        Node prop = node.getLastChild();\n        if (prop.isString() && \"call\".equals(prop.getString())) {\n            return getArgumentForCallOrNew(receiver, argIndex);\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (node.isCall() || node.isNew()) {\n        return NodeUtil.getArgumentForCallOrNew(node, argIndex);\n    } else if (node.isDot()) {\n        Node parent = node.getParent();\n        if (parent != null && parent.isCall() && parent.getFirstChild() == node) {\n            Node arg = NodeUtil.getArgumentForCallOrNew(parent, argIndex);\n            if (arg != null && arg.isDot()) {\n                return arg;\n            }\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node node = site.node;\n    if (node.isCall() || node.isNew()) {\n        return NodeUtil.getArgumentForCallOrNew(node, argIndex);\n    } else if (node.isDot()) {\n        Node parent = node.getParent();\n        if (parent != null && parent.isCall() && parent.getFirstChild() == node) {\n            Node function = parent.getFirstChild().getNext();\n            return NodeUtil.getArgumentForFunction(function, argIndex);\n        }\n    }\n    return null;\n}"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n        if (info.getDeprecationReason() != null) \n        {\n            return info.getDeprecationReason();\n        }\n        return \"\";\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    return null;\n  }",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n        if (info.getDeprecationReason() != null) \n        {\n            return info.getDeprecationReason();\n        }\n\n        return \"\";\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n        if (info.getDeprecationReason() != null) \n        {\n            return info.getDeprecationReason();\n        }\n        return \"\";\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    return null;\n}"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String display = cTimeZoneDisplayCache.get(key);\n    if (display == null) {\n        display = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, display);\n    }\n    return display;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String display = cTimeZoneDisplayCache.get(key);\n    if (display == null) \n    {\n        display = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, display);\n    }\n    return display;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String display = cTimeZoneDisplayCache.get(key);\n    if (display == null) {\n        display = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, display);\n    }\n    return display;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String display = cTimeZoneDisplayCache.get(key);\n    if (display == null) \n    {\n        display = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, display);\n    }\n    return display;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String display = cTimeZoneDisplayCache.get(key);\n    if (display == null) {\n        display = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, display);\n    }\n    return display;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String display = cTimeZoneDisplayCache.get(key);\n    if (display == null) {\n        display = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, display);\n    }\n    return display;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String display = cTimeZoneDisplayCache.get(key);\n    if (display == null) {\n        display = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, display);\n    }\n    return display;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String display = cTimeZoneDisplayCache.get(key);\n    if (display == null) {\n        display = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, display);\n    }\n    return display;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String display = cTimeZoneDisplayCache.get(key);\n    if (display == null) {\n        display = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.put(key, display);\n    }\n    return display;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String display = cTimeZoneDisplayCache.get(key);\n    if (display == null) {\n        display = tz.getDisplayName(daylight, style, locale);\n        cTimeZoneDisplayCache.putIfAbsent(key, display);\n    }\n    return display;\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    return this.underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if(key == null)\n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int index = underlying.getColumnIndex(key);\n    if(index >= firstCategoryIndex && index < lastCategoryIndex())\n    {\n        return index - firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int index = underlying.getColumnIndex(key);\n    if (index >= firstCategoryIndex && index < lastCategoryIndex()) \n    {\n        return index - firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n    if(key == null)\n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if(key == null)\n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.underlying.getColumnIndex(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if(key == null)\n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int index = underlying.getColumnIndex(key);\n    if(index >= firstCategoryIndex && index < lastCategoryIndex())\n    {\n        return index - firstCategoryIndex;\n    }\n    return -1;\n}",
      "public int getColumnIndex(Comparable key)  {\n        if(key == null) {\n            throw new IllegalArgumentException(\"Null 'key' argument.\");\n        }\n        List<Comparable> keys = getColumnKeys();\n        for(int i=0; i<keys.size(); i++) {\n            if(keys.get(i).equals(key)) {\n                return i;\n            }\n        }\n        return -1;\n    }",
      "public int getColumnIndex(Comparable key)  {\n    return this.underlying.getColumnIndex(key);\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < getLower() - tolerance || point > getUpper() + tolerance) \n    {\n        return Location.OUTSIDE;\n    } \n    else if (point < getLower() + tolerance || point > getUpper() - tolerance) \n    {\n        return Location.BOUNDARY;\n    } \n    else \n    {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < getLower() - tolerance || point > getUpper() + tolerance)\n        return Location.OUTSIDE;\n    else if (point > getLower() - tolerance && point < getLower() + tolerance)\n        return Location.BOUNDARY;\n    else if (point < getUpper() + tolerance && point > getUpper() - tolerance)\n        return Location.BOUNDARY;\n    else\n        return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < (getLower() - tolerance) || point > (getUpper() + tolerance)) \n    {\n        return Location.OUTSIDE;\n    }\n    else if (point < (getLower() + tolerance) || point > (getUpper() - tolerance)) \n    {\n        return Location.BOUNDARY;\n    }\n    else \n    {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < getLower() - tolerance || point > getUpper() + tolerance)\n    {\n        return Location.OUTSIDE;\n    }\n    else if (point > getLower() - tolerance && point < getLower() + tolerance || \n             point < getUpper() - tolerance && point > getUpper() + tolerance)\n    {\n        return Location.BOUNDARY;\n    }\n    else\n    {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < (getLower() - tolerance) || point > (getUpper() + tolerance)) \n    {\n        return Location.OUTSIDE;\n    }\n    else if (point > (getLower() - tolerance) && point < (getUpper() + tolerance)) \n    {\n        return Location.INSIDE;\n    }\n    else \n    {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < (getLower() - tolerance) || point > (getUpper() + tolerance)) \n    {\n        return Location.OUTSIDE;\n    }\n    else if (point > (getLower() - tolerance) && point < (getUpper() + tolerance)) \n    {\n        return Location.INSIDE;\n    }\n    else \n    {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < getLower() - tolerance || point > getUpper() + tolerance) \n    {\n        return Location.OUTSIDE;\n    }\n    else if (point < getLower() + tolerance || point > getUpper() - tolerance) \n    {\n        return Location.BOUNDARY;\n    }\n    else \n    {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if(point < (getLower() - tolerance) || point > (getUpper() + tolerance))\n    {\n        return Location.OUTSIDE;\n    }\n    else if(point > (getLower() - tolerance) && point < (getUpper() + tolerance))\n    {\n        return Location.INSIDE;\n    }\n    else\n    {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if(point < getLower() - tolerance || point > getUpper() + tolerance)\n    {\n        return Location.OUTSIDE;\n    }\n    else if(point > getLower() - tolerance && point < getLower() + tolerance || point < getUpper() - tolerance && point > getUpper() + tolerance)\n    {\n        return Location.BOUNDARY;\n    }\n    else\n    {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < getLower() - tolerance || point > getUpper() + tolerance)\n        return Location.OUTSIDE;\n    else if (point < getLower() + tolerance || point > getUpper() - tolerance)\n        return Location.BOUNDARY;\n    else\n        return Location.INSIDE;\n}"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(0.1, numberFormat, 2));\n    units.add(new NumberTickUnit(0.2, numberFormat, 2));\n    units.add(new NumberTickUnit(0.5, numberFormat, 5));\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(0.1, numberFormat, 2));\n    units.add(new NumberTickUnit(0.2, numberFormat, 2));\n    units.add(new NumberTickUnit(0.5, numberFormat, 5));\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(0.1, numberFormat, 2));\n    units.add(new NumberTickUnit(0.2, numberFormat, 2));\n    units.add(new NumberTickUnit(0.5, numberFormat, 5));\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(0.1, numberFormat, 2));\n    units.add(new NumberTickUnit(0.2, numberFormat, 2));\n    units.add(new NumberTickUnit(0.5, numberFormat, 5));\n    units.add(new NumberTickUnit(1.0, numberFormat, 2));\n    units.add(new NumberTickUnit(2.0, numberFormat, 2));\n    units.add(new NumberTickUnit(5.0, numberFormat, 5));\n    units.add(new NumberTickUnit(10.0, numberFormat, 2));\n    units.add(new NumberTickUnit(20.0, numberFormat, 2));\n    units.add(new NumberTickUnit(50.0, numberFormat, 5));\n    units.add(new NumberTickUnit(100.0, numberFormat, 2));\n    units.add(new NumberTickUnit(200.0, numberFormat, 2));\n    units.add(new NumberTickUnit(500.0, numberFormat, 5));\n    units.add(new NumberTickUnit(1000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(2000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(5000.0, numberFormat, 5));\n    units.add(new NumberTickUnit(10000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(20000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(50000.0, numberFormat, 5));\n    units.add(new NumberTickUnit(100000.0, numberFormat, 2));\n    units.add(new NumberTickUnit(200000.0, numberFormat, 2));\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer minColumn = null;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) \n    {\n        double coefficient = tableau.getEntry(0, i);\n        if (Precision.compareTo(coefficient, minCoefficient, maxUlps) < 0) \n        {\n            minCoefficient = coefficient;\n            minColumn = i;\n        }\n    }\n    return minColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer minColumn = null;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) {\n        final double coefficient = tableau.getEntry(0, i);\n        if (Precision.compareTo(coefficient, minCoefficient, maxUlps) < 0) {\n            minCoefficient = coefficient;\n            minColumn = i;\n        }\n    }\n    return minColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer minColumn = null;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) \n    {\n        final double coefficient = tableau.getEntry(0, i);\n        if (Precision.compareTo(coefficient, minCoefficient, maxUlps) < 0) \n        {\n            minCoefficient = coefficient;\n            minColumn = i;\n        }\n    }\n    return minColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int pivotCol = -1;\n    double minCoefficient = Double.MAX_VALUE;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) \n    {\n        final double coefficient = tableau.getEntry(0, i);\n        if (Precision.compareTo(coefficient, minCoefficient, maxUlps) < 0) \n        {\n            minCoefficient = coefficient;\n            pivotCol = i;\n        }\n    }\n    return pivotCol == -1 ? null : pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer pivotColumn = null;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) \n    {\n        final double coefficient = tableau.getEntry(0, i);\n        if (Precision.compareTo(coefficient, minCoefficient, maxUlps) < 0) \n        {\n            minCoefficient = coefficient;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer minCol = null;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) \n    {\n        final double coefficient = tableau.getEntry(0, i);\n        if (Precision.compareTo(coefficient, minCoefficient, maxUlps) < 0) \n        {\n            minCoefficient = coefficient;\n            minCol = i;\n        }\n    }\n    return minCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer pivotColumn = null;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) \n    {\n        double coefficient = tableau.getEntry(0, i);\n        if (coefficient < minCoefficient) \n        {\n            minCoefficient = coefficient;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer minCol = null;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) \n    {\n        final double coefficient = tableau.getEntry(0, i);\n        if (Precision.compareTo(coefficient, minCoefficient, maxUlps) < 0) \n        {\n            minCoefficient = coefficient;\n            minCol = i;\n        }\n    }\n    return minCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer minColumn = null;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) {\n        final double coefficient = tableau.getEntry(0, i);\n        if (Precision.compareTo(coefficient, minCoefficient, maxUlps) < 0) {\n            minCoefficient = coefficient;\n            minColumn = i;\n        }\n    }\n    return minColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer pivotColumn = null;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) \n    {\n        double coefficient = tableau.getEntry(0, i);\n        if (coefficient < minCoefficient) \n        {\n            minCoefficient = coefficient;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}"
    ]
  ]
}