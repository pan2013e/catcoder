{
  "benchmark": "javaeval_repo",
  "lastest_eval": {
    "compile@1": 0.5020100502512564,
    "pass@1": 0.29195979899497493,
    "compile@3": 0.6041038525963146,
    "pass@3": 0.35062814070351755,
    "compile@5": 0.6356783919597989,
    "pass@5": 0.3675919278934353
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }\n\n    /**\n     * Method for adding deserializer to handle specified type.\n     *<p>\n     * WARNING! Type matching only uses type-erased {@code Class} and should NOT\n     * be used when registering serializers for generic types like\n     * {@link java.util.Collection} and {@link java.util.Map}.",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }\n\n    /**\n     * Method for adding deserializer to handle specified type.\n     *<p>\n     * WARNING! Type matching only uses type-erased {@code Class} and should NOT\n     * be used when registering serializers for generic types like\n     * {@link java.util.Collection} and {@link java.util.Map}.",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }\n\n    /**\n     * Method for adding deserializer to handle specified type.\n     *<p>\n     * WARNING! Type matching only uses type-erased {@code Class} and should NOT\n     * be used when registering serializers for generic types like\n     * {@link java.util.Collection} and {@link java.util.Map}.",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }\n\n    /**\n     * Method for adding deserializer to handle specified type.\n     *<p>\n     * WARNING! Type matching only uses type-erased {@code Class} and should NOT\n     * be used when registering serializers for generic types like\n     * {@link java.util.Collection} and {@link java.util.Map}.",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }\n\n    /**\n     * Method for adding deserializer to handle specified type.\n     *<p>\n     * WARNING! Type matching only uses type-erased {@code Class} and should NOT\n     * be used when registering serializers for generic types like\n     * {@link java.util.Collection} and {@link java.util.Map}.",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }\n\n    /**\n     * Method for adding deserializer to handle specified type.\n     *<p>\n     * WARNING! Type matching only uses type-erased {@code Class} and should NOT\n     * be used when registering serializers for generic types like\n     * {@link java.util.Collection} and {@link java.util.Map}.",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }\n\n    /**\n     * Method for adding deserializer to handle specified type.\n     *<p>\n     * WARNING! Type matching only uses type-erased {@code Class} and should NOT\n     * be used when registering serializers for generic types like\n     * {@link java.util.Collection} and {@link java.util.Map}.",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }\n\n    /**\n     * Method for adding deserializer to handle specified type.\n     *<p>\n     * WARNING! Type matching only uses type-erased {@code Class} and should NOT\n     * be used when registering serializers for generic types like\n     * {@link java.util.Collection} and {@link java.util.Map}.",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }\n\n    /**\n     * Method for adding deserializer to handle specified type.\n     *<p>\n     * WARNING! Type matching only uses type-erased {@code Class} and should NOT\n     * be used when registering serializers for generic types like\n     * {@link java.util.Collection} and {@link java.util.Map}.",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }\n\n    /**\n     * Method for adding deserializer to handle specified type.\n     *<p>\n     * WARNING! Type matching only uses type-erased {@code Class} and should NOT\n     * be used when registering serializers for generic types like\n     * {@link java.util.Collection} and {@link java.util.Map}."
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        return task.getPercentComplete();\n    }\n    return null;\n}\n\n/**\n * Returns the percentage complete value of a sub-interval for a given item.\n *\n * @param row  the row index (zero-based).\n * @param column  the column index (zero-based).\n * @param subinterval  the sub-interval.\n *\n * @return The percent complete value (possibly <code>null</code>).",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        return task.getPercentComplete();\n    }\n    return null;\n}\n\n/**\n     * Returns the percentage complete value of a sub-interval for a given item.\n     *\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * @param subinterval  the sub-interval.\n     *\n     * @return The percent complete value (possibly <code>null</code>).\n     *\n     * @see #getPercentComplete(Comparable, Comparable, int)",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        return task.getPercentComplete();\n    }\n    return null;\n}\n\n/**\n     * Returns the percentage complete value of a sub-interval for a given item.\n     *\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * @param subinterval  the sub-interval.\n     *\n     * @return The percent complete value (possibly <code>null</code>).",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        return task.getPercentComplete();\n    }\n    return null;\n}\n\n/**\n * Returns the percentage complete value of a sub-interval for a given item.\n *\n * @param row  the row index (zero-based).\n * @param column  the column index (zero-based).\n * @param subinterval  the sub-interval.\n *\n * @return The percent complete value (possibly <code>null</code>).",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        return task.getPercentComplete();\n    }\n    return null;\n}\n\n/**\n * Returns the percentage complete value of a sub-interval for a given item.\n *\n * @param row  the row index (zero-based).\n * @param column  the column index (zero-based).\n * @param subinterval  the sub-interval.\n *\n * @return The percent complete value (possibly <code>null</code>).",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        return task.getPercentComplete();\n    }\n    return null;\n}\n\n/**\n * Returns the percentage complete value of a sub-interval for a given item.\n *\n * @param row  the row index (zero-based).\n * @param column  the column index (zero-based).\n * @param subinterval  the sub-interval.\n *\n * @return The percent complete value (possibly <code>null</code>).",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        return task.getPercentComplete();\n    }\n    return null;\n}\n\n/**\n     * Returns the percentage complete value of a sub-interval for a given item.\n     *\n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * @param subinterval  the sub-interval.\n     *\n     * @return The percent complete value (possibly <code>null</code>).",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        return task.getPercentComplete();\n    }\n    return null;\n}\n\n/**\n     * Returns the percentage complete value of a sub-interval for a given item.\n     *\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * @param subinterval  the sub-interval.\n     *\n     * @return The percent complete value (possibly <code>null</code>).\n     *\n     * @see #getPercentComplete(Comparable, Comparable)",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        return task.getPercentComplete();\n    }\n    return null;\n}\n\n/**\n * Returns the percentage complete value of a sub-interval for a given item.\n *\n * @param row  the row index (zero-based).\n * @param column  the column index (zero-based).\n * @param subinterval  the sub-interval.\n *\n * @return The percent complete value (possibly <code>null</code>).",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) {\n        return task.getPercentComplete();\n    }\n    return null;\n}\n\n/**\n     * Returns the percentage complete value of a sub-interval for a given item.\n     *\n     * @param rowKey  the row key.\n     * @param columnKey  the column key.\n     * @param subinterval  the sub-interval.\n     *\n     * @return The percent complete value (possibly <code>null</code>).\n     *\n     * @see #getPercentComplete(Comparable, Comparable)"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + len, len);\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + len, len);\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + len, len);\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new UnmodifiableIterable<E>(iterator);\n}\n\n/**\n * Gets an iterable that wraps an iterator.  The returned iterable can be\n * used for multiple iterations.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new, multiple use iterable\n * @throws NullPointerException if iterator is null",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}\n\n/**\n * Gets an iterable that wraps an iterator.  The returned iterable can be\n * used for multiple iterations.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new, multiple use iterable\n * @throws NullPointerException if iterator is null",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new UnmodifiableIterable<E>(iterator);\n}\n\n/**\n * Gets an iterable that wraps an iterator.  The returned iterable can be\n * used for multiple iterations.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new, multiple use iterable\n * @throws NullPointerException if iterator is null",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new UnmodifiableIterable<>(iterator);\n}\n\n/**\n * Gets an iterable that wraps an iterator.  The returned iterable can be\n * used for multiple iterations.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new, multiple use iterable\n * @throws NullPointerException if iterator is null",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new UnmodifiableIterable<E>(iterator);\n}\n\n/**\n * Gets an iterable that wraps an iterator.  The returned iterable can be\n * used for multiple iterations.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new, multiple use iterable\n * @throws NullPointerException if iterator is null",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new UnmodifiableIterator<>(iterator);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    return new UnmodifiableIterable<E>(iterator);\n}\n\n/**\n * Gets an iterable that wraps an iterator.  The returned iterable can be\n * used for multiple iterations.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new, multiple use iterable\n * @throws NullPointerException if iterator is null",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new UnmodifiableIterable<E>(iterator);\n}\n\n/**\n * Gets an iterable that wraps an iterator.  The returned iterable can be\n * used for multiple iterations.\n *\n * @param <E> the element type\n * @param iterator  the iterator to use, may not be null\n * @return a new, multiple use iterable\n * @throws NullPointerException if iterator is null",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return new DiagonalMatrix(m.getData()[0], false);\n    } else {\n        final int dim = m.getRowDimension();\n        final double[] data = new double[dim];\n        for (int i = 0; i < dim; i++) {\n            data[i] = m.getEntry(i, i);\n        }\n        return new DiagonalMatrix(data, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return new DiagonalMatrix(m.getData(), false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        final int dim = m.getRowDimension();\n        final double[] data = new double[dim];\n        for (int i = 0; i < dim; i++) {\n            data[i] = m.getEntry(i, i);\n        }\n        return new DiagonalMatrix(data, false);\n    } else {\n        throw new MatrixDimensionMismatchException(m.getRowDimension(), m.getColumnDimension());\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return new DiagonalMatrix(m.getData(), false);\n    } else {\n        return new DiagonalMatrix(m.getData(), true);\n    }\n}\n\n/**\n * @param m Input matrix.\n * @return the diagonal n-by-n matrix if m is a column matrix or the column\n * matrix representing the diagonal if m is a n-by-n matrix.",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return new DiagonalMatrix(m.getData(), false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        final int dim = m.getRowDimension();\n        final double[] data = new double[dim];\n        for (int i = 0; i < dim; i++) {\n            data[i] = m.getEntry(i, i);\n        }\n        return new DiagonalMatrix(data, false);\n    } else {\n        throw new MatrixDimensionMismatchException(m.getRowDimension(), m.getColumnDimension());\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return new DiagonalMatrix(m.getData(), false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        final int dim = m.getRowDimension();\n        final double[] data = new double[dim];\n        for (int i = 0; i < dim; i++) {\n            data[i] = m.getEntry(i, i);\n        }\n        return new DiagonalMatrix(data, false);\n    } else {\n        throw new MatrixDimensionMismatchException(m.getRowDimension(),\n                                                   m.getColumnDimension());\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return new DiagonalMatrix(m.getData(), false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        final int dim = m.getRowDimension();\n        final double[] data = new double[dim];\n        for (int i = 0; i < dim; i++) {\n            data[i] = m.getEntry(i, i);\n        }\n        return new DiagonalMatrix(data, false);\n    } else {\n        throw new MatrixDimensionMismatchException(m.getRowDimension(),\n                                                   m.getColumnDimension());\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return new DiagonalMatrix(m.getData()[0]);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        return new DiagonalMatrix(m.getData());\n    } else {\n        throw new MatrixDimensionMismatchException(m.getRowDimension(), m.getColumnDimension());\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return new DiagonalMatrix(m.getData(), false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        final int dim = m.getRowDimension();\n        final double[] data = new double[dim];\n        for (int i = 0; i < dim; i++) {\n            data[i] = m.getEntry(i, i);\n        }\n        return new DiagonalMatrix(data, false);\n    } else {\n        throw new MatrixDimensionMismatchException(m.getRowDimension(), m.getColumnDimension());\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return new DiagonalMatrix(m.getData()[0]);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        final int dim = m.getRowDimension();\n        final double[] data = new double[dim];\n        for (int i = 0; i < dim; i++) {\n            data[i] = m.getEntry(i, i);\n        }\n        return new DiagonalMatrix(data, false);\n    } else {\n        throw new MatrixDimensionMismatchException(m.getRowDimension(), m.getColumnDimension());\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        return new DiagonalMatrix(m.getData()[0], false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        final int dim = m.getRowDimension();\n        final double[] data = new double[dim];\n        for (int i = 0; i < dim; i++) {\n            data[i] = m.getEntry(i, i);\n        }\n        return new DiagonalMatrix(data, false);\n    } else {\n        throw new MatrixDimensionMismatchException(m.getRowDimension(),\n                m.getColumnDimension(), m.getRowDimension(), m.getColumnDimension());\n    }\n}"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(data[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}\n\n/**\n     * Reads a Field.\n     * \n     * @param field\n     *            the field to use\n     * @param target\n     *            the object to call on, may be null for static fields\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method.\n     * @return the field value\n     * @throws IllegalArgumentException\n     *             if the field is null\n     * @throws IllegalAccessException\n     *             if the field is not accessible",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}\n\n/**\n * Writes a static Field.\n * \n * @param field\n *            to write\n * @param value\n *            to set\n * @param forceAccess\n *            whether to break scope restrictions using the <code>setAccessible</code> method.\n * @throws IllegalArgumentException\n *             if the field is null or not static\n * @throws IllegalAccessException\n *             if the field is not made accessible",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}\n\n/**",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}\n\n/**\n     * Reads a Field.\n     * \n     * @param field\n     *            the field to use\n     * @param target\n     *            the object to call on, may be null for static fields\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method.\n     * @return the field value\n     * @throws IllegalArgumentException\n     *             if the field is null\n     * @throws IllegalAccessException\n     *             if the field is not accessible",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}\n\n/**\n     * Reads a Field.\n     * \n     * @param field\n     *            the field to use\n     * @param target\n     *            the object to call on, may be null for static fields\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method.\n     * @return the field value\n     * @throws IllegalArgumentException\n     *             if the field is null\n     * @throws IllegalAccessException\n     *             if the field is not accessible",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}\n\n/**",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}\n\n/**",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}\n\n/**\n     * Writes a static Field.\n     * \n     * @param field\n     *            to write\n     * @param value\n     *            to set\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method.\n     * @throws IllegalArgumentException\n     *             if the field is null or not static\n     * @throws IllegalAccessException\n     *             if the field is not made accessible",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}\n\n/**\n * Writes a static Field.\n * \n * @param field\n *            to write\n * @param value\n *            to set\n * @param forceAccess\n *            whether to break scope restrictions using the <code>setAccessible</code> method.\n * @throws IllegalArgumentException\n *             if the field is null or not static\n * @throws IllegalAccessException\n *             if the field is not made accessible or is final",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    return readField(field, null, forceAccess);\n}\n\n/**\n     * Reads a Field.\n     * \n     * @param field\n     *            the field to use\n     * @param target\n     *            the object to call on, may be null for static fields\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method.\n     * @return the field value\n     * @throws IllegalArgumentException\n     *             if the field is null\n     * @throws IllegalAccessException\n     *             if the field is not accessible"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone == null) {\n            try {\n                int offset = parseOffset(id);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    return fixedOffsetZone(id, offset);\n                }\n            } catch (Exception e) {\n                throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n            }\n        }\n        return zone;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     * \n     * @param millisOffset  the offset in millis from UTC, from -23:59:59.999 to +23:59:59.999\n     * @return the DateTimeZone object for the offset",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) {\n            return forOffsetMillis(parseOffset(id));\n        }\n        if (id.length() == 5 && id.startsWith(\"UTC+\")) {\n            return forOffsetHoursMinutes(Integer.parseInt(id.substring(4)), 0);\n        }\n        if (id.length() == 5 && id.startsWith(\"UTC-\")) {\n            return forOffsetHoursMinutes(Integer.parseInt(id.substring(4)), 0);\n        }\n        DateTimeZone zone = UTCProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = UTCProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.length() == 6) {\n            int offset = parseOffset(id);\n            return fixedOffsetZone(id, offset);\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"GMT+\") || id.startsWith(\"GMT-\")) {\n            return forOffsetMillis(parseOffset(id));\n        }\n        if (id.matches(\"\\\\d{4}-\\\\d{2}-\\\\d{2} \\\\d{2}:\\\\d{2}:\\\\d{2}\")) {\n            return forDateTime(id);\n        }\n        if (id.matches(\"\\\\d{4}-\\\\d{2}-\\\\d{2} \\\\d{2}:\\\\d{2}:\\\\d{2} [+-]\\\\d{2}:\\\\d{2}\")) {\n            return forDateTime(id);\n        }\n        if (id.matches(\"\\\\d{4}-\\\\d{2}-\\\\d{2} \\\\d{2}:\\\\d{2}:\\\\d{2} [+-]\\\\d{2}:\\\\d{2}:\\\\d{2}\")) {\n            return forDateTime(id);\n        }\n        DateTimeZone zone = UTCProvider.getZone(id);\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n        }\n        return zone;\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     * \n     * @param millisOffset  the offset in millis from UTC, from -23:59:59.999 to +23:59:59.999\n     * @return the DateTimeZone object for the offset",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n        }\n        return zone;\n    }\n    // DateTimeZone.java\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified offset to UTC in hours and minutes.\n     * This method assumes 60 minutes in an hour, and standard length minutes.\n     * <p>\n     * This factory is a convenient way of constructing zones with a fixed offset.\n     * The hours value must be in the range -23 to +23.\n     * The minutes value must be in the range -59 to +59.\n     * The following combinations of sign for the hour and minute are possible:\n     * <pre>\n     *  Hour    Minute    Example    Result\n     * \n     *  +ve     +ve       (2, 15)    +02:15\n     *  +ve     zero      (2, 0)     +02:00\n     *  +ve     -ve       (2, -15)   IllegalArgumentException\n     * \n     *  zero    +ve       (0, 15)    +00:15\n     *  zero    zero      (0, 0)     +00:00\n     *  zero    -ve       (0, -15)   -00:15\n     * \n     *  -ve     +ve       (-2, 15)   -02:15\n     *  -ve     zero      (-2, 0)    -02:00\n     *  -ve     -ve       (-2, -15)  -02:15\n     * </pre>\n     * Note that in versions before 2.3, the minutes had to be zero or positive.\n     * \n     * @param hoursOffset  the offset in hours from UTC, from -23 to +23\n     * @param minutesOffset  the offset in minutes from UTC, from -59 to +59\n     * @return the DateTimeZone object for the offset\n     * @throws IllegalArgumentException if any value is out of range, the minutes are negative",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"GMT+\")) {\n            int offset = parseOffset(id.substring(4));\n            return fixedOffsetZone(id, offset);\n        }\n        if (id.startsWith(\"GMT-\")) {\n            int offset = parseOffset(id.substring(4));\n            return fixedOffsetZone(id, offset);\n        }\n        if (id.matches(\"[+-]\\\\d{1,2}:\\\\d{2}\")) {\n            int offset = parseOffset(id);\n            return fixedOffsetZone(id, offset);\n        }\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone == null) {\n            zone = cProvider.getZone(convId(id));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n        }\n        return zone;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Converts a time zone id to a standard format.\n     * \n     * @param id  the ID of the datetime zone\n     * @return the standard ID of the datetime zone",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone == null) {\n            zone = parseFixedOffset(id);\n        }\n        return zone;\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"GMT+\")) {\n            int offset = parseOffset(id);\n            return fixedOffsetZone(id, offset);\n        }\n        if (id.startsWith(\"GMT-\")) {\n            int offset = parseOffset(id);\n            return fixedOffsetZone(id, offset);\n        }\n        if (id.length() > 3 && id.startsWith(\"Etc/\")) {\n            return fixedOffsetZone(id, parseOffset(id));\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n        }\n        return zone;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets a time zone instance for the specified offset to UTC in milliseconds.\n     * \n     * @param millisOffset  the offset in millis from UTC, from -23:59:59.999 to +23:59:59.999\n     * @return the DateTimeZone object for the offset"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(this);\n        int[] product = new int[mant.length];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x;    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length - 1;  // default, in case result is zero\n        for (int i = mant.length - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + 1;\n        result.sign = (byte)((sign == 1)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(this);\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x;    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + Math.log(RADIX) * x;\n        result.sign = (byte)((sign == 1)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n            result = dotrap(excp, MULTIPLY_TRAP, x, result);\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        // Handle special cases\n        if (x == 0) {\n            return newInstance(getZero());\n        }\n\n        if (x == 1) {\n            return newInstance(this);\n        }\n\n        if (x == RADIX - 1) {\n            return newInstance(getOne()).subtract(this);\n        }\n\n        if (x == RADIX / 2) {\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, this, result);\n            return result;\n        }\n\n        if (x == RADIX / 4) {\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, this, result);\n            return result;\n        }\n\n        if (x == RADIX / 8) {\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, this, result);\n            return result;\n        }\n\n        if (x == RADIX / 16) {\n            Dfp result = newInstance(getZero());\n            result.nans = QNAN;\n            result = dotrap(DfpField.FLAG_INVALID, MULTIPLY_TRAP, this, result);\n            return result;\n        }\n\n        // copy this\n        Dfp a = newInstance(this);\n\n        // initialize the result object\n        Dfp result = newInstance(getZero());\n\n        // compute the product\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x;    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (nans != FINITE || x == 0) {\n        if (isNaN()) {\n            return this;\n        }\n\n        if (x == 0) {\n            return getZero();\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n    }\n\n    int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j=0; j<mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i+mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + 1;\n    result.sign = (byte)((sign == 1)?1:-1);\n\n    if (result.mant[mant.length-1] == 0) {\n        // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n    final int excp;\n    if (md > (mant.length-1)) {\n        excp = result.round(product[md-mant.length]);\n    } else {\n        excp = result.round(0); // has no effect except to check status\n    }\n\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, x, result);\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(this);\n        int[] product = new int[mant.length];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x;    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length - 1;  // default, in case result is zero\n        for (int i = mant.length - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + 1;\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        return result;\n    }",
      "private Dfp multiplyFast(final int x)  {\n        Dfp result = newInstance(this);\n\n        if (x == 0) {\n            return getZero();\n        }\n\n        if (x == 1) {\n            return this;\n        }\n\n        if (x == 2) {\n            return add(this);\n        }\n\n        if (x == 3) {\n            return add(add(this));\n        }\n\n        if (x == 4) {\n            return add(add(add(this)));\n        }\n\n        if (x == 5) {\n            return add(add(add(add(this))));\n        }\n\n        if (x == 6) {\n            return add(add(add(add(add(this)))));\n        }\n\n        if (x == 7) {\n            return add(add(add(add(add(add(this))))));\n        }\n\n        if (x == 8) {\n            return add(add(add(add(add(add(add(this)))))));\n        }\n\n        if (x == 9) {\n            return add(add(add(add(add(add(add(add(this))))))));\n        }\n\n        return multiplySlow(x);\n    }",
      "private Dfp multiplyFast(final int x)  {\n    if (nans != FINITE) {\n        if (isNaN()) {\n            return this;\n        }\n\n        if (nans == INFINITE) {\n            return newInstance(this);\n        }\n    }\n\n    if (x == 0) {\n        return newInstance(getZero());\n    }\n\n    if (x == 1) {\n        return newInstance(this);\n    }\n\n    if (x == RADIX - 1) {\n        return newInstance(getOne()).subtract(this);\n    }\n\n    Dfp result = newInstance(getZero());\n\n    int[] product = new int[mant.length];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j = 0; j < mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length - 1;  // default, in case result is zero\n    for (int i = mant.length - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n    result.exp = exp + 1;\n\n    if (result.mant[mant.length-1] == 0) {\n        // if result is zero, set exp to zero\n        result.exp = 0;\n    }\n\n    final int excp;\n    if (md > (mant.length-1)) {\n        excp = result.round(product[md-mant.length]);\n    } else {\n        excp = result.round(0); // has no effect except to check status\n    }\n\n    if (excp != 0) {\n        result = dotrap(excp, MULTIPLY_TRAP, x, result);\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        if (x == 0) {\n            return newInstance(getZero());\n        }\n\n        if (x == 1) {\n            return newInstance(this);\n        }\n\n        if (x == RADIX - 1) {\n            return newInstance(getOne());\n        }\n\n        if (x == RADIX) {\n            return newInstance(getOne());\n        }\n\n        Dfp result = newInstance(this);\n\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x;    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + 1;\n        result.sign = (byte)((sign == 1)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n}\n}",
      "private Dfp multiplyFast(final int x)  {\n        if (nans != FINITE) {\n            if (isNaN()) {\n                return this;\n            }\n\n            if (nans == INFINITE) {\n                return newInstance(this);\n            }\n        }\n\n        if (x == 0) {\n            return newInstance(getZero());\n        }\n\n        if (x == 1) {\n            return newInstance(this);\n        }\n\n        if (x == RADIX-1) {\n            return negate();\n        }\n\n        Dfp result = newInstance(this);\n        int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n        for (int i = 0; i < mant.length; i++) {\n            int rh = 0;  // acts as a carry\n            for (int j=0; j<mant.length; j++) {\n                int r = mant[i] * x;    // multiply the 2 digits\n                r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n                rh = r / RADIX;\n                product[i+j] = r - rh * RADIX;\n            }\n            product[i+mant.length] = rh;\n        }\n\n        // Find the most sig digit\n        int md = mant.length * 2 - 1;  // default, in case result is zero\n        for (int i = mant.length * 2 - 1; i >= 0; i--) {\n            if (product[i] != 0) {\n                md = i;\n                break;\n            }\n        }\n\n        // Copy the digits into the result\n        for (int i = 0; i < mant.length; i++) {\n            result.mant[mant.length - i - 1] = product[md - i];\n        }\n\n        // Fixup the exponent.\n        result.exp = exp + 1;\n        result.sign = (byte)((sign == 1)?1:-1);\n\n        if (result.mant[mant.length-1] == 0) {\n            // if result is zero, set exp to zero\n            result.exp = 0;\n        }\n\n        final int excp;\n        if (md > (mant.length-1)) {\n            excp = result.round(product[md-mant.length]);\n        } else {\n            excp = result.round(0); // has no effect except to check status\n        }\n\n        if (excp != 0) {\n}\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (nans != FINITE || x == 0) {\n        return this;\n    }\n\n    if (x == 1) {\n        return this;\n    }\n\n    if (x == 2) {\n        return add(this);\n    }\n\n    if (x == 3) {\n        return add(add(this));\n    }\n\n    if (x == 4) {\n        return add(add(add(this)));\n    }\n\n    if (x == 5) {\n        return add(add(add(add(this))));\n    }\n\n    if (x == 6) {\n        return add(add(add(add(add(this)))));\n    }\n\n    if (x == 7) {\n        return add(add(add(add(add(add(this))))));\n    }\n\n    if (x == 8) {\n        return add(add(add(add(add(add(add(this)))))));\n    }\n\n    if (x == 9) {\n        return add(add(add(add(add(add(add(add(this)))))))));\n    }\n\n    if (x == 10) {\n        return add(add(add(add(add(add(add(add(add(this))))))))));\n    }\n\n    Dfp result = newInstance(this);\n    int[] product = new int[mant.length*2];  // Big enough to hold even the largest result\n\n    for (int i = 0; i < mant.length; i++) {\n        int rh = 0;  // acts as a carry\n        for (int j=0; j<mant.length; j++) {\n            int r = mant[i] * x;    // multiply the 2 digits\n            r = r + product[i+j] + rh;  // add to the product digit with carry in\n\n            rh = r / RADIX;\n            product[i+j] = r - rh * RADIX;\n        }\n        product[i+mant.length] = rh;\n    }\n\n    // Find the most sig digit\n    int md = mant.length * 2 - 1;  // default, in case result is zero\n    for (int i = mant.length * 2 - 1; i >= 0; i--) {\n        if (product[i] != 0) {\n            md = i;\n            break;\n        }\n    }\n\n    // Copy the digits into the result\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[mant.length - i - 1] = product[md - i];\n    }\n\n    // Fixup the exponent.\n}"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function(exportedFunction.getName(), null);\n    externFunction.setType(exportedFunction.getType());\n    Node param = exportedFunction.getFirstChild();\n    while (param != null) {\n        externFunction.addChildToFront(param.cloneTree());\n        param = param.getNext();\n    }\n    return externFunction;\n}\n\n/**\n * Given a function to export, create the empty function that\n * will be put in the externs file. This extern function should have\n * the same type as the original function and the same parameter\n * name but no function body.\n *\n * We create a warning here if the the function to export is missing\n * parameter or return types.",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Create a new function node with the same type as the original function\n    Node externFunction = IR.newFunction(exportedFunction.getJSType(), exportedFunction.getName());\n\n    // Check if the function has parameters\n    if (exportedFunction.getParameters().isEmpty()) {\n        // Create a warning if the function is missing parameters\n        compiler.reportWarning(\"Function \" + exportedFunction.getName() + \" is missing parameters\");\n    }\n\n    // Check if the function has return type\n    if (exportedFunction.getReturnType() == null) {\n        // Create a warning if the function is missing return type\n        compiler.reportWarning(\"Function \" + exportedFunction.getName() + \" is missing return type\");\n    }\n\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Create the extern function\n    Node externFunction = IR.newFunction(exportedFunction.getJSType(), exportedFunction.getName());\n    // Check if the function has parameters\n    if (exportedFunction.getJSType().getParameters() == null) {\n        // If the function has no parameters, we can't create an extern\n        // function for it. We should warn about this.\n        compiler.reportWarning(\"Function \" + exportedFunction.getName() + \" has no parameters. Cannot create extern function.\");\n        return null;\n    }\n    // Check if the function has return type\n    if (exportedFunction.getJSType().getReturnType() == null) {\n        // If the function has no return type, we can't create an extern\n        // function for it. We should warn about this.\n        compiler.reportWarning(\"Function \" + exportedFunction.getName() + \" has no return type. Cannot create extern function.\");\n        return null;\n    }\n    // Create the extern function\n    externFunction = IR.newFunction(exportedFunction.getJSType(), exportedFunction.getName());\n    // Add the parameters to the extern function\n    for (Node param : exportedFunction.getJSType().getParameters()) {\n        externFunction.addChild(param.cloneTree());\n    }\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.newFunction();\n    externFunction.setType(exportedFunction.getType());\n    Node paramList = exportedFunction.getParamList();\n    if (paramList != null) {\n        Node param = paramList.getFirstChild();\n        while (param != null) {\n            externFunction.addChildToFront(param.cloneTree());\n            param = param.getNext();\n        }\n    }\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Create the extern function\n    Node externFunction = IR.newFunction(\n        exportedFunction.getJSType().toMaybeFunctionType(),\n        exportedFunction.getName(),\n        null); // No function body\n\n    // Check if the function has missing parameters or return type\n    if (!exportedFunction.getJSType().toMaybeFunctionType().hasParameters()) {\n        IR.addWarning(\"The function \" + exportedFunction.getName() + \" is missing parameters.\");\n    }\n    if (!exportedFunction.getJSType().toMaybeFunctionType().hasReturnType()) {\n        IR.addWarning(\"The function \" + exportedFunction.getName() + \" is missing return type.\");\n    }\n\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function(exportedFunction.getName(), null);\n    if (exportedFunction.getJSType().isNoObjectType()) {\n        externFunction.setType(exportedFunction.getJSType());\n    } else {\n        externFunction.setType(JSType.objectType());\n    }\n    if (exportedFunction.getParameters() != null) {\n        externFunction.setParameters(exportedFunction.getParameters());\n    }\n    return externFunction;\n}\n\n/**\n * Given a function to export, create the empty function that\n * will be put in the externs file. This extern function should have\n * the same type as the original function and the same parameter\n * name but no function body.\n *\n * We create a warning here if the the function to export is missing\n * parameter or return types.",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Create the new function node\n    Node externFunction = IR.newFunction(exportedFunction.getJSType(), exportedFunction.getName());\n    // Check if the function has parameters\n    if (exportedFunction.getParameters().size() > 0) {\n        // Add the parameters to the new function\n        for (Node param : exportedFunction.getParameters()) {\n            externFunction.addChild(param.cloneTree());\n        }\n    } else {\n        // Create a warning if the function has no parameters\n        compiler.reportWarning(\"Function \" + exportedFunction.getName() + \" has no parameters.\");\n    }\n    // Check if the function has a return type\n    if (exportedFunction.getReturnType() != null) {\n        // Add the return type to the new function\n        externFunction.setReturnType(exportedFunction.getReturnType());\n    } else {\n        // Create a warning if the function has no return type\n        compiler.reportWarning(\"Function \" + exportedFunction.getName() + \" has no return type.\");\n    }\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Create the extern function with the same type as the original function\n    Node externFunction = IR.newFunction(exportedFunction.getJSType(), exportedFunction.getFirstChild().getNext());\n    // Set the parameter names\n    externFunction.setFirstChild(exportedFunction.getFirstChild());\n    // Set the return type\n    externFunction.setLastChild(exportedFunction.getLastChild());\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function(exportedFunction.getName(), null, null);\n    if (exportedFunction.getJSType().getReturnType() == null) {\n        // Create a return type\n        externFunction.setReturnType(IR.type(\"void\"));\n    }\n    if (exportedFunction.getJSType().getParameters().size() == 0) {\n        // Create a parameter\n        externFunction.addParameter(IR.type(\"any\"), \"param\");\n    }\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node externFunction = IR.function(exportedFunction.getName(), null, null);\n    externFunction.setType(exportedFunction.getType());\n    if (exportedFunction.getParameterCount() > 0) {\n        for (int i = 0; i < exportedFunction.getParameterCount(); i++) {\n            Node param = exportedFunction.getParameter(i);\n            Node externParam = IR.parameter(param.getName());\n            externParam.setType(param.getType());\n            externFunction.addParameter(externParam);\n        }\n    }\n    return externFunction;\n}"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[] sigma = new double[params.length];\n    Array2DRowRealMatrix covarianceMatrix = new Array2DRowRealMatrix(params.length, params.length);\n    // computeCovariances(params, covarianceSingularityThreshold, covarianceMatrix);\n    // compute the standard deviation of the parameters\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = Math.sqrt(covarianceMatrix.getSubMatrix(i, i).operate(new double[]{1}).getEntry(0));\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = Math.sqrt(getCovariance(i, i));\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    // Get the covariance matrix\n    RealMatrix covarianceMatrix = computeCovariances(params, covarianceSingularityThreshold);\n\n    // Get the number of parameters\n    int nParams = params.length;\n\n    // Create an array to store the standard deviations\n    double[] sigma = new double[nParams];\n\n    // Compute the standard deviations\n    for (int i = 0; i < nParams; i++) {\n        sigma[i] = Math.sqrt(covarianceMatrix.getEntry(i, i));\n    }\n\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    // Compute the covariance matrix\n    StorelessCovariance covariance = new StorelessCovariance();\n    for (int i = 0; i < params.length; i++) {\n        for (int j = 0; j < params.length; j++) {\n            covariance.setElement(i, j, computeCovariances(params, covarianceSingularityThreshold));\n        }\n    }\n\n    // Compute the standard deviation of the parameters\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = Math.sqrt(covariance.getElement(i, i));\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    int nParams = params.length;\n    double[] sd = new double[nParams];\n    for (int i = 0; i < nParams; i++) {\n        sd[i] = Math.sqrt(getCovariance(i, i));\n    }\n    return sd;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    int nParams = params.length;\n    double[] sigma = new double[nParams];\n    Array2DRowRealMatrix covarianceMatrix = new Array2DRowRealMatrix(nParams, nParams);\n    // compute the covariance matrix\n    computeCovariances(params, covarianceSingularityThreshold, covarianceMatrix);\n    // compute the standard deviation\n    for (int i = 0; i < nParams; i++) {\n        sigma[i] = Math.sqrt(covarianceMatrix.getEntry(i, i));\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    int m = params.length;\n    double[] sd = new double[m];\n    Array2DRowRealMatrix covMatrix = new Array2DRowRealMatrix(m, m);\n    StorelessCovariance storelessCovariance = new StorelessCovariance(covMatrix);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            if (i == j) {\n                covMatrix.setElement(i, j, 1.0);\n            } else {\n                covMatrix.setElement(i, j, 0.0);\n            }\n        }\n    }\n    try {\n        storelessCovariance.computeCovariances(params, covarianceSingularityThreshold);\n    } catch (SingularMatrixException e) {\n        // handle the exception\n    }\n    for (int i = 0; i < m; i++) {\n        sd[i] = Math.sqrt(covMatrix.getElement(i, i));\n    }\n    return sd;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[] sigma = new double[params.length];\n    Array2DRowRealMatrix covarianceMatrix = new Array2DRowRealMatrix(params.length, params.length);\n    // Compute the covariance matrix\n    computeCovariances(params, covarianceSingularityThreshold, covarianceMatrix);\n\n    // Compute the standard deviations\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = Math.sqrt(covarianceMatrix.getEntry(i, i));\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    int nParams = params.length;\n    double[] sigma = new double[nParams];\n    for (int i = 0; i < nParams; i++) {\n        try {\n            sigma[i] = Math.sqrt(getCovariance(i, i));\n        } catch (NumberIsTooSmallException e) {\n            // If the number of observations is too small, set the standard\n            // deviation to a small value (e.g., 1e-6).\n            sigma[i] = 1e-6;\n        }\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  {\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = Math.sqrt(getCovariance(i, i));\n    }\n    return sigma;\n}"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new CyclicSubstitutionException(\"Cyclic substitution detected for variable: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new StrSubstitutorException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new SubstitutionException(\"Cyclic substitution detected: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new SubstitutionException(\"Cyclic substitution detected for variable \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new CyclicSubstitutionException(\"Cyclic substitution detected for variable: \" + varName);\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new SubstitutionException(\"Cyclic substitution detected: \" + varName);\n    }\n}\n\n/**\n * Replaces all the occurrences of variables within the given source builder with their matching values from the resolver.\n *\n * @param source  the builder to replace in, null returns zero\n * @param offset  the start offset within the array, must be valid\n * @param length  the length within the builder to be processed, must be valid\n * @return true if altered",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new CyclicSubstitutionException(\"Cyclic substitution detected for variable \" + varName);\n    }\n}\n\n/**\n * Internal method that substitutes the variables.\n *\n * @param buf  the string builder to substitute into, not null\n * @param offset  the start offset within the builder, must be valid\n * @param length  the length within the builder to be processed, must be valid\n * @param priorVariables  the stack keeping track of the replaced variables, may be null\n * @return the length change that occurs, unless priorVariables is null when the int\n *  represents a boolean flag as to whether any change occurred.\n */\nprotected boolean substitute(final StrBuilder buf, final int offset, final int length, List<String> priorVariables) {\n    int endMatchLen = 0;\n    int pos = offset;\n    while (pos < offset + length) {\n        int startMatchLen = prefixMatcher.isMatch(buf.toCharArray(), pos, length - pos, buf.length());\n        if (startMatchLen > 0) {\n            int endPos = pos + startMatchLen;\n            endMatchLen = suffixMatcher.isMatch(buf.toCharArray(), endPos, length - endPos, buf.length());\n            if (endMatchLen > 0) {\n                String varName = new String(buf.toCharArray(), pos + startMatchLen, endPos - pos - startMatchLen);\n                if (isEnableSubstitutionInVariables()) {\n                    final StrBuilder bufName = new StrBuilder(varName);\n                    substitute(bufName, 0, bufName.length());\n                    varName = bufName.toString();\n                }\n                pos += endMatchLen;\n                if (priorVariables == null) {\n                    priorVariables = new ArrayList<String>();\n                    priorVariables.add(new String(buf.toCharArray(), offset, length));\n                }\n                checkCyclicSubstitution(varName, priorVariables);\n                priorVariables.add(varName);\n            }\n        }\n        pos++;\n    }\n    return endMatchLen > 0;\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new SubstitutionException(\"Cyclic substitution detected: \" + varName);\n    }\n}\n\n/**\n * Replaces all the occurrences of variables within the given source builder\n * with their matching values from the resolver.\n * The builder is updated with the result.\n * <p>\n * Only the specified portion of the buffer will be processed.\n * The rest of the buffer is not processed, but it is not deleted.\n *\n * @param source  the buffer to replace in, updated, null returns zero\n * @param offset  the start offset within the array, must be valid\n * @param length  the length within the buffer to be processed, must be valid\n * @return true if altered\n * @since 3.2",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new StrSubstitutorException(\"Cyclic substitution detected for variable \" + varName);\n    }\n}\n\n/**\n * Replaces all the occurrences of variables within the given source builder with their matching values from the resolver.\n * The builder is updated with the result.\n * <p>\n * Only the specified portion of the buffer will be processed.\n * The rest of the buffer is not processed, but it is not deleted.\n *\n * @param source  the buffer to replace in, updated, null returns zero\n * @param offset  the start offset within the array, must be valid\n * @param length  the length within the buffer to be processed, must be valid\n * @return true if altered\n * @since 3.2",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new SubstitutionException(\"Cyclic substitution detected: \" + varName);\n    }\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    if (sorted) {\n        return topologicalStableSort(roots, deps);\n    } else {\n        return roots;\n    }\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<INPUT>();\n    for (INPUT root : roots) {\n        result.add(root);\n    }\n    if (sorted) {\n        result = topologicalStableSort(result, deps);\n    }\n    return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<INPUT>();\n    for (INPUT root : roots) {\n        result.add(root);\n    }\n    if (sorted) {\n        // Add your code here\n    }\n    return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<INPUT>();\n    for (INPUT root : roots) {\n        result.add(root);\n    }\n    if (sorted) {\n        result = topologicalStableSort(result, deps);\n    }\n    return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> deps = new ArrayList<>();\n    for (INPUT root : roots) {\n        for (INPUT input : inputs) {\n            if (input.getRequires().contains(root.getSymbol())) {\n                deps.add(input);\n            }\n        }\n    }\n    if (sorted) {\n        // sort the dependencies\n        List<INPUT> sortedList = new ArrayList<>();\n        for (INPUT input : inputs) {\n            if (deps.contains(input)) {\n                sortedList.add(input);\n            }\n        }\n        deps = sortedList;\n    }\n    return deps;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<INPUT>();\n    for (INPUT root : roots) {\n        result.add(root);\n    }\n    if (sorted) {\n        // Sort the inputs by sucking in 0-in-degree nodes until we're done.\n        result = topologicalStableSort(result, deps);\n    }\n    return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> deps = new ArrayList<INPUT>();\n    for (INPUT root : roots) {\n        deps.addAll(getDependencies(root));\n    }\n    if (sorted) {\n        deps = topologicalStableSort(deps);\n    }\n    return deps;\n}\n\n/**\n * Gets all the dependencies of the given input. The inputs must be returned\n * in a stable order. In other words, if A comes before B, and A does not\n * transitively depend on B, then A must also come before B in the returned\n * list.\n *\n * @param input The input to get the dependencies of.\n * @return A list of all the dependencies of the given input.",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    if (sorted) {\n        return topologicalStableSort(roots, deps);\n    } else {\n        return new ArrayList<INPUT>(roots);\n    }\n}\n\n/**\n * Gets the input that provides the given symbol. If no input provides the\n * symbol, it throws a MissingProvideException.",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> deps = new ArrayList<>();\n    for (INPUT root : roots) {\n        deps.addAll(getDependencies(root));\n    }\n    if (sorted) {\n        deps = topologicalStableSort(deps);\n    }\n    return deps;\n}\n\n/**\n * Gets all the dependencies of the given root. The inputs must be returned\n * in a stable order. In other words, if A comes before B, and A does not\n * transitively depend on B, then A must also come before B in the returned\n * list.\n *\n * @param root the root to get dependencies of\n * @return a list of dependencies of the root",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<INPUT>();\n    for (INPUT root : roots) {\n        if (root.getProvides().isEmpty()) {\n            result.add(root);\n        }\n    }\n    if (sorted) {\n        List<INPUT> deps = new ArrayList<INPUT>();\n        for (INPUT input : inputs) {\n            if (!result.contains(input)) {\n                deps.add(input);\n            }\n        }\n}\n}"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null || str.isEmpty()) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n    final Dfp[] result = new Dfp[2];\n    final Dfp zero = a.getField().getZero();\n    final Dfp one = a.getField().getOne();\n\n    if (a.equals(zero)) {\n        result[0] = zero;\n        result[1] = zero;\n        return result;\n    }\n\n    if (a.equals(one)) {\n        result[0] = one;\n        result[1] = zero;\n        return result;\n    }\n\n    Dfp[] split = new Dfp[2];\n    split[0] = a.getField().getSqr2Split()[0];\n    split[1] = a.getField().getSqr2Split()[1];\n\n    Dfp[] x = split(a);\n    Dfp[] y = split(a.subtract(split[0].multiply(split[1])));\n\n    result[0] = splitMult(x, split[0]).add(splitMult(y, split[1]));\n    result[1] = splitMult(x, split[1]).add(splitMult(y, split[0]));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    Dfp[] aSplit = a.getField().getSqr2Split();\n    Dfp[] piSplit = a.getField().getPiSplit();\n\n    Dfp[] xs = split(a);\n\n    Dfp[] ds = splitMult(xs, aSplit);\n    ds[0] = ds[0].add(one);\n\n    xs[0] = xs[0].subtract(aSplit[0]);\n    xs[1] = xs[1].subtract(aSplit[1]);\n\n    xs = splitDiv(xs, ds);\n    result[0] = xs[0].add(xs[1]);\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    result[0] = a.getZero();\n    result[1] = a;\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    result[0] = a.getZero();\n    result[1] = a;\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    Dfp[] aSplit = split(a.toString());\n    result[0] = new Dfp(a.getField(), aSplit[0]);\n    result[1] = new Dfp(a.getField(), aSplit[1]);\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    final Dfp[] result = new Dfp[2];\n    final Dfp[] split10 = DfpField.getLn10Split();\n    final Dfp[] split5 = DfpField.getLn5Split();\n\n    Dfp[] a10 = splitMult(a, split10);\n    Dfp[] a5 = splitMult(a10[0], split5);\n\n    result[0] = a5[0];\n    result[1] = a5[1].add(a10[1]);\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    final Dfp[] result = new Dfp[2];\n    result[0] = a.getZero();\n    result[1] = a;\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    Dfp[] aSplit = split(a.toString());\n    result[0] = new Dfp(a.getField(), aSplit[0]);\n    result[1] = new Dfp(a.getField(), aSplit[1]);\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    result[0] = a.getZero();\n    result[1] = a;\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp[] result = new Dfp[2];\n    result[0] = a.getZero();\n    result[1] = a;\n\n    return result;\n}"
    ],
    [
      "public String cssSelector()  {\n    if (getId() != null) {\n        return \"#\" + getId();\n    }\n    String parentSelector = parent() != null ? parent().cssSelector() : \"\";\n    if (parentSelector.isEmpty()) {\n        return \"\";\n    }\n    return parentSelector + \" > \" + getTag().getName() + (getClassName() != null ? \".\" + getClassName() : \"\") + (getTagName() != null ? \":\" + getTagName() : \"\") + (getIndex() != null ? \":nth-child(\" + getIndex() + \")\" : \"\");\n}",
      "public String cssSelector()  {\n    String selector = \"\";\n    if (getId() != null) {\n        selector += \"#\" + getId();\n    } else {\n        Element parent = parent();\n        if (parent != null) {\n            selector += parent.cssSelector();\n            if (!selector.isEmpty()) {\n                selector += \" > \";\n            }\n        }\n        selector += getTagName();\n        if (!getClasses().isEmpty()) {\n            selector += \".\" + String.join(\".\", getClasses());\n        }\n        if (hasSibling()) {\n            selector += \":\" + (getSiblingIndex() + 1);\n        }\n    }\n    return selector;\n}",
      "public String cssSelector()  {\n    if (hasId()) {\n        return \"#\" + getId();\n    } else {\n        Element parent = parent();\n        if (parent != null) {\n            String parentSelector = parent.cssSelector();\n            if (parentSelector != null) {\n                return parentSelector + \" > \" + tagName() + (hasClass() ? \".\" + classNames() : \"\");\n            }\n        }\n        return tagName() + (hasClass() ? \".\" + classNames() : \"\") + (hasAttribute(\"nth-child\") ? \":nth-child(\" + getAttribute(\"nth-child\") + \")\" : \"\");\n    }\n}",
      "public String cssSelector()  {\n    String selector = \"\";\n    if (getId() != null) {\n        selector += \"#\" + getId();\n    } else {\n        Element parent = parent();\n        if (parent != null) {\n            selector += parent.cssSelector();\n            if (!selector.isEmpty()) {\n                selector += \" > \";\n            }\n        }\n        selector += tagName() + (getClassName() != null ? \".\" + getClassName() : \"\");\n        if (getIndex() != null) {\n            selector += \":\" + getIndex();\n        }\n    }\n    return selector;\n}",
      "public String cssSelector()  {\n    if (getId() != null) {\n        return \"#\" + getId();\n    }\n    String parentSelector = parents().cssSelector();\n    if (parentSelector.isEmpty()) {\n        return \"\";\n    }\n    return parentSelector + \" > \" + getTag().getName() + (hasClassNames() ? \".\" + classNames() : \"\") + (hasIndex() ? \":nth-child(\" + getIndex() + \")\" : \"\");\n}",
      "public String cssSelector()  {\n    String selector = \"\";\n    if (getId() != null) {\n        selector = \"#\" + getId();\n    } else {\n        Element parent = parent();\n        if (parent != null) {\n            selector = parent.cssSelector() + \" > \";\n        }\n        selector += getTagName() + (getClassName() != null ? \".\" + getClassName() : \"\") + (getIndex() != null ? \":nth-child(\" + getIndex() + \")\" : \"\");\n    }\n    return selector;\n}",
      "public String cssSelector()  {\n    String id = getId();\n    if (id != null) {\n        return \"#\" + id;\n    }\n    Element parent = parent();\n    if (parent == null) {\n        return \"\";\n    }\n    String parentSelector = parent.cssSelector();\n    if (parentSelector.isEmpty()) {\n        return \"\";\n    }\n    String tagName = getTagName();\n    String className = getClass().getSimpleName();\n    String nthChild = getSiblingIndex() > 0 ? \":nth-child(\" + (getSiblingIndex() + 1) + \")\" : \"\";\n    return parentSelector + \" > \" + tagName + \".\" + className + nthChild;\n}",
      "public String cssSelector()  {\n    if (hasId()) {\n        return \"#\" + getId();\n    } else {\n        Element parent = parent();\n        if (parent != null) {\n            return parent.cssSelector() + \" > \" + tagName() + (getClassName().isEmpty() ? \"\" : \".\" + getClassName());\n        } else {\n            return tagName() + (getClassName().isEmpty() ? \"\" : \".\" + getClassName());\n        }\n    }\n}",
      "public String cssSelector()  {\n    if (getId() != null) {\n        return \"#\" + getId();\n    }\n    String parentSelector = parent() != null ? parent().cssSelector() : \"\";\n    if (parentSelector.isEmpty()) {\n        return \"\";\n    }\n    String elementSelector = tagName() + (hasClass() ? \".\" + classNames() : \"\");\n    if (hasSibling()) {\n        elementSelector += \":\" + siblingIndex();\n    }\n    return parentSelector + \" > \" + elementSelector;\n}",
      "public String cssSelector()  {\n    if (hasId()) {\n        return \"#\" + getId();\n    }\n    Element parent = parent();\n    if (parent == null) {\n        return \"\";\n    }\n    String parentSelector = parent.cssSelector();\n    if (parentSelector.isEmpty()) {\n        return \"\";\n    }\n    return parentSelector + \" > \" + getTag().getName() + (getClassName() != null ? \".\" + getClassName() : \"\") + (getIndex() != null ? \":nth-child(\" + getIndex() + \")\" : \"\");\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isName()) {\n        cost += NAME_COST_ESTIMATE;\n    } else if (n.isCall()) {\n        cost += PAREN_COST;\n    } else if (n.isNot()) {\n        cost += COMMA_COST;\n    }\n    return cost;\n}\n\n/**\n *  Estimate the total number of characters in the textual representation\n *  of the given node and that will be devoted to negation or parentheses.\n *  Since these are the only characters that flipping a condition\n *  according to De Morgan's rule can affect, these are the only ones\n *  we count.\n *  Not nodes are counted by the NOT node itself, whereas\n *  parentheses around an expression are counted by the parent node.\n *  @param n the node to be checked.\n *  @return the number of negations and parentheses in the node.",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.isName()) {\n        return 0;\n    }\n    if (n.isCall()) {\n        return PAREN_COST + COMMA_COST;\n    }\n    if (n.isNot()) {\n        return NAME_COST_ESTIMATE + PAREN_COST;\n    }\n    if (n.isAnd() || n.isOr()) {\n        return NAME_COST_ESTIMATE + PAREN_COST;\n    }\n    return 0;\n}\n\n/**\n *  Estimate the number of characters in the textual representation of\n *  the given node and that will be devoted to negation or parentheses.\n *  Since these are the only characters that flipping a condition\n *  according to De Morgan's rule can affect, these are the only ones\n *  we count.\n *  Not nodes are counted by the NOT node itself, whereas\n *  parentheses around an expression are counted by the parent node.\n *  @param n the node to be checked.\n *  @return the number of negations and parentheses in the node.",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost += NAME_COST_ESTIMATE;\n    }\n    if (n.isParentheses()) {\n        cost += PAREN_COST;\n    }\n    return cost;\n}\n\n/**\n *  Estimate the cost of a function call.\n *  @param fnName The name of the function.\n *  @param fnNode The FUNCTION node of the function.\n *  @return Whether the function node meets the minimum requirements for\n *  inlining.\n */\nboolean doesFunctionMeetMinimumRequirements(\n      final String fnName, Node fnNode) {\n    Node block = NodeUtil.getFunctionBody(fnNode);\n\n    // Basic restrictions on functions that can be inlined:\n    // 0) The function is inlinable by convention\n    // 1) It contains a reference to itself.\n    // 2) It uses its parameters indirectly using \"arguments\" (it isn't\n    //    handled yet.\n    // 3) It references \"eval\". Inline a function containing eval can have\n    //    large performance implications.\n\n    if (!compiler.getCodingConvention().isInlinableFunction(fnNode)) {\n      return false;\n    }\n\n    final String fnRecursionName = fnNode.getFirstChild().getString();\n    Preconditions.checkState(fnRecursionName != null);\n\n    // If the function references \"arguments\" directly in the function\n    boolean referencesArguments = NodeUtil.isNameReferenced(\n        block, \"arguments\", NodeUtil.MATCH_NOT_FUNCTION);\n// javascript/jscomp/FunctionInjector.java\n// or it references \"eval\" or one of its names anywhere.\n    Predicate<Node> p = new Predicate<Node>(){\n}\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isName()) {\n        String name = n.getString();\n        if (name.equals(\"not\")) {\n            cost += 1;\n        }\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isName()) {\n        String name = n.getString();\n        if (name.equals(\"not\")) {\n            cost += NAME_COST_ESTIMATE;\n        }\n    }\n    if (n.isParentheses()) {\n        cost += PAREN_COST;\n    }\n    return cost;\n}\n\n/**\n *  Estimate the number of characters in the textual representation of\n *  the given node and that will be devoted to negation or parentheses.\n *  Since these are the only characters that flipping a condition\n *  according to De Morgan's rule can affect, these are the only ones\n *  we count.\n *  Not nodes are counted by the NOT node itself, whereas\n *  parentheses around an expression are counted by the parent node.\n *  @param n the node to be checked.\n *  @return the number of negations and parentheses in the node.",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isName()) {\n        cost += NAME_COST_ESTIMATE;\n    } else if (n.isParentheses()) {\n        cost += PAREN_COST;\n    } else if (n.isNot()) {\n        cost += COMMA_COST;\n    }\n    return cost;\n}\n\n/**\n *  Estimate the number of characters in the textual representation of\n *  the given node and that will be devoted to negation or parentheses.\n *  Since these are the only characters that flipping a condition\n *  according to De Morgan's rule can affect, these are the only ones\n *  we count.\n *  Not nodes are counted by the NOT node itself, whereas\n *  parentheses around an expression are counted by the parent node.\n *  @param n the node to be checked.\n *  @return the number of negations and parentheses in the node.",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.isName()) {\n        return 0;\n    }\n    if (n.isNot()) {\n        return 1 + estimateCostOneLevel(n.getChild(0));\n    }\n    if (n.isAnd() || n.isOr()) {\n        return estimateCostOneLevel(n.getChild(0)) + estimateCostOneLevel(n.getChild(1));\n    }\n    if (n.isParentheses()) {\n        return estimateCostOneLevel(n.getChild(0)) + 2;\n    }\n    return 0;\n}\n\n/**\n * @param fnName The name of this function. This either the name of the\n *  variable to which the function is assigned or the name from the FUNCTION\n *  node.\n * @param fnNode The FUNCTION node of the function to inspect.\n * @return Whether the function node meets the minimum requirements for\n * inlining.\n */\nboolean doesFunctionMeetMinimumRequirements(\n    final String fnName, Node fnNode) {\n    Node block = NodeUtil.getFunctionBody(fnNode);\n\n    // Basic restrictions on functions that can be inlined:\n    // 0) The function is inlinable by convention\n    // 1) It contains a reference to itself.\n    // 2) It uses its parameters indirectly using \"arguments\" (it isn't\n    //    handled yet.\n    // 3) It references \"eval\". Inline a function containing eval can have\n    //    large performance implications.\n\n    if (!compiler.getCodingConvention().isInlinableFunction(fnNode)) {\n        return false;\n    }\n\n    final String fnRecursionName = fnNode.getFirstChild().getString();\n    Preconditions.checkState(fnRecursionName != null);\n\n    // If the function references \"arguments\" directly in the function\n    boolean referencesArguments = NodeUtil.isNameReferenced(\n        block, \"arguments\", NodeUtil.MATCH_NOT_FUNCTION);\n    // or it references \"eval\" or one of its names anywhere.\n    Predicate<Node> p = new Predicate<Node>(){\n}\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost += NAME_COST_ESTIMATE;\n    }\n    if (n.isParentheses()) {\n        cost += PAREN_COST;\n    }\n    return cost;\n}\n\n/**\n *  Estimate the number of characters in the textual representation of\n *  the given node and that will be devoted to negation or parentheses.\n *  Since these are the only characters that flipping a condition\n *  according to De Morgan's rule can affect, these are the only ones\n *  we count.\n *  Not nodes are counted by the NOT node itself, whereas\n *  parentheses around an expression are counted by the parent node.\n *  @param n the node to be checked.\n *  @return the number of negations and parentheses in the node.",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost += 1;\n    }\n    if (n.isParentheses()) {\n        cost += 2;\n    }\n    return cost;\n}\n\n/**\n *  Estimate the number of characters in the textual representation of\n *  the given node and that will be devoted to negation or parentheses.\n *  Since these are the only characters that flipping a condition\n *  according to De Morgan's rule can affect, these are the only ones\n *  we count.\n *  Not nodes are counted by the NOT node itself, whereas\n *  parentheses around an expression are counted by the parent node.\n *  @param n the node to be checked.\n *  @return the number of negations and parentheses in the node.",
      "private static int estimateCostOneLevel(Node n)  {\n    if (n.getType() == Token.NOT) {\n        return 1 + estimateCostOneLevel(n.getChild(0));\n    } else if (n.getType() == Token.PARENTHESIS_OPEN) {\n        return estimateCostOneLevel(n.getChild(0)) + 2;\n    } else {\n        return 0;\n    }\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    char[] buffer = this.buffer;\n    int len = buffer.length;\n    int i = 0;\n    int j = len - 1;\n    char tmp;\n    while (j > i) {\n        tmp = buffer[j];\n        buffer[j] = buffer[i];\n        buffer[i] = tmp;\n        j--;\n        i++;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (this == null) {\n        return this;\n    }\n    final char[] buffer = this.buffer;\n    int i = 0;\n    int j = buffer.length - 1;\n    char tmp;\n    while (j > i) {\n        tmp = buffer[j];\n        buffer[j] = buffer[i];\n        buffer[i] = tmp;\n        j--;\n        i++;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    char[] chars = toCharArray(0, length());\n    reverse(chars);\n    System.arraycopy(chars, 0, buffer, 0, length());\n    return this;\n}\n\n    /**\n     * Reverses the array in place.\n     * \n     * @param array  the array to reverse",
      "public StrBuilder reverse()  {\n    char[] buffer = this.buffer;\n    int start = 0;\n    int end = buffer.length - 1;\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    char[] chars = this.toCharArray(0, this.size);\n    ArrayUtils.reverse(chars);\n    this.setChars(chars);\n    return this;\n}",
      "public StrBuilder reverse()  {\n    char[] buffer = this.buffer;\n    int len = buffer.length;\n    char[] reversed = new char[len];\n    for (int i = len - 1; i >= 0; i--) {\n        reversed[len - 1 - i] = buffer[i];\n    }\n    this.buffer = reversed;\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) {\n        return this;\n    }\n    char[] buffer = this.buffer;\n    int start = 0;\n    int end = size - 1;\n    while (start < end) {\n        char temp = buffer[start];\n        buffer[start] = buffer[end];\n        buffer[end] = temp;\n        start++;\n        end--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    char[] chars = toCharArray(0, length());\n    reverse(chars);\n    System.arraycopy(chars, 0, buffer, 0, length());\n    return this;\n}",
      "public StrBuilder reverse()  {\n    char[] buffer = this.buffer;\n    int len = buffer.length;\n    char[] newBuffer = new char[len];\n    for (int i = len - 1; i >= 0; i--) {\n        newBuffer[len - 1 - i] = buffer[i];\n    }\n    this.buffer = newBuffer;\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size == 0) {\n        return this;\n    }\n    char[] buffer = this.buffer;\n    int i = 0;\n    int j = size - 1;\n    char tmp;\n    while (j > i) {\n        tmp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = tmp;\n        j--;\n        i++;\n    }\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n    String text = this.text();\n    String before = text.substring(0, offset);\n    String after = text.substring(offset);\n    TextNode newNode = new TextNode(after);\n    this.text(before);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    if (offset > text.length()) {\n        throw new IndexOutOfBoundsException(\"Offset \" + offset + \" is greater than the length of the text \" + text.length());\n    }\n    String before = text.substring(0, offset);\n    String after = text.substring(offset);\n    TextNode newNode = new TextNode(after);\n    this.coreValue(before);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = this.text();\n    if (offset < 0 || offset > text.length()) {\n        throw new IndexOutOfBoundsException(\"Offset is out of bounds\");\n    }\n    String before = text.substring(0, offset);\n    String after = text.substring(offset);\n    TextNode newNode = new TextNode(after);\n    this.text(before);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = this.text();\n    String firstPart = text.substring(0, offset);\n    String secondPart = text.substring(offset);\n    TextNode firstTextNode = new TextNode(firstPart);\n    TextNode secondTextNode = new TextNode(secondPart);\n    this.parent().appendChild(firstTextNode);\n    this.parent().appendChild(secondTextNode);\n    return secondTextNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = this.text();\n    String before = text.substring(0, offset);\n    String after = text.substring(offset);\n    TextNode beforeNode = new TextNode(before);\n    TextNode afterNode = new TextNode(after);\n    this.parent().insertAfter(this, afterNode);\n    this.text(before);\n    return afterNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String firstPart = text.substring(0, offset);\n    String secondPart = text.substring(offset);\n    TextNode firstTextNode = new TextNode(firstPart);\n    TextNode secondTextNode = new TextNode(secondPart);\n    insertAfter(this, secondTextNode);\n    return secondTextNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = this.text();\n    String before = text.substring(0, offset);\n    String after = text.substring(offset);\n    TextNode beforeNode = new TextNode(before);\n    TextNode afterNode = new TextNode(after);\n    this.parentNode().appendChild(beforeNode);\n    this.parentNode().appendChild(afterNode);\n    return afterNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = this.text();\n    String firstPart = text.substring(0, offset);\n    String secondPart = text.substring(offset);\n    TextNode firstTextNode = new TextNode(firstPart);\n    TextNode secondTextNode = new TextNode(secondPart);\n    this.replaceWith(firstTextNode);\n    return secondTextNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = this.text();\n    String before = text.substring(0, offset);\n    String after = text.substring(offset);\n    TextNode newNode = new TextNode(after);\n    this.text(before);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    String text = getWholeText();\n    String before = text.substring(0, offset);\n    String after = text.substring(offset);\n    TextNode beforeNode = new TextNode(before);\n    TextNode afterNode = new TextNode(after);\n    parent().appendChild(beforeNode);\n    parent().appendChild(afterNode);\n    return afterNode;\n}"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(a, b).subtract(intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(subtract(a, b), subtract(b, a));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(a, b).subtract(intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(a, b).subtract(intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(a, b).subtract(intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(subtract(a, b), subtract(b, a));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(a, b).subtract(intersection(a, b));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(subtract(a, b), subtract(b, a));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(subtract(a, b), subtract(b, a));\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    return union(a, b).subtract(intersection(a, b));\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    for (int i = 0; i < 8; i++) {\n        bytes[7 - i] = (byte) ((value.toByteArray()[i] & 0xFF));\n    }\n    return bytes;\n}\n\n/**\n     * Helper method to get the value as a Java long from eight bytes\n     * starting at given array offset\n     * @param bytes the array of bytes\n     * @param offset the offset to start\n     * @return the corresponding Java long value",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    for (int i = 0; i < 8; i++) {\n        bytes[7 - i] = (byte) ((value.shiftRight(8 * i).and(0xFF)).intValue());\n    }\n    return bytes;\n}\n\n/**\n     * Helper method to get the value as a Java long from eight bytes\n     * starting at given array offset\n     * @param bytes the array of bytes\n     * @param offset the offset to start\n     * @return the corresponding Java long value",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    for (int i = 0; i < 8; i++) {\n        bytes[7 - i] = (byte) (value.toByteArray()[i]);\n    }\n    return bytes;\n}\n\n/**\n     * Helper method to get the value as a Java long from eight bytes\n     * starting at given array offset\n     * @param bytes the array of bytes\n     * @param offset the offset to start\n     * @return the corresponding Java long value",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    for (int i = 0; i < 8; i++) {\n        bytes[7 - i] = (byte) (value.toByteArray()[i + value.toByteArray().length() - 8 + i]);\n    }\n    return bytes;\n}\n\n/**\n     * Helper method to get the value as a Java long from eight bytes\n     * starting at given array offset\n     * @param bytes the array of bytes\n     * @param offset the offset to start\n     * @return the corresponding Java long value",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    for (int i = 0; i < 8; i++) {\n        bytes[7 - i] = (byte) (value.byteAt(7 - i));\n    }\n    return bytes;\n}\n\n/**\n     * Helper method to get the value as a Java long from eight bytes\n     * starting at given array offset\n     * @param bytes the array of bytes\n     * @param offset the offset to start\n     * @return the corresponding Java long value",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    for (int i = 0; i < 8; i++) {\n        bytes[7 - i] = (byte) ((value.shiftRight(i * 8).and(0xFF)).intValue());\n    }\n    return bytes;\n}\n\n/**\n     * Helper method to get the value as a Java long from eight bytes\n     * starting at given array offset\n     * @param bytes the array of bytes\n     * @param offset the offset to start\n     * @return the corresponding Java long value",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    for (int i = 0; i < 8; i++) {\n        bytes[7 - i] = (byte) ((value.toByteArray()[i] & 0xFF));\n    }\n    return bytes;\n}\n\n/**\n     * Helper method to get the value as a Java long from eight bytes\n     * starting at given array offset\n     * @param bytes the array of bytes\n     * @param offset the offset to start\n     * @return the corresponding Java long value",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    for (int i = 0; i < 8; i++) {\n        bytes[7 - i] = (byte) (value.byteAt(7 - i));\n    }\n    return bytes;\n}\n\n/**\n     * Helper method to get the value as a Java long from eight bytes\n     * starting at given array offset\n     * @param bytes the array of bytes\n     * @param offset the offset to start\n     * @return the corresponding Java long value",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    for (int i = 0; i < 8; i++) {\n        bytes[7 - i] = (byte) (value.shiftRight(i * 8).and(0xFF));\n    }\n    return bytes;\n}\n\n/**\n     * Helper method to get the value as a Java long from eight bytes\n     * starting at given array offset\n     * @param bytes the array of bytes\n     * @param offset the offset to start\n     * @return the corresponding Java long value",
      "public static byte[] getBytes(final BigInteger value)  {\n    byte[] bytes = new byte[8];\n    for (int i = 0; i < 8; i++) {\n        bytes[7 - i] = (byte) ((value.shiftRight(8 * i).and(0xFF)).intValue());\n    }\n    return bytes;\n}\n\n/**\n     * Helper method to get the value as a Java long from eight bytes\n     * starting at given array offset\n     * @param bytes the array of bytes\n     * @param offset the offset to start\n     * @return the corresponding Java long value"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final StringBuilder buffer = new StringBuilder(str.length());\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        char lastChar = ' ';\n        char ch = ' ';\n        for (int i = 0; i < sz; i++) {\n            ch = chrs[i];\n            if (chars.contains(ch)) {\n                buffer.append(ch);\n                lastChar = ch;\n            }\n        }\n        return buffer.toString();\n    }",
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final StringBuilder buffer = new StringBuilder(str.length());\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        char lastChar = ' ';\n        char ch = ' ';\n        for (int i = 0; i < sz; i++) {\n            ch = chrs[i];\n            if (chars.contains(ch)) {\n                buffer.append(ch);\n                lastChar = ch;\n            }\n        }\n        return buffer.toString();\n    }",
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final StringBuilder buffer = new StringBuilder(str.length());\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        char lastChar = ' ';\n        char ch = ' ';\n        for (int i = 0; i < sz; i++) {\n            ch = chrs[i];\n            if (chars.contains(ch)) {\n                buffer.append(ch);\n                lastChar = ch;\n            }\n        }\n        return buffer.toString();\n    }",
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final StringBuilder buffer = new StringBuilder(str.length());\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        char lastChar = ' ';\n        char ch = ' ';\n        for (int i = 0; i < sz; i++) {\n            ch = chrs[i];\n            if (chars.contains(ch)) {\n                buffer.append(ch);\n                lastChar = ch;\n            }\n        }\n        return buffer.toString();\n    }",
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final StringBuilder buffer = new StringBuilder(str.length());\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        char lastChar = ' ';\n        char ch = ' ';\n        for (int i = 0; i < sz; i++) {\n            ch = chrs[i];\n            if (chars.contains(ch)) {\n                buffer.append(ch);\n                lastChar = ch;\n            }\n        }\n        return buffer.toString();\n    }",
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final StringBuilder buffer = new StringBuilder(str.length());\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        char lastChar = ' ';\n        char ch = ' ';\n        for (int i = 0; i < sz; i++) {\n            ch = chrs[i];\n            if (chars.contains(ch)) {\n                buffer.append(ch);\n                lastChar = ch;\n            }\n        }\n        return buffer.toString();\n    }",
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final StringBuilder buffer = new StringBuilder(str.length());\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for (int i = 0; i < sz; i++) {\n            final char c = chrs[i];\n            if (chars.contains(c)) {\n                buffer.append(c);\n            }\n        }\n        return buffer.toString();\n    }",
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final StringBuilder buffer = new StringBuilder(str.length());\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for (int i = 0; i < sz; i++) {\n            char ch = chrs[i];\n            if (chars.contains(ch)) {\n                buffer.append(ch);\n            }\n        }\n        return buffer.toString();\n    }",
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final StringBuilder buffer = new StringBuilder(str.length());\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        char lastChar = ' ';\n        char ch = ' ';\n        for (int i = 0; i < sz; i++) {\n            ch = chrs[i];\n            if (chars.contains(ch)) {\n                buffer.append(ch);\n                lastChar = ch;\n            }\n        }\n        return buffer.toString();\n    }",
      "public static String keep(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return str;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        final StringBuilder buffer = new StringBuilder(str.length());\n        final char[] chrs = str.toCharArray();\n        final int sz = chrs.length;\n        for (int i = 0; i < sz; i++) {\n            char ch = chrs[i];\n            if (chars.contains(ch)) {\n                buffer.append(ch);\n            }\n        }\n        return buffer.toString();\n    }"
    ],
    [
      "public RealMatrix getSquareRoot()  {\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    RealMatrix squareRoot = null;\n    for (int i = 0; i < realEigenvalues.length; i++) {\n        squareRoot = squareRoot.add(eigenvectors[i].multiply(realEigenvalues[i]));\n    }\n    return squareRoot;\n}\n\n/**\n * Gets a solver for finding the A &times; X = B solution in exact\n * linear sense.\n * <p>\n * Since 3.1, eigen decomposition of a general matrix is supported,\n * but the {@link DecompositionSolver} only supports real eigenvalues.\n *\n * @return a solver\n * @throws MathUnsupportedOperationException if the decomposition resulted in\n * complex eigenvalues",
      "public RealMatrix getSquareRoot()  {\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    RealMatrix sqrt = MatrixUtils.createRealMatrix(getDimension(), getDimension());\n    for (int i = 0; i < getDimension(); i++) {\n        for (int j = 0; j < getDimension(); j++) {\n            sqrt.setEntry(i, j, (double) Math.sqrt(getEntry(i, j)));\n        }\n    }\n    return sqrt;\n}\n\n/**\n * Gets a solver for finding the A &times; X = B solution in exact\n * linear sense.\n * <p>\n * Since 3.1, eigen decomposition of a general matrix is supported,\n * but the {@link DecompositionSolver} only supports real eigenvalues.\n *\n * @return a solver\n * @throws MathUnsupportedOperationException if the decomposition resulted in\n * complex eigenvalues",
      "public RealMatrix getSquareRoot()  {\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    RealMatrix sqrt = new Array2DRowRealMatrix(getDimension(), getDimension());\n    for (int i = 0; i < getDimension(); i++) {\n        for (int j = 0; j < getDimension(); j++) {\n            sqrt.setEntry(i, j, (double) Math.sqrt(getEntry(i, j)));\n        }\n    }\n    return sqrt;\n}\n\n/**\n     * Gets a solver for finding the A &times; X = B solution in exact\n     * linear sense.\n     * <p>\n     * Since 3.1, eigen decomposition of a general matrix is supported,\n     * but the {@link DecompositionSolver} only supports real eigenvalues.\n     *\n     * @return a solver\n     * @throws MathUnsupportedOperationException if the decomposition resulted in\n     * complex eigenvalues",
      "public RealMatrix getSquareRoot()  {\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    RealMatrix sqrt = new Array2DRowRealMatrix(getDimension(), getDimension());\n    for (int i = 0; i < getDimension(); i++) {\n        for (int j = 0; j < getDimension(); j++) {\n            sqrt.setEntry(i, j, Math.sqrt(getEntry(i, j)));\n        }\n    }\n    return sqrt;\n}",
      "public RealMatrix getSquareRoot()  {\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    int n = getDimension();\n    RealMatrix sqrt = MatrixUtils.createRealMatrix(n, n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            sqrt.setEntry(i, j, (double) Math.sqrt(getEntry(i, j)));\n        }\n    }\n    return sqrt;\n}\n\n/**\n * Gets a solver for finding the A &times; X = B solution in exact\n * linear sense.\n * <p>\n * Since 3.1, eigen decomposition of a general matrix is supported,\n * but the {@link DecompositionSolver} only supports real eigenvalues.\n *\n * @return a solver\n * @throws MathUnsupportedOperationException if the decomposition resulted in\n * complex eigenvalues",
      "public RealMatrix getSquareRoot()  {\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    RealMatrix squareRoot = null;\n    for (int i = 0; i < realEigenvalues.length; i++) {\n        double eigenvalue = realEigenvalues[i];\n        squareRoot = squareRoot.add(eigenvectors[i].multiply(eigenvalue).multiply(eigenvectors[i].transpose()));\n    }\n    return squareRoot;\n}\n\n/**\n * Gets a solver for finding the A &times; X = B solution in exact\n * linear sense.\n * <p>\n * Since 3.1, eigen decomposition of a general matrix is supported,\n * but the {@link DecompositionSolver} only supports real eigenvalues.\n *\n * @return a solver\n * @throws MathUnsupportedOperationException if the decomposition resulted in\n * complex eigenvalues",
      "public RealMatrix getSquareRoot()  {\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    final int m = getRowDimension();\n    final double[][] sqrtMatrix = new double[m][m];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            sqrtMatrix[i][j] = Math.sqrt(getEntry(i, j));\n        }\n    }\n    return new Array2DRowRealMatrix(sqrtMatrix, false);\n}\n\n/**\n * Gets a solver for finding the A &times; X = B solution in exact\n * linear sense.\n * <p>\n * Since 3.1, eigen decomposition of a general matrix is supported,\n * but the {@link DecompositionSolver} only supports real eigenvalues.\n *\n * @return a solver\n * @throws MathUnsupportedOperationException if the decomposition resulted in\n * complex eigenvalues",
      "public RealMatrix getSquareRoot()  {\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    RealMatrix squareRoot = null;\n    for (int i = 0; i < realEigenvalues.length; i++) {\n        double eigenvalue = realEigenvalues[i];\n        squareRoot = squareRoot.add(eigenvectors[i].elementMultiply(eigenvalue));\n    }\n    return squareRoot;\n}\n\n/**\n * Gets a solver for finding the A &times; X = B solution in exact\n * linear sense.\n * <p>\n * Since 3.1, eigen decomposition of a general matrix is supported,\n * but the {@link DecompositionSolver} only supports real eigenvalues.\n *\n * @return a solver\n * @throws MathUnsupportedOperationException if the decomposition resulted in\n * complex eigenvalues",
      "public RealMatrix getSquareRoot()  {\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    int m = getRealEigenvalues().length;\n    double[] sqrtEigenvalues = new double[m];\n    for (int i = 0; i < m; i++) {\n        sqrtEigenvalues[i] = Math.sqrt(getRealEigenvalues()[i]);\n    }\n    return new Array2DRowRealMatrix(sqrtEigenvalues, m, 1);\n}\n\n/**\n * Gets a solver for finding the A &times; X = B solution in exact\n * linear sense.\n * <p>\n * Since 3.1, eigen decomposition of a general matrix is supported,\n * but the {@link DecompositionSolver} only supports real eigenvalues.\n *\n * @return a solver\n * @throws MathUnsupportedOperationException if the decomposition resulted in\n * complex eigenvalues",
      "public RealMatrix getSquareRoot()  {\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException();\n    }\n    final int m = getRowDimension();\n    final double[][] sqrtMatrix = new double[m][m];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            sqrtMatrix[i][j] = Math.sqrt(getEntry(i, j));\n        }\n    }\n    return new Array2DRowRealMatrix(sqrtMatrix, false);\n}\n\n/**\n     * Gets a solver for finding the A &times; X = B solution in exact\n     * linear sense.\n     * <p>\n     * Since 3.1, eigen decomposition of a general matrix is supported,\n     * but the {@link DecompositionSolver} only supports real eigenvalues.\n     *\n     * @return a solver\n     * @throws MathUnsupportedOperationException if the decomposition resulted in\n     * complex eigenvalues"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \tif (t == JsonToken.START_OBJECT) {\n    \t\tt = p.nextToken();\n    \t}\n    \tfor (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n    \t\tString propName = p.getCurrentName();\n    \t\tp.nextToken();\n    \t\tSettableBeanProperty prop = _beanProperties.find(propName);\n    \t\tif (prop != null) {\n    \t\t\ttry {\n    \t\t\t\tprop.deserializeAndSet(p, ctxt, builder);\n    \t\t\t} catch (Exception e) {\n    \t\t\t\twrapAndThrow(e, builder, propName, ctxt);\n    \t\t\t}\n    \t\t\tcontinue;\n    \t\t}\n    \t\thandleUnknownVanilla(p, ctxt, builder, propName);\n    \t}\n    \treturn builder;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \tif (t == JsonToken.END_OBJECT) {\n    \t\treturn null;\n    \t}\n    \tif (t == JsonToken.END_ARRAY) {\n    \t\treturn null;\n    \t}\n    \tif (t == JsonToken.FIELD_NAME) {\n    \t\tString propName = p.getCurrentName();\n    \t\tp.nextToken();\n    \t\tSettableBeanProperty prop = _beanProperties.find(propName);\n    \t\tif (prop != null) {\n    \t\t\ttry {\n    \t\t\t\tprop.deserializeAndSet(p, ctxt, null);\n    \t\t\t} catch (Exception e) {\n    \t\t\t\twrapAndThrow(e, null, propName, ctxt);\n    \t\t\t}\n    \t\t} else {\n    \t\t\thandleUnknownVanilla(p, ctxt, null, propName);\n    \t\t}\n    \t}\n    \treturn null;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.START_OBJECT) {\n            p.nextToken();\n        }\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            // Skip field name:\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                try {\n                    prop.deserializeAndSet(p, ctxt, handledType());\n                } catch (Exception e) {\n                    wrapAndThrow(e, handledType(), propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, handledType(), propName);\n        }\n        return handledType();\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.START_OBJECT) {\n            t = p.nextToken();\n        }\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            // Skip field name:\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                try {\n                    prop.deserializeAndSet(p, ctxt, handledType());\n                } catch (Exception e) {\n                    wrapAndThrow(e, handledType(), propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, handledType(), propName);\n        }\n        return handledType();\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.END_OBJECT) {\n            return ctxt.handleInstantiationForCreation();\n        }\n        String propName = p.getCurrentName();\n        p.nextToken();\n        SettableBeanProperty prop = _beanProperties.find(propName);\n        if (prop != null) {\n            try {\n                return prop.deserializeAndSet(p, ctxt, handledType());\n            } catch (Exception e) {\n                wrapAndThrow(e, handledType(), propName, ctxt);\n            }\n        }\n        handleUnknownVanilla(p, ctxt, handledType(), propName);\n        return handledType();\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.END_OBJECT) {\n            return null;\n        }\n        String propName = p.getCurrentName();\n        p.nextToken();\n        SettableBeanProperty prop = _beanProperties.find(propName);\n        if (prop != null) {\n            try {\n                return prop.deserializeAndSet(p, ctxt, null);\n            } catch (Exception e) {\n                wrapAndThrow(e, null, propName, ctxt);\n            }\n        }\n        handleUnknownVanilla(p, ctxt, null, propName);\n        return null;\n     }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \tif (t == JsonToken.END_OBJECT) {\n    \t\treturn null;\n    \t}\n    \tif (t == JsonToken.END_ARRAY) {\n    \t\treturn null;\n    \t}\n    \tif (t == JsonToken.FIELD_NAME) {\n    \t\tp.nextToken();\n    \t\tString propName = p.getCurrentName();\n    \t\tp.nextToken();\n    \t\tSettableBeanProperty prop = _beanProperties.find(propName);\n    \t\tif (prop != null) {\n    \t\t\ttry {\n    \t\t\t\treturn prop.deserializeSetAndReturn(p, ctxt, null);\n    \t\t\t} catch (Exception e) {\n    \t\t\t\twrapAndThrow(e, null, propName, ctxt);\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn null;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.START_OBJECT) {\n            p.nextToken();\n        }\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            // Skip field name:\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            if (prop != null) { // normal case\n                try {\n                    prop.deserializeAndSet(p, ctxt, builder);\n                } catch (Exception e) {\n                    wrapAndThrow(e, builder, propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, builder, propName);\n        }\n        return builder;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.START_OBJECT) {\n            t = p.nextToken();\n        }\n        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n            String propName = p.getCurrentName();\n            // Skip field name:\n            p.nextToken();\n            SettableBeanProperty prop = _beanProperties.find(propName);\n            \n            if (prop != null) { // normal case\n                try {\n                    prop.deserializeAndSet(p, ctxt, handledType());\n                } catch (Exception e) {\n                    wrapAndThrow(e, handledType(), propName, ctxt);\n                }\n                continue;\n            }\n            handleUnknownVanilla(p, ctxt, handledType(), propName);\n        }\n        return handledType();\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n    \tif (t == JsonToken.START_OBJECT) {\n    \t\tt = p.nextToken();\n    \t}\n    \tfor (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n    \t\tString propName = p.getCurrentName();\n    \t\tp.nextToken();\n    \t\tSettableBeanProperty prop = _beanProperties.find(propName);\n    \t\tif (prop != null) { // normal case\n    \t\t\ttry {\n    \t\t\t\tprop.deserializeAndSet(p, ctxt, bean);\n    \t\t\t} catch (Exception e) {\n    \t\t\t\twrapAndThrow(e, bean, propName, ctxt);\n    \t\t\t}\n    \t\t\tcontinue;\n    \t\t}\n    \t\thandleUnknownVanilla(p, ctxt, bean, propName);\n    \t}\n    \treturn bean;\n    }"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}\n\n/**\n     * Returns the mean of the (signed) differences between corresponding elements of the\n     * input arrays -- i.e., sum(sample1[i] - sample2[i]) / sample1.length.\n     *\n     * @param sample1  the first array\n     * @param sample2  the second array\n     * @return mean of paired differences\n     * @throws DimensionMismatchException if the arrays do not have the same\n     * (positive) length.\n     * @throws NoDataException if the sample arrays are empty.",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        _append(fullChunk);\n        return _freeBuffer;\n    }\n\n    /**\n     * Method called to indicate that the buffering process is now\n     * complete; and to construct a combined exactly-sized result\n     * array. Additionally the buffer itself will be reset to\n     * reduce memory retention.\n     *<p>\n     * Resulting array will be of generic <code>Object[]</code> type:\n     * if a typed array is needed, use the method with additional\n     * type argument.",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (_head == null) {\n            _head = _tail = new LinkedNode<>(fullChunk);\n        } else {\n            _tail.next = new LinkedNode<>(fullChunk);\n            _tail = _tail.next;\n        }\n        _size += fullChunk.length;\n        return _freeBuffer;\n     }\n\n    /**\n     * Method called to indicate that the buffering process is now\n     * complete; and to construct a combined exactly-sized result\n     * array. Additionally the buffer itself will be reset to\n     * reduce memory retention.\n     *<p>\n     * Resulting array will be of generic <code>Object[]</code> type:\n     * if a typed array is needed, use the method with additional\n     * type argument.",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_head == null) {\n             _head = _tail = new LinkedNode<Object[]>(fullChunk);\n         } else {\n             _tail.next = new LinkedNode<Object[]>(fullChunk);\n             _tail = _tail.next;\n         }\n         _size += fullChunk.length;\n         return _freeBuffer;\n     }\n\n    /**\n     * Method called to indicate that the buffering process is now\n     * complete; and to construct a combined exactly-sized result\n     * array. Additionally the buffer itself will be reset to\n     * reduce memory retention.\n     *<p>\n     * Resulting array will be of generic <code>Object[]</code> type:\n     * if a typed array is needed, use the method with additional\n     * type argument.",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (_head == null) { // first chunk\n            _head = _tail = new LinkedNode<Object[]>(fullChunk, fullChunk.length);\n        } else { // have something already\n            _tail.linkNext(new LinkedNode<Object[]>(fullChunk, fullChunk.length));\n            _tail = _tail.next;\n        }\n        _size += fullChunk.length;\n        return _freeBuffer;\n    }\n\n    /**\n     * Method called to indicate that the buffering process is now\n     * complete; and to construct a combined exactly-sized result\n     * array. Additionally the buffer itself will be reset to\n     * reduce memory retention.\n     *<p>\n     * Resulting array will be of generic <code>Object[]</code> type:\n     * if a typed array is needed, use the method with additional\n     * type argument.",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (_freeBuffer == null) {\n            _freeBuffer = new Object[12];\n        }\n        if (_freeBuffer.length < _size + fullChunk.length) {\n            _freeBuffer = new Object[Math.max(12, _size + fullChunk.length)];\n        }\n        System.arraycopy(fullChunk, 0, _freeBuffer, _size, fullChunk.length);\n        _size += fullChunk.length;\n        return _freeBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (_freeBuffer == null) {\n            _reset();\n        }\n        if (_freeBuffer.length < fullChunk.length) {\n            _freeBuffer = new Object[Math.max(12, fullChunk.length)];\n        }\n        System.arraycopy(fullChunk, 0, _freeBuffer, 0, fullChunk.length);\n        return _freeBuffer;\n     }\n\n    /**\n     * Method called to indicate that the buffering process is now\n     * complete; and to construct a combined exactly-sized result\n     * array. Additionally the buffer itself will be reset to\n     * reduce memory retention.\n     *<p>\n     * Resulting array will be of generic <code>Object[]</code> type:\n     * if a typed array is needed, use the method with additional\n     * type argument.",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (_head == null) {\n            _head = _tail = new LinkedNode<Object[]>(fullChunk, null);\n        } else {\n            _tail.next = new LinkedNode<Object[]>(fullChunk, null);\n            _tail = _tail.next;\n        }\n        _size += fullChunk.length;\n        return _freeBuffer;\n    }\n\n    /**\n     * Method called to indicate that the buffering process is now\n     * complete; and to construct a combined exactly-sized result\n     * array. Additionally the buffer itself will be reset to\n     * reduce memory retention.\n     *<p>\n     * Resulting array will be of generic <code>Object[]</code> type:\n     * if a typed array is needed, use the method with additional\n     * type argument.",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        _copyTo(_freeBuffer, _freeBuffer.length, fullChunk, fullChunk.length);\n        return _freeBuffer;\n     }\n\n    /**\n     * Method called to indicate that the buffering process is now\n     * complete; and to construct a combined exactly-sized result\n     * array. Additionally the buffer itself will be reset to\n     * reduce memory retention.\n     *<p>\n     * Resulting array will be of generic <code>Object[]</code> type:\n     * if a typed array is needed, use the method with additional\n     * type argument.",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         if (_freeBuffer == null) {\n             _freeBuffer = new Object[12];\n         }\n         if (_freeBuffer.length < _size + fullChunk.length) {\n             _freeBuffer = new Object[Math.max(12, _size + fullChunk.length)];\n         }\n         System.arraycopy(fullChunk, 0, _freeBuffer, _size, fullChunk.length);\n         _size += fullChunk.length;\n         return _freeBuffer;\n     }\n\n    /**\n     * Method called to indicate that the buffering process is now\n     * complete; and to construct a combined exactly-sized result\n     * array. Additionally the buffer itself will be reset to\n     * reduce memory retention.\n     *<p>\n     * Resulting array will be of generic <code>Object[]</code> type:\n     * if a typed array is needed, use the method with additional\n     * type argument.",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n         _copyTo(_freeBuffer, _freeBuffer.length, fullChunk, fullChunk.length);\n         return _freeBuffer;\n     }\n\n    /**\n     * Method called to indicate that the buffering process is now\n     * complete; and to construct a combined exactly-sized result\n     * array. Additionally the buffer itself will be reset to\n     * reduce memory retention.\n     *<p>\n     * Resulting array will be of generic <code>Object[]</code> type:\n     * if a typed array is needed, use the method with additional\n     * type argument."
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n        appendPatternTo(bld, pattern);\n        return bld.toFormatter();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses the given pattern and appends the rules to the given\n     * DateTimeFormatterBuilder.\n     *\n     * @param bld  the builder\n     * @param pattern  pattern specification\n     * @throws IllegalArgumentException if the pattern is invalid\n     */\n    static void appendPatternTo(DateTimeFormatterBuilder bld, String pattern) {\n        for (int i = 0; i < pattern.length(); i++) {\n            char c = pattern.charAt(i);\n            switch (c) {\n                case 'y':\n                    bld.appendYear();\n                    break;\n                case 'M':\n                    bld.appendMonthOfYear();\n                    break;\n                case 'd':\n                    bld.appendDayOfMonth();\n                    break;\n                case 'H':\n                    bld.appendHourOfDay();\n                    break;\n                case 'm':\n                    bld.appendMinuteOfHour();\n                    break;\n                case 's':\n                    bld.appendSecondOfMinute();\n                    break;\n                case 'S':\n                    bld.appendSecondOfMinuteOptionalFraction(1);\n                    break;\n                case 'z':\n                    bld.appendZoneText();\n                    break;\n                case 'Z':\n                    bld.appendZoneOffset();\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Invalid pattern character: \" + c);\n            }\n        }\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n        appendPatternTo(bld, pattern);\n        return bld.toFormatter();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Select a format from a custom pattern and append it to the given\n     * DateTimeFormatterBuilder.\n     *\n     * @param bld  the builder\n     * @param pattern  pattern specification\n     * @throws IllegalArgumentException if the pattern is invalid\n     */\n    static void appendPatternTo(DateTimeFormatterBuilder bld, String pattern) {\n        // This is a very simple parser, it does not support all the\n        // features of SimpleDateFormat.\n        int len = pattern.length();\n        for (int i = 0; i < len; i++) {\n            char c = pattern.charAt(i);\n            switch (c) {\n                case 'y':\n                    bld.appendYear();\n                    break;\n                case 'M':\n                    bld.appendMonthOfYear();\n                    break;\n                case 'd':\n                    bld.appendDayOfMonth();\n                    break;\n                case 'H':\n                    bld.appendHourOfDay();\n                    break;\n                case 'm':\n                    bld.appendMinuteOfHour();\n                    break;\n                case 's':\n                    bld.appendSecondOfMinute();\n                    break;\n                case 'S':\n                    bld.appendSecondOfMinuteOptionalFraction(1);\n                    break;\n                case 'Z':\n                    bld.appendOffsetId();\n                    break;\n                case 'X':\n                    bld.appendOffsetId();\n                    break;\n                case 'T':\n                    bld.appendLiteral('T');\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Invalid pattern character: \" + c);\n            }\n        }\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n        appendPatternTo(bld, pattern);\n        return bld.toFormatter();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses the given pattern and appends the rules to the given\n     * DateTimeFormatterBuilder.\n     *\n     * @param bld  the builder\n     * @param pattern  pattern specification\n     * @throws IllegalArgumentException if the pattern is invalid\n     */\n    static void appendPatternTo(DateTimeFormatterBuilder bld, String pattern) {\n        int len = pattern.length();\n        for (int i = 0; i < len; i++) {\n            char c = pattern.charAt(i);\n            switch (c) {\n                case 'G':\n                    bld.appendEra();\n                    break;\n                case 'C':\n                    bld.appendCenturyOfEra();\n                    break;\n                case 'Y':\n                    bld.appendYearOfEra();\n                    break;\n                case 'x':\n                    bld.appendWeekyear();\n                    break;\n                case 'w':\n                    bld.appendWeekOfWeekyear();\n                    break;\n                case 'e':\n                    bld.appendDayOfWeek();\n                    break;\n                case 'E':\n                    bld.appendTextDayOfWeek();\n                    break;\n                case 'y':\n                    bld.appendYear();\n                    break;\n                case 'D':\n                    bld.appendDayOfYear();\n                    break;\n                case 'M':\n                    bld.appendMonthOfYear();\n                    break;\n                case 'd':\n                    bld.appendDayOfMonth();\n                    break;\n                case 'T':\n                    bld.appendLiteral('T');\n                    break;\n                case '-':\n                    bld.appendLiteral('-');\n                    break;\n                default:\n                    throw new DateTimeParseException(\"Invalid pattern character: \" + c);\n            }\n        }\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    appendPatternTo(bld, pattern);\n    return bld.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    appendPatternTo(bld, pattern);\n    return bld.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n        appendPatternTo(bld, pattern);\n        return bld.toFormatter();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Parses the given pattern and appends the rules to the given\n     * DateTimeFormatterBuilder.\n     *\n     * @param bld  the builder\n     * @param pattern  pattern specification\n     * @throws IllegalArgumentException if the pattern is invalid\n     */\n    static void appendPatternTo(DateTimeFormatterBuilder bld, String pattern) {\n        // Remove any leading or trailing whitespace\n        pattern = pattern.trim();\n\n        // Split the pattern into date and time parts\n        String[] parts = pattern.split(\"(?<!\\\\\\\\)T\");\n\n        // Process each part\n        for (String part : parts) {\n            if (part.length() > 0) {\n                // Handle date part\n                if (part.matches(\"\\\\d{4}\")) {\n                    bld.appendYear(4);\n                } else if (part.matches(\"\\\\d{2}\")) {\n                    bld.appendYear(2);\n                } else if (part.matches(\"\\\\d{1}\")) {\n                    bld.appendYear(1);\n                } else if (part.matches(\"\\\\d{1,4}-\\\\d{1,2}-\\\\d{1,2}\")) {\n                    bld.appendDate();\n                } else {\n                    throw new IllegalArgumentException(\"Invalid date pattern: \" + part);\n                }\n\n                // Handle time part\n                if (part.matches(\"\\\\d{2}:\\\\d{2}(:\\\\d{2})?\")) {\n                    bld.appendTime();\n                } else if (part.matches(\"\\\\d{2}\")) {\n                    bld.appendHour(2);\n                } else if (part.matches(\"\\\\d{1,2}\")) {\n                    bld.appendHour(1);\n                } else {\n                    throw new IllegalArgumentException(\"Invalid time pattern: \" + part);\n                }\n            }\n        }\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    appendPatternTo(bld, pattern);\n    return bld.toFormatter();\n}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Select a format from a custom pattern.\n     *\n     * @param bld  the builder\n     * @param pattern  pattern specification\n     * @throws IllegalArgumentException if the pattern is invalid",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    appendPatternTo(bld, pattern);\n    return bld.toFormatter();\n}\n\n    //-----------------------------------------------------------------------\n    /**\n     * Select a format from a custom pattern.\n     *\n     * @param bld  the builder\n     * @param pattern  pattern specification\n     * @throws IllegalArgumentException if the pattern is invalid\n     */\n    static void appendPatternTo(DateTimeFormatterBuilder bld, String pattern) {\n        // parse the pattern\n        // check if the pattern is valid\n        // if valid, append the rules to the builder\n        // if invalid, throw an exception\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n        appendPatternTo(bld, pattern);\n        return bld.toFormatter();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Select a format from a custom pattern and append it to the given\n     * DateTimeFormatterBuilder.\n     *\n     * @param bld  the builder\n     * @param pattern  pattern specification\n     * @throws IllegalArgumentException if the pattern is invalid\n     */\n    static void appendPatternTo(DateTimeFormatterBuilder bld, String pattern) {\n        int i = 0;\n        int len = pattern.length();\n        while (i < len) {\n            char c = pattern.charAt(i);\n            switch (c) {\n                case 'G':\n                    bld.appendYearOfEra();\n                    i++;\n                    break;\n                case 'C':\n                    bld.appendCenturyOfEra();\n                    i++;\n                    break;\n                case 'Y':\n                    bld.appendYear();\n                    i++;\n                    break;\n                case 'x':\n                    bld.appendWeekyear();\n                    i++;\n                    break;\n                case 'w':\n                    bld.appendWeekOfWeekyear();\n                    i++;\n                    break;\n                case 'e':\n                    bld.appendDayOfWeek();\n                    i++;\n                    break;\n                case 'E':\n                    bld.appendTextDayOfWeek();\n                    i++;\n                    break;\n                case 'y':\n                    bld.appendYear();\n                    i++;\n                    break;\n                case 'D':\n                    bld.appendDayOfYear();\n                    i++;\n                    break;\n                case 'M':\n                    bld.appendMonthOfYear();\n                    i++;\n                    break;\n                case 'd':\n                    bld.appendDayOfMonth();\n                    i++;\n                    break;\n                case '-':\n                    bld.appendLiteral('-');\n                    i++;\n                    break;\n                default:\n                    throw new DateTimeParseException(\"Invalid pattern character: \" + c);\n            }\n        }\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n    appendPatternTo(bld, pattern);\n    return bld.toFormatter();\n}"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.STRING && stream.getString().equals(\"null\")) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.STRING && stream.getString().equals(\"undefined\")) {\n      return newNode(Token.UNDEFINED);\n    } else {\n      return parseTypeName(token);\n    }\n  }\n\n  /**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.STRING) {\n      return parseTypeName(token);\n    } else if (token == JsDocToken.FUNCTION) {\n      return parseFunctionType(token);\n    } else if (token == JsDocToken.NULL) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n      return newNode(Token.UNDEFINED);\n    } else {\n      return reportBasicTypeSyntaxWarning();\n    }\n}\n\n/**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.STRING && stream.getString().equals(\"null\")) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.STRING && stream.getString().equals(\"undefined\")) {\n      return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.STRING) {\n      return parseTypeName(token);\n    } else if (token == JsDocToken.FUNCTION) {\n      return parseFunctionType(token);\n    } else {\n      return reportBasicTypeSyntaxWarning();\n    }\n  }\n\n  /**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.STRING && stream.getString().equals(\"null\")) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.STRING && stream.getString().equals(\"undefined\")) {\n      return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.STRING) {\n      return parseTypeName(token);\n    } else {\n      return reportGenericTypeSyntaxWarning();\n    }\n  }\n\n  /**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STRING) {\n      String typeName = stream.getString();\n      int lineno = stream.getLineno();\n      int charno = stream.getCharno();\n      while (match(JsDocToken.EOL) &&\n          typeName.charAt(typeName.length() - 1) == '.') {\n        skipEOLs();\n        if (match(JsDocToken.STRING)) {\n          next();\n          typeName += stream.getString();\n        }\n      }\n\n      Node typeNameNode = newStringNode(typeName, lineno, charno);\n\n      if (match(JsDocToken.LT)) {\n        next();\n        skipEOLs();\n        Node memberType = parseTypeExpressionList(next());\n        if (memberType != null) {\n          typeNameNode.addChildToFront(memberType);\n\n          skipEOLs();\n          if (!match(JsDocToken.GT)) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n          }\n        }\n      }\n      return typeNameNode;\n    } else if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n      return newNode(Token.UNDEFINED);\n    } else {\n      return reportGenericTypeSyntaxWarning();\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STRING) {\n      String typeName = stream.getString();\n      int lineno = stream.getLineno();\n      int charno = stream.getCharno();\n      while (match(JsDocToken.EOL) &&\n          typeName.charAt(typeName.length() - 1) == '.') {\n        skipEOLs();\n        if (match(JsDocToken.STRING)) {\n          next();\n          typeName += stream.getString();\n        }\n      }\n\n      Node typeNameNode = newStringNode(typeName, lineno, charno);\n\n      if (match(JsDocToken.LT)) {\n        next();\n        skipEOLs();\n        Node memberType = parseTypeExpressionList(next());\n        if (memberType != null) {\n          typeNameNode.addChildToFront(memberType);\n\n          skipEOLs();\n          if (!match(JsDocToken.GT)) {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n          }\n        }\n      }\n\n      return typeNameNode;\n    } else if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n      return newNode(Token.UNDEFINED);\n    } else {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.unknown.type\");\n    }\n  }\n\n  /**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STRING) {\n      return parseTypeName(token);\n    } else if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n      return newNode(Token.UNDEFINED);\n    } else {\n      return reportBasicTypeSyntaxWarning();\n    }\n  }\n\n  /**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STRING) {\n      String typeName = stream.getString();\n      int lineno = stream.getLineno();\n      int charno = stream.getCharno();\n      while (match(JsDocToken.EOL) &&\n              typeName.charAt(typeName.length() - 1) == '.') {\n        skipEOLs();\n        if (match(JsDocToken.STRING)) {\n          next();\n          typeName += stream.getString();\n        }\n      }\n\n      Node typeNameNode = newStringNode(typeName, lineno, charno);\n\n      if (match(JsDocToken.LT)) {\n        next();\n        skipEOLs();\n        Node memberType = parseTypeExpressionList(next());\n        if (memberType != null) {\n          typeNameNode.addChildToFront(memberType);\n\n          skipEOLs();\n          if (!match(JsDocToken.GT)) {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n          }\n        }\n      }\n\n      return typeNameNode;\n    } else if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.NULL) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n      return newNode(Token.UNDEFINED);\n    } else {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.unknown.type\");\n    }\n  }",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.STRING) {\n      return parseTypeName(token);\n    } else if (token == JsDocToken.FUNCTION) {\n      return parseFunctionType(token);\n    } else if (token == JsDocToken.UNION) {\n      return parseUnionType(token);\n    } else if (token == JsDocToken.RECORD) {\n      return parseRecordType(token);\n    } else if (token == JsDocToken.ARRAY) {\n      return parseArrayType(token);\n    } else if (token == JsDocToken.NULL) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n      return newNode(Token.UNDEFINED);\n    } else {\n      return reportBasicTypeSyntaxWarning();\n    }\n  }\n\n  /**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.STRING) {\n      return parseTypeName(token);\n    } else if (token == JsDocToken.FUNCTION) {\n      return parseFunctionType(token);\n    } else if (token == JsDocToken.UNION) {\n      return parseUnionType(token);\n    } else if (token == JsDocToken.RECORD) {\n      return parseRecordType(token);\n    } else if (token == JsDocToken.ARRAY) {\n      return parseArrayType(token);\n    } else if (token == JsDocToken.NULL) {\n      return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n      return newNode(Token.UNDEFINED);\n    } else {\n      return reportGenericTypeSyntaxWarning();\n    }\n  }\n\n  /**\n   * ContextTypeExpression := BasicTypeExpression | '?'\n   * For expressions on the right hand side of a this: or new:"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    beforeName();\n    string(name);\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    beforeName();\n    string(name);\n    return this;\n}\n\n/**\n   * Ends encoding the current object.\n   *\n   * @return this writer.\n   */",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    beforeName();\n    string(name);\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    beforeName();\n    out.append(name);\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    beforeName();\n    string(name);\n    return this;\n}\n\n/**\n   * Begins encoding a new array. Each call to this method must be paired with\n   * a call to {@link #endArray}.\n   *\n   * @return this writer.",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    beforeName();\n    string(name);\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    beforeName();\n    string(name);\n    return this;\n  }\n\n  /**\n   * Ends encoding the current object.\n   *\n   * @return this writer.",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    beforeName();\n    string(name);\n    return this;\n  }\n\n  /**\n   * Ends encoding the current object.\n   *\n   * @return this writer.",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    beforeName();\n    string(name);\n    return this;\n  }",
      "public JsonWriter name(String name) throws IOException  {\n    writeDeferredName();\n    beforeName();\n    string(name);\n    return this;\n}\n\n/**\n   * Ends encoding the current object.\n   *\n   * @return this writer.\n   */"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double positive = 0.0;\n        double negative = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive = positive + value;\n                }\n                if (value < 0.0) {\n                    negative = negative + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, negative);\n    }\n    if (hasValidData) {\n        return new Double(minimum);\n    }\n    else {\n        return null;\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        if (total < minimum) {\n            minimum = total;\n        }\n    }\n    if (hasValidData) {\n        return new Double(minimum);\n    } else {\n        return null;\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double positive = 0.0;\n        double negative = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive += value;\n                }\n                if (value < 0.0) {\n                    negative += value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, negative);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total += value;\n                }\n            }\n        }\n        if (hasValidData) {\n            result = new Double(total);\n        }\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double positive = 0.0;\n        double negative = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive = positive + value;\n                }\n                if (value < 0.0) {\n                    negative = negative + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, negative);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        if (total < minimum) {\n            minimum = total;\n        }\n    }\n    if (hasValidData) {\n        return new Double(minimum);\n    } else {\n        return null;\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total += value;\n                }\n            }\n        }\n        if (hasValidData) {\n            result = new Double(total);\n        }\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        if (hasValidData) {\n            result = new Double(total);\n        }\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        if (hasValidData) {\n            result = new Double(total);\n        }\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = 0.0;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        if (hasValidData) {\n            result = new Double(total);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element != null && element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element != null && element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) {\n        if (element != null && element) {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } catch (final NullPointerException ex) {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return \"\";\n    }\n    final StringBuilder result = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < len; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            result.append(Character.toUpperCase(ch));\n            capitalizeNext = false;\n        } else {\n            result.append(ch);\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final char[] buffer = str.toCharArray();\n    StringBuilder result = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            result.append(Character.toUpperCase(ch));\n            capitalizeNext = false;\n        } else {\n            result.append(ch);\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final char[] buffer = str.toCharArray();\n    StringBuilder result = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            result.append(Character.toUpperCase(ch));\n            capitalizeNext = false;\n        } else {\n            result.append(ch);\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return \"\";\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < len; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            sb.append(Character.toLowerCase(ch));\n            uncapitalizeNext = false;\n        } else {\n            sb.append(ch);\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return \"\";\n    }\n    final StringBuilder sb = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < len; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            sb.append(Character.toUpperCase(ch));\n            capitalizeNext = false;\n        } else {\n            sb.append(ch);\n        }\n    }\n    return sb.toString();\n}\n\n/**\n     * Is the character a delimiter.\n     *\n     * @param ch  the character to check\n     * @param delimiters  the delimiters\n     * @return true if it is a delimiter",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final char[] buffer = str.toCharArray();\n    StringBuilder result = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            result.append(Character.toUpperCase(ch));\n            capitalizeNext = false;\n        } else {\n            result.append(ch);\n        }\n    }\n    return result.toString();\n}\n\n/**\n     * <p>Extracts the initial letters from each word in the String.</p>\n     * \n     * <p>The first letter of the string and all first letters after\n     * whitespace are returned as a new string.\n     * Their case is not changed.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * WordUtils.initials(null)             = null\n     * WordUtils.initials(\"\")               = \"\"\n     * WordUtils.initials(\"Ben John Lee\")   = \"BJL\"\n     * WordUtils.initials(\"Ben J.Lee\")      = \"BJ\"\n     * </pre>\n     *\n     * @param str  the String to get initials from, may be null\n     * @return String of initial letters, <code>null</code> if null String input\n     * @see #initials(String,char[])\n     * @since 2.2",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return \"\";\n    }\n    final StringBuilder result = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < len; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            result.append(Character.toUpperCase(ch));\n            capitalizeNext = false;\n        } else {\n            result.append(ch);\n        }\n    }\n    return result.toString();\n}\n\n/**\n     * <p>Extracts the initial letters from each word in the String.</p>\n     * \n     * <p>The first letter of the string and all first letters after\n     * whitespace are returned as a new string.\n     * Their case is not changed.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * WordUtils.initials(null)             = null\n     * WordUtils.initials(\"\")               = \"\"\n     * WordUtils.initials(\"Ben John Lee\")   = \"BJL\"\n     * WordUtils.initials(\"Ben J.Lee\")      = \"BJ\"\n     * </pre>\n     *\n     * @param str  the String to get initials from, may be null\n     * @return String of initial letters, <code>null</code> if null String input\n     * @see #initials(String,char[])\n     * @since 2.2",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return \"\";\n    }\n    final StringBuilder sb = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < len; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            sb.append(Character.toUpperCase(ch));\n            capitalizeNext = false;\n        } else {\n            sb.append(ch);\n        }\n    }\n    return sb.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final char[] buffer = str.toCharArray();\n    final StringBuilder result = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            result.append(Character.toUpperCase(ch));\n            capitalizeNext = false;\n        } else {\n            result.append(ch);\n        }\n    }\n    return result.toString();\n}\n\n/**\n     * <p>Extracts the initial letters from each word in the String.</p>\n     * \n     * <p>The first letter of the string and all first letters after\n     * whitespace are returned as a new string.\n     * Their case is not changed.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * WordUtils.initials(null)             = null\n     * WordUtils.initials(\"\")               = \"\"\n     * WordUtils.initials(\"Ben John Lee\")   = \"BJL\"\n     * WordUtils.initials(\"Ben J.Lee\")      = \"BJ\"\n     * </pre>\n     *\n     * @param str  the String to get initials from, may be null\n     * @return String of initial letters, <code>null</code> if null String input\n     * @see #initials(String,char[])\n     * @since 2.2",
      "public static String initials(final String str, final char... delimiters)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return \"\";\n    }\n    final StringBuilder sb = new StringBuilder();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < len; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            sb.append(Character.toUpperCase(ch));\n            capitalizeNext = false;\n        } else {\n            sb.append(ch);\n        }\n    }\n    return sb.toString();\n}\n\n/**\n     * <p>Extracts the initial letters from each word in the String.</p>\n     * \n     * <p>The first letter of the string and all first letters after\n     * whitespace are returned as a new string.\n     * Their case is not changed.</p>\n     *\n     * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.\n     * A <code>null</code> input String returns <code>null</code>.</p>\n     *\n     * <pre>\n     * WordUtils.initials(null)             = null\n     * WordUtils.initials(\"\")               = \"\"\n     * WordUtils.initials(\"Ben John Lee\")   = \"BJL\"\n     * WordUtils.initials(\"Ben J.Lee\")      = \"BJ\"\n     * </pre>\n     *\n     * @param str  the String to get initials from, may be null\n     * @return String of initial letters, <code>null</code> if null String input\n     * @see #initials(String,char[])\n     * @since 2.2"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}\n\n/**\n     * Returns the total of the values in one column of the supplied data\n     * table by taking only the row numbers in the array into account.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param column  the column index (zero-based).\n     * @param validRows the array with valid rows (zero-based).\n     *\n     * @return The total of the valid values in the specified column.\n     *\n     * @since 1.0.13",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}\n\n/**\n     * Returns the total of the values in one column of the supplied data\n     * table by taking only the row numbers in the array into account.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param column  the column index (zero-based).\n     * @param validRows the array with valid rows (zero-based).\n     *\n     * @return The total of the valid values in the specified column.\n     *\n     * @since 1.0.13",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}\n\n/**\n     * Returns the total of the values in one column of the supplied data\n     * table by taking only the row numbers in the array into account.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param column  the column index (zero-based).\n     * @param validRows the array with valid rows (zero-based).\n     *\n     * @return The total of the valid values in the specified column.\n     *\n     * @since 1.0.13",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}\n\n/**\n     * Returns the total of the values in one column of the supplied data\n     * table by taking only the row numbers in the array into account.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param column  the column index (zero-based).\n     * @param validRows the array with valid rows (zero-based).\n     *\n     * @return The total of the valid values in the specified column.\n     *\n     * @since 1.0.13",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}\n\n/**\n     * Returns the total of the values in one column of the supplied data\n     * table by taking only the row numbers in the array into account.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param column  the column index (zero-based).\n     * @param validRows the array with valid rows (zero-based).\n     *\n     * @return The total of the valid values in the specified column.\n     *\n     * @since 1.0.13",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}\n\n/**\n     * Returns the total of the values in one column of the supplied data\n     * table by taking only the row numbers in the array into account.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param column  the column index (zero-based).\n     * @param validRows the array with valid rows (zero-based).\n     *\n     * @return The total of the valid values in the specified column.\n     *\n     * @since 1.0.13",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}\n\n/**\n     * Returns the total of the values in one column of the supplied data\n     * table by taking only the row numbers in the array into account.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param column  the column index (zero-based).\n     * @param validRows the array with valid rows (zero-based).\n     *\n     * @return The total of the valid values in the specified column.\n     *\n     * @since 1.0.13",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}\n\n/**\n     * Returns the total of the values in one column of the supplied data\n     * table by taking only the row numbers in the array into account.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param column  the column index (zero-based).\n     * @param validRows the array with valid rows (zero-based).\n     *\n     * @return The total of the valid values in the specified column.\n     *\n     * @since 1.0.13",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}\n\n/**\n     * Returns the total of the values in one column of the supplied data\n     * table by taking only the row numbers in the array into account.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param column  the column index (zero-based).\n     * @param validRows the array with valid rows (zero-based).\n     *\n     * @return The total of the valid values in the specified column.\n     *\n     * @since 1.0.13",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int row = 0; row < rowCount; row++) {\n        Number n = data.getValue(row, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}\n\n/**\n     * Returns the total of the values in one column of the supplied data\n     * table by taking only the row numbers in the array into account.\n     *\n     * @param data  the table of values (<code>null</code> not permitted).\n     * @param column  the column index (zero-based).\n     * @param validRows the array with valid rows (zero-based).\n     *\n     * @return The total of the valid values in the specified column.\n     *\n     * @since 1.0.13"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}\n\n/**\n     * Translates a Java2D point on the chart to a screen location.\n     *\n     * @param java2DPoint  the Java2D point.\n     *\n     * @return The screen location.",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}\n\n/**\n     * Translates a Java2D point on the chart to a screen location.\n     *\n     * @param java2DPoint  the Java2D point.\n     *\n     * @return The screen location.",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Point2D result = null;\n    if (this.chart != null) {\n        result = this.chart.translateJava2DToScreen(screenPoint);\n    }\n    return result;\n}\n\n/**\n * Returns the chart entity at a given point.\n * <P>\n * This method will return null if there is (a) no entity at the given\n * point, or (b) no entity collection has been generated.\n *\n * @param viewX  the x-coordinate.\n * @param viewY  the y-coordinate.\n *\n * @return The chart entity (possibly <code>null</code>).",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}\n\n/**\n     * Translates a Java2D point on the chart to a screen location.\n     *\n     * @param java2DPoint  the Java2D point.\n     *\n     * @return The screen location.",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}\n\n/**\n     * Translates a Java2D point on the chart to a screen location.\n     *\n     * @param java2DPoint  the Java2D point.\n     *\n     * @return The screen location.",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Point2D result = new Point2D.Double();\n    result.setLocation(screenPoint.x - getInsets().left / this.scaleX,\n                       screenPoint.y - getInsets().top / this.scaleY);\n    return result;\n}\n\n/**\n     * Translates a Java2D point on the chart to a screen location.\n     *\n     * @param java2DPoint  the Java2D point.\n     *\n     * @return The screen location.",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}\n\n/**\n     * Translates a Java2D point on the chart to a screen location.\n     *\n     * @param java2DPoint  the Java2D point.\n     *\n     * @return The screen location.",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}\n\n/**\n     * Translates a Java2D point on the chart to a screen location.\n     *\n     * @param java2DPoint  the Java2D point.\n     *\n     * @return The screen location.",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}\n\n/**\n     * Translates a Java2D point on the chart to a screen location.\n     *\n     * @param java2DPoint  the Java2D point.\n     *\n     * @return The screen location.",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    Insets insets = getInsets();\n    double x = (screenPoint.x - insets.left) / this.scaleX;\n    double y = (screenPoint.y - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}\n\n/**\n     * Translates a Java2D point on the chart to a screen location.\n     *\n     * @param java2DPoint  the Java2D point.\n     *\n     * @return The screen location."
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }\n\n    /**\n     * Parses a string to produce a {@link BigFraction} object.\n     * This method expects the string to be formatted as an improper BigFraction.\n     * @param source the string to parse\n     * @param pos input/output parsing parameter.\n     * @return the parsed {@link BigFraction} object.\n     */",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }\n\n    /**\n     * Parses a string to produce a {@link BigFraction} object.\n     * This method expects the string to be formatted as an improper BigFraction.\n     * @param source the string to parse\n     * @param pos input/output parsing parameter.\n     * @return the parsed {@link BigFraction} object.\n     */",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }\n\n    /**\n     * Parses a string to produce a {@link BigFraction} object.  This method\n     * expects the string to be formatted as an improper BigFraction.\n     * @param source the string to parse\n     * @param pos input/output parsing parameter.\n     * @return the parsed {@link BigFraction} object.\n     */",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }\n\n    /**\n     * Parses a string to produce a {@link BigFraction} object.\n     * This method expects the string to be formatted as an improper BigFraction.\n     * @param source the string to parse\n     * @param pos input/output parsing parameter.\n     * @return the parsed {@link BigFraction} object.\n     */",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }\n\n    /**\n     * Parses a string to produce a {@link BigFraction} object.\n     * This method expects the string to be formatted as an improper BigFraction.\n     * @param source the string to parse\n     * @param pos input/output parsing parameter.\n     * @return the parsed {@link BigFraction} object.\n     */",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }\n\n    /**\n     * Parses a string to produce a {@link BigFraction} object.\n     * This method expects the string to be formatted as an improper BigFraction.\n     * @param source the string to parse\n     * @param pos input/output parsing parameter.\n     * @return the parsed {@link BigFraction} object.\n     */",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }\n\n    /**\n     * Parses a string to produce a {@link BigFraction} object.  This method\n     * expects the string to be formatted as a proper BigFraction.\n     * @param source the string to parse\n     * @param pos input/output parsing parameter.\n     * @return the parsed {@link BigFraction} object.\n     */",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }\n\n    /**\n     * Parses a string to produce a {@link BigFraction} object.\n     * This method expects the string to be formatted as an improper BigFraction.\n     * @param source the string to parse\n     * @param pos input/output parsing parameter.\n     * @return the parsed {@link BigFraction} object.\n     */",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }\n\n    /**\n     * Parses a string to produce a {@link BigFraction} object.\n     * This method expects the string to be formatted as an improper BigFraction.\n     * @param source the string to parse\n     * @param pos input/output parsing parameter.\n     * @return the parsed {@link BigFraction} object.\n     */",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }\n\n    /**\n     * Parses a string to produce a {@link BigFraction} object.  This method\n     * expects the string to be formatted as a proper BigFraction.\n     * @param source the string to parse\n     * @param pos input/ouput parsing parameter.\n     * @return the parsed {@link BigFraction} object.\n     */"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(list), new ArrayList<E>(list));\n}\n\n/**\n     * Factory method to create an ordered set specifying the list and set to use.\n     * <p>\n     * The list and set must both be empty.\n     *\n     * @param <E> the element type\n     * @param set the set to decorate, must be empty and not null\n     * @param list the list to decorate, must be empty and not null\n     * @return a new ordered set\n     * @throws NullPointerException if set or list is null\n     * @throws IllegalArgumentException if either the set or list is not empty\n     * @since 4.0",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}\n\n/**\n * Factory method to create an ordered set specifying the list and set to use.\n * <p>\n * The list and set must both be empty.\n *\n * @param <E> the element type\n * @param set the set to decorate, must be empty and not null\n * @param list the list to decorate, must be empty and not null\n * @return a new ordered set\n * @throws NullPointerException if set or list is null\n * @throws IllegalArgumentException if either the set or list is not empty\n * @since 4.0",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(list), new ArrayList<E>(list));\n}\n\n/**\n     * Factory method to create an ordered set specifying the list and set to use.\n     * <p>\n     * The list and set must both be empty.\n     *\n     * @param <E> the element type\n     * @param set the set to decorate, must be empty and not null\n     * @param list the list to decorate, must be empty and not null\n     * @return a new ordered set\n     * @throws NullPointerException if set or list is null\n     * @throws IllegalArgumentException if either the set or list is not empty\n     * @since 4.0",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(list), new ArrayList<E>(list));\n}\n\n/**\n     * Factory method to create an ordered set specifying the list and set to use.\n     * <p>\n     * The list and set must both be empty.\n     *\n     * @param <E> the element type\n     * @param set the set to decorate, must be empty and not null\n     * @param list the list to decorate, must be empty and not null\n     * @return a new ordered set\n     * @throws NullPointerException if set or list is null\n     * @throws IllegalArgumentException if either the set or list is not empty\n     * @since 4.0",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(list), new ArrayList<E>(list));\n}\n\n/**\n     * Factory method to create an ordered set specifying the list and set to use.\n     * <p>\n     * The list and set must both be empty.\n     *\n     * @param <E> the element type\n     * @param set the set to decorate, must be empty and not null\n     * @param list the list to decorate, must be empty and not null\n     * @return a new ordered set\n     * @throws NullPointerException if set or list is null\n     * @throws IllegalArgumentException if either the set or list is not empty\n     * @since 4.0",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    Set<E> set = new HashSet<E>(list);\n    List<E> order = new ArrayList<E>(list);\n    return new ListOrderedSet<E>(set, order);\n}\n\n/**\n     * Factory method to create an ordered set specifying the list and set to use.\n     * <p>\n     * The list and set must both be empty.\n     *\n     * @param <E> the element type\n     * @param set the set to decorate, must be empty and not null\n     * @param list the list to decorate, must be empty and not null\n     * @return a new ordered set\n     * @throws NullPointerException if set or list is null\n     * @throws IllegalArgumentException if either the set or list is not empty\n     * @since 4.0",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}\n\n/**\n     * Factory method to create an ordered set specifying the list and set to use.\n     * <p>\n     * The list and set must both be empty.\n     *\n     * @param <E> the element type\n     * @param set the set to decorate, must be empty and not null\n     * @param list the list to decorate, must be empty and not null\n     * @return a new ordered set\n     * @throws NullPointerException if set or list is null\n     * @throws IllegalArgumentException if either the set or list is not empty\n     * @since 4.0",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(list), new ArrayList<E>(list));\n}\n\n/**\n     * Factory method to create an ordered set specifying the list and set to use.\n     * <p>\n     * The list and set must both be empty.\n     *\n     * @param <E> the element type\n     * @param set the set to decorate, must be empty and not null\n     * @param list the list to decorate, must be empty and not null\n     * @return a new ordered set\n     * @throws NullPointerException if set or list is null\n     * @throws IllegalArgumentException if either the set or list is not empty\n     * @since 4.0",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    return new ListOrderedSet<E>(new HashSet<E>(list), list);\n}\n\n/**\n     * Factory method to create an ordered set specifying the list and set to use.\n     * <p>\n     * The list and set must both be empty.\n     *\n     * @param <E> the element type\n     * @param set the set to decorate, must be empty and not null\n     * @param list the list to decorate, must be empty and not null\n     * @return a new ordered set\n     * @throws NullPointerException if set or list is null\n     * @throws IllegalArgumentException if either the set or list is not empty\n     * @since 4.0"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis instanceof CategoryAxis) {\n        return getDomainAxis().getRange();\n    } else {\n        return getRangeAxis().getRange();\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis instanceof CategoryAxis) {\n        return new Range(0, getDatasetCount() - 1);\n    } else if (axis instanceof NumberAxis) {\n        NumberAxis numberAxis = (NumberAxis) axis;\n        double min = Double.MAX_VALUE;\n        double max = Double.MIN_VALUE;\n        for (int i = 0; i < getDatasetCount(); i++) {\n            NumberAxisPlot plot = (NumberAxisPlot) getSubplot(i);\n            Range range = plot.getDataRange(numberAxis);\n            if (range != null) {\n                min = Math.min(min, range.getLowerBound());\n                max = Math.max(max, range.getUpperBound());\n            }\n        }\n        return new Range(min, max);\n    } else {\n        return null;\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis instanceof ValueAxis) {\n        if (axis instanceof CategoryAxis) {\n            CategoryAxis categoryAxis = (CategoryAxis) axis;\n            return categoryAxis.getRange();\n        } else if (axis instanceof NumberAxis) {\n            NumberAxis numberAxis = (NumberAxis) axis;\n            return new Range(numberAxis.getMinimum(), numberAxis.getMaximum());\n        }\n    }\n    return null;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis instanceof ValueAxis) {\n        if (axis instanceof CategoryAxis) {\n            CategoryAxis categoryAxis = (CategoryAxis) axis;\n            // For category axis, the data range is the range of categories\n            // in the plot.\n            Range range = new Range(categoryAxis.getMinCategory(), categoryAxis.getMaxCategory());\n            return range;\n        } else if (axis instanceof NumberAxis) {\n            NumberAxis numberAxis = (NumberAxis) axis;\n            // For number axis, the data range is the range of values in the plot.\n            Range range = new Range(numberAxis.getMinValue(), numberAxis.getMaxValue());\n            return range;\n        } else {\n            // For other types of axes, the data range is unknown.\n            return null;\n        }\n    } else {\n        // For axes that are not ValueAxis, the data range is unknown.\n        return null;\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis instanceof CategoryAxis) {\n        return getDomainAxis().getRange();\n    } else {\n        return getRangeAxis().getRange();\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis instanceof CategoryAxis) {\n        CategoryAxis categoryAxis = (CategoryAxis) axis;\n        return categoryAxis.getRange();\n    } else if (axis instanceof NumberAxis) {\n        NumberAxis numberAxis = (NumberAxis) axis;\n        return new Range(numberAxis.getMinimumValue(), numberAxis.getMaximumValue());\n    } else {\n        return null;\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis instanceof CategoryAxis) {\n        CategoryPlot plot = (CategoryPlot) getPlot();\n        CategoryAxis categoryAxis = (CategoryAxis) axis;\n        return plot.getDataset().getRangeCategory(categoryAxis);\n    } else if (axis instanceof NumberAxis) {\n        NumberAxis numberAxis = (NumberAxis) axis;\n        NumberAxisPlot plot = (NumberAxisPlot) getPlot();\n        return plot.getDataset().getRangeNumber(numberAxis);\n    } else {\n        throw new UnsupportedOperationException(\"Unsupported axis type\");\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis instanceof CategoryAxis) {\n        return new Range(0, getDatasetCount() - 1);\n    } else if (axis instanceof ValueAxis) {\n        int upper = Math.max(getDatasetCount(), getRendererCount());\n        if (axis instanceof NumberAxis) {\n            NumberAxis numberAxis = (NumberAxis) axis;\n            double min = Double.MAX_VALUE;\n            double max = Double.MIN_VALUE;\n            for (int i = 0; i < upper; i++) {\n                Dataset dataset = getDataset(i);\n                if (dataset != null) {\n                    Number[] values = dataset.getX(i);\n                    for (Number value : values) {\n                        if (value != null) {\n                            if (value.doubleValue() < min) {\n                                min = value.doubleValue();\n                            }\n                            if (value.doubleValue() > max) {\n                                max = value.doubleValue();\n                            }\n                        }\n                    }\n                }\n            }\n            return new Range(min, max);\n        } else {\n            return new Range(0, getDatasetCount() - 1);\n        }\n    } else {\n        return new Range(0, getDatasetCount() - 1);\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis instanceof CategoryAxis) {\n        return new Range(0, getDatasetCount() - 1);\n    } else if (axis instanceof ValueAxis) {\n        int upper = Math.max(getDatasetCount(), getRendererCount());\n        double min = Double.MAX_VALUE;\n        double max = Double.MIN_VALUE;\n        for (int i = 0; i < upper; i++) {\n            ValueAxis valueAxis = getDomainAxisForDataset(i);\n            Range range = valueAxis.getRange();\n            if (range != null) {\n                min = Math.min(min, range.getMin());\n                max = Math.max(max, range.getMax());\n            }\n        }\n        return new Range(min, max);\n    } else {\n        throw new RuntimeException(\"Unsupported axis type: \" + axis.getClass());\n    }\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    if (axis instanceof ValueAxis) {\n        ValueAxis valueAxis = (ValueAxis) axis;\n        if (valueAxis instanceof NumberAxis) {\n            NumberAxis numberAxis = (NumberAxis) valueAxis;\n            return new Range(numberAxis.getMinimum(), numberAxis.getMaximum());\n        }\n        else {\n            return new Range(axis.getMinValue(), axis.getMaxValue());\n        }\n    }\n    else {\n        return new Range(0, 0);\n    }\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = Math.log(val) / LOG10_VALUE;\n        res = res - (res < 0.0 ? 0.0 : res); // subtract out margin\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = (Math.log(val) / LOG10_VALUE) - (1.0 - val); //adjust for log10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = (Math.log(val) / LOG10_VALUE) - (Math.log(1.0) / LOG10_VALUE);\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = Math.log(val) / LOG10_VALUE;\n        res = res - (1.0 - res); //adjustLog10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) + (1.0 - val / 10.0);\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) + (1.0 - val / 10.0);\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = Math.log(val) / LOG10_VALUE + (1.0 - val / 10.0);\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) + (1.0 - val / 10.0);\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = Math.log(val) / LOG10_VALUE;\n        res -= (1.0 - res); // subtract out margin\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 1.0) {\n        res = (Math.log(val) / LOG10_VALUE) + (1.0 - val);\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node node : cfg.getNodes()) {\n      if (node.isReturn()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if all execution paths contain a return statement.\n   * May report false positives.\n   *\n   * @return true if all paths return, converse not necessarily true",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node node : cfg.getNodes()) {\n      if (node.isReturn()) {\n        return true;\n      }\n    }\n    return false;\n  }",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node node : cfg.getNodes()) {\n        if (node.getType() == Node.Type.RETURN) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node node : cfg.getNodes()) {\n        if (node.isReturn()) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node node : cfg.getNodes()) {\n      if (node.isReturn()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if a node is a control dependent child of its parent.\n   * A node is control dependent if it is not a return statement\n   * and its parent is a control flow node.\n   *\n   * @param node the node to check\n   * @return true if the node is control dependent",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node node : cfg.getNodes()) {\n        if (node.getType() == Node.Type.NORMAL) {\n            if (nodeHasReturn(node)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    return fastAllPathsReturnCheck(cfg, new HashSet<>());\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  ",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node node : cfg.getNodes()) {\n        if (node.isReturn()) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (Node node : cfg.getNodes()) {\n        if (node.isReturn()) {\n            return true;\n        }\n    }\n    return false;\n}"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    final Dfp[] spz = new Dfp[2];\n    spz[0] = a[0];\n    spz[1] = a[1];\n    return spz;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x = a[0];\n    Dfp y = a[1];\n    Dfp[] spx = new Dfp[2];\n    Dfp[] spy = new Dfp[2];\n    Dfp[] spz = new Dfp[2];\n    Dfp[] spw = new Dfp[2];\n    Dfp[] spv = new Dfp[2];\n    Dfp[] spu = new Dfp[2];\n    Dfp[] sps = new Dfp[2];\n    Dfp[] spq = new Dfp[2];\n    Dfp[] spr = new Dfp[2];\n    Dfp[] spq = new Dfp[2];\n    Dfp[] spn = new Dfp[2];\n    Dfp[] smo = new Dfp[2];\n    Dfp[] smm = new Dfp[2];\n    Dfp[] smk = new Dfp[2];\n    Dfp[] smj = new Dfp[2];\n    Dfp[] smi = new Dfp[2];\n    Dfp[] smh = new Dfp[2];\n    Dfp[] smg = new Dfp[2];\n    Dfp[] smf = new Dfp[2];\n    Dfp[] sme = new Dfp[2];\n    Dfp[] smd = new Dfp[2];\n    Dfp[] smc = new Dfp[2];\n    Dfp[] smb = new Dfp[2];\n    Dfp[] sma = new Dfp[2];\n    Dfp[] sm = new Dfp[2];\n    Dfp[] sl = new Dfp[2];\n    Dfp[] sk = new Dfp[2];\n    Dfp[] si = new Dfp[2];\n    Dfp[] sh = new Dfp[2];\n    Dfp[] sg = new Dfp[2];\n    Dfp[] sf = new Dfp[2];\n    Dfp[] se = new Dfp[2];\n    Dfp[] sd = new Dfp[2];\n    Dfp[] sc = new Dfp[2];\n    Dfp[] sb = new Dfp[2];\n    Dfp[] sa = new Dfp[2];\n    Dfp[] s = new Dfp[2];\n    Dfp[] r = new Dfp[2];\n    Dfp[] q = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x = a[0];\n    Dfp y = a[1];\n    Dfp z = new Dfp(\"1.33333\");\n    Dfp[] spz = new Dfp[2];\n    Dfp[] spx = new Dfp[2];\n    Dfp[] spy = new Dfp[2];\n    Dfp[] spz2 = new Dfp[2];\n    Dfp[] spx2 = new Dfp[2];\n    Dfp[] spy2 = new Dfp[2];\n    Dfp[] spz3 = new Dfp[2];\n    Dfp[] spx3 = new Dfp[2];\n    Dfp[] spy3 = new Dfp[2];\n    Dfp[] spz4 = new Dfp[2];\n    Dfp[] spx4 = new Dfp[2];\n    Dfp[] spy4 = new Dfp[2];\n    Dfp[] spz5 = new Dfp[2];\n    Dfp[] spx5 = new Dfp[2];\n    Dfp[] spy5 = new Dfp[2];\n    Dfp[] spz6 = new Dfp[2];\n    Dfp[] spx6 = new Dfp[2];\n    Dfp[] spy6 = new Dfp[2];\n    Dfp[] spz7 = new Dfp[2];\n    Dfp[] spx7 = new Dfp[2];\n    Dfp[] spy7 = new Dfp[2];\n    Dfp[] spz8 = new Dfp[2];\n    Dfp[] spx8 = new Dfp[2];\n    Dfp[] spy8 = new Dfp[2];\n    Dfp[] spz9 = new Dfp[2];\n    Dfp[] spx9 = new Dfp[2];\n    Dfp[] spy9 = new Dfp[2];\n    Dfp[] spz10 = new Dfp[2];\n    Dfp[] spx10 = new Dfp[2];\n    Dfp[] spy10 = new Dfp[2];\n    Dfp[] spz11 = new Dfp[2];\n    Dfp[] spx11 = new Dfp[2];\n    Dfp[] spy11 = new Dfp[2];\n    Dfp[] spz12 = new Dfp[2];\n    Dfp[] spx12 = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = split(a[0]);\n    Dfp[] spy = new Dfp[2];\n    spy[0] = a[1];          // use spy[0] temporarily as a divisor\n    spx[0] = spx[0].divide(spy[0]);\n    spx[1] = spx[1].divide(spy[0]);\n\n    spy[0] = a[1].newInstance(\"1.33333\");    // Use spy[0] for comparison\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n    }\n\n    // X is now in the range of 2/3 < x < 4/3\n    Dfp[] spz = new Dfp[2];\n    spz[0] = spx[0].multiply(a[1]);\n    spz[1] = spx[1].multiply(a[1]);\n\n    Dfp[] result = new Dfp[2];\n    result[0] = spz[0].multiply(a[1]);\n    result[1] = spz[1].multiply(a[1]);\n\n    return result;\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spz = new Dfp[2];\n    spz[0] = a[0];\n    spz[1] = a[1];\n    Dfp[] spx = new Dfp[2];\n    spx[0] = a[0];\n    spx[1] = a[1];\n    Dfp[] spy = new Dfp[2];\n    spy[0] = a[0];\n    spy[1] = a[1];\n    Dfp[] spz1 = new Dfp[2];\n    spz1[0] = a[0];\n    spz1[1] = a[1];\n    Dfp[] spz2 = new Dfp[2];\n    spz2[0] = a[0];\n    spz2[1] = a[1];\n    Dfp[] spz3 = new Dfp[2];\n    spz3[0] = a[0];\n    spz3[1] = a[1];\n    Dfp[] spz4 = new Dfp[2];\n    spz4[0] = a[0];\n    spz4[1] = a[1];\n    Dfp[] spz5 = new Dfp[2];\n    spz5[0] = a[0];\n    spz5[1] = a[1];\n    Dfp[] spz6 = new Dfp[2];\n    spz6[0] = a[0];\n    spz6[1] = a[1];\n    Dfp[] spz7 = new Dfp[2];\n    spz7[0] = a[0];\n    spz7[1] = a[1];\n    Dfp[] spz8 = new Dfp[2];\n    spz8[0] = a[0];\n    spz8[1] = a[1];\n    Dfp[] spz9 = new Dfp[2];\n    spz9[0] = a[0];\n    spz9[1] = a[1];\n    Dfp[] spz10 = new Dfp[2];\n    spz10[0] = a[0];\n    spz10[1] = a[1];\n    Dfp[] spz11 = new Dfp[2];\n    spz11[0] = a[0];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x = a[0];\n    Dfp y = a[1];\n    Dfp[] spz = new Dfp[2];\n    Dfp[] spx = new Dfp[2];\n    Dfp[] spy = new Dfp[2];\n    Dfp[] spz1 = new Dfp[2];\n    Dfp[] spz2 = new Dfp[2];\n    Dfp[] spz3 = new Dfp[2];\n    Dfp[] spz4 = new Dfp[2];\n    Dfp[] spz5 = new Dfp[2];\n    Dfp[] spz6 = new Dfp[2];\n    Dfp[] spz7 = new Dfp[2];\n    Dfp[] spz8 = new Dfp[2];\n    Dfp[] spz9 = new Dfp[2];\n    Dfp[] spz10 = new Dfp[2];\n    Dfp[] spz11 = new Dfp[2];\n    Dfp[] spz12 = new Dfp[2];\n    Dfp[] spz13 = new Dfp[2];\n    Dfp[] spz14 = new Dfp[2];\n    Dfp[] spz15 = new Dfp[2];\n    Dfp[] spz16 = new Dfp[2];\n    Dfp[] spz17 = new Dfp[2];\n    Dfp[] spz18 = new Dfp[2];\n    Dfp[] spz19 = new Dfp[2];\n    Dfp[] spz20 = new Dfp[2];\n    Dfp[] spz21 = new Dfp[2];\n    Dfp[] spz22 = new Dfp[2];\n    Dfp[] spz23 = new Dfp[2];\n    Dfp[] spz24 = new Dfp[2];\n    Dfp[] spz25 = new Dfp[2];\n    Dfp[] spz26 = new Dfp[2];\n    Dfp[] spz27 = new Dfp[2];\n    Dfp[] spz28 = new Dfp[2];\n    Dfp[] spz29 = new Dfp[2];\n    Dfp[] spz30 = new Dfp[2];\n    Dfp[] spz31 = new Dfp[2];\n    Dfp[] spz32 = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x = a[0];\n    Dfp y = a[1];\n    Dfp z = new Dfp(1.0);\n    Dfp w = new Dfp(1.0);\n\n    for (int i = 1; i < 90; i++) {\n        z = z.multiply(x);\n        w = w.divide(i);\n        y = y.add(z.multiply(w));\n        if (y.equals(z)) {\n            break;\n        }\n    }\n\n    return new Dfp[]{y, z};\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x = a[0];\n    Dfp y = a[1];\n    Dfp z = a[1];\n    Dfp t = new Dfp(0.0);\n    Dfp s = new Dfp(0.0);\n    Dfp f = new Dfp(0.0);\n    Dfp fi = new Dfp(0.0);\n    Dfp x0 = new Dfp(0.0);\n    Dfp x1 = new Dfp(0.0);\n    Dfp x2 = new Dfp(0.0);\n    Dfp y0 = new Dfp(0.0);\n    Dfp y1 = new Dfp(0.0);\n    Dfp y2 = new Dfp(0.0);\n    Dfp z0 = new Dfp(0.0);\n    Dfp z1 = new Dfp(0.0);\n    Dfp z2 = new Dfp(0.0);\n    Dfp t0 = new Dfp(0.0);\n    Dfp t1 = new Dfp(0.0);\n    Dfp t2 = new Dfp(0.0);\n    Dfp s0 = new Dfp(0.0);\n    Dfp s1 = new Dfp(0.0);\n    Dfp s2 = new Dfp(0.0);\n    Dfp f0 = new Dfp(0.0);\n    Dfp f1 = new Dfp(0.0);\n    Dfp f2 = new Dfp(0.0);\n    Dfp fi0 = new Dfp(0.0);\n    Dfp fi1 = new Dfp(0.0);\n    Dfp fi2 = new Dfp(0.0);\n    Dfp x00 = new Dfp(0.0);\n    Dfp x10 = new Dfp(0.0);\n    Dfp x20 = new Dfp(0.0);\n    Dfp y00 = new Dfp(0.0);\n    Dfp y10 = new Dfp(0.0);\n    Dfp y20 = new Dfp(0.0);\n    Dfp z00 = new Dfp(0.0);\n    Dfp z10 = new Dfp(0.0);\n    Dfp z20 = new Dfp(0.0);\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp x = a[0];\n    Dfp y = a[1];\n    Dfp z = new Dfp();\n    Dfp t = new Dfp();\n    Dfp s = new Dfp();\n    Dfp f = new Dfp();\n    Dfp fi = new Dfp();\n    Dfp p = new Dfp();\n    Dfp q = new Dfp();\n    Dfp r = new Dfp();\n    Dfp w = new Dfp();\n    Dfp v = new Dfp();\n    Dfp u = new Dfp();\n    Dfp g = new Dfp();\n    Dfp h = new Dfp();\n    Dfp i = new Dfp();\n    Dfp j = new Dfp();\n    Dfp k = new Dfp();\n    Dfp l = new Dfp();\n    Dfp m = new Dfp();\n    Dfp n = new Dfp();\n    Dfp o = new Dfp();\n    Dfp p2 = new Dfp();\n    Dfp p3 = new Dfp();\n    Dfp p4 = new Dfp();\n    Dfp p5 = new Dfp();\n    Dfp p6 = new Dfp();\n    Dfp p7 = new Dfp();\n    Dfp p8 = new Dfp();\n    Dfp p9 = new Dfp();\n    Dfp p10 = new Dfp();\n    Dfp p11 = new Dfp();\n    Dfp p12 = new Dfp();\n    Dfp p13 = new Dfp();\n    Dfp p14 = new Dfp();\n    Dfp p15 = new Dfp();\n    Dfp p16 = new Dfp();\n    Dfp p17 = new Dfp();\n    Dfp p18 = new Dfp();\n    Dfp p19 = new Dfp();\n    Dfp p20 = new Dfp();\n    Dfp p21 = new Dfp();\n    Dfp p22 = new Dfp();\n    Dfp p23 = new Dfp();\n    Dfp p24 = new Dfp();\n    Dfp p25 = new Dfp();\n    Dfp p26 = new Dfp();\n    Dfp p27 = new Dfp();\n    Dfp p28 = new Dfp();\n    Dfp p29 = new Dfp();\n    Dfp p30 = new Dfp();\n    Dfp p31 = new Dfp();\n    Dfp p32 = new Dfp();\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n    Dfp[] spx = new Dfp[2];\n    Dfp[] spy = new Dfp[2];\n    spy[0] = a[0].newInstance(\"1.33333\");    // Use spy[0] for comparison\n    spx[0] = a[0].divide(spy[0]);\n    spx[1] = a[1].divide(spy[0]);\n\n    while (spx[0].add(spx[1]).greaterThan(spy[0])) {\n        spx[0] = spx[0].divide(2);\n        spx[1] = spx[1].divide(2);\n    }\n\n    return spx;\n}"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (containsKey(key)) {\n            Collection<V> coll = get(key);\n            if (coll != null) {\n                coll.remove(value);\n                if (coll.isEmpty()) {\n                    remove(key);\n                }\n                return true;\n            }\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (!containsKey(key)) {\n            return false;\n        }\n        Collection<V> collection = get(key);\n        if (collection != null) {\n            collection.remove(value);\n            if (collection.isEmpty()) {\n                remove(key);\n            }\n        }\n        return true;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (map.containsKey(key)) {\n            Collection<V> collection = map.get(key);\n            if (collection != null) {\n                collection.remove(value);\n                if (collection.isEmpty()) {\n                    map.remove(key);\n                }\n                return true;\n            }\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (containsKey(key)) {\n            Collection<V> coll = get(key);\n            if (coll != null) {\n                coll.remove(value);\n                if (coll.isEmpty()) {\n                    remove(key);\n                }\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (!containsKey(key)) {\n            return false;\n        }\n        Collection<V> collection = get(key);\n        if (collection == null) {\n            return false;\n        }\n        if (collection.remove(value)) {\n            if (collection.isEmpty()) {\n                remove(key);\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> collection = get(key);\n        if (collection == null) {\n            return false;\n        }\n        collection.remove(value);\n        if (collection.isEmpty()) {\n            remove(key);\n        }\n        return true;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (containsKey(key)) {\n            Collection<V> coll = get(key);\n            if (coll != null) {\n                coll.remove(value);\n                if (coll.isEmpty()) {\n                    remove(key);\n                }\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        Collection<V> collection = get(key);\n        if (collection == null) {\n            return false;\n        }\n        collection.remove(value);\n        if (collection.isEmpty()) {\n            remove(key);\n        }\n        return true;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (map.containsKey(key)) {\n            Collection<V> collection = map.get(key);\n            if (collection != null) {\n                collection.remove(value);\n                if (collection.isEmpty()) {\n                    map.remove(key);\n                }\n            }\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (!containsKey(key)) {\n            return false;\n        }\n        Collection<V> collection = get(key);\n        if (collection == null) {\n            return false;\n        }\n        collection.remove(value);\n        if (collection.isEmpty()) {\n            remove(key);\n        }\n        return true;\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) {\n        n.setType(Token.STRING);\n    } else if (n.getType() == Token.STRING) {\n        n.setString(\"\\\"\" + n.getString() + \"\\\"\");\n    }\n    return n;\n}\n\n/**\n * Replaces all occurrences of undefined with null.",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) {\n        n.setType(Token.STRING);\n    } else if (n.getType() == Token.STRING) {\n        n.setString(NodeUtil.quoteString(n.getString()));\n    }\n    return n;\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) {\n        n.setType(Token.STRING);\n        return n;\n    }\n    if (n.getType() == Token.STRING) {\n        n.setString(\"\\\"\" + n.getString() + \"\\\"\");\n        return n;\n    }\n    return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) {\n        n.setType(Token.STRING);\n    } else if (n.getType() == Token.STRING) {\n        n.setString(n.getString().trim());\n    }\n    return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) {\n        return IR.string(n.getString());\n    } else if (n.getType() == Token.STRING) {\n        return IR.string(n.getString());\n    } else {\n        return n;\n    }\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) {\n        return new Node(Token.STRING, n.getString());\n    } else if (n.getType() == Token.STRING) {\n        return new Node(Token.STRING, \"\\\"\" + n.getString() + \"\\\"\");\n    }\n    return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) {\n        n.setType(Token.STRING);\n        return n;\n    }\n    if (n.getType() == Token.STRING) {\n        n.setString(\"\\\"\" + n.getString() + \"\\\"\");\n        return n;\n    }\n    return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) {\n        return IR.string(n.getString());\n    } else if (n.getType() == Token.STRING) {\n        return IR.string(quoteString(n.getString()));\n    }\n    return n;\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) {\n        n.setType(Token.STRING);\n        return n;\n    } else if (n.getType() == Token.STRING) {\n        n.setString(quoteString(n.getString()));\n        return n;\n    }\n    return n;\n}\n\n/**\n * Replaces all occurrences of undefined with a new variable name.",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) {\n        n.setType(Token.STRING);\n    } else if (n.getType() == Token.STRING) {\n        n.setString(n.getString().replaceAll(\"\\\\\\\\(.)\", \"$1\"));\n    }\n    return n;\n}"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1), new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1), new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1), new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1), new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1), new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1), new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset, dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1), new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}"
    ],
    [
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n        shadowChildrenRef = new WeakReference<>(new ArrayList<>());\n    }\n    List<Element> list = (List<Element>) shadowChildrenRef.get();\n    if (list == null) {\n        list = new ArrayList<>();\n        shadowChildrenRef = new WeakReference<>(list);\n    }\n    return list;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        shadowChildrenRef = new WeakReference<>(new ArrayList<>());\n    }\n    List<Element> list = (List<Element>) shadowChildrenRef.get();\n    if (list == null) {\n        list = new ArrayList<>();\n        shadowChildrenRef = new WeakReference<>(list);\n    }\n    return list;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n        List<Element> children = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element) {\n                children.add((Element) node);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(children);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n        List<Node> nodes = ensureChildNodes();\n        shadowChildrenRef = new WeakReference<>(new ArrayList<>(nodes.size()));\n        for (Node node : nodes) {\n            if (node instanceof Element) {\n                ((ArrayList<Element>) shadowChildrenRef.get()).add((Element) node);\n            }\n        }\n    }\n    return (List<Element>) shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n        List<Element> elements = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                elements.add((Element) node);\n        }\n        shadowChildrenRef = new WeakReference<>(elements);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n        List<Element> shadowChildren = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element) {\n                shadowChildren.add((Element) node);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(shadowChildren);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        List<Node> nodes = childNodes;\n        List<Element> elements = new ArrayList<>();\n        for (Node node : nodes) {\n            if (node instanceof Element) {\n                elements.add((Element) node);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(elements);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n        List<Node> nodes = childNodes;\n        List<Element> elements = new ArrayList<>();\n        for (Node node : nodes) {\n            if (node instanceof Element) {\n                elements.add((Element) node);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(elements);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n        List<Node> nodes = ensureChildNodes();\n        shadowChildrenRef = new WeakReference<>(new ArrayList<>());\n        for (Node node : nodes) {\n            if (node instanceof Element) {\n                ((ArrayList<Element>) shadowChildrenRef.get()).add((Element) node);\n            }\n        }\n    }\n    return (List<Element>) shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        nodelistChanged();\n    }\n    return shadowChildrenRef.get();\n}"
    ],
    [
      "private int getHash(final Object key)  {\n        return hashIndex(hash(key), data.length);\n    }",
      "private int getHash(final Object key)  {\n        return hashIndex(hash(key), data.length);\n    }",
      "private int getHash(final Object key)  {\n        return hashIndex(hash(key), data.length);\n    }",
      "private int getHash(final Object key)  {\n        int hash = key.hashCode();\n        return hash & (buckets.length - 1);\n    }",
      "private int getHash(final Object key)  {\n        return key.hashCode() & (data.length - 1);\n    }",
      "private int getHash(final Object key)  {\n        return key.hashCode() & (data.length - 1);\n    }",
      "private int getHash(final Object key)  {\n        int hash = key.hashCode();\n        return hash & (buckets.length - 1);\n    }\n\n    /**\n     * Gets the value associated with the key.\n     *\n     * @param key  the key to retrieve\n     * @return the associated value\n     */",
      "private int getHash(final Object key)  {\n        return hashIndex(hash(key), data.length);\n    }\n\n    /**\n     * Get the entry mapped to the key specified.\n     * <p>\n     * This method exists for subclasses that may need to perform a multi-step",
      "private int getHash(final Object key)  {\n        int hash = key.hashCode();\n        return hash & (data.length - 1);\n    }\n\n    /**\n     * Gets the value associated with the key.\n     *\n     * @param key  the key to retrieve\n     * @return the associated value\n     */",
      "private int getHash(final Object key)  {\n        return hashIndex(hash(key), data.length);\n    }"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    RealMatrix out = new Array2DRowRealMatrix(rows, cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (i > j - k) {\n                out.setEntry(i, j, m.getEntry(i, j));\n            } else {\n                out.setEntry(i, j, 0);\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    RealMatrix out = new Array2DRowRealMatrix(rows - k, cols - k);\n    for (int i = k; i < rows; i++) {\n        for (int j = k; j < cols; j++) {\n            out.setEntry(i - k, j - k, m.getEntry(i, j));\n        }\n    }\n    return out;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rowCount = m.getRowDimension();\n    int columnCount = m.getColumnDimension();\n    RealMatrix out = new Array2DRowRealMatrix(rowCount, columnCount);\n    for (int row = 0; row < rowCount; row++) {\n        for (int col = 0; col < columnCount; col++) {\n            if (row > k || col > k) {\n                out.setEntry(row, col, m.getEntry(row, col));\n            } else {\n                out.setEntry(row, col, 0);\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int rowCount    = m.getRowDimension();\n    final int columnCount = m.getColumnDimension();\n    final RealMatrix out = createMatrix(rowCount, columnCount);\n    for (int row = 0; row < rowCount; ++row) {\n        for (int col = 0; col < columnCount; ++col) {\n            if (row > k || col > k) {\n                out.setEntry(row, col, 0);\n            } else {\n                out.setEntry(row, col, m.getEntry(row, col));\n            }\n        }\n    }\n\n    return out;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int nRows = m.getRowDimension();\n    final int nCols = m.getColumnDimension();\n    final RealMatrix out = createMatrix(nRows - k, nCols - k);\n    for (int i = 0; i < nRows - k; i++) {\n        for (int j = 0; j < nCols - k; j++) {\n            out.setEntry(i, j, m.getEntry(i + k, j + k));\n        }\n    }\n    return out;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    RealMatrix out = new Array2DRowRealMatrix(rows - k, cols - k);\n    for (int i = k; i < rows; i++) {\n        for (int j = k; j < cols; j++) {\n            out.setEntry(i - k, j - k, m.getEntry(i, j));\n        }\n    }\n    return out;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int nRows = m.getRowDimension();\n    final int nCols = m.getColumnDimension();\n    final RealMatrix out = new Array2DRowRealMatrix(nRows - k, nCols - k);\n    for (int i = k; i < nRows; i++) {\n        for (int j = k; j < nCols; j++) {\n            if (i >= j) {\n                out.setEntry(i - k, j - k, m.getEntry(i, j));\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int nRows = m.getRowDimension();\n    final int nCols = m.getColumnDimension();\n    final RealMatrix out = new Array2DRowRealMatrix(nRows - k, nCols - k);\n    for (int i = k; i < nRows; i++) {\n        for (int j = k; j < nCols; j++) {\n            out.setEntry(i - k, j - k, m.getEntry(i, j));\n        }\n    }\n    return out;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    int rows = m.getRowDimension();\n    int cols = m.getColumnDimension();\n    RealMatrix out = new Array2DRowRealMatrix(rows - k, cols - k);\n    for (int i = k; i < rows; i++) {\n        for (int j = k; j < cols; j++) {\n            out.setEntry(i - k, j - k, m.getEntry(i, j));\n        }\n    }\n    return out;\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final int rowCount    = m.getRowDimension();\n    final int columnCount = m.getColumnDimension();\n    final RealMatrix out = createMatrix(rowCount - k, columnCount - k);\n    for (int row = k; row < rowCount; ++row) {\n        for (int col = k; col < columnCount; ++col) {\n            out.setEntry(row - k, col - k, m.getEntry(row, col));\n        }\n    }\n\n    return out;\n}"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) {\n            rotateCCW();\n            skew      = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n            return true;\n        } else if (right.skew == Skew.BALANCED) {\n            rotateCCW();\n            skew      = Skew.LEFT_HIGH;\n            left.skew = Skew.RIGHT_HIGH;\n            return false;\n        } else {\n            final Skew s = right.right.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        }\n    default:\n        skew = Skew.LEFT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) {\n            rotateCCW();\n            skew      = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n            return true;\n        } else if (right.skew == Skew.BALANCED) {\n            rotateCCW();\n            skew      = Skew.LEFT_HIGH;\n            left.skew = Skew.RIGHT_HIGH;\n            return false;\n        } else {\n            final Skew s = right.right.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        }\n    default:\n        skew = Skew.LEFT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCW();\n                skew      = Skew.RIGHT_HIGH;\n                left.skew = Skew.LEFT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.right.skew;\n                right.rotateCCW();\n                rotateCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.right.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) {\n                case LEFT_HIGH:\n                    left.skew  = Skew.BALANCED;\n                    right.skew = Skew.RIGHT_HIGH;\n                    break;\n                case RIGHT_HIGH:\n                    left.skew  = Skew.LEFT_HIGH;\n                    right.skew = Skew.BALANCED;\n                    break;\n                default:\n                    left.skew  = Skew.BALANCED;\n                    right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) {\n            rotateCCW();\n            skew      = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n            return true;\n        } else if (right.skew == Skew.BALANCED) {\n            rotateCCW();\n            skew      = Skew.LEFT_HIGH;\n            left.skew = Skew.RIGHT_HIGH;\n            return false;\n        } else {\n            final Skew s = right.right.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        }\n    default:\n        skew = Skew.LEFT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCW();\n                skew      = Skew.RIGHT_HIGH;\n                left.skew = Skew.LEFT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.right.skew;\n                right.rotateCCW();\n                rotateCW();\n                switch (s) {\n                case LEFT_HIGH:\n                    left.skew  = Skew.BALANCED;\n                    right.skew = Skew.RIGHT_HIGH;\n                    break;\n                case RIGHT_HIGH:\n                    left.skew  = Skew.LEFT_HIGH;\n                    right.skew = Skew.BALANCED;\n                    break;\n                default:\n                    left.skew  = Skew.BALANCED;\n                    right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.right.skew;\n                right.rotateCCW();\n                rotateCW();\n                switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n        case LEFT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        case RIGHT_HIGH:\n            if (right.skew == Skew.RIGHT_HIGH) {\n                rotateCCW();\n                skew      = Skew.BALANCED;\n                left.skew = Skew.BALANCED;\n                return true;\n            } else if (right.skew == Skew.BALANCED) {\n                rotateCCW();\n                skew      = Skew.LEFT_HIGH;\n                left.skew = Skew.RIGHT_HIGH;\n                return false;\n            } else {\n                final Skew s = right.right.skew;\n                right.rotateCW();\n                rotateCCW();\n                switch (s) {\n                case LEFT_HIGH:\n                    left.skew  = Skew.BALANCED;\n                    right.skew = Skew.RIGHT_HIGH;\n                    break;\n                case RIGHT_HIGH:\n                    left.skew  = Skew.LEFT_HIGH;\n                    right.skew = Skew.BALANCED;\n                    break;\n                default:\n                    left.skew  = Skew.BALANCED;\n                    right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) {\n            rotateCCW();\n            skew      = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n            return true;\n        } else if (right.skew == Skew.BALANCED) {\n            rotateCCW();\n            skew      = Skew.LEFT_HIGH;\n            left.skew = Skew.RIGHT_HIGH;\n            return false;\n        } else {\n            final Skew s = right.right.skew;\n            right.rotateCW();\n            rotateCCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n            return true;\n        }\n    default:\n        skew = Skew.LEFT_HIGH;\n        return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) {\n    case LEFT_HIGH:\n        skew = Skew.BALANCED;\n        return true;\n    case RIGHT_HIGH:\n        if (right.skew == Skew.RIGHT_HIGH) {\n            rotateCW();\n            skew      = Skew.BALANCED;\n            left.skew = Skew.BALANCED;\n        } else if (right.skew == Skew.BALANCED) {\n            rotateCW();\n            skew      = Skew.LEFT_HIGH;\n            left.skew = Skew.RIGHT_HIGH;\n        } else {\n            final Skew s = right.right.skew;\n            right.rotateCCW();\n            rotateCW();\n            switch (s) {\n            case LEFT_HIGH:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.RIGHT_HIGH;\n                break;\n            case RIGHT_HIGH:\n                left.skew  = Skew.LEFT_HIGH;\n                right.skew = Skew.BALANCED;\n                break;\n            default:\n                left.skew  = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            }\n            skew = Skew.BALANCED;\n        }\n        return true;\n    default:\n        skew = Skew.LEFT_HIGH;\n        return false;\n    }\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    double epsilon = norm * FastMath.MIN_NORMAL;\n    while (im < matrixT.length - 1) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) + FastMath.abs(z) + FastMath.abs(matrixT[im + 1][im + 1]));\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im++;\n    }\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    double epsilon = norm * 1e-12;\n    while (im < matrixT.length - 1) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) + FastMath.abs(z) + FastMath.abs(matrixT[im + 1][im + 1]));\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im++;\n    }\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    double epsilon = norm * 1e-12;\n    while (im < matrixT.length - 1) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) + FastMath.abs(z) + FastMath.abs(matrixT[im + 1][im + 1]));\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im++;\n    }\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    double epsilon = norm * 1e-12;\n    while (im < matrixT.length - 1) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) + FastMath.abs(z) + FastMath.abs(matrixT[im + 1][im + 1]));\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im++;\n    }\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    double epsilon = norm * 1e-12;\n    while (im < matrixT.length - 1) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) + FastMath.abs(z) + FastMath.abs(matrixT[im + 1][im + 1]));\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im++;\n    }\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    double epsilon = norm * 1e-12;\n    while (im < matrixT.length - 1) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) + FastMath.abs(z) + FastMath.abs(matrixT[im + 1][im + 1]));\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im++;\n    }\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    double epsilon = norm * FastMath.EPSILON;\n    while (im < matrixT.length - 1) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) + FastMath.abs(z) + FastMath.abs(matrixT[im + 1][im + 1]));\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im++;\n    }\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    double epsilon = norm * 1e-10;\n    while (im < matrixT.length - 1) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) + FastMath.abs(z) + FastMath.abs(matrixT[im + 1][im + 1]));\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im++;\n    }\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    double epsilon = norm * 1e-10;\n    while (im < matrixT.length - 1) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) +\n                                                      FastMath.abs(z) +\n                                                      FastMath.abs(matrixT[im + 1][im + 1]));\n\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im++;\n    }\n    return im;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int im = startIdx;\n    double epsilon = norm * 1e-12;\n    while (im < matrixT.length - 1) {\n        final double lhs = FastMath.abs(matrixT[im][im - 1]) * (FastMath.abs(hVec[1]) + FastMath.abs(hVec[2]));\n        final double rhs = FastMath.abs(hVec[0]) * (FastMath.abs(matrixT[im - 1][im - 1]) + FastMath.abs(z) + FastMath.abs(matrixT[im + 1][im + 1]));\n        if (lhs < epsilon * rhs) {\n            break;\n        }\n        im++;\n    }\n    return im;\n}"
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) < 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    int index = 0;\n    while ((index = indexOf(str, index)) != -1) {\n        deleteImpl(index, index + len, len);\n        index += len;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    int start = 0;\n    while (true) {\n        start = indexOf(str, start);\n        if (start == -1) {\n            break;\n        }\n        deleteImpl(start, start + len, len);\n        start += len;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    int start = 0;\n    while (true) {\n        start = indexOf(str, start);\n        if (start == -1) {\n            break;\n        }\n        deleteImpl(start, start + len, len);\n        start += len;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    int start = 0;\n    while ((start = indexOf(str, start)) != -1) {\n        deleteImpl(start, start + len, len);\n        start += len;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    int start = 0;\n    while (true) {\n        start = indexOf(str, start);\n        if (start == -1) {\n            break;\n        }\n        deleteImpl(start, start + len, len);\n        start += len;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return this;\n    }\n    int start = 0;\n    while ((start = indexOf(str, start)) != -1) {\n        deleteImpl(start, start + len, len);\n        start += len;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    int index = 0;\n    while ((index = indexOf(str, index)) != -1) {\n        deleteImpl(index, index + len, len);\n        index += len;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return this;\n    }\n    int start = 0;\n    while ((start = indexOf(str, start)) != -1) {\n        deleteImpl(start, start + len, len);\n        start += len;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    int start = 0;\n    while (true) {\n        start = indexOf(str, start);\n        if (start == -1) {\n            break;\n        }\n        deleteImpl(start, start + len, len);\n        start += len;\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    if (str == null) {\n        return this;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return this;\n    }\n    final int index = indexOf(str, 0);\n    while (index >= 0) {\n        deleteImpl(index, index + len, len);\n        index = indexOf(str, index + len);\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (irNode instanceof NodeWithJsDoc) {\n      ((NodeWithJsDoc) irNode).setJsDocInfo(getJsDocInfo(node));\n    }\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (irNode instanceof NodeWithInlineJsDoc) {\n      ((NodeWithInlineJsDoc) irNode).setJsDocInfo(\n          ((NodeWithInlineJsDoc) node).getJsDocInfo());\n    }\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == CommentType.JSDOC &&\n            !irFactory.parsedComments.contains(comment)) {\n          irFactory.handlePossibleFileOverviewJsDoc(comment, irNode);\n        } else if (comment.getCommentType() == CommentType.BLOCK_COMMENT) {\n          irFactory.handleBlockComment(comment);\n        }\n      }\n    }\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (node instanceof Name) {\n        Node nameNode = transformNameAsString((Name) node);\n        irNode = new Node(Token.NAME, nameNode);\n    } else if (node instanceof NumberLiteral) {\n        Node numberNode = transformNumberAsString((NumberLiteral) node);\n        irNode = new Node(Token.NUMBER, numberNode);\n    }\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == CommentType.JSDOC &&\n            !irFactory.parsedComments.contains(comment)) {\n          irFactory.handlePossibleFileOverviewJsDoc(comment, irNode);\n        } else if (comment.getCommentType() == CommentType.BLOCK_COMMENT) {\n          irFactory.handleBlockComment(comment);\n        }\n      }\n    }\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (irNode.isBlock()) {\n      return irNode;\n    }\n    if (irNode.isName()) {\n      Name name = (Name) irNode;\n      String jsDocComment = name.getJsDocComment();\n      if (jsDocComment != null) {\n        irNode = new JsDocNode(irNode, jsDocComment);\n      }\n    }\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == CommentType.JSDOC &&\n            !parsedComments.contains(comment)) {\n          handlePossibleFileOverviewJsDoc(comment, irNode);\n        } else if (comment.getCommentType() == CommentType.BLOCK_COMMENT) {\n          handleBlockComment(comment);\n        }\n      }\n    }\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == CommentType.JSDOC &&\n            !irFactory.parsedComments.contains(comment)) {\n          irFactory.handlePossibleFileOverviewJsDoc(comment, irNode);\n        } else if (comment.getCommentType() == CommentType.BLOCK_COMMENT) {\n          irFactory.handleBlockComment(comment);\n        }\n      }\n    }\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (irNode.isBlock()) {\n        return irNode;\n    }\n    if (irNode.isName()) {\n        String name = ((Name) irNode).getName();\n        String jsDoc = getJsDoc(node);\n        if (jsDoc != null) {\n            irNode.setJSDocInfo(new JSDocInfo(jsDoc));\n        }\n        return irNode;\n    }\n    return irNode;\n}\n\n/**\n * Method that will set specified field, replacing old value,\n * if any.\n *\n * @param value to set field to; if null, will be converted\n *   to a {@link NullNode} first  (to remove field entry, call\n *   {@link #remove} instead)\n *\n * @return Old value of the field, if any; null if there was no\n *   old value.",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transform(node);\n    if (irNode instanceof NodeWithInlineJsDoc) {\n      NodeWithInlineJsDoc inlineJsDoc = (NodeWithInlineJsDoc) irNode;\n      if (inlineJsDoc.getJsDocInfo() != null) {\n        irNode.setJSDocInfo(inlineJsDoc.getJsDocInfo());\n      }\n    }\n    return irNode;\n  }"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(set, list);\n}\n\n/**\n     * Constructor that wraps (not copies) the Set and specifies the list to use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     *\n     * @param set the set to decorate, must not be null\n     * @param list the list to decorate, must not be null\n     * @throws NullPointerException if set or list is null\n     */\nprotected SetUniqueList(final Set<E> set, final List<E> list) {\n    super(set);\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    setOrder = list;\n}\n\n/**\n     * Gets an unmodifiable view of the order of the Set.\n     *\n     * @return an unmodifiable list view",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}\n\n/**\n     * Constructor that wraps (not copies) the Set and specifies the list to use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param list  the list to decorate, must not be null\n     * @throws NullPointerException if set or list is null\n     */\nprotected SetUniqueList(final List<E> list, final Set<E> set) {\n    super(set);\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    setOrder = list;\n}\n\n// -----------------------------------------------------------------------\n/**\n     * Gets an unmodifiable view of the order of the Set.\n     *\n     * @return an unmodifiable list view",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}\n\n/**\n     * Constructor that wraps (not copies) the Set and specifies the list to use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     *\n     * @param set the set to decorate, must not be null\n     * @param list the list to decorate, must not be null\n     * @throws NullPointerException if set or list is null\n     */\nprotected SetUniqueList(final List<E> list, final Set<E> set) {\n    super(set);\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    setOrder = list;\n}\n\n// -----------------------------------------------------------------------\n/**\n     * Gets an unmodifiable view of the order of the Set.\n     *\n     * @return an unmodifiable list view",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(set, list);\n}\n\n/**\n     * Constructor that wraps (not copies) the Set and specifies the list to use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     *\n     * @param set the set to decorate, must not be null\n     * @param list the list to decorate, must not be null\n     * @throws NullPointerException if set or list is null\n     */\nprotected SetUniqueList(final Set<E> set, final List<E> list) {\n    super(set);\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    setOrder = list;\n}\n\n// -----------------------------------------------------------------------\n/**\n     * Gets an unmodifiable view of the order of the Set.\n     *\n     * @return an unmodifiable list view",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(set, list);\n}\n\n/**\n * Constructor that wraps (not copies) the Set and specifies the list to use.\n * <p>\n * The set and list must both be correctly initialised to the same elements.\n *\n * @param set  the set to decorate, must not be null\n * @param list  the list to decorate, must not be null\n * @throws NullPointerException if set or list is null\n */\nprotected SetUniqueList(final Set<E> set, final List<E> list) {\n    super(set);\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    setOrder = list;\n}\n\n// -----------------------------------------------------------------------\n/**\n * Gets an unmodifiable view of the order of the Set.\n *\n * @return an unmodifiable list view",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}\n\n/**\n     * Constructor that wraps (not copies) the Set and specifies the list to use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param list  the list to decorate, must not be null\n     * @throws NullPointerException if set or list is null\n     */\nprotected SetUniqueList(final List<E> list, final Set<E> set) {\n    super(set);\n    setOrder = list;\n}\n\n// -----------------------------------------------------------------------\n/**\n     * Gets an unmodifiable view of the order of the Set.\n     *\n     * @return an unmodifiable list view",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(list, set);\n}\n\n/**\n     * Constructor that wraps (not copies) the Set and specifies the list to use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param list  the list to decorate, must not be null\n     * @throws NullPointerException if set or list is null\n     */\nprotected SetUniqueList(final List<E> list, final Set<E> set) {\n    super(set);\n    setOrder = list;\n}\n\n// -----------------------------------------------------------------------\n/**\n     * Gets an unmodifiable view of the order of the Set.\n     *\n     * @return an unmodifiable list view",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(set, list);\n}\n\n/**\n * Constructor that wraps (not copies) the Set and specifies the list to use.\n * <p>\n * The set and list must both be correctly initialised to the same elements.\n *\n * @param set  the set to decorate, must not be null\n * @param list  the list to decorate, must not be null\n * @throws NullPointerException if set or list is null\n */\nprotected SetUniqueList(final Set<E> set, final List<E> list) {\n    super(set);\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    setOrder = list;\n}\n\n/**\n * Gets an unmodifiable view of the order of the Set.\n *\n * @return an unmodifiable list view",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(set, list);\n}\n\n/**\n     * Constructor that wraps (not copies) the Set and specifies the list to use.\n     * <p>\n     * The set and list must both be correctly initialised to the same elements.\n     *\n     * @param set the set to decorate, must not be null\n     * @param list the list to decorate, must not be null\n     * @throws NullPointerException if set or list is null\n     */\nprotected SetUniqueList(final Set<E> set, final List<E> list) {\n    super(set);\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    setOrder = list;\n}\n\n// -----------------------------------------------------------------------\n/**\n     * Gets an unmodifiable view of the order of the Set.\n     *\n     * @return an unmodifiable list view",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(set, list);\n}\n\n/**\n * Constructor that wraps (not copies) the Set and specifies the list to use.\n * <p>\n * The set and list must both be correctly initialised to the same elements.\n *\n * @param set  the set to decorate, must not be null\n * @param list  the list to decorate, must not be null\n * @throws NullPointerException if set or list is null\n */\nprotected SetUniqueList(final Set<E> set, final List<E> list) {\n    super(set);\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    setOrder = list;\n}\n\n/**\n * Gets an unmodifiable view of the order of the Set.\n *\n * @return an unmodifiable list view"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    if (elementTypeList == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    arrayType.addChildToBack(elementTypeList);\n    skipEOLs();\n    if (!match(JsDocToken.RB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n}\n\n/**\n * RecordType := '{' FieldTypeList '}'",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    if (elementTypeList == null) {\n        return reportArrayTypeSyntaxWarning();\n    }\n    arrayType.addChildToFront(elementTypeList);\n    skipEOLs();\n    if (!match(JsDocToken.RB)) {\n        return reportArrayTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    arrayType.addChildToBack(elementTypeList);\n    arrayType.addChildToBack(newNode(Token.RB));\n    return arrayType;\n}\n\n/**\n * ElementTypeList := <empty> | TypeExpression | '...' TypeExpression\n *     | TypeExpression ',' ElementTypeList",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    if (elementTypeList == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n    }\n    arrayType.addChildToBack(elementTypeList);\n    if (!match(JsDocToken.RB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    if (elementTypeList == null) {\n        return reportArrayTypeSyntaxWarning();\n    }\n    arrayType.addChildToFront(elementTypeList);\n    skipEOLs();\n    if (!match(JsDocToken.RB)) {\n        return reportArrayTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n}\n\n/**\n * RecordType := '{' FieldTypeList '}'",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    if (elementTypeList == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    arrayType.addChildToFront(elementTypeList);\n    if (match(JsDocToken.RP)) {\n        next();\n    } else {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    return arrayType;\n}\n\n/**\n * RecordType := '{' FieldTypeList '}'",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    if (elementTypeList == null) {\n        return reportGenericTypeSyntaxWarning();\n    }\n    arrayType.addChildToFront(elementTypeList);\n    skipEOLs();\n    if (!match(JsDocToken.RB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n}\n\n/**\n * RecordType := '{' FieldTypeList '}'",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    if (elementTypeList == null) {\n        return reportGenericTypeSyntaxWarning();\n    }\n    arrayType.addChildToBack(elementTypeList);\n    skipEOLs();\n    if (!match(JsDocToken.RB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    arrayType.addChildToBack(elementTypeList);\n    arrayType.addChildToBack(newNode(Token.RB));\n    return arrayType;\n}\n\n/**\n * ElementTypeList := <empty> | TypeExpression | '...' TypeExpression\n *     | TypeExpression ',' ElementTypeList",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node elementTypeList = parseElementTypeList(token);\n    if (elementTypeList == null) {\n        return reportArrayTypeSyntaxWarning();\n    }\n    arrayType.addChildToBack(elementTypeList);\n    skipEOLs();\n    if (!match(JsDocToken.RB)) {\n        return reportArrayTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n}\n\n/**\n * RecordType := '{' FieldTypeList '}'"
    ],
    [
      "public Vector3D getAxis()  {\n  final double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n  if (squaredSine == 0) {\n    return new Vector3D(1, 0, 0);\n  } else if (q0 < 0) {\n    final double inverse = Math.sqrt(squaredSine);\n    return new Vector3D(q1 / inverse, q2 / inverse, q3 / inverse);\n  }\n  final double inverse = Math.sqrt(squaredSine);\n  return new Vector3D(q1 / inverse, q2 / inverse, q3 / inverse);\n}",
      "public Vector3D getAxis()  {\n  final double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n  if (squaredSine == 0) {\n    return new Vector3D(1, 0, 0);\n  } else if (q0 < 0) {\n    final double inverse = Math.sqrt(squaredSine);\n    return new Vector3D(q1 / inverse, q2 / inverse, q3 / inverse);\n  }\n  final double inverse = Math.sqrt(squaredSine);\n  return new Vector3D(q1 / inverse, q2 / inverse, q3 / inverse);\n}",
      "public Vector3D getAxis()  {\n  final double squaredSine = q1*q1 + q2*q2 + q3*q3;\n  if (squaredSine == 0) {\n    return new Vector3D(1, 0, 0);\n  } else if (q0 < 0) {\n    final double inverse = Math.sqrt(squaredSine);\n    return new Vector3D(q1/inverse, q2/inverse, q3/inverse);\n  }\n  final double inverse = Math.sqrt(squaredSine);\n  return new Vector3D(q1/inverse, q2/inverse, q3/inverse);\n}",
      "public Vector3D getAxis()  {\n  final double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n  if (squaredSine == 0) {\n    return new Vector3D(1, 0, 0);\n  } else if (q0 < 0) {\n    final double inverse = Math.sqrt(squaredSine);\n    return new Vector3D(q1 / inverse, q2 / inverse, q3 / inverse);\n  }\n  final double inverse = Math.sqrt(squaredSine);\n  return new Vector3D(q1 / inverse, q2 / inverse, q3 / inverse);\n}",
      "public Vector3D getAxis()  {\n  final double squaredSine = q1*q1 + q2*q2 + q3*q3;\n  if (squaredSine == 0) {\n    return new Vector3D(1, 0, 0);\n  } else if (q0 < 0) {\n    final double inverse = Math.sqrt(squaredSine);\n    return new Vector3D(q1/inverse, q2/inverse, q3/inverse);\n  }\n  final double inverse = Math.sqrt(squaredSine);\n  return new Vector3D(q1/inverse, q2/inverse, q3/inverse);\n}",
      "public Vector3D getAxis()  {\n  return new Vector3D(q1, q2, q3);\n}",
      "public Vector3D getAxis()  {\n  final double squaredSine = q1*q1 + q2*q2 + q3*q3;\n  if (squaredSine == 0) {\n    return new Vector3D(1, 0, 0);\n  } else if (q0 < 0) {\n    final double inverse = Math.sqrt(squaredSine);\n    return new Vector3D(q1/inverse, q2/inverse, q3/inverse);\n  }\n  final double inverse = Math.sqrt(squaredSine);\n  return new Vector3D(q1/inverse, q2/inverse, q3/inverse);\n}",
      "public Vector3D getAxis()  {\n  final double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n  if (squaredSine == 0) {\n    return new Vector3D(1, 0, 0);\n  } else if (q0 < 0) {\n    final double inverse = Math.sqrt(squaredSine);\n    return new Vector3D(q1 / inverse, q2 / inverse, q3 / inverse);\n  }\n  final double inverse = Math.sqrt(squaredSine);\n  return new Vector3D(q1 / inverse, q2 / inverse, q3 / inverse);\n}",
      "public Vector3D getAxis()  {\n    return a1;\n  }",
      "public Vector3D getAxis()  {\n    return new Vector3D(q1, q2, q3).normalize();\n}"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    boolean inEscape = false;\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            inEscape = true;\n        } else if (inEscape) {\n            buffer.write((byte) ((c >= '0' && c <= '9') ? (c - '0') : (c >= 'A' && c <= 'F') ? (c - 'A' + 10) : (c >= 'a' && c <= 'f') ? (c - 'a' + 10) : 0));\n            inEscape = false;\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    boolean inEscape = false;\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            inEscape = true;\n        } else if (inEscape) {\n            buffer.write(c);\n            inEscape = false;\n        } else if (c == '+') {\n            buffer.write(' ');\n        } else if (c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f') {\n            buffer.write((byte) ((inEscape ? 0 : Character.toUpperCase(c)) - '0' + 0));\n            inEscape = false;\n        } else {\n            throw new DecoderException(\"Invalid URL decoding\");\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            try {\n                final byte[] hex = new byte[2];\n                buffer.write(hex[0]);\n                buffer.write(hex[1]);\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL decoding\", e);\n            }\n        } else if (c != '+' && c != '%' && c != ESCAPE_CHAR) {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    boolean inEscape = false;\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            inEscape = true;\n        } else if (inEscape) {\n            buffer.write((byte) ((c >= '0' && c <= '9') ? (c - '0') : (c >= 'A' && c <= 'F') ? (c - 'A' + 10) : (c >= 'a' && c <= 'f') ? (c - 'a' + 10) : 0));\n            inEscape = false;\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    boolean inEscape = false;\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            inEscape = true;\n        } else if (inEscape) {\n            buffer.write(c);\n            inEscape = false;\n        } else {\n            if (c == '+' || c == '-') {\n                buffer.write(c);\n            } else if (c >= '0' && c <= '9' || c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f') {\n                buffer.write((byte) ((c >= '0' && c <= '9' ? 0 : c >= 'A' && c <= 'F' ? 10 : 10) + (c >= '0' && c <= '9' ? 0 : c >= 'A' && c <= 'F' ? 0 : 1)));\n            } else {\n                throw new DecoderException(\"Invalid URL safe encoding\");\n            }\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    boolean inEscape = false;\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            inEscape = true;\n        } else if (inEscape) {\n            buffer.write(c);\n            inEscape = false;\n        } else if (c == '+') {\n            buffer.write(32); // space\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) {\n        final byte b = bytes[i];\n        if (b == ESCAPE_CHAR) {\n            try {\n                // if the next octet is a CR we have found a soft line break\n                if (i + 1 < bytes.length && bytes[i + 1] == CR) {\n                    i++;\n                    continue;\n                }\n                final int u = Utils.digit16(bytes[i + 1]);\n                final int l = Utils.digit16(bytes[i + 2]);\n                buffer.write((char) ((u << 4) + l));\n                i += 2;\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL decoding\", e);\n            }\n        } else if (b != CR && b != LF) {\n            // every other octet is appended except for CR & LF\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    boolean inEscape = false;\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            inEscape = true;\n        } else if (inEscape) {\n            buffer.write(c);\n            inEscape = false;\n        } else if (c == '+' || c == '-' || c == '.' || c == '_' || c == '~') {\n            buffer.write(c);\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    boolean inEscape = false;\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            inEscape = true;\n        } else if (inEscape) {\n            buffer.write((byte) ((c - '0') << 4));\n            inEscape = false;\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (final byte c : bytes) {\n        if (c == ESCAPE_CHAR) {\n            try {\n                final byte[] hex = new byte[2];\n                buffer.write((byte) ((bytes[buffer.size() + 1] & 0xF) + (bytes[buffer.size() + 2] & 0xF)));\n                buffer.write((byte) ((bytes[buffer.size() + 3] & 0xF) + (bytes[buffer.size() + 4] & 0xF)));\n            } catch (final ArrayIndexOutOfBoundsException e) {\n                throw new DecoderException(\"Invalid URL decoding\", e);\n            }\n        } else {\n            buffer.write(c);\n        }\n    }\n    return buffer.toByteArray();\n}"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial cannot be null\");\n        }\n        for (int i = 0; i < partial.size() - 1; i++) {\n            DateTimeField field = partial.getField(i);\n            DateTimeField nextField = partial.getField(i + 1);\n            if (field.getMaximumValue() != nextField.getMinimumValue()) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial cannot be null\");\n        }\n        int size = partial.size();\n        for (int i = 0; i < size - 1; i++) {\n            DateTimeField field = partial.getField(i);\n            DateTimeField nextField = partial.getField(i + 1);\n            if (field.getMaximumValue() != nextField.getMinimumValue()) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial cannot be null\");\n        }\n        for (int i = 0, isize = partial.size(); i < isize - 1; i++) {\n            DateTimeField field1 = partial.getField(i);\n            DateTimeField field2 = partial.getField(i + 1);\n            if (field1.getMaximumValue() != field2.getMinimumValue()) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    for (int i = 0; i < partial.size() - 1; i++) {\n        DateTimeField field = partial.getField(i);\n        DateTimeField nextField = partial.getField(i + 1);\n        if (field.getRange() != nextField.getRange()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial cannot be null\");\n        }\n        for (int i = 0, isize = partial.size(); i < isize; i++) {\n            DateTimeField field = partial.getField(i);\n            if (i < isize - 1) {\n                DateTimeField nextField = partial.getField(i + 1);\n                if (field.getRangeValue() != nextField.getType()) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) {\n        DateTimeField field1 = partial.getField(i);\n        DateTimeField field2 = partial.getField(i + 1);\n        if (field1.getMaximumValue() != field2.getMinimumValue()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial cannot be null\");\n        }\n        for (int i = 0, isize = partial.size(); i < isize - 1; i++) {\n            DateTimeField field = partial.getField(i);\n            DateTimeField nextField = partial.getField(i + 1);\n            if (field.getRange() != nextField.getRange()) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial cannot be null\");\n        }\n        for (int i = 0; i < partial.size() - 1; i++) {\n            DateTimeField field = partial.getField(i);\n            DateTimeField nextField = partial.getField(i + 1);\n            if (field.getRangeValue() != nextField.getMinimumValue()) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial cannot be null\");\n        }\n        int size = partial.size();\n        for (int i = 0; i < size - 1; i++) {\n            DateTimeField field1 = partial.getField(i);\n            DateTimeField field2 = partial.getField(i + 1);\n            if (field1.getRange().getMaximumValue() != field2.getType()) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size; i++) {\n        DateTimeField field = partial.getField(i);\n        if (i < size - 1) {\n            DateTimeField nextField = partial.getField(i + 1);\n            if (field.getMaximumValue() != nextField.getMinimumValue()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    return helper.list();\n}\n\n/**\n     * Returns a new {@link Collection} containing the symmetric difference\n     * of the two given {@link Iterable}s.\n     * <p>\n     * The cardinality of each element in the returned {@link Collection} will\n     * be equal to the maximum of the cardinality of that element in the two\n     * given {@link Iterable}s, minus the minimum of the cardinality of that\n     * element in the two given {@link Iterable}s.\n     *\n     * @param a the first collection, must not be null\n     * @param b the second collection, must not be null\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return the symmetric difference of the two collections\n     * @see Collection#removeAll",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    final List<O> result = new ArrayList<O>(helper);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    final List<O> result = new ArrayList<O>(helper);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    final List<O> list = new ArrayList<O>(helper);\n    for (final O obj : list) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return list;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    final List<O> result = new ArrayList<O>(helper);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return result;\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    return helper.list();\n}\n\n/**\n     * Returns a new {@link Collection} containing the symmetric difference\n     * of the two given {@link Iterable}s.\n     * <p>\n     * The cardinality of each element in the returned {@link Collection} will\n     * be equal to the maximum of the cardinality of that element in the two\n     * given {@link Iterable}s, minus the minimum of the cardinality of that\n     * element in the two given {@link Iterable}s.\n     *\n     * @param a the first collection, must not be null\n     * @param b the second collection, must not be null\n     * @param <O> the generic type that is able to represent the types contained\n     *        in both input collections.\n     * @return the symmetric difference of the two collections\n     * @see Collection#removeAll"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    while (params != null) {\n        if (params.isString()) {\n            result.add(params);\n        }\n        params = params.getNext();\n    }\n    return result;\n}\n\n/**\n   * Given a FUNCTION node returns array of STRING nodes representing function\n   * parameters.\n   * @param n the FUNCTION node.\n   * @return STRING nodes.",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    while (params != null) {\n        if (params.isString()) {\n            result.add(params);\n        } else {\n            params = params.getNext();\n        }\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n        strings.add(param);\n        param = param.getNext();\n    }\n    return strings;\n}\n\n/**\n * Given a FUNCTION node returns array of STRING nodes representing function\n * parameters.\n * @param n the FUNCTION node.\n * @return STRING nodes.",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n        result.add(param);\n        param = param.getNext();\n    }\n    return result;\n}\n\n/**\n * Given a FUNCTION node returns array of STRING nodes representing function\n * parameters.\n * @param n the FUNCTION node.\n * @return STRING nodes.",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n        result.add(param.getString());\n        param = param.getNext();\n    }\n    return result;\n}\n\n/**\n * Given a FUNCTION node returns array of STRING nodes representing function\n * parameters.\n * @param n the FUNCTION node.\n * @return STRING nodes.",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n        result.add(param);\n        param = param.getNext();\n    }\n    return result;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n        result.add(param.getString());\n        param = param.getNext();\n    }\n    return result;\n}\n\n/**\n * Given a FUNCTION node returns array of STRING nodes representing function\n * parameters.\n * @param n the FUNCTION node.\n * @return STRING nodes.",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    while (params != null) {\n        if (params.isString()) {\n            strings.add(params);\n        } else if (params.isParamList()) {\n            strings.addAll(createStringsFromParamList(params.getFirstChild()));\n        }\n        params = params.getNext();\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) {\n        result.add(param);\n        param = param.getNext();\n    }\n    return result;\n}\n\n/**\n   * Given a FUNCTION node returns array of STRING nodes representing function\n   * parameters.\n   * @param n the FUNCTION node.\n   * @return STRING nodes.",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> result = new ArrayList<>();\n    while (params != null) {\n        result.add(params.getString());\n        params = params.getNext();\n    }\n    return result;\n}\n\n/**\n * Given a FUNCTION node returns array of STRING nodes representing function parameters.\n * @param n the FUNCTION node.\n * @return STRING nodes."
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str = str.substring(strLen - width);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            size += padLen;\n        }\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        if (obj == null) {\n            appendFixedWidthPadRight(nullText, width, padChar);\n        } else {\n            String str = obj.toString();\n            if (str.length() > width) {\n                str = str.substring(str.length() - width);\n            }\n            while (str.length() < width) {\n                str += padChar;\n            }\n            append(str);\n        }\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str = str.substring(strLen - width);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            size += padLen;\n        }\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(strLen - width, strLen, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters.length == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    Map<String, String> map = cZoneIdConversion;\n    if (map == null) {\n        map = createConversionMap();\n        cZoneIdConversion = map;\n    }\n    return map.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    Map<String, String> map = cZoneIdConversion;\n    if (map == null) {\n        map = new HashMap<String, String>();\n        map.put(\"SST\", \"Pacific/Guadalcanal\");\n        map.put(\"NST\", \"Pacific/Auckland\");\n        cZoneIdConversion = map;\n    }\n    return map.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    Map<String, String> map = cZoneIdConversion;\n    if (map == null) {\n        map = createMap();\n        cZoneIdConversion = map;\n    }\n    return map.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    Map<String, String> map = cZoneIdConversion;\n    if (map == null) {\n        map = new HashMap<String, String>();\n        map.put(\"SST\", \"Pacific/Guadalcanal\");\n        map.put(\"NST\", \"Pacific/Auckland\");\n        cZoneIdConversion = map;\n    }\n    return map.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    Map<String, String> map = cZoneIdConversion;\n    if (map == null) {\n        map = createMap();\n        cZoneIdConversion = map;\n    }\n    return map.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    Map<String, String> map = cZoneIdConversion;\n    if (map == null) {\n        map = new HashMap<String, String>();\n        map.put(\"SST\", \"Pacific/Guadalcanal\");\n        map.put(\"NST\", \"Pacific/Auckland\");\n        cZoneIdConversion = map;\n    }\n    return map.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n        if (id == null) {\n            return null;\n        }\n        Map<String, String> map = cZoneIdConversion;\n        return map.get(id);\n    }",
      "private static synchronized String getConvertedId(String id)  {\n        if (id == null) {\n            return null;\n        }\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            map = new HashMap<String, String>();\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }",
      "private static synchronized String getConvertedId(String id)  {\n        if (id == null) {\n            return null;\n        }\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            map = new HashMap<String, String>();\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }",
      "private static synchronized String getConvertedId(String id)  {\n    if (id == null) {\n        return null;\n    }\n    Map<String, String> map = cZoneIdConversion;\n    if (map == null) {\n        map = createConversionMap();\n        cZoneIdConversion = map;\n    }\n    return map.get(id);\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    RealMatrix jacobian = new Array2DRowRealMatrix(numCols, numCols);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < numCols; j++) {\n            for (int k = 0; k < numCols; k++) {\n                jacobian.setEntry(j, k, (gamma[i][j] * gamma[i][k]) * (params[j] - newMeans[j][j]) * (params[k] - newMeans[k][k]));\n            }\n        }\n    }\n    return jacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    RealMatrix jacobian = new Array2DRowRealMatrix(numCols, numCols);\n    for (int i = 0; i < n; i++) {\n        RealMatrix vec = new Array2DRowRealMatrix(MathArrays.ebeSubtract(data[i], means));\n        RealMatrix dataCov = vec.multiply(vec.transpose()).scalarMultiply(gamma[i]);\n        jacobian.add(dataCov);\n    }\n    return jacobian;\n}\n\n/**\n * Computes the objective function value at given parameters.\n *\n * @param params Model parameters at which to compute the objective function.\n * @return the objective function value.\n */\nprotected double[] computeObjectiveValue(double[] params) {\n    double[] objective = new double[n];\n    for (int i = 0; i < n; i++) {\n        double rowDensity = density(data[i], params);\n        sumLogLikelihood += Math.log(rowDensity);\n        for (int j = 0; j < k; j++) {\n            gamma[i][j] = weights[j] * mvns[j].density(data[i]) / rowDensity;\n            gammaSums[j] += gamma[i][j];\n            for (int col = 0; col < numCols; col++) {\n                gammaDataProdSums[j][col] += gamma[i][j] * data[i][col];\n            }\n        }\n    }\n    logLikelihood = sumLogLikelihood / n;\n    return new double[]{logLikelihood};\n}\n\n/**\n * Computes the residuals at given parameters.\n *\n * @param params Model parameters at which to compute the residuals.\n * @return the residuals.\n */\nprotected double[] computeResiduals(double[] params) {\n    double[] residuals = new double[n];\n    for (int i = 0; i < n; i++) {\n        double rowDensity = density(data[i], params);\n        for (int j = 0; j < k; j++) {\n            gamma[i][j] = weights[j] * mvns[j].density(data[i]) / rowDensity;\n            residuals[i] += gamma[i][j] * (data[i][0] - means[j][0]);\n        }\n    }\n    return residuals;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  /**\n * Computes the partial derivative of the objective function with respect to\n * the jth parameter at the ith data point.\n *\n * @param params Model parameters at which to compute the partial derivative.\n * @param i Index of the data point.\n * @param j Index of the parameter.\n * @return the partial derivative.\n */\nprotected double computePartialDerivative(double[] params, int i, int j) {\n    // Compute the partial derivative of the log-likelihood function\n    // with respect to the jth parameter at the ith data point.\n    final double[] weights = params.subArray(0, k);\n    final double[] means = params.subArray(k, k + numCols * k);\n    final double[] covMats = new double[numCols * numCols];\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final int nR = getTarget().length; // Number of observed data.\n    final int nC = params.length; // Number of model parameters.\n\n    final RealMatrix jacobian = new Array2DRowRealMatrix(nR, nC);\n\n    for (int i = 0; i < nR; i++) {\n        final double[] grad = new double[nC];\n        for (int j = 0; j < nC; j++) {\n            grad[j] = computePartialDerivative(i, params[j]);\n        }\n        jacobian.setRow(i, grad);\n    }\n\n    return jacobian;\n}\n\n/**\n * Computes the partial derivative of the objective function with respect\n * to the jth parameter at the ith data point.\n *\n * @param i Index of the data point.\n * @param j Index of the parameter.\n * @return the partial derivative.\n */\nprotected abstract double computePartialDerivative(int i, double j);\n\n/**\n * Computes the objective function value at the given parameters.\n *\n * @param params Model parameters.\n * @return the objective function value.\n */\nprotected abstract double computeObjectiveValue(double[] params);\n\n/**\n * Computes the residuals at the given parameters.\n *\n * @param params Model parameters.\n * @return the residuals.\n */\nprotected abstract double[] computeResiduals(double[] params);",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final int nR = params.length; // Number of observed data.\n    final int nC = params.length; // Number of parameters.\n    final RealMatrix jacobian = new Array2DRowRealMatrix(nR, nC);\n    for (int i = 0; i < nR; i++) {\n        final double[] grad = new double[nC];\n        for (int j = 0; j < nC; j++) {\n            grad[j] = computePartialDerivative(params, i, j);\n        }\n        jacobian.setRow(i, grad);\n    }\n    return jacobian;\n}\n\n/**\n * Computes the partial derivative of the objective function with respect to\n * the jth parameter at the given point.\n *\n * @param params Model parameters at which to compute the partial derivative.\n * @param i Index of the observed data point.\n * @param j Index of the parameter.\n * @return the partial derivative.\n */\nprotected double computePartialDerivative(double[] params, int i, int j) {\n    // implement this method\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    RealMatrix jacobian = new Array2DRowRealMatrix(numCols, numCols);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < numCols; j++) {\n            for (int k = 0; k < numCols; k++) {\n                jacobian.setEntry(j, k, computePartialDerivative(params, i, j, k));\n            }\n        }\n    }\n    return jacobian;\n}\n\n/**\n * Computes the partial derivative of the model density with respect to a\n * specific parameter at a given data point.\n *\n * @param params Model parameters.\n * @param i Data point index.\n * @param j Parameter index.\n * @param k Data column index.\n * @return the partial derivative.\n */\nprotected double computePartialDerivative(double[] params, int i, int j, int k) {\n    double partialDerivative = 0.0;\n    // compute the partial derivative\n    // ...\n    return partialDerivative;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    RealMatrix jacobian = new Array2DRowRealMatrix(numCols, k);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < k; j++) {\n            double[] vec = MathArrays.ebeSubtract(data[i], means[j]);\n            jacobian.setEntry(i, j, vec[0]);\n        }\n    }\n    return jacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    RealMatrix jacobian = new Array2DRowRealMatrix(numCols, numCols);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < numCols; j++) {\n            for (int k = 0; k < numCols; k++) {\n                jacobian.setEntry(j, k, computePartialDerivative(params, i, j, k));\n            }\n        }\n    }\n    return jacobian;\n}\n\n/**\n * Computes the partial derivative of the objective function with respect to\n * the model parameters at a given point.\n *\n * @param params Model parameters at which to compute the partial derivative.\n * @param i Index of the data point.\n * @param j Index of the column.\n * @param k Index of the row.\n * @return the partial derivative.\n */\nprotected double computePartialDerivative(double[] params, int i, int j, int k) {\n    double partialDerivative = 0;\n    for (int l = 0; l < k; l++) {\n        partialDerivative += (data[i][j] - newMeans[k][j]) * (data[i][l] - newMeans[k][l]);\n    }\n    return partialDerivative;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final int nR = getTarget().length;\n    final int nC = params.length;\n\n    final RealMatrix jacobian = new Array2DRowRealMatrix(nR, nC);\n    for (int i = 0; i < nR; i++) {\n        for (int j = 0; j < nC; j++) {\n            jacobian.setEntry(i, j, computePartialDerivative(i, j, params));\n        }\n    }\n    return jacobian;\n}\n\n/**\n * Computes the partial derivative of the objective function with respect to\n * the j-th parameter at the i-th data point.\n *\n * @param i the index of the data point.\n * @param j the index of the parameter.\n * @param params the current model parameters.\n * @return the partial derivative.\n */\nprotected double computePartialDerivative(int i, int j, double[] params) {\n    // TO DO: implement this method\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  {\n    final int nR = params.length; // Number of observed data.\n    final RealMatrix jacobian = new Array2DRowRealMatrix(nR, params.length);\n    for (int i = 0; i < nR; i++) {\n        final double[] grad = computeGradient(params, i);\n        jacobian.setRow(i, grad);\n    }\n    return jacobian;\n}\n\n/**\n * Computes the gradient of the objective function at the given point.\n *\n * @param params Model parameters at which to compute the gradient.\n * @param i Index of the residual.\n * @return the gradient of the objective function at the given point.\n */\nprotected double[] computeGradient(double[] params, int i) {\n    // Compute the residual at the given point.\n    final double residual = computeResidual(params);\n\n    // Compute the gradient of the residual.\n    final double[] grad = computeGradientResidual(params, residual);\n\n    return grad;\n}\n\n/**\n * Computes the gradient of the residual.\n *\n * @param params Model parameters.\n * @param residual Residual value.\n * @return the gradient of the residual.\n */\nprotected double[] computeGradientResidual(double[] params, double residual) {\n    // Compute the gradient of the residual.\n    final double[] grad = new double[params.length];\n    for (int j = 0; j < params.length; j++) {\n        final double param = params[j];\n        final double delta = 1e-6;\n        final double residualPlusDelta = computeResidual(plus(params, j, delta));\n        final double residualMinusDelta = computeResidual(minus(params, j, delta));\n        grad[j] = (residualPlusDelta - residualMinusDelta) / (2 * delta);\n    }\n    return grad;\n}\n\n/**\n * Computes the residual.\n *\n * @param params Model parameters.\n * @return the residual.\n */\nprotected double computeResidual(double[] params) {\n    // Compute the residual.\n    final double residual = 0.0;\n    for (int i = 0; i < params.length; i++) {\n        residual += Math.pow(params[i] - params[i], 2);\n    }\n    return residual;\n}\n\n/**\n * Computes the plus operation.\n *\n * @param params Model parameters.\n * @param j Index of the parameter.\n * @param delta Delta value.\n * @return the plus operation.\n */\nprotected double[] plus(double[] params, int j, double delta) {\n}"
    ],
    [
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must not be null\");\n    }\n    int leastIndex = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (comparator.compare(values[leastIndex], values[i]) > 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must not be null\");\n    }\n    int leastIndex = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (comparator.compare(values[leastIndex], values[i]) > 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must not be null\");\n    }\n    int minIndex = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (comparator.compare(values[i - 1], values[i]) > 0) {\n            minIndex = i;\n        }\n    }\n    return minIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must not be null\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"Values must not be null\");\n    }\n    int minIndex = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (comparator.compare(values[minIndex], values[i]) > 0) {\n            minIndex = i;\n        }\n    }\n    return minIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must not be null\");\n    }\n    int leastIndex = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (comparator.compare(values[i - 1], values[i]) > 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must not be null\");\n    }\n    int leastIndex = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (comparator.compare(values[i - 1], values[i]) > 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must not be null\");\n    }\n    int leastIndex = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (comparator.compare(values[i], values[leastIndex]) < 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must not be null\");\n    }\n    if (values == null) {\n        values = new ArrayList<>();\n        for (int i = 0; i < size; i++) {\n            values.add(i);\n        }\n    }\n    int leastIndex = 0;\n    for (int i = 1; i < values.size(); i++) {\n        if (comparator.compare(values.get(i), values.get(leastIndex)) < 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must not be null\");\n    }\n    if (values == null) {\n        throw new NullPointerException(\"Values must not be null\");\n    }\n    int minIndex = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (comparator.compare(values[i], values[minIndex]) < 0) {\n            minIndex = i;\n        }\n    }\n    return minIndex;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"Comparator must not be null\");\n    }\n    int leastIndex = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (comparator.compare(values[i], values[leastIndex]) < 0) {\n            leastIndex = i;\n        }\n    }\n    return leastIndex;\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    if (step.getAxis() == Compiler.AXIS_CHILD) {\n        return new NodePointer(parentPointer, name.toString());\n    } else if (step.getAxis() == Compiler.AXIS_ATTRIBUTE) {\n        return new AttributePointer(parentPointer, name.toString());\n    } else {\n        return new NullPropertyPointer(parentPointer);\n    }\n}\n\n/**\n * A path that starts with a standard InfoSet node, e.g. a DOM Node.\n * The method evaluates the first predicate in a special way and\n * then forwards to a general predicate processing method.\n * @param context evaluation context\n * @param parent parent pointer\n * @param steps path steps\n * @param currentStep step number\n * @return NodePointer",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    if (step.getAxis() == Compiler.AXIS_CHILD) {\n        return new ChildNodePointer(parentPointer, name);\n    } else if (step.getAxis() == Compiler.AXIS_ATTRIBUTE) {\n        return new AttributeNodePointer(parentPointer, name);\n    } else {\n        return new SelfNodePointer(parentPointer);\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    if (name.getLocalPart().equals(\"property\")) {\n        return new PropertyOwnerPointer(parentPointer, name);\n    } else {\n        return new NodePointer(parentPointer, name);\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    if (step.getAxis() == Compiler.AXIS_SELF) {\n        return parentPointer;\n    }\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    return new PropertyOwnerPointer(parentPointer, name.toString());\n}\n\n/**\n     * A path that starts with a standard InfoSet node, e.g. a DOM Node.\n     * The method evaluates the first predicate in a special way and\n     * then forwards to a general predicate processing method.\n     * @param context evaluation context\n     * @param parent parent pointer\n     * @param steps path steps\n     * @param currentStep step number\n     * @return NodePointer",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    return new NodePointer(parentPointer, name.toString());\n}\n\n/**\n * A path that starts with a standard InfoSet node, e.g. a DOM Node.\n * The method evaluates the first predicate in a special way and\n * then forwards to a general predicate processing method.\n * @param context evaluation context\n * @param parent parent pointer\n * @param steps path steps\n * @param currentStep step number\n * @return NodePointer",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        Step step = steps[currentStep];\n        Expression[] predicates = step.getPredicates();\n        return doPredicate(\n            context,\n            childPointer,\n            steps,\n            currentStep,\n            predicates,\n            0);\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    if (name.getLocalPart().equals(\"children\")) {\n        return new NodePointer(parentPointer, name);\n    } else {\n        return new PropertyPointer(parentPointer, name);\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n        Property property = parentPointer.getProperty(name.toString());\n        if (property != null) {\n            return property.getNodePointer();\n        }\n        return null;\n    }\n\n    /**\n     * A path that starts with a standard InfoSet node, e.g. a DOM Node.\n     * The method evaluates the first predicate in a special way and\n     * then forwards to a general predicate processing method.\n     * @param context evaluation context\n     * @param parent parent pointer\n     * @param steps path steps\n     * @param currentStep step number\n     * @return NodePointer",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    return new NodePointer(parentPointer, name.toString());\n}\n\n/**\n * A path that starts with a standard InfoSet node, e.g. a DOM Node.\n * The method evaluates the first predicate in a special way and\n * then forwards to a general predicate processing method.\n * @param context evaluation context\n * @param parent parent pointer\n * @param steps path steps\n * @param currentStep step number\n * @return NodePointer",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    QName name = ((NodeNameTest) step.getNodeTest()).getNodeName();\n    if (step.getAxis() == Compiler.AXIS_CHILD) {\n        return new ChildNodePointer(parentPointer, name);\n    } else if (step.getAxis() == Compiler.AXIS_ATTRIBUTE) {\n        return new AttributeNodePointer(parentPointer, name);\n    } else {\n        return new SelfNodePointer(parentPointer);\n    }\n}"
    ],
    [
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? inf : Double.POSITIVE_INFINITY;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? inf : Double.NEGATIVE_INFINITY;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? inf : Double.POSITIVE_INFINITY;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}\n\n/**\n * Obtain a Strategy given a field from a SimpleDateFormat pattern\n * @param formatField A sub-sequence of the SimpleDateFormat pattern\n * @param definingCalendar The calendar to obtain the short and long values\n * @return The Strategy that will handle parsing for the field",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}\n\n/**\n     * Obtain a Strategy given a field from a SimpleDateFormat pattern\n     * @param formatField A sub-sequence of the SimpleDateFormat pattern\n     * @param definingCalendar The calendar to obtain the short and long values\n     * @return The Strategy that will handle parsing for the field",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}\n\n/**\n * Obtain a Strategy given a field from a SimpleDateFormat pattern\n * @param formatField A sub-sequence of the SimpleDateFormat pattern\n * @param definingCalendar The calendar to obtain the short and long values\n * @return The Strategy that will handle parsing for the field",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    return new TextStrategy(field, definingCalendar, locale);\n}\n\n/**\n     * Obtain a Strategy given a field from a SimpleDateFormat pattern\n     * @param formatField A sub-sequence of the SimpleDateFormat pattern\n     * @param definingCalendar The calendar to obtain the short and long values\n     * @return The Strategy that will handle parsing for the field"
    ],
    [
      "private boolean setNextObject()  {\n        if (!iterator.hasNext()) {\n            return false;\n        }\n        nextObject = iterator.next();\n        nextObjectSet = true;\n        return true;\n    }\n\n    /**\n     * Set previousObject to the previous object. If there are no more\n     * objects then return false. Otherwise, return true.\n     */",
      "private boolean setNextObject()  {\n        if (iterator.hasNext()) {\n            nextObject = iterator.next();\n            nextObjectSet = true;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Set previousObject to the previous object. If there are no more\n     * objects then return false. Otherwise, return true.\n     */",
      "private boolean setNextObject()  {\n        if (iterator.hasNext()) {\n            nextObject = iterator.next();\n            nextObjectSet = true;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Set previousObject to the previous object. If there are no more\n     * objects then return false. Otherwise, return true.\n     */",
      "private boolean setNextObject()  {\n        if (iterator.hasNext()) {\n            nextObject = iterator.next();\n            nextObjectSet = true;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Set previousObject to the previous object. If there are no more\n     * objects then return false. Otherwise, return true.\n     */",
      "private boolean setNextObject()  {\n        if (nextIndex >= values.size()) {\n            return false;\n        }\n        if (valueSet.get(nextIndex)) {\n            nextObject = values.get(nextIndex);\n            nextIndex++;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Set previousObject to the previous object. If there are no more\n     * objects then return false. Otherwise, return true.\n     */",
      "private boolean setNextObject()  {\n        if (nextIndex >= iteratorSize) {\n            return false;\n        }\n        nextObject = iterator.next();\n        nextIndex++;\n        return true;\n    }\n\n    /**\n     * Set previousObject to the previous object. If there are no more\n     * objects then return false. Otherwise, return true.\n     */",
      "private boolean setNextObject()  {\n    if (!iterator.hasNext()) {\n        return false;\n    }\n    nextObject = iterator.next();\n    nextObjectSet = true;\n    return true;\n}\n\n/**\n     * Set previousObject to the previous object. If there are no more\n     * objects then return false. Otherwise, return true.\n     */",
      "private boolean setNextObject()  {\n        if (iterator.hasNext()) {\n            nextObject = iterator.next();\n            nextObjectSet = true;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Set previousObject to the previous object. If there are no more\n     * objects then return false. Otherwise, return true.\n     */",
      "private boolean setNextObject()  {\n        if (!iterator.hasNext()) {\n            return false;\n        }\n        nextObject = iterator.next();\n        return true;\n    }\n\n    /**\n     * Set previousObject to the previous object. If there are no more\n     * objects then return false. Otherwise, return true.\n     */",
      "private boolean setNextObject()  {\n    if (!iterator.hasNext()) {\n        return false;\n    }\n    nextObject = iterator.next();\n    return true;\n}\n\n/**\n     * Set previousObject to the previous object. If there are no more\n     * objects then return false. Otherwise, return true.\n     */"
    ],
    [
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; ++i) {\n        if (x[i] < getLowerBound()[i]) {\n            repaired[i] = getLowerBound()[i];\n        } else if (x[i] > getUpperBound()[i]) {\n            repaired[i] = getUpperBound()[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < getLowerBound()[i]) {\n            repaired[i] = getLowerBound()[i];\n        } else if (x[i] > getUpperBound()[i]) {\n            repaired[i] = getUpperBound()[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < getLowerBound()[i]) {\n            repaired[i] = getLowerBound()[i];\n        } else if (x[i] > getUpperBound()[i]) {\n            repaired[i] = getUpperBound()[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}\n\n/**\n * @param x Normalized objective variables.\n * @param y Repaired objective variables.\n * @return the penalty for the objective variables.",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < getLowerBound()[i]) {\n            repaired[i] = getLowerBound()[i];\n        } else if (x[i] > getUpperBound()[i]) {\n            repaired[i] = getUpperBound()[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}\n\n/**\n * @param x Normalized objective variables.\n * @return the penalty for boundary violations.",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; ++i) {\n        if (x[i] < getLowerBound()[i]) {\n            repaired[i] = getLowerBound()[i];\n        } else if (x[i] > getUpperBound()[i]) {\n            repaired[i] = getUpperBound()[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}\n\n        /**\n         * @param x Normalized objective variables.\n         * @param y repaired (i.e. all in bounds) objective variables.\n         * @return the penalty for boundary violations.",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; ++i) {\n        if (x[i] < getLowerBound()[i]) {\n            repaired[i] = getLowerBound()[i];\n        } else if (x[i] > getUpperBound()[i]) {\n            repaired[i] = getUpperBound()[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}\n\n/**\n * @param point Normalized objective variables.\n * @return the penalty for the given point.",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < getLowerBound()[i]) {\n            repaired[i] = getLowerBound()[i];\n        } else if (x[i] > getUpperBound()[i]) {\n            repaired[i] = getUpperBound()[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}\n\n/**\n * @param x Normalized objective variables.\n * @return the penalty for the given objective variables.",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; ++i) {\n        if (x[i] < getLowerBound()[i]) {\n            repaired[i] = getLowerBound()[i];\n        } else if (x[i] > getUpperBound()[i]) {\n            repaired[i] = getUpperBound()[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}\n\n/**\n * @param x Normalized objective variables.\n * @return the penalty for boundary violations.",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < getLowerBound()[i]) {\n            repaired[i] = getLowerBound()[i];\n        } else if (x[i] > getUpperBound()[i]) {\n            repaired[i] = getUpperBound()[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}\n\n        /**\n         * @param x Normalized objective variables.\n         * @param y repaired (i.e. all in bounds) objective variables.\n         * @return penalty for boundary violations",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < getLowerBound()[i]) {\n            repaired[i] = getLowerBound()[i];\n        } else if (x[i] > getUpperBound()[i]) {\n            repaired[i] = getUpperBound()[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    return schurTransformer;\n}\n\n/**\n     * Find eigenvectors from a matrix transformed to Schur form.\n     *\n     * @param schur the schur transformation of the matrix\n     * @throws MathArithmeticException if the Schur form has a norm of zero",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final double[][] matrixT = new double[matrix.getRowDimension()][matrix.getColumnDimension()];\n    final double[][] matrixP = new double[matrix.getRowDimension()][matrix.getColumnDimension()];\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    matrixT = schurTransformer.getT().getData();\n    matrixP = schurTransformer.getP().getData();\n    return new SchurTransformer(matrixT, matrixP);\n}\n\n/**\n     * Find eigenvectors from a matrix transformed to Schur form.\n     *\n     * @param schur the schur transformation of the matrix\n     * @throws MathArithmeticException if the Schur form has a norm of zero",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    HessenbergTransformer transformer = new HessenbergTransformer(matrix);\n    double[][] matrixT = transformer.getH().getData();\n    double[][] matrixP = transformer.getP().getData();\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    schurTransformer.setT(matrixT);\n    schurTransformer.setP(matrixP);\n    return schurTransformer;\n}\n\n/**\n     * Calculates the eigen decomposition of the given real matrix.\n     * <p>\n     * Supports decomposition of a general matrix since 3.1.\n     *\n     * @param matrix Matrix to decompose.\n     * @throws MathArithmeticException if the decomposition of a general matrix\n     * results in a matrix with zero norm\n     * @since 3.1",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    return schurTransformer;\n}\n\n/**\n     * Calculates the eigen decomposition of the given real matrix.\n     * <p>\n     * Supports decomposition of a general matrix since 3.1.\n     *\n     * @param matrix Matrix to decompose.\n     * @throws MathArithmeticException if the decomposition of a general matrix\n     * results in a matrix with zero norm\n     * @since 3.1",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    HessenbergTransformer transformer = new HessenbergTransformer(matrix);\n    double[][] matrixT = transformer.getH().getData();\n    double[][] matrixP = transformer.getP().getData();\n    SchurTransformer schur = new SchurTransformer(matrix);\n    schur.setT(matrixT);\n    schur.setP(matrixP);\n    return schur;\n}\n\n/**\n     * Calculates the eigen decomposition of the given real matrix.\n     * <p>\n     * Supports decomposition of a general matrix since 3.1.\n     *\n     * @param matrix Matrix to decompose.\n     * @throws MaxCountExceededException if the algorithm fails to converge.\n     * @throws MathArithmeticException if the decomposition of a general matrix\n     * results in a matrix with zero norm\n     * @since 3.1",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    HessenbergTransformer transformer = new HessenbergTransformer(matrix);\n    matrixT = transformer.getH().getData();\n    matrixP = transformer.getP().getData();\n    cachedT = null;\n    cachedP = null;\n    cachedPt = null;\n\n    // transform matrix\n    transformer.transform();\n\n    return new SchurTransformer(matrix);\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    HessenbergTransformer transformer = new HessenbergTransformer(matrix);\n    double[][] matrixT = transformer.getH().getData();\n    double[][] matrixP = transformer.getP().getData();\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    schurTransformer.setT(matrixT);\n    schurTransformer.setP(matrixP);\n    return schurTransformer;\n}\n\n/**\n     * Find eigenvectors from a matrix transformed to Schur form.\n     *\n     * @param schur the schur transformation of the matrix\n     * @throws MathArithmeticException if the Schur form has a norm of zero",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    final double[][] matrixT = new double[matrix.getRowDimension()][matrix.getColumnDimension()];\n    final double[][] matrixP = new double[matrix.getRowDimension()][matrix.getColumnDimension()];\n    HessenbergTransformer transformer = new HessenbergTransformer(matrix);\n    matrixT = transformer.getH().getData();\n    matrixP = transformer.getP().getData();\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    schurTransformer.transform();\n    return schurTransformer;\n}\n\n/**\n     * Find eigenvectors from a matrix transformed to Schur form.\n     *\n     * @param schur the schur transformation of the matrix\n     * @throws MathArithmeticException if the Schur form has a norm of zero",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    SchurTransformer schurTransformer = new SchurTransformer(matrix);\n    return schurTransformer;\n}\n\n/**\n     * Find eigenvectors from a matrix transformed to Schur form.\n     *\n     * @param schur the schur transformation of the matrix\n     * @throws MathArithmeticException if the Schur form has a norm of zero",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  {\n    HessenbergTransformer transformer = new HessenbergTransformer(matrix);\n    double[][] matrixT = transformer.getH().getData();\n    double[][] matrixP = transformer.getP().getData();\n    SchurTransformer schur = new SchurTransformer(matrix);\n    schur.setT(matrixT);\n    schur.setP(matrixP);\n    return schur;\n}\n\n/**\n     * Find eigenvectors from a matrix transformed to Schur form.\n     *\n     * @param schur the schur transformation of the matrix\n     * @throws MathArithmeticException if the Schur form has a norm of zero"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (int i = Long.SIZE - 1; i >= 0; i--) {\n            final E valueEnum = enumClass.getEnumConstants()[ (int) ((value >> i) & 0x1)];\n            if (valueEnum != null) {\n                result.add(valueEnum);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (int i = Long.SIZE - 1; i >= 0; i--) {\n            final E valueEnum = enumClass.getEnumConstants()[((int) (value & ((1L << i) - 1)))];\n            result.add(valueEnum);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (int i = Long.SIZE - 1; i >= 0; i--) {\n            final E constant = enumClass.getEnumConstants()[value & (1 << i) - 1];\n            result.add(constant);\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (int i = Long.SIZE - 1; i >= 0; i--) {\n            if ((value & (1L << i)) != 0) {\n                condensed.add(enumClass.getEnumConstants()[(int) (value & ((1L << i) - 1))]);\n            }\n        }\n    }\n    return condensed;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (int i = Long.SIZE - 1; i >= 0; i--) {\n            if ((value & (1 << i)) != 0) {\n                result.add(enumClass.getEnumConstants()[(int) (value & ((1 << i) - 1))]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (int i = Long.SIZE - 1; i >= 0; i--) {\n            if ((value & (1L << i)) != 0) {\n                result.add(enumClass.getEnumConstants()[(int) (value & ((1L << i) - 1))]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (int i = Long.SIZE - 1; i >= 0; i--) {\n            if ((value & (1L << i)) != 0) {\n                result.add(enumClass.getEnumConstants()[(int) (value & ((1L << i) - 1))]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (int i = Long.SIZE - 1; i >= 0; i--) {\n            if ((value & (1L << i)) != 0) {\n                condensed.add(enumClass.getEnumConstants()[(int) (value & ((1L << i) - 1)) + i]);\n            }\n        }\n    }\n    return condensed;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (int i = Long.SIZE - 1; i >= 0; i--) {\n            final E constant = enumClass.getEnumConstants()[ (int) ((value >> i) & 0x1)];\n            if (constant != null) {\n                result.add(constant);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (long value : values) {\n        for (int i = Long.SIZE - 1; i >= 0; i--) {\n            final E constant = enumClass.getEnumConstants()[((int) (value & ((1L) << i)))];\n            result.add(constant);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeUtils.getZone();\n    }\n    DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n    if (newZone == originalZone) {\n        return oldInstant;\n    }\n    long offset = originalZone.getOffset(oldInstant);\n    long instantLocal = oldInstant - offset;\n    long instantUTC = instantLocal;\n    return instantUTC;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n    if (newZone == originalZone) {\n        return oldInstant;\n    }\n    \n    long instantLocal = originalZone.convertUTCToLocal(oldInstant);\n    long instantUTC = newZone.convertLocalToUTC(instantLocal, true, oldInstant);\n    return instantUTC;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeUtils.getZone(DateTimeZone.getDefault());\n    }\n    DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n    if (newZone == originalZone) {\n        return oldInstant;\n    }\n    long offset = originalZone.getOffset(oldInstant);\n    long instantLocal = oldInstant - offset;\n    long instantUTC = instantLocal;\n    // check for overflow\n    if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n        throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n    }\n    return instantUTC;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeUtils.getZone(DateTimeZone.getDefault());\n    }\n    DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n    long offset = originalZone.getOffset(oldInstant);\n    long instantLocal = oldInstant - offset;\n    long instantUTC = instantLocal;\n    if (instantLocal < 0) {\n        instantUTC -= offset;\n    }\n    if (instantUTC < 0) {\n        throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n    }\n    return instantUTC;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    DateTimeZone originalZone = getZone();\n    if (newZone == originalZone) {\n        return oldInstant;\n    }\n    int offsetOriginal = getOffset(oldInstant);\n    long instantLocal = oldInstant - offsetOriginal;\n    int offsetLocalFromOriginal = getOffset(instantLocal);\n    if (offsetLocalFromOriginal == offsetOriginal) {\n        return oldInstant;\n    }\n    return convertLocalToUTC(instantLocal, true);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeUtils.getZone();\n    }\n    DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n    if (newZone == originalZone) {\n        return oldInstant;\n    }\n    \n    long instantLocal = originalZone.convertUTCToLocal(oldInstant);\n    long instantUTC = newZone.convertLocalToUTC(instantLocal, true, oldInstant);\n    return instantUTC;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeUtils.getZone();\n    }\n    DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n    if (newZone == originalZone) {\n        return oldInstant;\n    }\n    \n    long instantLocal = originalZone.convertUTCToLocal(oldInstant);\n    long instantUTC = newZone.convertLocalToUTC(instantLocal, true, oldInstant);\n    return instantUTC;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeUtils.getZone(newZone);\n    }\n    DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n    if (newZone == originalZone) {\n        return oldInstant;\n    }\n    long offset = originalZone.getOffset(oldInstant);\n    long instantLocal = oldInstant - offset;\n    long instantUTC = instantLocal;\n    if (instantUTC < 0) {\n        instantUTC += 86400000; // add a day\n    }\n    return newZone.getMillisFromLocal(instantUTC);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n    if (newZone == originalZone) {\n        return oldInstant;\n    }\n    long instantLocal = originalZone.convertUTCToLocal(oldInstant);\n    long instantUTC = newZone.convertLocalToUTC(instantLocal, true, oldInstant);\n    return instantUTC;\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeUtils.getZone();\n    }\n    DateTimeZone originalZone = DateTimeUtils.getZone(getZone());\n    if (newZone == originalZone) {\n        return oldInstant;\n    }\n    \n    long instantLocal = originalZone.convertUTCToLocal(oldInstant);\n    long instantUTC = newZone.convertLocalToUTC(instantLocal, true, oldInstant);\n    return instantUTC;\n}"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    if (unit.getUnitType().equals(DateTickUnitType.MILLISECOND)) {\n        calendar.set(Calendar.MILLISECOND, value);\n    }\n    else if (unit.getUnitType().equals(DateTickUnitType.SECOND)) {\n        calendar.set(Calendar.SECOND, value);\n    }\n    else if (unit.getUnitType().equals(DateTickUnitType.MINUTE)) {\n        calendar.set(Calendar.MINUTE, value);\n    }\n    else if (unit.getUnitType().equals(DateTickUnitType.HOUR)) {\n        calendar.set(Calendar.HOUR_OF_DAY, value);\n    }\n    else if (unit.getUnitType().equals(DateTickUnitType.DAY)) {\n        calendar.set(Calendar.DAY_OF_MONTH, value);\n    }\n    else if (unit.getUnitType().equals(DateTickUnitType.MONTH)) {\n        calendar.set(Calendar.MONTH, value);\n    }\n    else if (unit.getUnitType().equals(DateTickUnitType.YEAR)) {\n        calendar.set(Calendar.YEAR, value);\n    }\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    calendar.set(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n    calendar.set(Calendar.MILLISECOND, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.DAY_OF_MONTH, 1);\n    calendar.set(Calendar.MONTH, 0);\n    calendar.set(Calendar.YEAR, 0);\n    calendar.add(unit.getCalendarField(), value - current);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n\n    calendar.set(Calendar.MILLISECOND, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.DAY_OF_MONTH, 1);\n    calendar.set(Calendar.MONTH, 0);\n    calendar.set(Calendar.YEAR, 0);\n\n    calendar.add(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    if (unit.equals(DateTickUnitType.MILLISECOND)) {\n        milliseconds = value + count;\n        calendar.set(Calendar.MILLISECOND, milliseconds);\n    }\n    else if (unit.equals(DateTickUnitType.SECOND)) {\n        seconds = value + count;\n        calendar.set(Calendar.SECOND, seconds);\n    }\n    else if (unit.equals(DateTickUnitType.MINUTE)) {\n        minutes = value + count;\n        calendar.set(Calendar.MINUTE, minutes);\n    }\n    else if (unit.equals(DateTickUnitType.HOUR)) {\n        hours = value + count;\n        calendar.set(Calendar.HOUR_OF_DAY, hours);\n    }\n    else if (unit.equals(DateTickUnitType.DAY)) {\n        days = value + count;\n        calendar.set(Calendar.DAY_OF_MONTH, days);\n    }\n    else if (unit.equals(DateTickUnitType.MONTH)) {\n        months = value + count;\n        calendar.set(Calendar.MONTH, months);\n    }\n    else if (unit.equals(DateTickUnitType.YEAR)) {\n        years = value + count;\n        calendar.set(Calendar.YEAR, years);\n    }\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    calendar.add(unit.getCalendarField(), count);\n    if (unit.getUnitType().equals(DateTickUnitType.MILLISECOND)) {\n        calendar.set(Calendar.MILLISECOND, 0);\n    }\n    else if (unit.getUnitType().equals(DateTickUnitType.SECOND)) {\n        calendar.set(Calendar.SECOND, 0);\n    }\n    else if (unit.getUnitType().equals(DateTickUnitType.MINUTE)) {\n        calendar.set(Calendar.MINUTE, 0);\n    }\n    else if (unit.getUnitType().equals(DateTickUnitType.HOUR)) {\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n    }\n    else if (unit.getUnitType().equals(DateTickUnitType.DAY)) {\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n    }\n    else if (unit.getUnitType().equals(DateTickUnitType.MONTH)) {\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.add(Calendar.MONTH, 1);\n    }\n    else if (unit.getUnitType().equals(DateTickUnitType.YEAR)) {\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.add(Calendar.YEAR, 1);\n    }\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n    calendar.set(Calendar.MILLISECOND, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.DAY_OF_MONTH, 1);\n    calendar.set(Calendar.MONTH, 0);\n    calendar.set(Calendar.YEAR, 0);\n    calendar.add(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    calendar.set(unit.getCalendarField(), value);\n    Date mm = calendar.getTime();\n    if (mm.getTime() >= date.getTime()) {\n        calendar.set(unit.getCalendarField(), value - 1);\n        mm = calendar.getTime();\n    }\n    return mm;\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n    calendar.set(Calendar.MILLISECOND, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.DAY_OF_MONTH, 1);\n    calendar.set(Calendar.MONTH, 0);\n    calendar.set(Calendar.YEAR, 0);\n    calendar.add(unit.getCalendarField(), value);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    calendar.add(unit.getCalendarField(), count);\n    while (calendar.get(unit.getCalendarField()) > current) {\n        calendar.add(unit.getCalendarField(), -count);\n    }\n    return calendar.getTime();\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableName == null) {\n        throw new NullPointerException(\"Variable name must not be null!\");\n    }\n    if (buf == null) {\n        throw new NullPointerException(\"Buffer must not be null!\");\n    }\n    if (startPos < 0 || startPos > buf.length()) {\n        throw new IndexOutOfBoundsException(\"Start position out of bounds!\");\n    }\n    if (endPos < 0 || endPos > buf.length()) {\n        throw new IndexOutOfBoundsException(\"End position out of bounds!\");\n    }\n    if (startPos > endPos) {\n        throw new IndexOutOfBoundsException(\"Start position greater than end position!\");\n    }\n    final StrLookup<?> resolver = getVariableResolver();\n    return resolver.lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().lookup(variableName);\n}\n\n/**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source string as a template.\n     * <p>\n     * Only the specified portion of the string will be processed.\n     * The rest of the string is not processed, and is not returned.\n     *\n     * @param source  the string to replace in, null returns null\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the array to be processed, must be valid\n     * @return the result of the replace operation",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    return resolver.lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableName == null) {\n        throw new NullPointerException(\"Variable name must not be null!\");\n    }\n    if (buf == null) {\n        throw new NullPointerException(\"Buffer must not be null!\");\n    }\n    if (startPos < 0 || endPos > buf.length()) {\n        throw new IndexOutOfBoundsException(\"Invalid start or end position!\");\n    }\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    return resolver.lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    final String varValue = resolver.lookup(variableName);\n    if (varValue == null) {\n        return null;\n    }\n    return varValue;\n}\n\n/**\n     * Internal method that performs the substitution.\n     * <p>\n     * Most users of this class do not need to call this method. This method is\n     * called automatically by the substitution process.\n     * <p>\n     * Writers of subclasses can override this method if they need to alter\n     * how each substitution occurs. The method is passed the buffer where\n     * the substitution is occurring, the start position, the length, and the\n     * previous variables. This implementation iterates over the buffer,\n     * looking for variables to substitute.\n     *\n     * @param buf  the buffer where the substitution is occurring, not null\n     * @param start  the start position of the buffer, valid\n     * @param length  the length of the buffer, valid\n     * @param priorVariables  the previous variables, not null\n     * @return <b>true</b> if any substitutions were made, <b>false</b> otherwise\n     */\nprotected boolean substitute(final StrBuilder buf, final int start, final int length, final List<String> priorVariables) {\n    int pos = start;\n    int bufEnd = start;\n    int lengthChange = 0;\n    boolean altered = false;\n    boolean top = true;\n    int nestedVarCount = 0;\n    while (pos < bufEnd + length) {\n        int matchLen = 0;\n        int matchPos = pos;\n        while (matchPos < bufEnd + length) {\n            final char c = buf.buffer[matchPos];\n            if (c == escape) {\n                matchPos++;\n                break;\n            }\n            if (c == prefixMatcher.charAt(0)) {\n                matchLen = prefixMatcher.length();\n                matchPos += matchLen;\n                break;\n            }\n            matchPos++;\n        }\n        if (matchLen == 0) {\n            pos = bufEnd + length;\n            break;\n        }\n        int endMatchLen = 0;\n        matchPos = matchPos + matchLen;\n        while (matchPos < bufEnd + length) {\n            final char c = buf.buffer[matchPos];\n            if (c == escape) {\n                matchPos++;\n                break;\n}\n}\n}\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableName == null) {\n        throw new NullPointerException(\"Variable name cannot be null\");\n    }\n    if (buf == null) {\n        throw new NullPointerException(\"Buffer cannot be null\");\n    }\n    if (startPos < 0 || startPos > endPos) {\n        throw new IndexOutOfBoundsException(\"Start position out of bounds\");\n    }\n    if (endPos < 0) {\n        throw new IndexOutOfBoundsException(\"End position out of bounds\");\n    }\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    return resolver.lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return getVariableResolver().lookup(variableName);\n}\n\n/**\n     * Replaces all the occurrences of variables with their matching values\n     * from the resolver using the given source string as a template.\n     * The array is not altered by this method.\n     *\n     * @param source  the character array to replace in, not altered, null returns null\n     * @param offset  the start offset within the array, must be valid\n     * @param length  the length within the array to be processed, must be valid\n     * @return the result of the replace operation",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    return resolver.lookup(variableName);\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    final Object value = resolver.lookup(variableName);\n    if (value == null) {\n        return null;\n    }\n    return value.toString();\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    final StrLookup<?> resolver = getVariableResolver();\n    if (resolver == null) {\n        return null;\n    }\n    return resolver.lookup(variableName);\n}\n\n/**\n     * Substitutes variables in the given buffer.\n     * <p>\n     * This method is called by the replace methods. It is responsible for\n     * identifying and replacing variables in the buffer. The method is\n     * passed the buffer and the start position of the buffer. It returns\n     * <b>true</b> if any substitutions were made, <b>false</b> otherwise.\n     *\n     * @param buf  the buffer where the substitution is occurring, not null\n     * @param offset  the start offset within the buffer, must be valid\n     * @param length  the length within the buffer to be processed, must be valid\n     * @return <b>true</b> if any substitutions were made, <b>false</b> otherwise\n     */\nprotected boolean substitute(final StrBuilder buf, final int offset, final int length) {\n    boolean altered = false;\n    int pos = offset;\n    int bufEnd = offset;\n    int lengthChange = 0;\n    final int end = offset + length;\n    final StrMatcher prefixMatcher = getVariablePrefixMatcher();\n    final StrMatcher suffixMatcher = getVariableSuffixMatcher();\n    final char escape = getEscapeChar();\n    while (pos < end) {\n        final int prefixLen = prefixMatcher.getMatchLength(buf, pos);\n        if (prefixLen > 0) {\n            final int suffixLen = suffixMatcher.getMatchLength(buf, pos + prefixLen);\n            if (suffixLen > 0) {\n                final int endPos = pos + prefixLen + suffixLen;\n                final String varName = buf.substring(pos + prefixLen, endPos).toString();\n                final String varValue = resolveVariable(varName, buf, pos, endPos);\n                if (varValue != null) {\n                    buf.replace(pos, endPos, varValue);\n                    altered = true;\n                    lengthChange += varValue.length() - (endPos - pos);\n                    pos += varValue.length() - (endPos - pos);\n                    bufEnd += varValue.length() - (endPos - pos);\n                } else {\n                    pos += prefixLen + suffixLen;\n                }\n            } else {\n                pos += prefixLen;\n            }\n        } else {\n            pos++;\n        }\n    }\n    return altered;\n}"
    ],
    [
      "public String soundex(String str)  {\n    if (str == null || str.length() == 0) {\n        return \"\";\n    }\n\n    str = clean(str);\n\n    char[] chars = str.toCharArray();\n    StringBuilder code = new StringBuilder();\n    char lastChar = '\\0';\n    boolean lastCode = false;\n\n    for (int i = 0; i < chars.length; i++) {\n        char chr = chars[i];\n\n        if (Character.isLetter(chr)) {\n            if (chr == 'H' || chr < 'A' || chr > 'Z') {\n                if (lastCode) {\n                    continue;\n                }\n                code.append('-');\n                lastCode = true;\n            } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) {\n                code.append('1');\n            } else if ((chr == 'D' || chr == 'T') && !arrayContains(SCZ, nextChar)) {\n                code.append('2');\n            } else if (arrayContains(WFPV, chr)) {\n                code.append('3');\n            } else if (arrayContains(GKQ, chr)) {\n                code.append('4');\n            } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) {\n                code.append('4');\n                code.append('S');\n                lastCode = true;\n            } else if (chr == 'S' || chr == 'Z') {\n                code.append('8');\n            } else if (chr == 'C') {\n                if (lastCode) {\n                    if (arrayContains(AHKLOQRUX, nextChar)) {\n                        code.append('4');\n                    } else {\n                        code.append('8');\n                    }\n                } else {\n                    if (arrayContains(SZ, lastChar) || !arrayContains(AHOUKQX, nextChar)) {\n                        code.append('8');\n                    } else {\n                        code.append('4');\n                    }\n                }\n            } else if (arrayContains(TDX, chr)) {\n                code.append('8');\n            } else if (chr == 'R') {\n                code.append('7');\n            } else if (chr == 'L') {\n                code.append('5');\n            } else if (chr == 'M' || chr == 'N') {\n                code.append('6');\n            } else {\n                code.append(chr);\n            }\n\n            lastChar = chr;\n        }\n    }\n\n    return code.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = clean(str);\n    char[] chars = str.toCharArray();\n    StringBuilder code = new StringBuilder();\n    char lastChar = '\\0';\n    for (int i = 0; i < chars.length; i++) {\n        char ch = chars[i];\n        if (Character.isLetter(ch)) {\n            ch = Character.toUpperCase(ch);\n            if (ch == 'X' && !arrayContains(CKQ, lastChar)) {\n                code.append('4');\n                code.append('S');\n                rightLength++;\n            } else if (ch == 'S' || ch == 'Z') {\n                code.append('8');\n            } else if (ch == 'C') {\n                if (lastCode == '/') {\n                    if (arrayContains(AHKLOQRUX, ch)) {\n                        code.append('4');\n                    } else {\n                        code.append('8');\n                    }\n                } else {\n                    if (arrayContains(SZ, lastChar) || !arrayContains(AHOUKQX, ch)) {\n                        code.append('8');\n                    } else {\n                        code.append('4');\n                    }\n                }\n            } else if (arrayContains(TDX, ch)) {\n                code.append('8');\n            } else if (ch == 'R') {\n                code.append('7');\n            } else if (ch == 'L') {\n                code.append('5');\n            } else if (ch == 'M' || ch == 'N') {\n                code.append('6');\n            } else {\n                code.append(ch);\n            }\n            lastCode = code.length() > 0 ? code.charAt(code.length() - 1) : '/';\n        }\n    }\n    return code.toString();\n}",
      "public String soundex(String str)  {\n    str = clean(str);\n    char[] chars = str.toCharArray();\n    StringBuilder code = new StringBuilder();\n    for (int i = 0; i < chars.length; i++) {\n        char chr = chars[i];\n        if (Character.isLetter(chr)) {\n            chr = Character.toUpperCase(chr);\n            if (chr == 'X' && i > 0 && chars[i - 1] == 'S') {\n                chr = '4';\n            } else if (chr == 'C' && i > 0 && chars[i - 1] == 'S') {\n                chr = '8';\n            } else if (chr == 'K' || chr == 'Q' || chr == 'X') {\n                chr = '0';\n            } else if (chr == 'B' || chr == 'F' || chr == 'P' || chr == 'V') {\n                chr = '1';\n            } else if (chr == 'D' || chr == 'T') {\n                chr = '2';\n            } else if (chr == 'G' || chr == 'J' || chr == 'W' || chr == 'Y') {\n                chr = '4';\n            } else if (chr == 'H') {\n                chr = '5';\n            } else if (chr == 'M' || chr == 'N') {\n                chr = '6';\n            } else if (chr == 'L') {\n                chr = '5';\n            } else if (chr == 'R') {\n                chr = '7';\n            } else if (chr == 'S' || chr == 'Z') {\n                chr = '8';\n            }\n            if (chr != '-') {\n                if (code.length() > 0 && chr != code.charAt(code.length() - 1)) {\n                    code.append(chr);\n                }\n            }\n        }\n    }\n    return code.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null || str.length() == 0) {\n        return \"\";\n    }\n\n    str = SoundexUtils.clean(str);\n    char[] chars = str.toCharArray();\n    StringBuilder sb = new StringBuilder();\n    char lastCode = '/';\n    int rightLength = 0;\n\n    for (int i = 0; i < chars.length; i++) {\n        char chr = chars[i];\n        if (Character.isLetter(chr)) {\n            chr = Character.toUpperCase(chr);\n            if (chr == 'H' || chr < 'A' || chr > 'Z') {\n                if (lastCode == '/') {\n                    continue;\n                }\n                sb.append('-');\n                lastCode = '-';\n            } else if (chr == 'B' || (chr == 'P' && i + 1 < chars.length && chars[i + 1] != 'H')) {\n                sb.append('1');\n                lastCode = '1';\n            } else if ((chr == 'D' || chr == 'T') && i + 1 < chars.length && !arrayContains(\"SCZ\", chars[i + 1])) {\n                sb.append('2');\n                lastCode = '2';\n            } else if (arrayContains(\"WFPV\", chr)) {\n                sb.append('3');\n                lastCode = '3';\n            } else if (arrayContains(\"GKQ\", chr)) {\n                sb.append('4');\n                lastCode = '4';\n            } else if (chr == 'X' && i - 1 >= 0 && !arrayContains(\"CKQ\", chars[i - 1])) {\n                sb.append('4');\n                sb.append('S');\n                rightLength++;\n                lastCode = '4';\n            } else if (chr == 'S' || chr == 'Z') {\n                sb.append('8');\n                lastCode = '8';\n            } else if (chr == 'C') {\n                if (lastCode == '/') {\n                    if (arrayContains(\"AHKLOQRUX\", chars[i + 1])) {\n                        sb.append('4');\n                        lastCode = '4';\n                    } else {\n                        sb.append('8');\n                        lastCode = '8';\n                    }\n                } else {\n                    if (arrayContains(\"SZ\", chars[i - 1]) || !arrayContains(\"AHOUKQX\", chars[i + 1])) {\n                        sb.append('8');\n                        lastCode = '8';\n                    } else {\n}\n}\n}\n}\n}\n}",
      "public String soundex(String str)  {\n    str = clean(str);\n    String code = \"\";\n    for (int i = 0; i < str.length(); i++) {\n        char chr = str.charAt(i);\n        if (Character.isLetter(chr)) {\n            chr = Character.toUpperCase(chr);\n            if (chr == 'X' && i > 0 && chr == lastChar) {\n                continue;\n            }\n            if (chr == 'H' || chr < 'A' || chr > 'Z') {\n                if (lastCode == '/') {\n                    continue;\n                }\n                code = '-';\n            } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) {\n                code = '1';\n            } else if ((chr == 'D' || chr == 'T') && !arrayContains(SCZ, nextChar)) {\n                code = '2';\n            } else if (arrayContains(WFPV, chr)) {\n                code = '3';\n            } else if (arrayContains(GKQ, chr)) {\n                code = '4';\n            } else if (chr == 'S' || chr == 'Z') {\n                code = '8';\n            } else if (chr == 'C') {\n                if (lastCode == '/') {\n                    if (arrayContains(AHKLOQRUX, nextChar)) {\n                        code = '4';\n                    } else {\n                        code = '8';\n                    }\n                } else {\n                    if (arrayContains(SZ, lastChar) || !arrayContains(AHOUKQX, nextChar)) {\n                        code = '8';\n                    } else {\n                        code = '4';\n                    }\n                }\n            } else if (arrayContains(TDX, chr)) {\n                code = '8';\n            } else if (chr == 'R') {\n                code = '7';\n            } else if (chr == 'L') {\n                code = '5';\n            } else if (chr == 'M' || chr == 'N') {\n                code = '6';\n            } else {\n                code = chr;\n            }\n            if (code != '-' && (lastCode != code && (code != '0' || lastCode == '/') || code < '0' || code > '8')) {\n                output.addRight(code);\n            }\n            lastCode = code;\n        }\n    }\n    return output.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = clean(str);\n    char[] chars = str.toCharArray();\n    StringBuilder output = new StringBuilder();\n    char lastCode = '/';\n    for (char chr : chars) {\n        if (Character.isLetter(chr)) {\n            chr = Character.toUpperCase(chr);\n            if (chr == 'X' && !arrayContains(CKQ, lastCode)) {\n                output.append('S');\n                rightLength++;\n            }\n            if (chr == 'C') {\n                if (lastCode == '/') {\n                    if (arrayContains(AHKLOQRUX, chr)) {\n                        output.append('4');\n                    } else {\n                        output.append('8');\n                    }\n                } else {\n                    if (arrayContains(SZ, lastCode) || !arrayContains(AHOUKQX, chr)) {\n                        output.append('8');\n                    } else {\n                        output.append('4');\n                    }\n                }\n            } else if (chr == 'R') {\n                output.append('7');\n            } else if (chr == 'L') {\n                output.append('5');\n            } else if (chr == 'M' || chr == 'N') {\n                output.append('6');\n            } else {\n                output.append(chr);\n            }\n            lastCode = chr;\n        }\n    }\n    return output.toString();\n}",
      "public String soundex(String str)  {\n    str = clean(str);\n    String code = \"\";\n    for (int i = 0; i < str.length(); i++) {\n        char chr = str.charAt(i);\n        if (Character.isLetter(chr)) {\n            chr = Character.toUpperCase(chr);\n            if (chr == 'X' && i > 0 && chr == lastChar) {\n                code += 'S';\n                rightLength++;\n            } else if (chr == 'S' || chr == 'Z') {\n                code += '8';\n            } else if (chr == 'C') {\n                if (lastCode == '/') {\n                    if (arrayContains(AHKLOQRUX, chr)) {\n                        code += '4';\n                    } else {\n                        code += '8';\n                    }\n                } else {\n                    if (arrayContains(SZ, lastChar) || !arrayContains(AHOUKQX, chr)) {\n                        code += '8';\n                    } else {\n                        code += '4';\n                    }\n                }\n            } else if (arrayContains(TDX, chr)) {\n                code += '8';\n            } else if (chr == 'R') {\n                code += '7';\n            } else if (chr == 'L') {\n                code += '5';\n            } else if (chr == 'M' || chr == 'N') {\n                code += '6';\n            } else {\n                code += chr;\n            }\n            lastChar = chr;\n        }\n    }\n    return code;\n}",
      "public String soundex(String str)  {\n    if (str == null || str.length() == 0) {\n        return \"\";\n    }\n    str = clean(str);\n    char[] chars = str.toCharArray();\n    StringBuilder code = new StringBuilder();\n    char lastChar = '\\0';\n    for (int i = 0; i < chars.length; i++) {\n        char ch = chars[i];\n        if (Character.isLetter(ch)) {\n            if (ch == 'H' || ch < 'A' || ch > 'Z') {\n                if (lastChar == '/') {\n                    continue;\n                }\n                code.append('-');\n            } else if (ch == 'B' || (ch == 'P' && nextChar != 'H')) {\n                code.append('1');\n            } else if ((ch == 'D' || ch == 'T') && !arrayContains(SCZ, nextChar)) {\n                code.append('2');\n            } else if (arrayContains(WFPV, ch)) {\n                code.append('3');\n            } else if (arrayContains(GKQ, ch)) {\n                code.append('4');\n            } else if (ch == 'X' && !arrayContains(CKQ, lastChar)) {\n                code.append('4');\n                code.append('S');\n                rightLength++;\n            } else if (ch == 'S' || ch == 'Z') {\n                code.append('8');\n            } else if (ch == 'C') {\n                if (lastCode == '/') {\n                    if (arrayContains(AHKLOQRUX, nextChar)) {\n                        code.append('4');\n                    } else {\n                        code.append('8');\n                    }\n                } else {\n                    if (arrayContains(SZ, lastChar) || !arrayContains(AHOUKQX, nextChar)) {\n                        code.append('8');\n                    } else {\n                        code.append('4');\n                    }\n                }\n            } else if (arrayContains(TDX, ch)) {\n                code.append('8');\n            } else if (ch == 'R') {\n                code.append('7');\n            } else if (ch == 'L') {\n                code.append('5');\n            } else if (ch == 'M' || ch == 'N') {\n                code.append('6');\n            } else {\n                code.append(ch);\n            }\n            lastChar = ch;\n        }\n    }\n    return code.toString();\n}",
      "public String soundex(String str)  {\n    str = clean(str);\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < str.length(); i++) {\n        char chr = str.charAt(i);\n        if (Character.isLetter(chr)) {\n            if (chr == 'H' || chr < 'A' || chr > 'Z') {\n                if (lastCode == '/') {\n                    continue;\n                }\n                code = '-';\n            } else if (chr == 'B' || (chr == 'P' && nextChar != 'H')) {\n                code = '1';\n            } else if ((chr == 'D' || chr == 'T') && !arrayContains(SCZ, nextChar)) {\n                code = '2';\n            } else if (arrayContains(WFPV, chr)) {\n                code = '3';\n            } else if (arrayContains(GKQ, chr)) {\n                code = '4';\n            } else if (chr == 'X' && !arrayContains(CKQ, lastChar)) {\n                code = '4';\n                input.addLeft('S');\n                rightLength++;\n            } else if (chr == 'S' || chr == 'Z') {\n                code = '8';\n            } else if (chr == 'C') {\n                if (lastCode == '/') {\n                    if (arrayContains(AHKLOQRUX, nextChar)) {\n                        code = '4';\n                    } else {\n                        code = '8';\n                    }\n                } else {\n                    if (arrayContains(SZ, lastChar) || !arrayContains(AHOUKQX, nextChar)) {\n                        code = '8';\n                    } else {\n                        code = '4';\n                    }\n                }\n            } else if (arrayContains(TDX, chr)) {\n                code = '8';\n            } else if (chr == 'R') {\n                code = '7';\n            } else if (chr == 'L') {\n                code = '5';\n            } else if (chr == 'M' || chr == 'N') {\n                code = '6';\n            } else {\n                code = chr;\n            }\n            if (code != '-' && (lastCode != code && (code != '0' || lastCode == '/') || code < '0' || code > '8')) {\n                sb.append(code);\n            }\n            lastCode = code;\n        }\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null || str.length() == 0) {\n        return \"\";\n    }\n\n    str = SoundexUtils.clean(str);\n\n    char[] chars = str.toCharArray();\n    StringBuilder sb = new StringBuilder();\n    char lastChar = ' ';\n    int rightLength = 0;\n\n    for (int i = 0; i < chars.length; i++) {\n        char chr = chars[i];\n        if (Character.isLetter(chr)) {\n            chr = Character.toUpperCase(chr);\n            if (chr == 'X' && lastChar == 'K' || lastChar == 'Q') {\n                chr = 'S';\n            }\n            if (chr == 'K' && lastChar == 'X') {\n                chr = 'S';\n            }\n            if (chr == 'Q' && lastChar == 'X') {\n                chr = 'S';\n            }\n            if (chr == 'S' && lastChar == 'C') {\n                chr = 'S';\n            }\n            if (chr == 'Z' && lastChar == 'C') {\n                chr = 'S';\n            }\n            if (chr == 'C' && lastChar == 'K' || lastChar == 'Q') {\n                chr = 'S';\n            }\n            if (chr == 'C' && lastChar == 'X') {\n                chr = 'S';\n            }\n            if (chr == 'X' && lastChar == 'K' || lastChar == 'Q') {\n                chr = 'S';\n            }\n            if (chr == 'K' && lastChar == 'X') {\n                chr = 'S';\n            }\n            if (chr == 'Q' && lastChar == 'X') {\n                chr = 'S';\n            }\n            if (chr == 'S' && lastChar == 'C') {\n                chr = 'S';\n            }\n            if (chr == 'Z' && lastChar == 'C') {\n                chr = 'S';\n            }\n            if (chr == 'C' && lastChar == 'K' || lastChar == 'Q') {\n                chr = 'S';\n            }\n            if (chr == 'C' && lastChar == 'X') {\n                chr = 'S';\n            }\n            if (chr == 'X' && lastChar == 'K' || lastChar == 'Q') {\n                chr = 'S';\n            }\n}\n}\n}"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return StringKD.forType(clz);\n    } else if (clz == Integer.class) {\n        return IntegerKD.forType(clz);\n    } else if (clz == Long.class) {\n        return LongKD.forType(clz);\n    } else if (clz == Boolean.class) {\n        return BooleanKD.forType(clz);\n    } else if (clz == Double.class) {\n        return DoubleKD.forType(clz);\n    } else if (clz == Float.class) {\n        return FloatKD.forType(clz);\n    } else if (clz == Byte.class) {\n        return ByteKD.forType(clz);\n    } else if (clz == Short.class) {\n        return ShortKD.forType(clz);\n    } else if (clz == Character.class) {\n        return CharacterKD.forType(clz);\n    } else if (clz == URI.class) {\n        return URIKD.forType(clz);\n    } else if (clz == URL.class) {\n        return URLKD.forType(clz);\n    } else if (clz == Class.class) {\n        return ClassKD.forType(clz);\n    } else if (clz == Locale.class) {\n        return LocaleKD.forType(clz);\n    } else if (clz == Currency.class) {\n        return CurrencyKD.forType(clz);\n    } else if (clz == byte[].class) {\n        return ByteArrayKD.forType(clz);\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return StringKD.forType(clz);\n    } else if (clz == Integer.class) {\n        return IntegerKD.forType(clz);\n    } else if (clz == Long.class) {\n        return LongKD.forType(clz);\n    } else if (clz == Boolean.class) {\n        return BooleanKD.forType(clz);\n    } else if (clz == Double.class) {\n        return DoubleKD.forType(clz);\n    } else if (clz == Float.class) {\n        return FloatKD.forType(clz);\n    } else if (clz == Byte.class) {\n        return ByteKD.forType(clz);\n    } else if (clz == Short.class) {\n        return ShortKD.forType(clz);\n    } else if (clz == Character.class) {\n        return CharacterKD.forType(clz);\n    } else if (clz == UUID.class) {\n        return UUIDKD.forType(clz);\n    } else if (clz == Date.class) {\n        return DateKD.forType(clz);\n    } else if (clz == Calendar.class) {\n        return CalendarKD.forType(clz);\n    } else if (clz == URI.class) {\n        return URIKD.forType(clz);\n    } else if (clz == URL.class) {\n        return URLKD.forType(clz);\n    } else if (clz == Class.class) {\n        return ClassKD.forType(clz);\n    } else if (clz == Locale.class) {\n        return LocaleKD.forType(clz);\n    } else if (clz == Currency.class) {\n        return CurrencyKD.forType(clz);\n    } else if (clz == byte[].class) {\n        return ByteArrayKD.forType(clz);\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return JavaTypeFactory.stringType();\n    } else if (clz == Integer.class) {\n        return JavaTypeFactory.intType();\n    } else if (clz == Long.class) {\n        return JavaTypeFactory.longType();\n    } else if (clz == Boolean.class) {\n        return JavaTypeFactory.booleanType();\n    } else if (clz == Double.class) {\n        return JavaTypeFactory.doubleType();\n    } else if (clz == Float.class) {\n        return JavaTypeFactory.floatType();\n    } else if (clz == Byte.class) {\n        return JavaTypeFactory.byteType();\n    } else if (clz == Short.class) {\n        return JavaTypeFactory.shortType();\n    } else if (clz == Character.class) {\n        return JavaTypeFactory.charType();\n    } else if (clz == Locale.class) {\n        return JavaTypeFactory.localeType();\n    } else if (clz == Currency.class) {\n        return JavaTypeFactory.currencyType();\n    } else if (clz == URI.class) {\n        return JavaTypeFactory.uriType();\n    } else if (clz == URL.class) {\n        return JavaTypeFactory.urlType();\n    } else if (clz == Class.class) {\n        return JavaTypeFactory.classType();\n    } else if (clz == byte[].class) {\n        return JavaTypeFactory.byteArrayType();\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return JavaTypeFactory.stringType();\n    } else if (clz == Integer.class) {\n        return JavaTypeFactory.intType();\n    } else if (clz == Long.class) {\n        return JavaTypeFactory.longType();\n    } else if (clz == Boolean.class) {\n        return JavaTypeFactory.booleanType();\n    } else if (clz == Double.class) {\n        return JavaTypeFactory.doubleType();\n    } else if (clz == Float.class) {\n        return JavaTypeFactory.floatType();\n    } else if (clz == Byte.class) {\n        return JavaTypeFactory.byteType();\n    } else if (clz == Short.class) {\n        return JavaTypeFactory.shortType();\n    } else if (clz == Character.class) {\n        return JavaTypeFactory.charType();\n    } else if (clz == Date.class) {\n        return JavaTypeFactory.dateType();\n    } else if (clz == Calendar.class) {\n        return JavaTypeFactory.calendarType();\n    } else if (clz == URI.class) {\n        return JavaTypeFactory.uriType();\n    } else if (clz == URL.class) {\n        return JavaTypeFactory.urlType();\n    } else if (clz == Class.class) {\n        return JavaTypeFactory.classType();\n    } else if (clz == Locale.class) {\n        return JavaTypeFactory.localeType();\n    } else if (clz == Currency.class) {\n        return JavaTypeFactory.currencyType();\n    } else if (clz == byte[].class) {\n        return JavaTypeFactory.byteArrayType();\n    } else {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return JavaTypeFactory.stringType();\n    } else if (clz == Integer.class) {\n        return JavaTypeFactory.intType();\n    } else if (clz == Long.class) {\n        return JavaTypeFactory.longType();\n    } else if (clz == Boolean.class) {\n        return JavaTypeFactory.booleanType();\n    } else if (clz == Double.class) {\n        return JavaTypeFactory.doubleType();\n    } else if (clz == Float.class) {\n        return JavaTypeFactory.floatType();\n    } else if (clz == Byte.class) {\n        return JavaTypeFactory.byteType();\n    } else if (clz == Short.class) {\n        return JavaTypeFactory.shortType();\n    } else if (clz == Character.class) {\n        return JavaTypeFactory.charType();\n    } else if (clz == Locale.class) {\n        return JavaTypeFactory.localeType();\n    } else if (clz == Currency.class) {\n        return JavaTypeFactory.currencyType();\n    } else if (clz == URI.class) {\n        return JavaTypeFactory.uriType();\n    } else if (clz == URL.class) {\n        return JavaTypeFactory.urlType();\n    } else if (clz == Class.class) {\n        return JavaTypeFactory.classType();\n    } else {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return StringKD.forType(clz);\n    } else if (clz == Integer.class) {\n        return IntegerKD.forType(clz);\n    } else if (clz == Long.class) {\n        return LongKD.forType(clz);\n    } else if (clz == Boolean.class) {\n        return BooleanKD.forType(clz);\n    } else if (clz == Double.class) {\n        return DoubleKD.forType(clz);\n    } else if (clz == Float.class) {\n        return FloatKD.forType(clz);\n    } else if (clz == Byte.class) {\n        return ByteKD.forType(clz);\n    } else if (clz == Short.class) {\n        return ShortKD.forType(clz);\n    } else if (clz == Character.class) {\n        return CharacterKD.forType(clz);\n    } else if (clz == UUID.class) {\n        return UUIDKD.forType(clz);\n    } else if (clz == Date.class) {\n        return DateKD.forType(clz);\n    } else if (clz == Calendar.class) {\n        return CalendarKD.forType(clz);\n    } else if (clz == URI.class) {\n        return URIKD.forType(clz);\n    } else if (clz == URL.class) {\n        return URLKD.forType(clz);\n    } else if (clz == Class.class) {\n        return ClassKD.forType(clz);\n    } else if (clz == Locale.class) {\n        return LocaleKD.forType(clz);\n    } else if (clz == Currency.class) {\n        return CurrencyKD.forType(clz);\n    } else if (clz == byte[].class) {\n        return ByteArrayKD.forType(clz);\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return StringKD.forType(clz);\n    } else if (clz == Integer.class) {\n        return IntegerKD.forType(clz);\n    } else if (clz == Long.class) {\n        return LongKD.forType(clz);\n    } else if (clz == Boolean.class) {\n        return BooleanKD.forType(clz);\n    } else if (clz == Double.class) {\n        return DoubleKD.forType(clz);\n    } else if (clz == Float.class) {\n        return FloatKD.forType(clz);\n    } else if (clz == Byte.class) {\n        return ByteKD.forType(clz);\n    } else if (clz == Short.class) {\n        return ShortKD.forType(clz);\n    } else if (clz == Character.class) {\n        return CharacterKD.forType(clz);\n    } else if (clz == URI.class) {\n        return URIKD.forType(clz);\n    } else if (clz == URL.class) {\n        return URLKD.forType(clz);\n    } else if (clz == Class.class) {\n        return ClassKD.forType(clz);\n    } else if (clz == Locale.class) {\n        return LocaleKD.forType(clz);\n    } else if (clz == Currency.class) {\n        return CurrencyKD.forType(clz);\n    } else if (clz == byte[].class) {\n        return ByteArrayKD.forType(clz);\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return JavaTypeFactory.stringType();\n    } else if (clz == Integer.class) {\n        return JavaTypeFactory.intType();\n    } else if (clz == Long.class) {\n        return JavaTypeFactory.longType();\n    } else if (clz == Boolean.class) {\n        return JavaTypeFactory.booleanType();\n    } else if (clz == Double.class) {\n        return JavaTypeFactory.doubleType();\n    } else if (clz == Float.class) {\n        return JavaTypeFactory.floatType();\n    } else if (clz == Byte.class) {\n        return JavaTypeFactory.byteType();\n    } else if (clz == Short.class) {\n        return JavaTypeFactory.shortType();\n    } else if (clz == Character.class) {\n        return JavaTypeFactory.charType();\n    } else if (clz == Locale.class) {\n        return JavaTypeFactory.localeType();\n    } else if (clz == Currency.class) {\n        return JavaTypeFactory.currencyType();\n    } else if (clz == URI.class) {\n        return JavaTypeFactory.uriType();\n    } else if (clz == URL.class) {\n        return JavaTypeFactory.urlType();\n    } else if (clz == Date.class) {\n        return JavaTypeFactory.dateType();\n    } else if (clz == Calendar.class) {\n        return JavaTypeFactory.calendarType();\n    } else if (clz == Byte[].class) {\n        return JavaTypeFactory.byteArrayType();\n    } else {\n        return null;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return StringKD.forType(clz);\n    } else if (clz == Integer.class) {\n        return IntegerKD.forType(clz);\n    } else if (clz == Long.class) {\n        return LongKD.forType(clz);\n    } else if (clz == Boolean.class) {\n        return BooleanKD.forType(clz);\n    } else if (clz == Double.class) {\n        return DoubleKD.forType(clz);\n    } else if (clz == Float.class) {\n        return FloatKD.forType(clz);\n    } else if (clz == Byte.class) {\n        return ByteKD.forType(clz);\n    } else if (clz == Short.class) {\n        return ShortKD.forType(clz);\n    } else if (clz == Character.class) {\n        return CharacterKD.forType(clz);\n    } else if (clz == UUID.class) {\n        return UUIDKD.forType(clz);\n    } else if (clz == Date.class) {\n        return DateKD.forType(clz);\n    } else if (clz == Calendar.class) {\n        return CalendarKD.forType(clz);\n    } else if (clz == URI.class) {\n        return URIKD.forType(clz);\n    } else if (clz == URL.class) {\n        return URLKD.forType(clz);\n    } else if (clz == Class.class) {\n        return ClassKD.forType(clz);\n    } else if (clz == Locale.class) {\n        return LocaleKD.forType(clz);\n    } else if (clz == Currency.class) {\n        return CurrencyKD.forType(clz);\n    } else if (clz == byte[].class) {\n        return ByteArrayKD.forType(clz);\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == String.class) {\n        return StringKD.forType(clz);\n    } else if (clz == Integer.class) {\n        return IntegerKD.forType(clz);\n    } else if (clz == Long.class) {\n        return LongKD.forType(clz);\n    } else if (clz == Boolean.class) {\n        return BooleanKD.forType(clz);\n    } else if (clz == Double.class) {\n        return DoubleKD.forType(clz);\n    } else if (clz == Float.class) {\n        return FloatKD.forType(clz);\n    } else if (clz == Byte.class) {\n        return ByteKD.forType(clz);\n    } else if (clz == Short.class) {\n        return ShortKD.forType(clz);\n    } else if (clz == Character.class) {\n        return CharacterKD.forType(clz);\n    } else if (clz == UUID.class) {\n        return UUIDKD.forType(clz);\n    } else if (clz == Date.class) {\n        return DateKD.forType(clz);\n    } else if (clz == Calendar.class) {\n        return CalendarKD.forType(clz);\n    } else if (clz == URI.class) {\n        return URIKD.forType(clz);\n    } else if (clz == URL.class) {\n        return URLKD.forType(clz);\n    } else if (clz == Class.class) {\n        return ClassKD.forType(clz);\n    } else if (clz == Locale.class) {\n        return LocaleKD.forType(clz);\n    } else if (clz == Currency.class) {\n        return CurrencyKD.forType(clz);\n    } else if (clz == byte[].class) {\n        return ByteArrayKD.forType(clz);\n    }\n    return null;\n}"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isFunction()) {\n        if (NodeUtil.isFunctionDeclaration(n)) {\n            PrototypeMemberDeclaration declaration = new PrototypeMemberDeclaration();\n            declaration.setName(n.getFirstChild().getString());\n            return declaration;\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isFunction()) {\n        if (NodeUtil.isFunctionDeclaration(n)) {\n            PrototypeMemberDeclaration declaration = new PrototypeMemberDeclaration();\n            declaration.setName(n.getFirstChild().getString());\n            return declaration;\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isFunction()) {\n        if (NodeUtil.isFunctionDeclaration(n)) {\n            return new PrototypeMemberDeclaration(n.getFirstChild().getString(), n);\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isFunction()) {\n        JSType type = n.getJSType();\n        if (type != null) {\n            return new PrototypeMemberDeclaration(type);\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isFunction()) {\n        if (NodeUtil.isFunctionDeclaration(n)) {\n            PrototypeMemberDeclaration declaration = new PrototypeMemberDeclaration();\n            declaration.setName(n.getFirstChild().getString());\n            declaration.setType(NodeUtil.getReturnType(n));\n            return declaration;\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isFunction()) {\n        if (NodeUtil.isFunctionDeclaration(n)) {\n            PrototypeMemberDeclaration declaration = new PrototypeMemberDeclaration();\n            declaration.setName(n.getFirstChild().getString());\n            return declaration;\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isFunction()) {\n        JSType type = n.getJSType();\n        if (type != null) {\n            return extractPrototypeMemberDeclaration(type);\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isFunction()) {\n        JSType type = n.getJSType();\n        if (type != null) {\n            return new PrototypeMemberDeclaration(type, n.getFirstChild().getString());\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isFunction()) {\n        if (NodeUtil.isFunctionDeclaration(n)) {\n            return new PrototypeMemberDeclaration(\n                n.getFirstChild().getString(),\n                isDeprecatedFunction(n),\n                isPropertyDeclaredConstant(ObjectType.cast(NodeUtil.getObjectType(n)), n.getFirstChild().getString()));\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isFunction()) {\n        if (NodeUtil.isFunctionDeclaration(n)) {\n            return new PrototypeMemberDeclaration(n.getFirstChild().getString(), n);\n        }\n    } else if (n.isName()) {\n        if (NodeUtil.isAssignmentOp(n) || n.getType() == Token.INC || n.getType() == Token.DEC) {\n            Node lhs = n.getFirstChild();\n            if (!isLocalName(lhs)) {\n                return new PrototypeMemberDeclaration(lhs.getString(), n);\n            }\n        }\n    }\n    return null;\n}"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rowDimension = mat.getRowDimension();\n    final int columnDimension = mat.getColumnDimension();\n    final RealMatrix out = MatrixUtils.createRealMatrix(rowDimension * n, columnDimension * m);\n    for (int i = 0; i < rowDimension; i++) {\n        for (int j = 0; j < columnDimension; j++) {\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    out.setEntry(i * n + k, j * m + l, mat.getEntry(i, j));\n                }\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rowDim = mat.getRowDimension();\n    final int colDim = mat.getColumnDimension();\n    final RealMatrix out = MatrixUtils.createRealMatrix(rowDim * n, colDim * m);\n    for (int i = 0; i < rowDim; i++) {\n        for (int j = 0; j < colDim; j++) {\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    out.setEntry(i * n + k, j * m + l, mat.getEntry(i, j));\n                }\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rowDimension = mat.getRowDimension();\n    final int columnDimension = mat.getColumnDimension();\n    final RealMatrix out = MatrixUtils.createRealMatrix(rowDimension * n, columnDimension * m);\n    for (int i = 0; i < rowDimension; i++) {\n        for (int j = 0; j < columnDimension; j++) {\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    out.setEntry(i * n + k, j * m + l, mat.getEntry(i, j));\n                }\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    if (n <= 0 || m <= 0) {\n        return MatrixUtils.createRealMatrix(0, 0);\n    }\n    final int rows = mat.getRowDimension();\n    final int cols = mat.getColumnDimension();\n    final RealMatrix out = MatrixUtils.createRealMatrix(rows * n, cols * m);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    out.setEntry(i * n + k, j * m + l, mat.getEntry(i, j));\n                }\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    if (n <= 0 || m <= 0) {\n        return zeros(mat.getRowDimension(), mat.getColumnDimension());\n    }\n    final int rows = mat.getRowDimension() * n;\n    final int cols = mat.getColumnDimension() * m;\n    final RealMatrix out = MatrixUtils.createRealMatrix(rows, cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            final int row = i / n;\n            final int col = j / m;\n            out.setEntry(i, j, mat.getEntry(row, col));\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rows = mat.getRowDimension();\n    final int cols = mat.getColumnDimension();\n    final RealMatrix out = MatrixUtils.createRealMatrix(rows * n, cols * m);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    out.setEntry(i * n + k, j * m + l, mat.getEntry(i, j));\n                }\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rows = mat.getRowDimension();\n    final int cols = mat.getColumnDimension();\n    final RealMatrix out = MatrixUtils.createRealMatrix(rows * n, cols * m);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    out.setEntry(i * n + k, j * m + l, mat.getEntry(i, j));\n                }\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    if (n <= 0 || m <= 0) {\n        return zeros(mat.getRowDimension(), mat.getColumnDimension());\n    }\n    final int rows = mat.getRowDimension() * n;\n    final int cols = mat.getColumnDimension() * m;\n    final RealMatrix out = MatrixUtils.createRealMatrix(rows, cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            out.setEntry(i, j, mat.getEntry(i % mat.getRowDimension(), j % mat.getColumnDimension()));\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    if (n == 1 && m == 1) {\n        return mat;\n    }\n    final int rows = mat.getRowDimension();\n    final int cols = mat.getColumnDimension();\n    final RealMatrix out = ones(rows * n, cols * m);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    out.setEntry(i * n + k, j * m + l, mat.getEntry(i, j));\n                }\n            }\n        }\n    }\n    return out;\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    if (n <= 0 || m <= 0) {\n        return zeros(mat.getRowDimension(), mat.getColumnDimension());\n    }\n    final int rows = mat.getRowDimension() * n;\n    final int cols = mat.getColumnDimension() * m;\n    final RealMatrix out = MatrixUtils.createRealMatrix(rows, cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            out.setEntry(i, j, mat.getEntry(i % mat.getRowDimension(), j % mat.getColumnDimension()));\n        }\n    }\n    return out;\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null; ) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) {\n        if (node.element.compareTo(reference) > 0) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  {\n    long bytesRead = getBytesRead();\n    long bytesInflated = bytesRead - (bytesRead % (1L << 32));\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesRead = getBytesRead();\n    long bytesInflated = getBytesInflated();\n    if (bytesInflated > bytesRead) {\n        bytesInflated = bytesRead;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesRead = getBytesRead();\n    long bytesInflated = bytesRead;\n    if (bytesInflated > bytesRead) {\n        bytesInflated = bytesRead;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesRead = getBytesRead();\n    long bytesInflated = getBytesRead();\n    if (bytesRead > bytesInflated) {\n        bytesInflated = bytesRead - 1;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesRead = getBytesRead();\n    long bytesInflated = bytesRead - (bytesRead % (1L << 32));\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesRead = getBytesRead();\n    long bytesInflated = bytesRead - ((bytesRead >> 31) == 0 ? bytesRead : Long.MAX_VALUE);\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesRead = getBytesRead();\n    long bytesInflated = bytesRead - (bytesRead % (1L << 31));\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    long bytesRead = getBytesRead();\n    long bytesInflated = bytesRead - (bytesRead % (1L << 32));\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    return bytesRead;\n}",
      "private long getBytesInflated()  {\n    long bytesRead = getBytesRead();\n    long bytesInflated = bytesRead - (bytesRead % 0x100000000L);\n    return bytesInflated;\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n    return !name.isEmpty();\n}\n  // and this should be moved into a \"Language\" API.\n  /**\n   * Determines whether the given name is a valid unqualified name.",
      "public static boolean isValidQualifiedName(String name)  {\n    return name.matches(\"^[a-zA-Z_$][a-zA-Z_$0-9]*$\");\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name == null) {\n      return false;\n    }\n    if (name.isEmpty()) {\n      return false;\n    }\n    if (name.startsWith(\"$\")) {\n      return false;\n    }\n    if (name.startsWith(\"this\")) {\n      return false;\n    }\n    if (name.startsWith(\"super\")) {\n      return false;\n    }\n    if (name.startsWith(\"arguments\")) {\n      return false;\n    }\n    if (name.startsWith(\"length\")) {\n      return false;\n    }\n    if (name.startsWith(\"prototype\")) {\n      return false;\n    }\n    return true;\n  }",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name == null) {\n      return false;\n    }\n    // Check if the name is a valid ES5 qualified name.\n    if (name.startsWith(\"Object.\") || name.startsWith(\"Array.\")\n        || name.startsWith(\"Boolean.\") || name.startsWith(\"Number.\")\n        || name.startsWith(\"String.\")\n        || name.startsWith(\"Date.\")\n        || name.startsWith(\"RegExp.\")\n        || name.startsWith(\"Error.\")\n        || name.startsWith(\"EvalError.\")\n        || name.startsWith(\"RangeError.\")\n        || name.startsWith(\"ReferenceError.\")\n        || name.startsWith(\"SyntaxError.\")\n        || name.startsWith(\"TypeError.\")\n        || name.startsWith(\"URIError.\")\n        || name.startsWith(\"JSON.\")\n        || name.startsWith(\"Math.\")\n        || name.startsWith(\"JSON2.\")\n        || name.startsWith(\"JSON3.\")\n        || name.startsWith(\"JSON4.\")\n        || name.startsWith(\"JSON5.\")\n        || name.startsWith(\"JSON6.\")\n        || name.startsWith(\"JSON7.\")\n        || name.startsWith(\"JSON8.\")\n        || name.startsWith(\"JSON9.\")\n        || name.startsWith(\"JSON10.\")\n        || name.startsWith(\"JSON11.\")\n        || name.startsWith(\"JSON12.\")\n        || name.startsWith(\"JSON13.\")\n        || name.startsWith(\"JSON14.\")\n        || name.startsWith(\"JSON15.\")\n        || name.startsWith(\"JSON16.\")\n        || name.startsWith(\"JSON17.\")\n        || name.startsWith(\"JSON18.\")\n        || name.startsWith(\"JSON19.\")\n        || name.startsWith(\"JSON20.\")\n        || name.startsWith(\"JSON21.\")\n        || name.startsWith(\"JSON22.\")\n        || name.startsWith(\"JSON23.\")\n        || name.startsWith(\"JSON24.\")\n        || name.startsWith(\"JSON25.\")\n        || name.startsWith(\"JSON26.\")\n        || name.startsWith(\"JSON27.\")\n        || name.startsWith(\"JSON28.\")\n        || name.startsWith(\"JSON29.\")\n        || name.startsWith(\"JSON30.\")\n        || name.startsWith(\"JSON31.\")\n        || name.startsWith(\"JSON32.\")\n        || name.startsWith(\"JSON33.\")\n        || name.startsWith(\"JSON34.\")\n        || name.startsWith(\"JSON35.\")\n        || name.startsWith(\"JSON36.\")\n        || name.startsWith(\"JSON37.\")\n        || name.startsWith(\"JSON38.\")\n        || name.startsWith(\"JSON39.\")\n        || name.startsWith(\"JSON40.\")\n        || name.startsWith(\"JSON41.\")\n        || name.startsWith(\"JSON42.\")\n        || name.startsWith(\"JSON43.\")\n        || name.startsWith(\"JSON44.\")\n        || name.startsWith(\"JSON45.\")\n        || name.startsWith(\"JSON46.\")\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return !name.isEmpty();\n}\n\n/**\n * Determines whether the given name is a valid unqualified name.",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name == null) {\n        return false;\n    }\n    // Check if the name is a valid identifier\n    if (!isValidIdentifier(name)) {\n        return false;\n    }\n    // Check if the name contains a dot\n    if (!name.contains(\".\")) {\n        return true;\n    }\n    // Check if the name contains more than one dot\n    if (name.split(\"\\\\.\").length > 2) {\n        return false;\n    }\n    // Check if the name ends with a dot\n    if (name.endsWith(\".\")) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * Determines whether the given name is a valid identifier.",
      "public static boolean isValidQualifiedName(String name)  {\n    return name.matches(\"^[a-zA-Z_][a-zA-Z_0-9]*$\");\n}\n\n/**\n * Determines whether the given name is a valid simple name.",
      "public static boolean isValidQualifiedName(String name)  {\n    return name.matches(\"^[a-zA-Z_][a-zA-Z_0-9]*$\");\n}\n\n/**\n * Determines whether the given name is a valid property name.",
      "public static boolean isValidQualifiedName(String name)  {\n    return !name.isEmpty() && !name.startsWith(\"$\");\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    if (name == null) {\n      return false;\n    }\n    int dotIndex = name.indexOf('.');\n    if (dotIndex == -1) {\n      return true;\n    }\n    String prefix = name.substring(0, dotIndex);\n    if (!isValidSimpleName(prefix)) {\n      return false;\n    }\n    String suffix = name.substring(dotIndex + 1);\n    if (!isValidSimpleName(suffix)) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Determines whether the given name is a valid simple name."
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = im; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != im) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != im) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != im) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n                    matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                }\n                matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n            }\n        }\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != il) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != il) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n                    matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                }\n                matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n            }\n\n            // Column modification\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != il) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != il) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n                    matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                }\n                matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n            }\n        }\n    }\n    return iu;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != il) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n                    matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                }\n                matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n            }\n\n            // Column modification\n            for (int i = 0; i <= k; i++) {\n                p = matrixT[i][k - 1];\n                q = matrixT[i][k];\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != il) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n                    matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                }\n                matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n            }\n        }\n    }\n    return iu;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu - 1;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = im; k >= il; k--) {\n        boolean notlast = k != il;\n        if (k != im) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != im) {\n                matrixT[k][k - 1] = -s * shift.x;\n            } else if (il != im) {\n                matrixT[k][k - 1] = -matrixT[k][k - 1];\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n                    matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                }\n                matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n            }\n        }\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = iu - 1;\n    if (iu > 1) {\n        double p = hVec[0];\n        double q = hVec[1];\n        double r = hVec[2];\n        for (int k = im; k >= il; k--) {\n            boolean notlast = k != il;\n            if (k != im) {\n                p = matrixT[k][k - 1];\n                q = matrixT[k + 1][k - 1];\n                r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n                shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n                if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                    p = p / shift.x;\n                    q = q / shift.x;\n                    r = r / shift.x;\n                }\n            }\n            if (shift.x == 0.0) {\n                break;\n            }\n            double s = FastMath.sqrt(p * p + q * q + r * r);\n            if (p < 0.0) {\n                s = -s;\n            }\n            if (s != 0.0) {\n                if (k != im) {\n                    matrixT[k][k - 1] = -s * shift.x;\n                } else if (il != im) {\n                    matrixT[k][k - 1] = -matrixT[k][k - 1];\n                }\n                p = p + s;\n                shift.x = p / s;\n                shift.y = q / s;\n                double z = r / s;\n                q = q / p;\n                r = r / p;\n                // Row modification\n                for (int j = k; j < n; j++) {\n                    p = matrixT[k][j] + q * matrixT[k + 1][j];\n                    if (notlast) {\n                        p = p + r * matrixT[k + 2][j];\n                        matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                    }\n                    matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                    matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n                }\n            }\n        }\n    }\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != il) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n                    matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                }\n                matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n            }\n\n            // Column modification\n            for (int i = 0; i <= k; i++) {\n                p = matrixT[i][k - 1];\n}\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != il) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n                    matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                }\n                matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n            }\n        }\n    }\n    return iu;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = hVec[0];\n    double q = hVec[1];\n    double r = hVec[2];\n\n    for (int k = il; k <= iu - 1; k++) {\n        boolean notlast = k != (iu - 1);\n        if (k != il) {\n            p = matrixT[k][k - 1];\n            q = matrixT[k + 1][k - 1];\n            r = notlast ? matrixT[k + 2][k - 1] : 0.0;\n            shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n            if (!Precision.equals(shift.x, 0.0, epsilon)) {\n                p = p / shift.x;\n                q = q / shift.x;\n                r = r / shift.x;\n            }\n        }\n        if (shift.x == 0.0) {\n            break;\n        }\n        double s = FastMath.sqrt(p * p + q * q + r * r);\n        if (p < 0.0) {\n            s = -s;\n        }\n        if (s != 0.0) {\n            if (k != il) {\n                matrixT[k][k - 1] = -s * shift.x;\n            }\n            p = p + s;\n            shift.x = p / s;\n            shift.y = q / s;\n            double z = r / s;\n            q = q / p;\n            r = r / p;\n\n            // Row modification\n            for (int j = k; j < n; j++) {\n                p = matrixT[k][j] + q * matrixT[k + 1][j];\n                if (notlast) {\n                    p = p + r * matrixT[k + 2][j];\n                    matrixT[k + 2][j] = matrixT[k + 2][j] - p * z;\n                }\n                matrixT[k][j] = matrixT[k][j] - p * shift.x;\n                matrixT[k + 1][j] = matrixT[k + 1][j] - p * shift.y;\n            }\n\n            // Column modification\n            for (int i = 0; i <= k; i++) {\n                p = matrixT[i][k - 1];\n}\n}\n}\n}"
    ],
    [
      "public List<TextNode> textNodes()  {\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    return new ArrayList<>(ensureChildNodes().stream()\n            .filter(node -> node instanceof TextNode)\n            .map(node -> (TextNode) node)\n            .collect(Collectors.toList()));\n}",
      "public List<TextNode> textNodes()  {\n    List<Node> childNodes = childNodes();\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    List<Node> childNodes = childNodes();\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    return new ArrayList<>(ensureChildNodes().stream()\n            .filter(node -> node instanceof TextNode)\n            .map(node -> (TextNode) node)\n            .collect(Collectors.toList()));\n}",
      "public List<TextNode> textNodes()  {\n    return new ArrayList<>(childNodes().stream()\n            .filter(node -> node instanceof TextNode)\n            .map(node -> (TextNode) node)\n            .collect(Collectors.toList()));\n}",
      "public List<TextNode> textNodes()  {\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    return textNodes;\n}",
      "public List<TextNode> textNodes()  {\n    return new ArrayList<>(ensureChildNodes().stream()\n            .filter(node -> node instanceof TextNode)\n            .map(node -> (TextNode) node)\n            .collect(Collectors.toList()));\n}",
      "public List<TextNode> textNodes()  {\n    List<Node> childNodes = childNodes();\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node node : childNodes) {\n        if (node instanceof TextNode) {\n            textNodes.add((TextNode) node);\n        }\n    }\n    return textNodes;\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) {\n        if (segment.inIncludeSegments()) {\n            return true;\n        }\n    }\n    return false;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) {\n        if (segment.inIncludeSegments()) {\n            return true;\n        }\n    }\n    return false;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (segment.inIncludedSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) {\n        if (segment.inIncludeSegments()) {\n            return (true);\n        }\n    }\n    return false;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n         segment.getSegmentStart() < this.segmentEnd;\n         segment.inc()) {\n        if (segment.inIncludeSegments()) {\n            return (true);\n        }\n    }\n    return false;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (segment.inIncludeSegments()) {\n            return true;\n        }\n    }\n    return false;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (segment.inIncludeSegments()) {\n            return (true);\n        }\n    }\n    return false;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (segment.inIncludedSegments()) {\n            return (true);\n        }\n    }\n    return false;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (segment.inIncludedSegments()) {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) {\n        if (segment.inIncludeSegments()) {\n            return true;\n        }\n    }\n    return false;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start instanceof LocalDate && end instanceof LocalDate) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int seconds = chrono.seconds().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return seconds;\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance);\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start instanceof LocalDate && end instanceof LocalDate) {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int seconds = chrono.seconds().getDifference(\n                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n            return seconds;\n        }\n        int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance);\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start instanceof LocalDate && end instanceof LocalDate) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int seconds = chrono.seconds().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return seconds;\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance);\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start instanceof LocalDate && end instanceof LocalDate) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int seconds = chrono.seconds().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return seconds;\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance);\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start instanceof LocalDate && end instanceof LocalDate) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int seconds = chrono.seconds().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return seconds;\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance);\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start instanceof LocalDate && end instanceof LocalDate) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int seconds = chrono.seconds().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return seconds;\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance);\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start instanceof LocalDate && end instanceof LocalDate) {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int seconds = chrono.seconds().getDifference(\n                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n            return seconds;\n        }\n        int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance);\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start instanceof LocalDate && end instanceof LocalDate) {\n        Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n        int seconds = chrono.seconds().getDifference(\n                ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n        return seconds;\n    }\n    int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance);\n    return amount;\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start instanceof LocalDate && end instanceof LocalDate) {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int seconds = chrono.seconds().getDifference(\n                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n            return seconds;\n        }\n        // Weeks.java\n        if (start instanceof LocalDate && end instanceof LocalDate) {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int weeks = chrono.weeks().getDifference(\n                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n            return weeks * 604800;\n        }\n        int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance);\n        return amount;\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start instanceof LocalDate && end instanceof LocalDate) {\n            Chronology chrono = DateTimeUtils.getChronology(start.getChronology());\n            int seconds = chrono.seconds().getDifference(\n                    ((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis());\n            return seconds;\n        }\n        int amount = BaseSingleFieldPeriod.between(start, end, zeroInstance);\n        return amount;\n    }"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    if (index < this.legends.size()) {\n        return (LegendTitle) this.legends.get(index);\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < this.legends.size()) {\n        return (LegendTitle) this.legends.get(index);\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < this.legends.size()) {\n        return (LegendTitle) this.legends.get(index);\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < this.legends.size()) {\n        return (LegendTitle) this.legends.get(index);\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < this.legends.size()) {\n        return (LegendTitle) this.legends.get(index);\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.legends.size()) {\n        return null;\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.legends.size()) {\n        return null;\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < this.legends.size()) {\n        return (LegendTitle) this.legends.get(index);\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < this.legends.size()) {\n        return (LegendTitle) this.legends.get(index);\n    }\n    return null;\n}",
      "public LegendTitle getLegend(int index)  {\n    if (index < 0 || index >= this.legends.size()) {\n        return null;\n    }\n    return (LegendTitle) this.legends.get(index);\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n}"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (match(JsDocToken.LB)) {\n        skipEOLs();\n        Node paramType = parseTypeExpression(next());\n        skipEOLs();\n        if (match(JsDocToken.RB)) {\n            return paramType;\n        }\n        if (match(JsDocToken.ELLIPSIS)) {\n            skipEOLs();\n            if (match(JsDocToken.RB)) {\n                return wrapNode(Token.ELLIPSIS, paramType);\n            }\n            skipEOLs();\n            if (!match(JsDocToken.RB)) {\n                return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n            }\n            skipEOLs();\n            next();\n        }\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    return null;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LB) {\n        token = next();\n        skipEOLs();\n        Node paramType = parseTypeExpression(next());\n        if (match(JsDocToken.RB)) {\n            skipEOLs();\n            next();\n        } else {\n            if (match(JsDocToken.EQUALS)) {\n                skipEOLs();\n                next();\n                paramType = wrapNode(Token.EQUALS, paramType);\n            }\n        }\n        return paramType;\n    } else if (token == JsDocToken.ELLIPSIS) {\n        token = next();\n        skipEOLs();\n        Node paramType = parseTypeExpression(next());\n        return wrapNode(Token.ELLIPSIS, paramType);\n    } else {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LB) {\n        token = next();\n        skipEOLs();\n        Node paramType = parseTypeExpression(next());\n        skipEOLs();\n        if (match(JsDocToken.RB)) {\n            return newNode(Token.PARAM_TYPE, paramType);\n        } else if (match(JsDocToken.ELLIPSIS)) {\n            token = next();\n            skipEOLs();\n            paramType = parseTypeExpression(next());\n            skipEOLs();\n            if (match(JsDocToken.RB)) {\n                return newNode(Token.PARAM_TYPE, paramType);\n            } else {\n                return reportTypeSyntaxWarning(\"msg.jsdoc.function.varargs\");\n            }\n        } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n        }\n    } else {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (match(JsDocToken.LB)) {\n        if (match(JsDocToken.RB)) {\n            return newNode(Token.EMPTY);\n        }\n        Node paramType = parseTypeExpression(next());\n        if (match(JsDocToken.COMMA)) {\n            return newNode(Token.EMPTY);\n        }\n        if (match(JsDocToken.RB)) {\n            return paramType;\n        }\n        if (match(JsDocToken.ELLIPSIS)) {\n            return wrapNode(Token.ELLIPSIS, paramType);\n        }\n        return wrapNode(Token.EMPTY, paramType);\n    }\n    return null;\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (match(JsDocToken.LB)) {\n        skipEOLs();\n        Node paramType = parseTypeExpression(next());\n        skipEOLs();\n        if (match(JsDocToken.RB)) {\n            return paramType;\n        } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n        }\n    } else if (match(JsDocToken.ELLIPSIS)) {\n        skipEOLs();\n        Node paramType = parseTypeExpression(next());\n        skipEOLs();\n        if (match(JsDocToken.RB)) {\n            return wrapNode(Token.ELLIPSIS, paramType);\n        } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n        }\n    } else {\n        return null;\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (match(JsDocToken.LB)) {\n        token = next();\n        skipEOLs();\n        Node paramType = parseTypeExpression(token);\n        if (match(JsDocToken.RB)) {\n            return paramType;\n        }\n        if (match(JsDocToken.ELLIPSIS)) {\n            token = next();\n            skipEOLs();\n            paramType = wrapNode(Token.ELLIPSIS, paramType);\n        }\n        return paramType;\n    } else {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (match(JsDocToken.LB)) {\n        token = next();\n        skipEOLs();\n        Node paramType = parseTypeExpression(next());\n        skipEOLs();\n        if (match(JsDocToken.RB)) {\n            return wrapNode(Token.PARAM_TYPE_EXPRESSION, paramType);\n        } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n        }\n    } else if (match(JsDocToken.ELLIPSIS)) {\n        token = next();\n        skipEOLs();\n        Node paramType = parseTypeExpression(next());\n        skipEOLs();\n        if (match(JsDocToken.RB)) {\n            return wrapNode(Token.PARAM_TYPE_EXPRESSION, paramType);\n        } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n        }\n    } else {\n        return null;\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (match(JsDocToken.LB)) {\n        token = next();\n        skipEOLs();\n        Node paramType = parseTypeExpression(token);\n        if (match(JsDocToken.RB)) {\n            return paramType;\n        } else {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n        }\n    } else if (match(JsDocToken.ELLIPSIS)) {\n        token = next();\n        skipEOLs();\n        Node paramType = parseTypeExpression(token);\n        return wrapNode(Token.ELLIPSIS, paramType);\n    } else {\n        return null;\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LB) {\n        token = next();\n        skipEOLs();\n        Node paramType = parseTypeExpression(next());\n        skipEOLs();\n        if (match(JsDocToken.RB)) {\n            return paramType;\n        } else {\n            return wrapNode(Token.LB, paramType);\n        }\n    } else if (token == JsDocToken.ELLIPSIS) {\n        token = next();\n        skipEOLs();\n        Node paramType = parseTypeExpression(next());\n        skipEOLs();\n        if (match(JsDocToken.RB)) {\n            return wrapNode(Token.ELLIPSIS, paramType);\n        } else {\n            return wrapNode(Token.ELLIPSIS, paramType);\n        }\n    } else {\n        return null;\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LB) {\n        token = next();\n        skipEOLs();\n        Node paramType = parseTypeExpression(next());\n        if (match(JsDocToken.RB)) {\n            skipEOLs();\n            next();\n        } else {\n            if (match(JsDocToken.COMMA)) {\n                skipEOLs();\n                next();\n                paramType = wrapNode(Token.COMMA, paramType);\n            }\n        }\n        return paramType;\n    } else {\n        return parseTypeExpression(token);\n    }\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> frames = new ArrayList<String>();\n    final StackTraceElement[] stackTraceElements = t.getStackTrace();\n    for (int i = 0; i < stackTraceElements.length; i++) {\n        final StackTraceElement element = stackTraceElements[i];\n        frames.add(element.getClassName() + \".\" + element.getMethodName() + \"(\" + element.getFileName() + \":\" + element.getLineNumber() + \")\");\n    }\n    return frames;\n}\n\n/**\n     * <p>Produces a <code>List</code> of stack frames - the message\n     * is not included. Only the trace of the specified exception is\n     * returned, any caused by trace is stripped.</p>\n     *\n     * <p>This works in most cases - it will only fail if the exception\n     * message contains a line that starts with:\n     * <code>&quot;&nbsp;&nbsp;&nbsp;at&quot;.</code></p>\n     * \n     * @param throwables is any array of throwables\n     * @return List of stack frames\n     */\nstatic List<String> getStackFrameList(final Throwable[] throwables) {\n    final List<String> frames = new ArrayList<String>();\n    for (final Throwable throwable : throwables) {\n        final StackTraceElement[] stackTraceElements = throwable.getStackTrace();\n        for (int i = 0; i < stackTraceElements.length; i++) {\n            final StackTraceElement element = stackTraceElements[i];\n            frames.add(element.getClassName() + \".\" + element.getMethodName() + \"(\" + element.getFileName() + \":\" + element.getLineNumber() + \")\");\n        }\n    }\n    return frames;\n}\n\n/**\n     * <p>Removes common frames from the trace of the current exception\n     * and the trace of the next exception.</p>\n     *\n     * <p>This method is used to strip the trace of the current exception\n     * from the trace of the next exception.</p>\n     * \n     * @param currentFrames is the trace of the current exception\n     * @param nextFrames is the trace of the next exception\n     */\nstatic void removeCommonFrames(final List<String> currentFrames, final List<String> nextFrames) {\n    final List<String> commonFrames = new ArrayList<String>();\n    for (final String frame : currentFrames) {\n        if (nextFrames.contains(frame)) {\n            commonFrames.add(frame);\n        }\n    }\n    currentFrames.removeAll(commonFrames);\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> trace = new ArrayList<String>();\n    final StackTraceElement[] elements = t.getStackTrace();\n    for (int i = 0; i < elements.length; i++) {\n        trace.add(elements[i].toString());\n    }\n    return trace;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> trace = new ArrayList<String>();\n    for (StackTraceElement ste : t.getStackTrace()) {\n        trace.add(ste.toString());\n    }\n    return trace;\n}\n\n/**\n     * <p>Produces a <code>Throwable[]</code> of the exception\n     * and all its causes.</p>\n     *\n     * @param t is any throwable\n     * @return Array of throwables\n     */\nstatic Throwable[] getThrowables(final Throwable t) {\n    final List<Throwable> throwables = new ArrayList<Throwable>();\n    Throwable current = t;\n    while (current != null) {\n        throwables.add(current);\n        current = current.getCause();\n    }\n    return throwables.toArray(new Throwable[throwables.size()]);\n}\n\n/**\n     * <p>Removes common frames from the two traces.</p>\n     *\n     * @param trace1 the first trace\n     * @param trace2 the second trace\n     */\nstatic void removeCommonFrames(final List<String> trace1, final List<String> trace2) {\n    int i = 0;\n    while (i < trace1.size() && i < trace2.size()) {\n        if (trace1.get(i).equals(trace2.get(i))) {\n            i++;\n        } else {\n            break;\n        }\n    }\n    trace1.subList(i, trace1.size()).clear();\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> frames = new ArrayList<String>();\n    StackTraceElement[] stack = t.getStackTrace();\n    for (int i = 0; i < stack.length; i++) {\n        frames.add(stack[i].toString());\n    }\n    return frames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> frames = new ArrayList<String>();\n    StackTraceElement[] stack = t.getStackTrace();\n    for (int i = 0; i < stack.length; i++) {\n        frames.add(stack[i].toString());\n    }\n    return frames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> trace = new ArrayList<String>();\n    StackTraceElement[] stackTraceElements = t.getStackTrace();\n    for (int i = 0; i < stackTraceElements.length; i++) {\n        trace.add(stackTraceElements[i].toString());\n    }\n    return trace;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> frames = new ArrayList<String>();\n    StackTraceElement[] trace = t.getStackTrace();\n    for (StackTraceElement element : trace) {\n        frames.add(element.toString());\n    }\n    return frames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    List<String> frames = new ArrayList<String>();\n    StackTraceElement[] stack = t.getStackTrace();\n    for (int i = 0; i < stack.length; i++) {\n        frames.add(stack[i].toString());\n    }\n    return frames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> frames = new ArrayList<String>();\n    final StackTraceElement[] stackTrace = t.getStackTrace();\n    for (int i = 0; i < stackTrace.length; i++) {\n        frames.add(stackTrace[i].toString());\n    }\n    return frames;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> frames = new ArrayList<String>();\n    final StackTraceElement[] stackTrace = t.getStackTrace();\n    for (final StackTraceElement element : stackTrace) {\n        frames.add(element.toString());\n    }\n    return frames;\n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  } else {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  } else {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  } else {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  } else {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  } else {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_TRUE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return true;\n    } else if (p == PEEKED_FALSE) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return false;\n    } else {\n      throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n  }",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  } else {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}",
      "public boolean nextBoolean() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_TRUE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  } else if (p == PEEKED_FALSE) {\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  } else {\n    throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n  }\n}"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, String.valueOf(padChar));\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, String.valueOf(padChar));\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, String.valueOf(padChar));\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, String.valueOf(padChar));\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, String.valueOf(padChar));\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, String.valueOf(padChar));\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, String.valueOf(padChar));\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, String.valueOf(padChar));\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, String.valueOf(padChar));\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, String.valueOf(padChar));\n    str = rightPad(str, size, padChar);\n    return str;\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n    if (call.isCall()) {\n        Node nameNode = call.getFirstChild();\n        if (nameNode.isName()) {\n            String name = nameNode.getString();\n            if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n                return false;\n            }\n        } else if (nameNode.isGetProp()) {\n            if (call.hasOneChild() && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n                return false;\n            }\n            if (call.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) {\n                return false;\n            }\n            if (nameNode.getFirstChild().isName() && \"Math.floor\".equals(nameNode.getQualifiedName())) {\n                return false;\n            }\n            if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n                if (nameNode.getFirstChild().isRegExp() && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                    return false;\n                } else if (nameNode.getFirstChild().isString() && STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                    Node param = nameNode.getNext();\n                    if (param != null && (param.isString() || param.isRegExp())) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  /**\n   * Check whether the given method call's arguments have side effects.\n   * @param call The call node of a method invocation.",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    if (call.isCall()) {\n        Node nameNode = call.getFirstChild();\n        if (nameNode.isName()) {\n            String name = nameNode.getString();\n            if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n                return false;\n            }\n        } else if (nameNode.isGetProp()) {\n            if (call.hasOneChild() && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n                return false;\n            }\n            if (call.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) {\n                return false;\n            }\n            if (nameNode.getFirstChild().isName() && \"Math.floor\".equals(nameNode.getQualifiedName())) {\n                return false;\n            }\n            if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n                if (nameNode.getFirstChild().isRegExp() && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                    return false;\n                } else if (nameNode.getFirstChild().isString() && STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                    Node param = nameNode.getNext();\n                    if (param != null && (param.isString() || param.isRegExp())) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node nameNode = call.getFirstChild();\n    if (nameNode.isName()) {\n      String name = nameNode.getString();\n      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n        return false;\n      }\n    } else if (nameNode.isGetProp()) {\n      if (call.hasOneChild() && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n        return false;\n      }\n      if (call.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) {\n        return false;\n      }\n      if (nameNode.getFirstChild().isName() && \"Math.floor\".equals(nameNode.getQualifiedName())) {\n        return false;\n      }\n      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n        if (nameNode.getFirstChild().isRegExp() && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n          return false;\n        } else if (nameNode.getFirstChild().isString() && STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n          Node param = nameNode.getNext();\n          if (param != null && (param.isString() || param.isRegExp())) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    if (call.isCall()) {\n        Node nameNode = call.getFirstChild();\n        if (nameNode.isName()) {\n            String name = nameNode.getString();\n            if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n                return false;\n            }\n        } else if (nameNode.isGetProp()) {\n            if (call.hasOneChild()\n                    && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n                    nameNode.getLastChild().getString())) {\n                return false;\n            }\n            if (call.isOnlyModifiesThisCall()\n                    && evaluatesToLocalValue(nameNode.getFirstChild())) {\n                return false;\n            }\n            if (nameNode.getFirstChild().isName()\n                    && \"Math.floor\".equals(nameNode.getQualifiedName())) {\n                return false;\n            }\n            if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n                if (nameNode.getFirstChild().isRegExp()\n                        && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                    return false;\n                } else if (nameNode.getFirstChild().isString()\n                        && STRING_REGEXP_METHODS.contains(\n                        nameNode.getLastChild().getString())) {\n                    Node param = nameNode.getNext();\n                    if (param != null\n                            && (param.isString() || param.isRegExp())) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node nameNode = call.getFirstChild();\n    if (nameNode.isName()) {\n        String name = nameNode.getString();\n        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n            return false;\n        }\n    } else if (nameNode.isGetProp()) {\n        if (call.hasOneChild() && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n            return false;\n        }\n        if (call.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) {\n            return false;\n        }\n        if (nameNode.getFirstChild().isName() && \"Math.floor\".equals(nameNode.getQualifiedName())) {\n            return false;\n        }\n        if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n            if (nameNode.getFirstChild().isRegExp() && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                return false;\n            } else if (nameNode.getFirstChild().isString() && STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                Node param = nameNode.getNext();\n                if (param != null && (param.isString() || param.isRegExp())) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node nameNode = call.getFirstChild();\n    if (nameNode.isName()) {\n      String name = nameNode.getString();\n      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n        return false;\n      }\n    } else if (nameNode.isGetProp()) {\n      if (call.hasOneChild() && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n        return false;\n      }\n      if (call.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) {\n        return false;\n      }\n      if (nameNode.getFirstChild().isName() && \"Math.floor\".equals(nameNode.getQualifiedName())) {\n        return false;\n      }\n      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n        if (nameNode.getFirstChild().isRegExp() && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n          return false;\n        } else if (nameNode.getFirstChild().isString() && STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n          Node param = nameNode.getNext();\n          if (param != null && (param.isString() || param.isRegExp())) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node nameNode = call.getFirstChild();\n    if (nameNode.isName()) {\n      String name = nameNode.getString();\n      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n        return false;\n      }\n    } else if (nameNode.isGetProp()) {\n      if (call.hasOneChild() && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n        return false;\n      }\n      if (call.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) {\n        return false;\n      }\n      if (nameNode.getFirstChild().isName() && \"Math.floor\".equals(nameNode.getQualifiedName())) {\n        return false;\n      }\n      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n        if (nameNode.getFirstChild().isRegExp() && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n          return false;\n        } else if (nameNode.getFirstChild().isString() && STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n          Node param = nameNode.getNext();\n          if (param != null && (param.isString() || param.isRegExp())) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node nameNode = call.getFirstChild();\n    if (nameNode.isName()) {\n        String name = nameNode.getString();\n        if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n            return false;\n        }\n    } else if (nameNode.isGetProp()) {\n        if (call.hasOneChild()\n            && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n                nameNode.getLastChild().getString())) {\n            return false;\n        }\n        if (call.isOnlyModifiesThisCall()\n            && evaluatesToLocalValue(nameNode.getFirstChild())) {\n            return false;\n        }\n        if (nameNode.getFirstChild().isName()) {\n            if (\"Math.floor\".equals(nameNode.getQualifiedName())) {\n                return false;\n            }\n        }\n        if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n            if (nameNode.getFirstChild().isRegExp()\n                && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n                return false;\n            } else if (nameNode.getFirstChild().isString()\n                && STRING_REGEXP_METHODS.contains(\n                    nameNode.getLastChild().getString())) {\n                Node param = nameNode.getNext();\n                if (param != null &&\n                    (param.isString() || param.isRegExp())) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node nameNode = call.getFirstChild();\n    if (nameNode.isName()) {\n      String name = nameNode.getString();\n      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n        return false;\n      }\n    } else if (nameNode.isGetProp()) {\n      if (call.hasOneChild() && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(nameNode.getLastChild().getString())) {\n        return false;\n      }\n      if (call.isOnlyModifiesThisCall() && evaluatesToLocalValue(nameNode.getFirstChild())) {\n        return false;\n      }\n      if (nameNode.getFirstChild().isName() && \"Math.floor\".equals(nameNode.getQualifiedName())) {\n        return false;\n      }\n      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n        if (nameNode.getFirstChild().isRegExp() && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n          return false;\n        } else if (nameNode.getFirstChild().isString() && STRING_REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n          Node param = nameNode.getNext();\n          if (param != null && (param.isString() || param.isRegExp())) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(getField(), m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], 1.0);\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, 0.0);\n                }\n            }\n        }\n    }\n    return cachedP;\n}\n\n/**\n * Returns the pivot permutation vector.\n * @return the pivot permutation vector\n * @see #getP()",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(getField(), m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], 1.0);\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, 0.0);\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(getField(), m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], 1.0);\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, 0.0);\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(getField(), m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], 1.0);\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, 0.0);\n                }\n            }\n        }\n    }\n    return cachedP;\n}\n\n/**\n * Returns the pivot permutation vector.\n * @return the pivot permutation vector\n * @see #getP()",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(getField(), m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], 1.0);\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, 0.0);\n                }\n            }\n        }\n    }\n    return cachedP;\n}\n\n/**\n * Returns the pivot permutation vector.\n * @return the pivot permutation vector\n * @see #getP()",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(getField(), m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], 1.0);\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, 0.0);\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(getField(), m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], 1.0);\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, 0.0);\n                }\n            }\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(getField(), m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], 1.0);\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, 0.0);\n                }\n            }\n        }\n    }\n    return cachedP;\n}\n\n/**\n * Returns the pivot permutation vector.\n * @return the pivot permutation vector\n * @see #getP()",
      "public FieldMatrix<T> getP()  /**\n     * Returns the matrix L of the decomposition.\n     * <p>L is a lower-triangular matrix</p>\n     * @return the L matrix (or null if decomposed matrix is singular)",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(getField(), m, m);\n        for (int i = 0; i < m; ++i) {\n            cachedP.setEntry(i, pivot[i], 1.0);\n            for (int j = 0; j < m; ++j) {\n                if (j != pivot[i]) {\n                    cachedP.setEntry(i, j, 0.0);\n                }\n            }\n        }\n    }\n    return cachedP;\n}"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double getSup()  {\n    return Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    return Double.POSITIVE_INFINITY;\n}",
      "public double getSup()  {\n    if (isEmpty()) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return Double.max(getMin(), getMax());\n}",
      "public double getSup()  {\n    if (isEmpty()) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return Double.max(getMin(), getMax());\n}",
      "public double getSup()  {\n    if (isEmpty()) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return Double.max(getMin(), getMax());\n}",
      "public double getSup()  {\n    return super.getMax();\n}",
      "public double getSup()  {\n    if (isEmpty()) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return Double.max(getMin(), getMax());\n}",
      "public double getSup()  {\n    return Double.isInfinite(getMax()) ? Double.POSITIVE_INFINITY : getMax();\n}",
      "public double getSup()  {\n    if (isEmpty()) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    return Double.max(getMin(), getMax());\n}",
      "public double getSup()  {\n    return Double.isInfinite(getMax()) ? Double.POSITIVE_INFINITY : getMax();\n}"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    if (isEscape(ch)) {\n        final int unescaped = readEscape();\n        if (unescaped == END_OF_STREAM) { // unexpected char after escape\n            token.content.append((char) ch).append((char) reader.getLastChar());\n        } else {\n            token.content.append((char) unescaped);\n        }\n    } else if (isQuoteChar(ch)) {\n        if (isQuoteChar(reader.lookAhead())) {\n            // double or escaped encapsulator -> add single encapsulator to token\n            ch = reader.read();\n            token.content.append((char) ch);\n        } else {\n            // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n            while (true) {\n                ch = reader.read();\n                if (isDelimiter(ch)) {\n                    token.type = TOKEN;\n                    return token;\n                } else if (isEndOfFile(ch)) {\n                    token.type = EOF;\n                    token.isReady = true; // There is data at EOF\n                    return token;\n                } else if (readEndOfLine(ch)) {\n                    token.type = EORECORD;\n                    return token;\n                } else if (!isWhitespace(ch)) {\n                    // error invalid char between token and next delimiter\n                    throw new IOException(\"(line \" + getCurrentLineNumber() +\n                            \") invalid char between encapsulated token and delimiter\");\n                }\n            }\n        }\n    } else if (isEndOfFile(ch)) {\n        // error condition (end of file before end of token)\n        throw new IOException(\"(startline \" + startLineNumber +\n                \") EOF reached before encapsulated token finished\");\n    } else {\n        token.content.append((char) ch);\n    }\n    return token;\n}\n\n/**\n     * Parses an encapsulated token.\n     * <p/>\n     * Encapsulated tokens are surrounded by the given encapsulating-string. The encapsulator itself might be included\n     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n     * an encapsulated token are ignored. The token is finished when one of the following conditions become true:\n     * <ul>\n     * <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n     * <ul>\n     * <li>delimiter (TOKEN)</li>\n     * <li>end of line (EORECORD)</li>\n     * </ul>",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    if (isEscape(ch)) {\n        final int unescaped = readEscape();\n        if (unescaped == END_OF_STREAM) { // unexpected char after escape\n            token.content.append((char) ch).append((char) reader.getLastChar());\n        } else {\n            token.content.append((char) unescaped);\n        }\n    } else if (isQuoteChar(ch)) {\n        if (isQuoteChar(reader.lookAhead())) {\n            // double or escaped encapsulator -> add single encapsulator to token\n            ch = reader.read();\n            token.content.append((char) ch);\n        } else {\n            // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n            while (true) {\n                ch = reader.read();\n                if (isDelimiter(ch)) {\n                    token.type = TOKEN;\n                    return token;\n                } else if (isEndOfFile(ch)) {\n                    token.type = EOF;\n                    token.isReady = true; // There is data at EOF\n                    return token;\n                } else if (readEndOfLine(ch)) {\n                    token.type = EORECORD;\n                    return token;\n                } else if (!isWhitespace(ch)) {\n                    // error invalid char between token and next delimiter\n                    throw new IOException(\"(line \" + getCurrentLineNumber() +\n                            \") invalid char between encapsulated token and delimiter\");\n                }\n            }\n        }\n    } else if (isEndOfFile(ch)) {\n        // error condition (end of file before end of token)\n        throw new IOException(\"(startline \" + startLineNumber +\n                \") EOF reached before encapsulated token finished\");\n    } else {\n        token.content.append((char) ch);\n    }\n    return token;\n}\n\n/**\n     * Parses an encapsulated token.\n     * <p/>\n     * Encapsulated tokens are surrounded by the given encapsulating-string. The encapsulator itself might be included\n     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n     * an encapsulated token are ignored. The token is finished when one of the following conditions become true:\n     * <ul>\n     * <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n     * <ul>\n     * <li>delimiter (TOKEN)</li>\n     * <li>end of line (EORECORD)</li>\n     * </ul>",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    if (isEscape(ch)) {\n        final int unescaped = readEscape();\n        if (unescaped == END_OF_STREAM) { // unexpected char after escape\n            token.content.append((char) ch).append((char) reader.getLastChar());\n        } else {\n            token.content.append((char) unescaped);\n        }\n    } else if (isQuoteChar(ch)) {\n        if (isQuoteChar(reader.lookAhead())) {\n            // double or escaped encapsulator -> add single encapsulator to token\n            ch = reader.read();\n            token.content.append((char) ch);\n        } else {\n            // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n            while (true) {\n                ch = reader.read();\n                if (isDelimiter(ch)) {\n                    token.type = TOKEN;\n                    return token;\n                } else if (isEndOfFile(ch)) {\n                    token.type = EOF;\n                    token.isReady = true; // There is data at EOF\n                    return token;\n                } else if (readEndOfLine(ch)) {\n                    token.type = EORECORD;\n                    return token;\n                } else if (!isWhitespace(ch)) {\n                    // error invalid char between token and next delimiter\n                    throw new IOException(\"(line \" + getCurrentLineNumber() +\n                            \") invalid char between encapsulated token and delimiter\");\n                }\n            }\n        }\n    } else if (isEndOfFile(ch)) {\n        // error condition (end of file before end of token)\n        throw new IOException(\"(startline \" + startLineNumber +\n                \") EOF reached before encapsulated token finished\");\n    } else {\n        token.content.append((char) ch);\n    }\n    return token;\n}\n\n/**\n     * Parses an encapsulated token.\n     * <p/>\n     * Encapsulated tokens are surrounded by the given encapsulating-string. The encapsulator itself might be included\n     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n     * an encapsulated token are ignored. The token is finished when one of the following conditions become true:\n     * <ul>\n     * <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n     * <ul>\n     * <li>delimiter (TOKEN)</li>\n     * <li>end of line (EORECORD)</li>\n     * </ul>",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    if (isEscape(ch)) {\n        final int unescaped = readEscape();\n        if (unescaped == END_OF_STREAM) { // unexpected char after escape\n            token.content.append((char) ch).append((char) reader.getLastChar());\n        } else {\n            token.content.append((char) unescaped);\n        }\n    } else if (isQuoteChar(ch)) {\n        if (isQuoteChar(reader.lookAhead())) {\n            // double or escaped encapsulator -> add single encapsulator to token\n            ch = reader.read();\n            token.content.append((char) ch);\n        } else {\n            // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n            while (true) {\n                ch = reader.read();\n                if (isDelimiter(ch)) {\n                    token.type = TOKEN;\n                    return token;\n                } else if (isEndOfFile(ch)) {\n                    token.type = EOF;\n                    token.isReady = true; // There is data at EOF\n                    return token;\n                } else if (readEndOfLine(ch)) {\n                    token.type = EORECORD;\n                    return token;\n                } else if (!isWhitespace(ch)) {\n                    // error invalid char between token and next delimiter\n                    throw new IOException(\"(line \" + getCurrentLineNumber() +\n                            \") invalid char between encapsulated token and delimiter\");\n                }\n            }\n        }\n    } else if (isEndOfFile(ch)) {\n        // error condition (end of file before end of token)\n        throw new IOException(\"(startline \" + startLineNumber +\n                \") EOF reached before encapsulated token finished\");\n    } else {\n        token.content.append((char) ch);\n    }\n    return token;\n}\n\n/**\n     * Parses an encapsulated token.\n     * <p/>\n     * Encapsulated tokens are surrounded by the given encapsulating-string. The encapsulator itself might be included\n     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n     * an encapsulated token are ignored. The token is finished when one of the following conditions become true:\n     * <ul>\n     * <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n     * <ul>\n     * <li>delimiter (TOKEN)</li>\n     * <li>end of line (EORECORD)</li>\n     * </ul>",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    if (isEscape(ch)) {\n        final int unescaped = readEscape();\n        if (unescaped == END_OF_STREAM) { // unexpected char after escape\n            token.content.append((char) ch).append((char) reader.getLastChar());\n        } else {\n            token.content.append((char) unescaped);\n        }\n    } else if (isQuoteChar(ch)) {\n        if (isQuoteChar(reader.lookAhead())) {\n            // double or escaped encapsulator -> add single encapsulator to token\n            ch = reader.read();\n            token.content.append((char) ch);\n        } else {\n            // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n            while (true) {\n                ch = reader.read();\n                if (isDelimiter(ch)) {\n                    token.type = TOKEN;\n                    return token;\n                } else if (isEndOfFile(ch)) {\n                    token.type = EOF;\n                    token.isReady = true; // There is data at EOF\n                    return token;\n                } else if (readEndOfLine(ch)) {\n                    token.type = EORECORD;\n                    return token;\n                } else if (!isWhitespace(ch)) {\n                    // error invalid char between token and next delimiter\n                    throw new IOException(\"(line \" + getCurrentLineNumber() +\n                            \") invalid char between encapsulated token and delimiter\");\n                }\n            }\n        }\n    } else if (isEndOfFile(ch)) {\n        // error condition (end of file before end of token)\n        throw new IOException(\"(startline \" + startLineNumber +\n                \") EOF reached before encapsulated token finished\");\n    } else {\n        token.content.append((char) ch);\n    }\n    return token;\n}\n\n/**\n     * Parses an encapsulated token.\n     * <p/>\n     * Encapsulated tokens are surrounded by the given encapsulating-string. The encapsulator itself might be included\n     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n     * an encapsulated token are ignored. The token is finished when one of the following conditions become true:\n     * <ul>\n     * <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n     * <ul>\n     * <li>delimiter (TOKEN)</li>\n     * <li>end of line (EORECORD)</li>\n     * </ul>",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    if (isEscape(ch)) {\n        final int unescaped = readEscape();\n        if (unescaped == END_OF_STREAM) { // unexpected char after escape\n            token.content.append((char) ch).append((char) reader.getLastChar());\n        } else {\n            token.content.append((char) unescaped);\n        }\n    } else if (isQuoteChar(ch)) {\n        if (isQuoteChar(reader.lookAhead())) {\n            // double or escaped encapsulator -> add single encapsulator to token\n            ch = reader.read();\n            token.content.append((char) ch);\n        } else {\n            // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n            while (true) {\n                ch = reader.read();\n                if (isDelimiter(ch)) {\n                    token.type = TOKEN;\n                    return token;\n                } else if (isEndOfFile(ch)) {\n                    token.type = EOF;\n                    token.isReady = true; // There is data at EOF\n                    return token;\n                } else if (readEndOfLine(ch)) {\n                    token.type = EORECORD;\n                    return token;\n                } else if (!isWhitespace(ch)) {\n                    // error invalid char between token and next delimiter\n                    throw new IOException(\"(line \" + getCurrentLineNumber() +\n                            \") invalid char between encapsulated token and delimiter\");\n                }\n            }\n        }\n    } else if (isEndOfFile(ch)) {\n        // error condition (end of file before end of token)\n        throw new IOException(\"(startline \" + startLineNumber +\n                \") EOF reached before encapsulated token finished\");\n    } else {\n        token.content.append((char) ch);\n    }\n    return token;\n}\n\n/**\n     * Parses an encapsulated token.\n     * <p/>\n     * Encapsulated tokens are surrounded by the given encapsulating-string. The encapsulator itself might be included\n     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n     * an encapsulated token are ignored. The token is finished when one of the following conditions become true:\n     * <ul>\n     * <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n     * <ul>\n     * <li>delimiter (TOKEN)</li>\n     * <li>end of line (EORECORD)</li>\n     * </ul>",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    if (isEscape(ch)) {\n        final int unescaped = readEscape();\n        if (unescaped == END_OF_STREAM) { // unexpected char after escape\n            token.content.append((char) ch).append((char) reader.getLastChar());\n        } else {\n            token.content.append((char) unescaped);\n        }\n    } else if (isQuoteChar(ch)) {\n        if (isQuoteChar(reader.lookAhead())) {\n            // double or escaped encapsulator -> add single encapsulator to token\n            ch = reader.read();\n            token.content.append((char) ch);\n        } else {\n            // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n            while (true) {\n                ch = reader.read();\n                if (isDelimiter(ch)) {\n                    token.type = TOKEN;\n                    return token;\n                } else if (isEndOfFile(ch)) {\n                    token.type = EOF;\n                    token.isReady = true; // There is data at EOF\n                    return token;\n                } else if (readEndOfLine(ch)) {\n                    token.type = EORECORD;\n                    return token;\n                } else if (!isWhitespace(ch)) {\n                    // error invalid char between token and next delimiter\n                    throw new IOException(\"(line \" + getCurrentLineNumber() +\n                            \") invalid char between encapsulated token and delimiter\");\n                }\n            }\n        }\n    } else if (isEndOfFile(ch)) {\n        // error condition (end of file before end of token)\n        throw new IOException(\"(startline \" + startLineNumber +\n                \") EOF reached before encapsulated token finished\");\n    } else {\n        token.content.append((char) ch);\n    }\n    return token;\n}\n\n/**\n     * Parses an encapsulated token.\n     * <p/>\n     * Encapsulated tokens are surrounded by the given encapsulating-string. The encapsulator itself might be included\n     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n     * an encapsulated token are ignored. The token is finished when one of the following conditions become true:\n     * <ul>\n     * <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n     * <ul>\n     * <li>delimiter (TOKEN)</li>\n     * <li>end of line (EORECORD)</li>\n     * </ul>",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    if (isEscape(ch)) {\n        final int unescaped = readEscape();\n        if (unescaped == END_OF_STREAM) { // unexpected char after escape\n            token.content.append((char) ch).append((char) reader.getLastChar());\n        } else {\n            token.content.append((char) unescaped);\n        }\n    } else if (isQuoteChar(ch)) {\n        if (isQuoteChar(reader.lookAhead())) {\n            // double or escaped encapsulator -> add single encapsulator to token\n            ch = reader.read();\n            token.content.append((char) ch);\n        } else {\n            // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n            while (true) {\n                ch = reader.read();\n                if (isDelimiter(ch)) {\n                    token.type = TOKEN;\n                    return token;\n                } else if (isEndOfFile(ch)) {\n                    token.type = EOF;\n                    token.isReady = true; // There is data at EOF\n                    return token;\n                } else if (readEndOfLine(ch)) {\n                    token.type = EORECORD;\n                    return token;\n                } else if (!isWhitespace(ch)) {\n                    // error invalid char between token and next delimiter\n                    throw new IOException(\"(line \" + getCurrentLineNumber() +\n                            \") invalid char between encapsulated token and delimiter\");\n                }\n            }\n        }\n    } else if (isEndOfFile(ch)) {\n        // error condition (end of file before end of token)\n        throw new IOException(\"(startline \" + startLineNumber +\n                \") EOF reached before encapsulated token finished\");\n    } else {\n        token.content.append((char) ch);\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    if (isDelimiter(ch)) {\n        token.type = TOKEN;\n    } else if (isEndOfFile(ch)) {\n        token.type = EOF;\n        token.isReady = true; // There is data at EOF\n    } else if (readEndOfLine(ch)) {\n        token.type = EORECORD;\n    } else {\n        token.content.append((char) ch);\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    if (isDelimiter(ch)) {\n        token.type = TOKEN;\n    } else if (readEndOfLine(ch)) {\n        token.type = EORECORD;\n    } else if (isEndOfFile(ch)) {\n        token.type = EOF;\n        token.isReady = true; // There is data at EOF\n    } else {\n        token.content.append((char) ch);\n    }\n    return token;\n}\n\n/**\n     * Parses an encapsulated token.\n     * <p/>\n     * Encapsulated tokens are surrounded by the given encapsulating-string. The encapsulator itself might be included\n     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n     * an encapsulated token are ignored. The token is finished when one of the following conditions become true:\n     * <ul>\n     * <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n     * <ul>\n     * <li>delimiter (TOKEN)</li>\n     * <li>end of line (EORECORD)</li>\n     * </ul>\n     * <li>end of stream has been reached (EOF)</li> </ul>\n     *\n     * @param token\n     *            the current token\n     * @return a valid token object\n     * @throws IOException\n     *             on invalid state: EOF before closing encapsulator or invalid character before delimiter or EOL"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index % size[i];\n        index /= size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index % size[i];\n        index /= size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int i = index;\n    for (int j = dimension - 1; j >= 0; j--) {\n        counts[j] = i % size[j];\n        i /= size[j];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index % size[i];\n        index /= size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index % size[i];\n        index /= size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int temp = index;\n    for (int i = dimension - 1; i >= 0; i--) {\n        counts[i] = temp % size[i];\n        temp /= size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int i = index;\n    for (int j = dimension - 1; j >= 0; j--) {\n        counts[j] = i % size[j];\n        i = i / size[j];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = 0; i < dimension; i++) {\n        counts[i] = index / uniCounterOffset[i] % size[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int i = index;\n    for (int j = dimension - 1; j >= 0; j--) {\n        counts[j] = i % size[j];\n        i /= size[j];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    int tempIndex = index;\n    for (int i = dimension - 1; i >= 0; i--) {\n        counts[i] = tempIndex % size[i];\n        tempIndex /= size[i];\n    }\n    return counts;\n}"
    ],
    [
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}\n\n/**\n * Factory method that will construct a pointer instance that describes\n * path to location given {@link JsonStreamContext} points to.\n *\n * @param context Context to build pointer expression for\n * @param includeRoot Whether to include number offset for virtual \"root context\"\n *    or not.\n *\n * @since 2.9",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}\n\n/**\n * Factory method that will construct a pointer instance that describes\n * path to location given {@link JsonStreamContext} points to.\n *\n * @param context Context to build pointer expression for\n * @param includeRoot Whether to include number offset for virtual \"root context\"\n *    or not.\n *\n * @since 2.9",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer current = this;\n    while (current._nextSegment != null) {\n        current = current._nextSegment;\n    }\n    return current;\n}\n\n/**\n * Factory method that will construct a pointer instance that describes\n * path to location given {@link JsonStreamContext} points to.\n *\n * @param context Context to build pointer expression for\n * @param includeRoot Whether to include number offset for virtual \"root context\"\n *    or not.\n *\n * @since 2.9",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}\n\n/**\n * Factory method that will construct a pointer instance that describes\n * path to location given {@link JsonStreamContext} points to.\n *\n * @param context Context to build pointer expression for\n * @param includeRoot Whether to include number offset for virtual \"root context\"\n *    or not.\n *\n * @since 2.9",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}\n\n/**\n * Factory method that will construct a pointer instance that describes\n * path to location given {@link JsonStreamContext} points to.\n *\n * @param context Context to build pointer expression for\n * @param includeRoot Whether to include number offset for virtual \"root context\"\n *    or not.\n *\n * @since 2.9",
      "public JsonPointer last()  {\n    JsonPointer last = this;\n    while (last._nextSegment != null) {\n        last = last._nextSegment;\n    }\n    return last;\n}\n\n/**\n * Factory method that will construct a pointer instance that describes\n * path to location given {@link JsonStreamContext} points to.\n *\n * @param context Context to build pointer expression for\n * @param includeRoot Whether to include number offset for virtual \"root context\"\n *    or not.\n *\n * @since 2.9"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            try {\n                return (T) SerializationUtils.clone(obj);\n            } catch (IOException e) {\n                throw new CloneFailedException(\"Failed to clone object\", e);\n            }\n        } else {\n            return obj;\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            try {\n                return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            } catch (Exception e) {\n                throw new CloneFailedException(\"Failed to clone object\", e);\n            }\n        } else if (obj instanceof Serializable) {\n            return (T) SerializationUtils.clone(obj);\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            try {\n                return (T) SerializationUtils.clone(obj);\n            } catch (IOException e) {\n                throw new CloneFailedException(\"Failed to clone object\", e);\n            }\n        } else {\n            return obj;\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            try {\n                return (T) SerializationUtils.clone(obj);\n            } catch (IOException e) {\n                throw new CloneFailedException(\"Failed to clone object\", e);\n            }\n        } else {\n            return obj;\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            try {\n                return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            } catch (Exception e) {\n                throw new CloneFailedException(\"Failed to clone object\", e);\n            }\n        } else if (obj instanceof Serializable) {\n            return SerializationUtils.clone(obj);\n        } else {\n            return null;\n        }\n    }",
      "public static <T> T clone(final T obj)  /**\n     * <p>SerializationUtils instances should NOT be constructed in standard programming.\n     * Instead, the class should be used as {@code SerializationUtils.clone(object)}.</p>\n     *",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            try {\n                return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n            } catch (Exception e) {\n                throw new CloneFailedException(\"Failed to clone object\", e);\n            }\n        } else if (obj instanceof Serializable) {\n            try {\n                final byte[] objectData = serialize(obj);\n                final ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n                final ClassLoaderAwareObjectInputStream in = new ClassLoaderAwareObjectInputStream(bais, obj.getClass().getClassLoader());\n                return (T) in.readObject();\n            } catch (Exception e) {\n                throw new CloneFailedException(\"Failed to clone object\", e);\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (!(obj instanceof Serializable)) {\n            return null;\n        }\n        try {\n            final byte[] objectData = serialize(obj);\n            final ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n            final ClassLoaderAwareObjectInputStream in = new ClassLoaderAwareObjectInputStream(bais, obj.getClass().getClassLoader());\n            return (T) in.readObject();\n        } catch (IOException e) {\n            throw new CloneFailedException(\"Failed to clone object\", e);\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Cloneable) {\n            try {\n                return (T) SerializationUtils.clone(obj);\n            } catch (IOException e) {\n                throw new CloneFailedException(\"Failed to clone object\", e);\n            }\n        } else {\n            return obj;\n        }\n    }",
      "public static <T> T clone(final T obj)  {\n        if (obj == null) {\n            return null;\n        }\n        if (!(obj instanceof Serializable)) {\n            return null;\n        }\n        try {\n            final byte[] objectData = serialize(obj);\n            final ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n            final ClassLoaderAwareObjectInputStream in = new ClassLoaderAwareObjectInputStream(bais, obj.getClass().getClassLoader());\n            return (T) in.readObject();\n        } catch (IOException | ClassNotFoundException e) {\n            throw new CloneFailedException(\"Failed to clone object\", e);\n        }\n    }"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getFunctionType() == null) {\n        return null;\n    }\n    Node functionNode = sym.getFunctionType().getSource();\n    if (functionNode == null) {\n        return null;\n    }\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n        return null;\n    }\n    return scope.getQualifiedSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getFunctionType() == null) {\n        return null;\n    }\n    Node functionNode = sym.getFunctionType().getSource();\n    if (functionNode == null) {\n        return null;\n    }\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n        return null;\n    }\n    return scope.getQualifiedSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym instanceof FunctionType) {\n        FunctionType type = (FunctionType) sym;\n        Node functionNode = type.getSource();\n        if (functionNode != null) {\n            SymbolScope scope = getScopeInFunction(sym);\n            if (scope != null) {\n                return scope.getQualifiedSlot(paramName);\n            }\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getFunctionType() == null) {\n        return null;\n    }\n    Node functionNode = sym.getFunctionType().getSource();\n    if (functionNode == null) {\n        return null;\n    }\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n        return null;\n    }\n    return scope.getQualifiedSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym instanceof FunctionType) {\n        FunctionType type = (FunctionType) sym;\n        if (type.getSource() != null) {\n            SymbolScope scope = getScopeInFunction(sym);\n            if (scope != null) {\n                return scope.getQualifiedSlot(paramName);\n            }\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym instanceof FunctionType) {\n        FunctionType type = (FunctionType) sym;\n        if (type.isConstructor() || type.isInterface()) {\n            SymbolScope scope = getScopeInFunction(sym);\n            if (scope != null) {\n                return scope.getQualifiedSlot(paramName);\n            }\n        }\n    }\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getFunctionType() == null) {\n        return null;\n    }\n    Node functionNode = sym.getFunctionType().getSource();\n    if (functionNode == null) {\n        return null;\n    }\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n        return null;\n    }\n    return scope.getQualifiedSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getFunctionType() == null) {\n        return null;\n    }\n    Node functionNode = sym.getFunctionType().getSource();\n    if (functionNode == null) {\n        return null;\n    }\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n        return null;\n    }\n    return scope.getQualifiedSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym.getFunctionType() == null) {\n        return null;\n    }\n    Node functionNode = sym.getFunctionType().getSource();\n    if (functionNode == null) {\n        return null;\n    }\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n        return null;\n    }\n    return scope.getQualifiedSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    if (sym instanceof FunctionType) {\n        FunctionType type = (FunctionType) sym;\n        Node functionNode = type.getSource();\n        if (functionNode != null) {\n            SymbolScope scope = getScopeInFunction(sym);\n            if (scope != null) {\n                return scope.getQualifiedSlot(paramName);\n            }\n        }\n    }\n    return null;\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            data[i][j] = matrix.getEntry(i, j);\n        }\n    }\n    if (biasCorrected) {\n        return computeCovarianceMatrix(data, true);\n    } else {\n        return computeCovarianceMatrix(data, false);\n    }\n}\n\n/**\n * Compute a covariance matrix from a rectangular array whose columns represent\n * covariates.\n * @param data input array (must have at least one column and two rows)\n * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n * @return covariance matrix\n * @throws MathIllegalArgumentException if the data array does not contain sufficient data\n * @throws NotStrictlyPositiveException if the input data array is not\n * rectangular with at least one row and one column.\n */\nprotected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected)\n    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n    checkSufficientData(data);\n    int nRows = data.length;\n    int nCols = data[0].length;\n    if (nRows < 2 || nCols < 2) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.ROWS_AND_COLUMNS);\n    }\n    RealMatrix covarianceMatrix = new BlockRealMatrix(nCols, nCols);\n    for (int i = 0; i < nCols; i++) {\n        for (int j = 0; j < nCols; j++) {\n            double sum = 0;\n            for (int k = 0; k < nRows; k++) {\n                sum += (data[k][i] - mean[i]) * (data[k][j] - mean[j]);\n            }\n            covarianceMatrix.setEntry(i, j, sum / (nRows - 1));\n        }\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            data[i][j] = matrix.getEntry(i, j);\n        }\n    }\n    return computeCovarianceMatrix(data, biasCorrected);\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            data[i][j] = matrix.getEntry(i, j);\n        }\n    }\n    RealMatrix covarianceMatrix = computeCovarianceMatrix(data, biasCorrected);\n    return covarianceMatrix;\n}\n\n/**\n * Compute a covariance matrix from a rectangular array whose columns represent\n * covariates.\n * @param data input array (must have at least one column and two rows)\n * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n * @return covariance matrix\n * @throws MathIllegalArgumentException if the data array does not contain sufficient data\n * @throws NotStrictlyPositiveException if the input data array is not\n * rectangular with at least one row and one column.\n */\nprotected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected)\n    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n    checkSufficientData(data);\n    int nRows = data.length;\n    int nCols = data[0].length;\n    if (nRows < 2 || nCols < 2) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.ROWS_AND_COLUMNS, nRows, nCols);\n    }\n    double[] means = new double[nCols];\n    for (int j = 0; j < nCols; j++) {\n        double sum = 0;\n        for (int i = 0; i < nRows; i++) {\n            sum += data[i][j];\n        }\n        means[j] = sum / nRows;\n    }\n    double[][] centeredData = new double[nRows][nCols];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            centeredData[i][j] = data[i][j] - means[j];\n        }\n    }\n    double[][] covarianceMatrix = new double[nCols][nCols];\n    for (int i = 0; i < nCols; i++) {\n        for (int j = 0; j < nCols; j++) {\n            double sum = 0;\n}\n}\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            data[i][j] = matrix.getEntry(i, j);\n        }\n    }\n    if (biasCorrected) {\n        return computeCovarianceMatrix(data, true);\n    } else {\n        return computeCovarianceMatrix(data, false);\n    }\n}\n\n/**\n * Compute a covariance matrix from a rectangular array whose columns represent\n * covariates.\n * @param data input array (must have at least one column and two rows)\n * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n * @return covariance matrix\n * @throws MathIllegalArgumentException if the data array does not contain sufficient data\n * @throws NotStrictlyPositiveException if the input data array is not\n * rectangular with at least one row and one column.\n */\nprotected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected)\n    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n    checkSufficientData(data);\n    int nRows = data.length;\n    int nCols = data[0].length;\n    if (nRows < 2 || nCols < 2) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS,\n                                               nRows, nCols);\n    }\n    double[] means = new double[nCols];\n    for (int j = 0; j < nCols; j++) {\n        means[j] = 0;\n        for (int i = 0; i < nRows; i++) {\n            means[j] += data[i][j];\n        }\n        means[j] /= nRows;\n    }\n    double[][] centeredData = new double[nRows][nCols];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            centeredData[i][j] = data[i][j] - means[j];\n        }\n    }\n    double[][] covarianceMatrix = new double[nCols][nCols];\n    for (int i = 0; i < nCols; i++) {\n        for (int j = 0;\n}\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            data[i][j] = matrix.getEntry(i, j);\n        }\n    }\n    if (biasCorrected) {\n        return computeCovarianceMatrix(data, true);\n    } else {\n        return computeCovarianceMatrix(data, false);\n    }\n}\n\n/**\n * Compute a covariance matrix from a rectangular array whose columns represent\n * covariates.\n * @param data input array (must have at least one column and two rows)\n * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n * @return covariance matrix\n * @throws MathIllegalArgumentException if the data array does not contain sufficient data\n * @throws NotStrictlyPositiveException if the input data array is not\n * rectangular with at least one row and one column.\n */\nprotected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected)\n    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n    checkSufficientData(data);\n    int nRows = data.length;\n    int nCols = data[0].length;\n    if (nRows < 2 || nCols < 2) {\n        throw new NotStrictlyPositiveException(\"Input data array is not rectangular\");\n    }\n    RealMatrix covarianceMatrix = new BlockRealMatrix(nCols, nCols);\n    for (int i = 0; i < nCols; i++) {\n        for (int j = 0; j < nCols; j++) {\n            double sum = 0;\n            for (int k = 0; k < nRows; k++) {\n                sum += (data[k][i] - mean(data, i)) * (data[k][j] - mean(data, j));\n            }\n            covarianceMatrix.setEntry(i, j, sum / (nRows - 1));\n        }\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            data[i][j] = matrix.getEntry(i, j);\n        }\n    }\n    RealMatrix covarianceMatrix = computeCovarianceMatrix(data, biasCorrected);\n    return covarianceMatrix;\n}\n\n/**\n * Compute a covariance matrix from a rectangular array whose columns represent\n * covariates.\n * @param data input array (must have at least one column and two rows)\n * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n * @return covariance matrix\n * @throws MathIllegalArgumentException if the data array does not contain sufficient data\n * @throws NotStrictlyPositiveException if the input data array is not\n * rectangular with at least one row and one column.\n */\nprotected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected)\n    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n    checkSufficientData(data);\n    int nRows = data.length;\n    int nCols = data[0].length;\n    if (nRows < 2 || nCols < 2) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS, nRows, nCols);\n    }\n    RealMatrix covarianceMatrix = new BlockRealMatrix(nCols, nCols);\n    for (int i = 0; i < nCols; i++) {\n        for (int j = 0; j < nCols; j++) {\n            double sum = 0;\n            for (int k = 0; k < nRows; k++) {\n                sum += (data[k][i] - mean[i]) * (data[k][j] - mean[j]);\n            }\n            covarianceMatrix.setEntry(i, j, sum / (nRows - 1));\n        }\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            data[i][j] = matrix.getEntry(i, j);\n        }\n    }\n    return computeCovarianceMatrix(data, biasCorrected);\n}\n\n/**\n * Compute a covariance matrix from a rectangular array whose columns represent\n * covariates.\n * @param data input array (must have at least one column and two rows)\n * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n * @return covariance matrix\n * @throws MathIllegalArgumentException if the data array does not contain sufficient data\n * @throws NotStrictlyPositiveException if the input data array is not\n * rectangular with at least one row and one column.\n */\nprotected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected)\n    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n    checkSufficientData(data);\n    int nRows = data.length;\n    int nCols = data[0].length;\n    if (nRows < 2 || nCols < 2) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.ROWS_AND_COLUMNS);\n    }\n    RealMatrix covarianceMatrix = new BlockRealMatrix(nCols, nCols);\n    for (int i = 0; i < nCols; i++) {\n        for (int j = 0; j < nCols; j++) {\n            double sum = 0;\n            for (int k = 0; k < nRows; k++) {\n                sum += (data[k][i] - mean(data, i)) * (data[k][j] - mean(data, j));\n            }\n            covarianceMatrix.setEntry(i, j, sum / (nRows - 1));\n        }\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            data[i][j] = matrix.getEntry(i, j);\n        }\n    }\n    RealMatrix covarianceMatrix = computeCovarianceMatrix(data, biasCorrected);\n    return covarianceMatrix;\n}\n\n/**\n * Compute a covariance matrix from a rectangular array whose columns represent\n * covariates.\n * @param data input array (must have at least one column and two rows)\n * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n * @return covariance matrix\n * @throws MathIllegalArgumentException if the data array does not contain sufficient data\n * @throws NotStrictlyPositiveException if the input data array is not\n * rectangular with at least one row and one column.\n */\nprotected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected)\n    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n    checkSufficientData(data);\n    int nRows = data.length;\n    int nCols = data[0].length;\n    if (nRows < 2 || nCols < 2) {\n        throw new NotStrictlyPositiveException(\"Input data array is not rectangular with at least one row and one column.\");\n    }\n    RealMatrix covarianceMatrix = new BlockRealMatrix(nCols, nCols);\n    for (int i = 0; i < nCols; i++) {\n        for (int j = 0; j < nCols; j++) {\n            double sum = 0;\n            for (int k = 0; k < nRows; k++) {\n                sum += (data[k][i] - mean[i]) * (data[k][j] - mean[j]);\n            }\n            covarianceMatrix.setEntry(i, j, sum / (nRows - 1));\n        }\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            data[i][j] = matrix.getEntry(i, j);\n        }\n    }\n    if (biasCorrected) {\n        return computeCovarianceMatrix(data, true);\n    } else {\n        return computeCovarianceMatrix(data, false);\n    }\n}\n\n/**\n * Compute a covariance matrix from a rectangular array whose columns represent\n * covariates.\n * @param data input array (must have at least one column and two rows)\n * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n * @return covariance matrix\n * @throws MathIllegalArgumentException if the data array does not contain sufficient data\n * @throws NotStrictlyPositiveException if the input data array is not\n * rectangular with at least one row and one column.\n */\nprotected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected)\n    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n    checkSufficientData(data);\n    int nRows = data.length;\n    int nCols = data[0].length;\n    if (nRows < 2 || nCols < 2) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS, nRows, nCols);\n    }\n    RealMatrix covarianceMatrix = new BlockRealMatrix(nCols, nCols);\n    for (int i = 0; i < nCols; i++) {\n        for (int j = 0; j < nCols; j++) {\n            double sum = 0;\n            for (int k = 0; k < nRows; k++) {\n                sum += (data[k][i] - mean[i]) * (data[k][j] - mean[j]);\n            }\n            covarianceMatrix.setEntry(i, j, sum / (nRows - 1));\n        }\n    }\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    double[][] data = new double[nRows][nCols];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            data[i][j] = matrix.getEntry(i, j);\n        }\n    }\n    RealMatrix covarianceMatrix = computeCovarianceMatrix(data, biasCorrected);\n    return covarianceMatrix;\n}\n\n/**\n * Compute a covariance matrix from a rectangular array whose columns represent\n * covariates.\n * @param data input array (must have at least one column and two rows)\n * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n * @return covariance matrix\n * @throws MathIllegalArgumentException if the data array does not contain sufficient data\n * @throws NotStrictlyPositiveException if the input data array is not\n * rectangular with at least one row and one column.\n */\nprotected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected)\n    throws MathIllegalArgumentException, NotStrictlyPositiveException {\n    checkSufficientData(data);\n    int nRows = data.length;\n    int nCols = data[0].length;\n    if (nRows < 2 || nCols < 2) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS, nRows, nCols);\n    }\n    double[] means = new double[nCols];\n    for (int j = 0; j < nCols; j++) {\n        means[j] = 0;\n        for (int i = 0; i < nRows; i++) {\n            means[j] += data[i][j];\n        }\n        means[j] /= nRows;\n    }\n    double[][] deviations = new double[nRows][nCols];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            deviations[i][j] = data[i][j] - means[j];\n        }\n    }\n    double[][] covarianceMatrix = new double[nCols][nCols];\n    for (int i = 0; i < nCols; i++) {\n        for (int j = 0; j < nCols; j++) {\n            double sum = 0;\n}\n}\n}"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n    if (count > 63) {\n        throw new IOException(\"count must be a positive number not bigger than 63\");\n    }\n    if (bitsCachedSize >= count) {\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    if (bitsCachedSize < count) {\n        return processBitsGreater57(count);\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}\n\n    /**\n     * Fills the cache up to 56 bits\n     * @param count\n     * @return return true, when EOF\n     * @throws IOException",
      "public long readBits(final int count) throws IOException  {\n    if (count > 63) {\n        throw new IOException(\"count > 63\");\n    }\n    if (bitsCachedSize >= count) {\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    if (bitsCachedSize < count) {\n        return processBitsGreater57(count);\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IOException(\"Invalid bit count: \" + count);\n    }\n    if (bitsCachedSize >= count) {\n        return readBitsCached(count);\n    }\n    return processBitsGreater57(count);\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IOException(\"Invalid count: \" + count);\n    }\n    if (bitsCachedSize >= count) {\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    if (bitsCachedSize < count) {\n        return processBitsGreater57(count);\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}\n\n/**\n * Fills the cache up to 56 bits\n * @param count\n * @return return true, when EOF\n * @throws IOException",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IOException(\"Invalid count: \" + count);\n    }\n    if (bitsCachedSize >= count) {\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    if (bitsCachedSize < count) {\n        return processBitsGreater57(count);\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}\n\n/**\n     * Fills the cache up to 56 bits\n     * @param count\n     * @return return true, when EOF\n     * @throws IOException",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IOException(\"Invalid count: \" + count);\n    }\n    if (bitsCachedSize >= count) {\n        return readBitsFromCache(count);\n    }\n    return processBitsGreater57(count);\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count > 63) {\n        throw new IOException(\"Invalid count: \" + count);\n    }\n    if (bitsCachedSize >= count) {\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    if (bitsCachedSize < count) {\n        return processBitsGreater57(count);\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 1 || count > 63) {\n        throw new IOException(\"Invalid count: \" + count);\n    }\n    if (bitsCachedSize >= count) {\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    if (bitsCachedSize < count) {\n        return processBitsGreater57(count);\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IOException(\"Invalid count: \" + count);\n    }\n    if (bitsCachedSize >= count) {\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    if (bitsCachedSize < count) {\n        return processBitsGreater57(count);\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}\n\n    /**\n     * Fills the cache up to 56 bits\n     * @param count\n     * @return return true, when EOF\n     * @throws IOException",
      "public long readBits(final int count) throws IOException  {\n    if (count > 63) {\n        throw new IOException(\"Count is too big\");\n    }\n    if (bitsCachedSize >= count) {\n        final long bitsOut;\n        if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n            bitsOut = (bitsCached & MASKS[count]);\n            bitsCached >>>= count;\n        } else {\n            bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n        }\n        bitsCachedSize -= count;\n        return bitsOut;\n    }\n    if (bitsCachedSize < count) {\n        return processBitsGreater57(count);\n    }\n    final long bitsOut;\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) {\n        bitsOut = (bitsCached & MASKS[count]);\n        bitsCached >>>= count;\n    } else {\n        bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];\n    }\n    bitsCachedSize -= count;\n    return bitsOut;\n}"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.getType() == Token.LABEL) {\n        return target.getString().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    return target.getName().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.getType() == Token.LABEL) {\n        return target.getString().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    return target.getName().equals(label);\n}\n\n/**\n * Returns true if this is a literal value. We define a literal value\n * as any node that evaluates to the same thing regardless of when or\n * where it is evaluated. So /xyz/ and [3, 5] are literals, but\n * the name a is not.\n *\n * Function literals do not meet this definition, because they\n * lexically capture variables. For example, if you have\n * <code>\n * function() { return a; }\n * </code>\n * If it is evaluated in a different scope, then it\n * captures a different variable. Even if the function did not read\n * any captured variables directly, it would still fail this definition,\n * because it affects the lifecycle of variables in the enclosing scope.\n *\n * However, a function literal with respect to a particular scope is\n * a literal.\n *\n * @param includeFunctions If true, all function expressions will be\n *     treated as literals.\n */\nstatic boolean isLiteralValue(Node n, boolean includeFunctions) {\n    switch (n.getType()) {\n        case Token.CAST:\n            return isLiteralValue(n.getFirstChild(), includeFunctions);\n\n        case Token.ARRAYLIT:\n            for (Node child = n.getFirstChild(); child != null;\n                 child = child.getNext()) {\n                if ((!child.isEmpty()) && !isLiteralValue(child, includeFunctions)) {\n                    return false;\n                }\n            }\n            return true;\n\n        case Token.REGEXP:\n            // Return true only if all children are const.\n            for (Node child = n.getFirstChild(); child != null;\n                 child = child.getNext()) {\n                if (!isLiteralValue(child, includeFunctions)) {\n                    return false;\n                }\n            }\n            return true;\n\n        case Token.OBJECTLIT:\n            // Return true only if all values are const.\n            for (Node child = n.getFirstChild(); child != null;\n                 child = child.getNext()) {\n                if (!isLiteralValue(child.getFirstChild(), includeFunctions)) {\n                    return false;\n                }\n            }\n            return true;\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.getType() == Token.LABEL) {\n        return target.getString().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.getType() == Token.LABEL) {\n        return target.getString().equals(label);\n    }\n    return false;\n}\n\n/**\n   * Check if a node is a function declaration.",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.getType() == Token.LABEL) {\n        return label.equals(target.getString());\n    }\n    return false;\n}\n\n/**\n * Returns true if this is a literal value. We define a literal value\n * as any node that evaluates to the same thing regardless of when or\n * where it is evaluated. So /xyz/ and [3, 5] are literals, but\n * the name a is not.\n *\n * Function literals do not meet this definition, because they\n * lexically capture variables. For example, if you have\n * <code>\n * function() { return a; }\n * </code>\n * If it is evaluated in a different scope, then it\n * captures a different variable. Even if the function did not read\n * any captured variables directly, it would still fail this definition,\n * because it affects the lifecycle of variables in the enclosing scope.\n *\n * However, a function literal with respect to a particular scope is\n * a literal.\n *\n * @param includeFunctions If true, all function expressions will be\n *     treated as literals.\n */\nstatic boolean isLiteralValue(Node n, boolean includeFunctions) {\n    switch (n.getType()) {\n        case Token.CAST:\n            return isLiteralValue(n.getFirstChild(), includeFunctions);\n\n        case Token.ARRAYLIT:\n            for (Node child = n.getFirstChild(); child != null;\n                 child = child.getNext()) {\n                if ((!child.isEmpty()) && !isLiteralValue(child, includeFunctions)) {\n                    return false;\n                }\n            }\n            return true;\n\n        case Token.REGEXP:\n            // Return true only if all children are const.\n            for (Node child = n.getFirstChild(); child != null;\n                 child = child.getNext()) {\n                if (!isLiteralValue(child, includeFunctions)) {\n                    return false;\n                }\n            }\n            return true;\n\n        case Token.OBJECTLIT:\n            // Return true only if all values are const.\n            for (Node child = n.getFirstChild(); child != null;\n                 child = child.getNext()) {\n                if (!isLiteralValue(child.getFirstChild(), includeFunctions)) {\n                    return false;\n                }\n            }\n            return true;\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    return target.getString().equals(label);\n}\n\n/**\n * Method that constructs transformer that applies given transformers\n * as a sequence; essentially combines separate transform operations\n * into one logical transformation.",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (target.getType() == Token.LABEL) {\n        return label.equals(target.getString());\n    }\n    return false;\n}\n\n/**\n * Check if the given node is a function declaration.",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    return target.getString().equals(label);\n}"
    ],
    [
      "public String getURL(int series, int item)  {\n    XYURLGenerator urlGenerator = getURLGenerator(series, item, false);\n    if (urlGenerator == null) {\n        return null;\n    }\n    return urlGenerator.generateURL(getDataset(), series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator == null) {\n        return null;\n    }\n    return generator.generateURL(dataset, series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator == null) {\n        return null;\n    }\n    return generator.generateURL(getDataset(), series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator == null) {\n        return null;\n    }\n    return generator.generateURL(getDataset(), series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator == null) {\n        return null;\n    }\n    return generator.generateURL(getDataset(), series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator == null) {\n        return null;\n    }\n    return generator.generateURL(getDataset(), series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator urlGenerator = getURLGenerator(series, item, false);\n    if (urlGenerator == null) {\n        return null;\n    }\n    return urlGenerator.generateURL(dataset, series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator == null) {\n        return null;\n    }\n    return generator.generateURL(dataset, series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator == null) {\n        return null;\n    }\n    return generator.generateURL(getDataset(), series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator == null) {\n        return null;\n    }\n    return generator.generateURL(getDataset(), series, item);\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    int index = 0;\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        if (c == '0') {\n            index++;\n        }\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int num = 0;\n    for (int i = 0; i < len; i++) {\n        char c = str.charAt(i);\n        if (c >= '0' && c <= '9') {\n            num = num * 10 + (c - '0');\n        } else {\n            return num;\n        }\n    }\n    return num;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int num = 0;\n    for (int i = 0; i < len; i++) {\n        char c = str.charAt(i);\n        if (c >= '0' && c <= '9') {\n            num = num * 10 + (c - '0');\n        } else {\n            return num;\n        }\n    }\n    return num;\n}\nprotected void _parseNumericValue(int expType) throws IOException {\n    if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n        int len = _intLength;\n        if (len <= 9) {\n            int i = _textBuffer.contentsAsInt(_numberNegative);\n            _numberInt = i;\n            _numTypesValid = NR_INT;\n            return;\n        }\n        if (len <= 18) {\n            long l = _textBuffer.contentsAsLong(_numberNegative);\n            if (len == 10) {\n                if (_numberNegative) {\n                    if (l >= MIN_INT_L) {\n                        _numberInt = (int) l;\n                        _numTypesValid = NR_INT;\n                        return;\n                    }\n                } else {\n                    if (l <= MAX_INT_L) {\n                        _numberInt = (int) l;\n                        _numTypesValid = NR_INT;\n                        return;\n                    }\n                }\n            }\n            _numberLong = l;\n            _numTypesValid = NR_LONG;\n            return;\n        }\n        if (NumberInput.inLongRange(_textBuffer.getTextBuffer(), _textBuffer.getTextOffset(), _intLength, _numberNegative)) {\n            _numberLong = Long.parseLong(_textBuffer.contentsAsString());\n            _numTypesValid = NR_LONG;\n        } else {\n            if ((expType == NR_INT) || (expType == NR_LONG)) {\n                _reportTooLongIntegral(expType, _textBuffer.contentsAsString());\n            }\n            if ((expType == NR_DOUBLE) || (expType == NR_FLOAT)) {\n                _numberDouble = NumberInput.parseDouble(_textBuffer.contentsAsString());\n                _numTypesValid = NR_DOUBLE;\n            } else {\n                _numberBigInt = new BigInteger(_textBuffer.contentsAsString());\n                _numTypesValid = NR_BIGINT;\n            }\n        }\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    int i = 0;\n    int len = str.length();\n    while (i < len) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return i;\n        }\n        i++;\n    }\n    return i;\n}\nprotected void _parseNumericValue(int expType) throws IOException {\n    if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n        int len = _intLength;\n        if (len <= 9) {\n            int i = _textBuffer.contentsAsInt(_numberNegative);\n            _numberInt = i;\n            _numTypesValid = NR_INT;\n            return;\n        }\n        if (len <= 18) {\n            long l = _textBuffer.contentsAsLong(_numberNegative);\n            if (len == 10) {\n                if (_numberNegative) {\n                    if (l >= MIN_INT_L) {\n                        _numberInt = (int) l;\n                        _numTypesValid = NR_INT;\n                        return;\n                    }\n                } else {\n                    if (l <= MAX_INT_L) {\n                        _numberInt = (int) l;\n                        _numTypesValid = NR_INT;\n                        return;\n                    }\n                }\n            }\n            _numberLong = l;\n            _numTypesValid = NR_LONG;\n            return;\n        }\n        _parseSlowInt(expType);\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int num = 0;\n    for (int i = 0; i < len; i++) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            break;\n        }\n        num = num * 10 + (c - '0');\n    }\n    return num;\n}",
      "private final static int _parseIndex(String str)  {\n    int i = 0;\n    int len = str.length();\n    while (i < len) {\n        char c = str.charAt(i);\n        if (c >= '0' && c <= '9') {\n            i++;\n        } else {\n            break;\n        }\n    }\n    return i;\n}\nprotected void _parseNumericValue(int expType) throws IOException {\n    if (_currToken == JsonToken.VALUE_NUMBER_INT) {\n        int len = _intLength;\n        if (len <= 9) {\n            int i = _textBuffer.contentsAsInt(_numberNegative);\n            _numberInt = i;\n            _numTypesValid = NR_INT;\n            return;\n        }\n        if (len <= 18) {\n            long l = _textBuffer.contentsAsLong(_numberNegative);\n            if (len == 10) {\n                if (_numberNegative) {\n                    if (l >= MIN_INT_L) {\n                        _numberInt = (int) l;\n                        _numTypesValid = NR_INT;\n                        return;\n                    }\n                } else {\n                    if (l <= MAX_INT_L) {\n                        _numberInt = (int) l;\n                        _numTypesValid = NR_INT;\n                        return;\n                    }\n                }\n            }\n            _numberLong = l;\n            _numTypesValid = NR_LONG;\n            return;\n        }\n        _parseSlowInt(expType);\n    }\n}\nprotected void _parseSlowInt(int expType) throws IOException {\n    String numStr = _textBuffer.contentsAsString();\n    try {\n        int len = _intLength;\n        char[] buf = _textBuffer.getTextBuffer();\n        int offset = _textBuffer.getTextOffset();\n        if (_numberNegative) {\n            ++offset;\n        }\n        if (NumberInput.inLongRange(buf, offset, len, _numberNegative)) {\n            _numberLong = Long.parseLong(numStr);\n            _numTypesValid = NR_LONG;\n        } else {\n            if ((expType == NR_INT) || (expType == NR_LONG)) {\n                _reportTooLongIntegral(expType, numStr);\n            }\n            if ((expType == NR_DOUBLE) || (expType == NR_FLOAT)) {\n                _numberDouble = NumberInput.parseDouble(numStr);\n                _numTypesValid = NR_DOUBLE;\n            } else {\n                _numberBigInt = new BigInteger(numStr);\n                _numTypesValid = NR_BIGINT;\n            }\n        }\n    } catch (NumberFormatException nex) {\n}\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int i = 0;\n    while (i < len) {\n        char c = str.charAt(i);\n        if (c == '0') {\n            if (i == len - 1) {\n                return 0;\n            }\n            i++;\n        } else if (c >= '1' && c <= '9') {\n            int num = c - '0';\n            while (i + 1 < len && str.charAt(i + 1) >= '0' && str.charAt(i + 1) <= '9') {\n                num = num * 10 + (str.charAt(i + 1) - '0');\n                i++;\n            }\n            return num;\n        } else {\n            break;\n        }\n    }\n    return -1;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int i = 0;\n    while (i < len) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            break;\n        }\n        i++;\n    }\n    return i;\n}",
      "private final static int _parseIndex(String str)  {\n    int index = str.indexOf('.');\n    if (index == -1) {\n        return str.length();\n    } else {\n        return index;\n    }\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    int i = 0;\n    int num = 0;\n    boolean negative = false;\n    char c;\n    if (str.charAt(0) == '-') {\n        negative = true;\n        i++;\n    }\n    while (i < len) {\n        c = str.charAt(i);\n        if (c >= '0' && c <= '9') {\n            num = num * 10 + (c - '0');\n        } else {\n            break;\n        }\n        i++;\n    }\n    return negative ? -num : num;\n}"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N, k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE, k);\n    }\n    int[] index = new int[c.size()];\n    for (int i = 0; i < c.size(); i++) {\n        index[i] = i;\n    }\n    MathArrays.shuffle(index, getRandomGenerator());\n    Object[] ret = new Object[k];\n    for (int i = 0; i < k; i++) {\n        ret[i] = c.toArray()[index[i]];\n    }\n    return ret;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N, k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE, k);\n    }\n    int[] index = new int[c.size()];\n    for (int i = 0; i < c.size(); i++) {\n        index[i] = i;\n    }\n    MathArrays.shuffle(index, getRandomGenerator());\n    Object[] ret = new Object[k];\n    for (int i = 0; i < k; i++) {\n        ret[i] = c.toArray()[index[i]];\n    }\n    return ret;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    if (k > n) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N, k, n, true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE, k);\n    }\n    return delegate.nextPermutation(n, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_COLLECTION_SIZE, k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE, k);\n    }\n    int[] index = new int[c.size()];\n    for (int i = 0; i < c.size(); i++) {\n        index[i] = i;\n    }\n    MathArrays.shuffle(index, getRandomGenerator());\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = c.toArray()[index[i]];\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    if (k > n) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N, k, n, true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE, k);\n    }\n    return new RandomDataGenerator().nextSample(n, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N, k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE, k);\n    }\n    int[] index = new int[c.size()];\n    for (int i = 0; i < c.size(); i++) {\n        index[i] = i;\n    }\n    MathArrays.shuffle(index, getRandomGenerator());\n    Object[] ret = new Object[k];\n    for (int i = 0; i < k; i++) {\n        ret[i] = c.toArray()[index[i]];\n    }\n    return ret;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    if (k > n) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N, k, n, true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE, k);\n    }\n    int[] index = new int[n];\n    for (int i = 0; i < n; i++) {\n        index[i] = i;\n    }\n    int[] permutation = nextPermutation(n, k);\n    Object[] sample = new Object[k];\n    for (int i = 0; i < k; i++) {\n        sample[i] = c.toArray()[permutation[i]];\n    }\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    int n = c.size();\n    if (k > n) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N, k, n, true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE, k);\n    }\n    return nextPermutation(n, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE, k);\n    }\n\n    int[] index = new int[c.size()];\n    for (int i = 0; i < c.size(); i++) {\n        index[i] = i;\n    }\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    Object[] ret = new Object[k];\n    for (int i = 0; i < k; i++) {\n        ret[i] = c.toArray()[index[i]];\n    }\n    return ret;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE, k);\n    }\n    return getRandomGenerator().nextPermutation(c.size(), k);\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Node(NodeType.METHOD_CALL);\n    callNode.addChild(methodName);\n    callNode.addChild(argumentNode);\n    if (srcref != null) {\n        callNode.addChild(srcref);\n    }\n    return callNode;\n}\n\n/**\n * Builds a property name based on the given local name and namespace.\n *\n * @param localName Local name of the property.\n * @param namespace Namespace of the property.\n * @return Property name.\n */\nprotected final PropertyName buildPropertyName(String localName, String namespace) {\n    if (localName.isEmpty()) {\n        return PropertyName.USE_DEFAULT;\n    }\n    if (namespace == null || namespace.isEmpty()) {\n        return PropertyName.construct(localName);\n    }\n    return PropertyName.construct(localName, namespace);\n}\n\n/**\n * Verifies that a method call has exactly one argument, and that it's a\n * string literal. Reports a compile error if it doesn't.\n *\n * @return Whether the argument checked out okay",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    // Create a new method call node\n    Node callNode = compiler.createMethodCallNode(methodName, argumentNode, srcref);\n\n    // Check if the method call is a define or provide method call\n    if (methodName.equals(\"provide\") || methodName.equals(\"define\")) {\n        // Verify the method call\n        if (methodName.equals(\"provide\")) {\n            verifyProvide(compiler, callNode, argumentNode);\n        } else {\n            verifyDefine(compiler, expr, callNode, argumentNode);\n        }\n    }\n\n    return callNode;\n}\n\n/**\n * Verifies that a method call has exactly one argument, and that it's a\n * string literal. Reports a compile error if it doesn't.\n *\n * @return Whether the argument checked out okay",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = new Node(NodeType.CALL);\n    callNode.setFirstChild(methodName);\n    callNode.addChildChild(argumentNode);\n    callNode.setSourceReference(srcref);\n    return callNode;\n}\n\n/**\n * Verifies that a method call has exactly one argument, and that it's a\n * string literal. Reports a compile error if it doesn't.\n *\n * @return Whether the argument checked out okay",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    // Create a new method call node\n    Node callNode = compiler.newNode(NodeType.METHOD_CALL);\n    // Set the method name\n    callNode.setStringProperty(Node.PROP_NAME, methodName);\n    // Set the argument\n    callNode.addChildNode(argumentNode);\n    // Set the source reference\n    callNode.setSourceReference(srcref);\n    return callNode;\n}\n\n/**\n * Builds a property name based on the given local name and namespace.\n *\n * @param localName Local name of the property.\n * @param namespace Namespace of the property.\n */\nprotected final PropertyName buildPropertyName(String localName, String namespace) {\n    if (localName.isEmpty()) {\n        return PropertyName.USE_DEFAULT;\n    }\n    if (namespace == null || namespace.isEmpty()) {\n        return PropertyName.construct(localName);\n    }\n    return PropertyName.construct(localName, namespace);\n}\n\n/**\n * Builds a property name based on the given method name,\n * argument and history.\n *\n * @param methodName Method to call.\n * @param argumentNode Method argument.\n */\nprotected final PropertyName buildPropertyName(String methodName, Node argumentNode) {\n    // Get the namespace and local name\n    String namespace = null;\n    String localName = null;\n    // Split the method name\n    String[] parts = methodName.split(\"\\\\.\");\n    // Get the namespace and local name\n    if (parts.length > 1) {\n        namespace = parts[0];\n        localName = parts[1];\n    } else {\n        localName = parts[0];\n    }\n    // Build the property name\n    return buildPropertyName(localName, namespace);\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = compiler.newNode(NodeTypes.CALL);\n    callNode.setMethod(methodName);\n    callNode.setArgument(argumentNode);\n    callNode.setSourceReference(srcref);\n    return callNode;\n}\n\n/**\n * Verifies that a method call has exactly one argument, and that it's a\n * string literal. Reports a compile error if it doesn't.\n *\n * @return Whether the argument checked out okay",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    // Create a new method call node\n    Node callNode = NodeUtil.createMethodCallNode(methodName, srcref);\n\n    // Add the argument to the method call node\n    callNode.addChild(argumentNode);\n\n    // Return the method call node\n    return callNode;\n}\n\n/**\n * Builds a property name based on the given local name and namespace.\n *\n * @param localName Local name of the property.\n * @param namespace Namespace of the property.\n */\nprotected final PropertyName buildPropertyName(String localName, String namespace) {\n    // Check if the local name is empty\n    if (localName.isEmpty()) {\n        // Return the default property name\n        return PropertyName.USE_DEFAULT;\n    }\n\n    // Check if the namespace is null or empty\n    if (namespace == null || namespace.isEmpty()) {\n        // Return the property name with the local name\n        return PropertyName.construct(localName);\n    }\n\n    // Return the property name with the local name and namespace\n    return PropertyName.construct(localName, namespace);\n}\n\n/**\n * Builds a property name based on the given method name, argument and history.\n *\n * @param methodName Method name.\n * @param argumentNode Method argument.\n * @param srcref Source reference.\n */\nprotected final Node buildPropertyName(String methodName, Node argumentNode, Node srcref) {\n    // Create a new property name node\n    Node propertyNameNode = NodeUtil.createPropertyNameNode(methodName, srcref);\n\n    // Add the argument to the property name node\n    propertyNameNode.addChild(argumentNode);\n\n    // Return the property name node\n    return propertyNameNode;\n}\n\n/**\n * Builds a method call based on the the given method name,\n * argument and history.\n *\n * @param methodName Method to call.\n * @param argumentNode Method argument.\n * @param srcref Source reference.\n */\nprotected final Node buildMethodCallNode(String methodName, Node argumentNode, Node srcref) {\n    // Create a new method call node\n    Node methodCallNode = NodeUtil.createMethodCallNode(methodName, srcref);\n\n    // Add the argument to the method call node\n    methodCallNode.addChild(argumentNode);\n\n    // Return the method call node\n    return methodCallNode;\n}\n\n/**\n * Builds a property name based on the given local name and namespace.\n *\n * @param localName Local name of the property.\n * @param namespace Namespace of the property.\n */",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    // Create a new method call node\n    Node callNode = compiler.createMethodCallNode(methodName, argumentNode, srcref);\n    // Add the method call node to the current node\n    parent.addChild(callNode);\n    return callNode;\n}\n\n/**\n * Verifies that a method call has exactly one argument, and that it's a\n * string literal. Reports a compile error if it doesn't.\n *\n * @return Whether the argument checked out okay",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    // Check if the method name is a valid property name\n    if (!NodeUtil.isValidPropertyName(methodName)) {\n        compiler.report(t.makeError(srcref, INVALID_METHOD_NAME_ERROR, methodName));\n        return null;\n    }\n\n    // Check if the method name is a valid property name\n    if (!verifyProvide(t, srcref, argumentNode)) {\n        return null;\n    }\n\n    // Check if the method name is a valid property name\n    if (!verifyDefine(t, srcref, argumentNode)) {\n        return null;\n    }\n\n    // Create a new method call node\n    Node callNode = compiler.newNode(NodeType.METHOD_CALL);\n    callNode.setStringValue(methodName);\n    callNode.addChild(NodeUtil.newStringNode(argumentNode.getString()));\n\n    return callNode;\n}\n\n/**\n * Verifies that a method call has exactly one argument, and that it's a\n * string literal. Reports a compile error if it doesn't.\n *\n * @return Whether the argument checked out okay",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = NodeUtil.createMethodCallNode(methodName, argumentNode, srcref);\n    if (!verifyDefine(getTraversal(), expr, callNode, argumentNode)) {\n        return null;\n    }\n    return callNode;\n}\n\n/**\n * Verifies that a define method call has exactly one argument,\n * and that it's a string literal and that the contents of the string are\n * valid JS tokens. Reports a compile error if it doesn't.\n *\n * @return Whether the argument checked out okay",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = NodeUtil.createMethodCallNode(methodName, argumentNode, srcref);\n    return callNode;\n}\n\n/**\n * Verifies that a method call has exactly one argument, and that it's a\n * string literal. Reports a compile error if it doesn't.\n *\n * @return Whether the argument checked out okay"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, (i1, i2) -> Double.compare(doubles[i1], doubles[i2]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, (i1, i2) -> Double.compare(doubles[i1], doubles[i2]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, (i1, i2) -> Double.compare(doubles[i1], doubles[i2]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, (i1, i2) -> Double.compare(doubles[i1], doubles[i2]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n    Arrays.sort(indices, (i1, i2) -> Double.compare(doubles[i1], doubles[i2]));\n    return indices;\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int[] indices = new int[doubles.length];\n    for (int i = 0; i < doubles.length; i++) {\n        indices[i] = i;\n    }\n}"
    ],
    [
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}\n\n/**\n * Returns the matrix T of the transform.\n * @return the T matrix",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}\n\n/**\n * Returns the matrix T of the transform.\n * @return the T matrix",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}\n\n/**\n * Returns the matrix T of the transform.\n * @return the T matrix",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) {\n        cachedQt = getQ().transpose();\n    }\n    return cachedQt;\n}\n\n/**\n * Returns the matrix T of the transform.\n * @return the T matrix"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    Comparable result = this.keyToGroupMap.get(key);\n    if (result == null) {\n        return this.defaultGroup;\n    }\n    return result;\n}",
      "public Comparable getGroup(Comparable key)  {\n    return this.keyToGroupMap.get(key);\n}",
      "public Comparable getGroup(Comparable key)  {\n    return keyToGroupMap.get(key);\n}",
      "public Comparable getGroup(Comparable key)  {\n    return keyToGroupMap.get(key);\n}",
      "public Comparable getGroup(Comparable key)  {\n    return this.keyToGroupMap.get(key);\n}",
      "public Comparable getGroup(Comparable key)  {\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) {\n        return this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    return this.keyToGroupMap.get(key);\n}",
      "public Comparable getGroup(Comparable key)  {\n    return this.keyToGroupMap.get(key);\n}",
      "public Comparable getGroup(Comparable key)  {\n    return this.keyToGroupMap.get(key);\n}",
      "public Comparable getGroup(Comparable key)  {\n    return keyToGroupMap.get(key);\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @throws NullPointerException if set or transformer is null\n     */\n    protected TransformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n        super(set, transformer);\n    }",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}\n\n/**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @throws NullPointerException if set or transformer is null\n     */\nprotected TransformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    super(set, transformer);\n}\n\n/**\n     * Gets the decorated set.\n     *\n     * @return the decorated set\n     */\n@Override\nprotected Set<E> decorated() {\n    return (Set<E>) super.decorated();\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @throws NullPointerException if set or transformer is null\n     */\n    protected TransformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n        super(set, transformer);\n    }",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}\n\n/**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @throws NullPointerException if set or transformer is null\n     */\nprotected TransformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    super(set, transformer);\n}\n\n/**\n     * Gets the decorated set.\n     *\n     * @return the decorated set\n     */\n@Override\nprotected Set<E> decorated() {\n    return (Set<E>) super.decorated();\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @throws NullPointerException if set or transformer is null\n     */\nprotected TransformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    super(set, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}\n\n/**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @throws NullPointerException if set or transformer is null\n     */\nprotected TransformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    super(set, transformer);\n}\n\n/**\n     * Gets the decorated set.\n     *\n     * @return the decorated set\n     */\n@Override\nprotected Set<E> decorated() {\n    return (Set<E>) super.decorated();\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}\n\n/**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @throws NullPointerException if set or transformer is null\n     */\nprotected TransformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    super(set, transformer);\n}\n\n/**\n     * Gets the decorated set.\n     *\n     * @return the decorated set\n     */\n@Override\nprotected Set<E> decorated() {\n    return (Set<E>) super.decorated();\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}\n\n/**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @throws NullPointerException if set or transformer is null\n     */\nprotected TransformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n    super(set, transformer);\n}\n\n/**\n     * Gets the decorated set.\n     *\n     * @return the decorated set\n     */\n@Override\nprotected Set<E> decorated() {\n    return (Set<E>) super.decorated();\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @throws NullPointerException if set or transformer is null\n     */\n    protected TransformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n        super(set, transformer);\n    }",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    return new TransformedSet<E>(set, transformer);\n}\n\n    /**\n     * Constructor that wraps (not copies).\n     * <p>\n     * If there are any elements already in the set being decorated, they\n     * are NOT transformed.\n     *\n     * @param set  the set to decorate, must not be null\n     * @param transformer  the transformer to use for conversion, must not be null\n     * @throws NullPointerException if set or transformer is null\n     */\n    protected TransformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n        super(set, transformer);\n    }"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final int newCapacity = buffer.length * 2;\n        if (newCapacity < capacity) {\n            newCapacity = capacity;\n        }\n        buffer = Arrays.copyOf(buffer, newCapacity);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] newBuffer = new char[capacity];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final int newCapacity = Math.max(capacity, buffer.length * 2);\n        buffer = Arrays.copyOf(buffer, newCapacity);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        buffer = Arrays.copyOf(buffer, capacity);\n    }\n    return this;\n}\n\n/**\n     * Validates the index.\n     *\n     * @param index  the index to validate\n     * @throws IndexOutOfBoundsException if the index is invalid",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final int newCapacity = buffer.length * 2;\n        if (newCapacity < capacity) {\n            newCapacity = capacity;\n        }\n        buffer = Arrays.copyOf(buffer, newCapacity);\n    }\n    return this;\n}\n\n/**\n     * Validates the index for the specified operation.\n     *\n     * @param index  the index to validate\n     * @throws IndexOutOfBoundsException if the index is invalid",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final int newCapacity = (buffer.length * 2) + 1;\n        if (newCapacity < capacity) {\n            newCapacity = capacity;\n        }\n        buffer = Arrays.copyOf(buffer, newCapacity);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final int newCapacity = (buffer.length * 3) / 2 + 1;\n        if (newCapacity < capacity) {\n            newCapacity = capacity;\n        }\n        buffer = Arrays.copyOf(buffer, newCapacity);\n    }\n    return this;\n}\n\n/**\n     * Validates the index and throws an exception if it is invalid.\n     *\n     * @param index  the index to validate\n     * @throws IndexOutOfBoundsException if the index is invalid",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final int newCapacity = buffer.length * 2;\n        if (newCapacity < capacity) {\n            newCapacity = capacity;\n        }\n        buffer = Arrays.copyOf(buffer, newCapacity);\n    }\n    return this;\n}\n\n/**\n     * Validates the index and throws an exception if it is invalid.\n     *\n     * @param index  the index to validate\n     * @throws IndexOutOfBoundsException if the index is invalid",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final char[] newBuffer = new char[capacity];\n        System.arraycopy(buffer, 0, newBuffer, 0, size);\n        buffer = newBuffer;\n    }\n    return this;\n}\n\n/**\n     * Validates the index.\n     *\n     * @param index  the index to validate\n     * @throws IndexOutOfBoundsException if the index is invalid",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final int newCapacity = (buffer.length * 3) / 2 + 1;\n        if (newCapacity < capacity) {\n            newCapacity = capacity;\n        }\n        buffer = Arrays.copyOf(buffer, newCapacity);\n    }\n    return this;\n}\n\n/**\n     * Validates the index for the specified operation.\n     *\n     * @param index  the index to validate\n     * @throws IndexOutOfBoundsException if the index is invalid"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof CategoryRangeInfo) {\n        CategoryRangeInfo info = (CategoryRangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}\n\n/**\n * Iterates over the data items of the category dataset to find the range\n * bounds.\n *\n * @param dataset  the dataset (<code>null</code> not permitted).\n *\n * @return The range (possibly <code>null</code>).\n *\n * @since 1.0.10",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof CumulativeCategoryDataset) {\n        CumulativeCategoryDataset cumulativeDataset = (CumulativeCategoryDataset) dataset;\n        result = cumulativeDataset.getRangeBounds();\n    } else {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}\n\n/**\n * Iterates over the data item of the cumulative category dataset to find\n * the range bounds.\n *\n * @param dataset  the dataset (<code>null</code> not permitted).\n *\n * @return The range (possibly <code>null</code>).\n *\n * @since 1.0.10",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    return findRangeBounds(dataset, true);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    return findRangeBounds(dataset, true);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof CategoryRangeInfo) {\n        CategoryRangeInfo info = (CategoryRangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}\n\n/**\n * Iterates over the data item of the category dataset to find\n * the range bounds.\n *\n * @param dataset  the dataset (<code>null</code> not permitted).\n * @param includeInterval  a flag that determines whether or not the\n *                         y-interval is taken into account.\n *\n * @return The range (possibly <code>null</code>).\n *\n * @since 1.0.10",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof CategoryRangeInfo) {\n        CategoryRangeInfo info = (CategoryRangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}\n\n/**\n * Iterates over the data item of the category dataset to find\n * the range bounds.\n *\n * @param dataset  the dataset (<code>null</code> not permitted).\n * @param includeInterval  a flag that determines whether or not the\n *                         y-interval is taken into account.\n *\n * @return The range (possibly <code>null</code>).\n *\n * @since 1.0.10",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    return findRangeBounds(dataset, true);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    return findRangeBounds(dataset, true);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    if (dataset instanceof CategoryRangeInfo) {\n        CategoryRangeInfo info = (CategoryRangeInfo) dataset;\n        result = info.getRangeBounds(true);\n    }\n    else {\n        result = iterateCumulativeRangeBounds(dataset);\n    }\n    return result;\n}\n\n/**\n * Iterates over the data items of the category dataset to find the range\n * bounds for the cumulative values.\n *\n * @param dataset  the dataset (<code>null</code> not permitted).\n *\n * @return The range.",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    return findRangeBounds(dataset, true);\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n    }\n    int offset = 0;\n    try {\n        int hoursInMinutes = hoursOffset * 60;\n        if (hoursInMinutes < 0) {\n            minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n        } else {\n            minutesOffset = hoursInMinutes + minutesOffset;\n        }\n        offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n    } catch (ArithmeticException ex) {\n        throw new IllegalArgumentException(\"Offset is too large\");\n    }\n    return forOffsetMillis(offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n    }\n    int offset = 0;\n    try {\n        int hoursInMinutes = hoursOffset * 60;\n        if (hoursInMinutes < 0) {\n            minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n        } else {\n            minutesOffset = hoursInMinutes + minutesOffset;\n        }\n        offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n    } catch (ArithmeticException ex) {\n        throw new IllegalArgumentException(\"Offset is too large\");\n    }\n    return forOffsetMillis(offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n    }\n    int offset = 0;\n    try {\n        int hoursInMinutes = hoursOffset * 60;\n        if (hoursInMinutes < 0) {\n            minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n        } else {\n            minutesOffset = hoursInMinutes + minutesOffset;\n        }\n        offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n    } catch (ArithmeticException ex) {\n        throw new IllegalArgumentException(\"Offset is too large\");\n    }\n    return forOffsetMillis(offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n    }\n    int offset = 0;\n    try {\n        int hoursInMinutes = hoursOffset * 60;\n        if (hoursInMinutes < 0) {\n            minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n        } else {\n            minutesOffset = hoursInMinutes + minutesOffset;\n        }\n        offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n    } catch (ArithmeticException ex) {\n        throw new IllegalArgumentException(\"Offset is too large\");\n    }\n    return forOffsetMillis(offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n    }\n    int offset = 0;\n    try {\n        int hoursInMinutes = hoursOffset * 60;\n        if (hoursInMinutes < 0) {\n            minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n        } else {\n            minutesOffset = hoursInMinutes + minutesOffset;\n        }\n        offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n    } catch (ArithmeticException ex) {\n        throw new IllegalArgumentException(\"Offset is too large\");\n    }\n    return forOffsetMillis(offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n    }\n    int offset = 0;\n    try {\n        int hoursInMinutes = hoursOffset * 60;\n        if (hoursInMinutes < 0) {\n            minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n        } else {\n            minutesOffset = hoursInMinutes + minutesOffset;\n        }\n        offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n    } catch (ArithmeticException ex) {\n        throw new IllegalArgumentException(\"Offset is too large\");\n    }\n    return forOffsetMillis(offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n    }\n    int offset = 0;\n    try {\n        int hoursInMinutes = hoursOffset * 60;\n        if (hoursInMinutes < 0) {\n            minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n        } else {\n            minutesOffset = hoursInMinutes + minutesOffset;\n        }\n        offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n    } catch (ArithmeticException ex) {\n        throw new IllegalArgumentException(\"Offset is too large\");\n    }\n    return forOffsetMillis(offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n    }\n    int offset = 0;\n    try {\n        int hoursInMinutes = hoursOffset * 60;\n        if (hoursInMinutes < 0) {\n            minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n        } else {\n            minutesOffset = hoursInMinutes + minutesOffset;\n        }\n        offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n    } catch (ArithmeticException ex) {\n        throw new IllegalArgumentException(\"Offset is too large\");\n    }\n    return forOffsetMillis(offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n    }\n    int offset = 0;\n    try {\n        int hoursInMinutes = hoursOffset * 60;\n        if (hoursInMinutes < 0) {\n            minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n        } else {\n            minutesOffset = hoursInMinutes + minutesOffset;\n        }\n        offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n    } catch (ArithmeticException ex) {\n        throw new IllegalArgumentException(\"Offset is too large\");\n    }\n    return forOffsetMillis(offset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset > 23 || hoursOffset < -23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset > 59 || minutesOffset < -59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset);\n    }\n    int offset = 0;\n    try {\n        int hoursInMinutes = hoursOffset * 60;\n        if (hoursInMinutes < 0) {\n            minutesOffset = hoursInMinutes - Math.abs(minutesOffset);\n        } else {\n            minutesOffset = hoursInMinutes + minutesOffset;\n        }\n        offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n    } catch (ArithmeticException ex) {\n        throw new IllegalArgumentException(\"Offset is too large\");\n    }\n    return forOffsetMillis(offset);\n}"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n    do {\n        if (isEmpty()) break;\n        Character c = consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals('\\'') && c != open && !inDoubleQuote)\n                inSingleQuote = !inSingleQuote;\n            else if (c.equals('\"') && c != open && !inSingleQuote)\n                inDoubleQuote = !inDoubleQuote;\n            if (inSingleQuote || inDoubleQuote)\n                continue;\n\n            if (c.equals(open)) {\n                depth++;\n                if (start == -1)\n                    start = pos;\n            }\n            else if (c.equals(close))\n                depth--;\n        }\n\n        if (depth > 0 && last != 0)\n            end = pos; // don't include the outer match pair in the return\n        last = c;\n    } while (depth > 0);\n    final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n    if (depth > 0) {// ran out of queue before seeing enough )\n        Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n    }\n    return out;\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = -1;\n    int depth = 0;\n    int last = 0;\n    do {\n        if (isEmpty()) break;\n        Character c = consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals(open)) {\n                depth++;\n                if (start == -1)\n                    start = pos;\n            }\n            else if (c.equals(close))\n                depth--;\n        }\n\n        if (depth > 0 && last != 0)\n            last = c;\n    } while (depth > 0);\n    final String out = (start >= 0) ? queue.substring(start, pos) : \"\";\n    if (depth > 0) {\n        Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n    }\n    return out;\n}\n\n/**\n     * Unescape a \\ escaped string.\n     * @param in backslash escaped string\n     * @return unescaped string",
      "public String chompBalanced(char open, char close)  {\n    do {\n        if (isEmpty()) break;\n        Character c = consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals('\\'') && c != open && !inDoubleQuote)\n                inSingleQuote = !inSingleQuote;\n            else if (c.equals('\"') && c != open && !inSingleQuote)\n                inDoubleQuote = !inDoubleQuote;\n            if (inSingleQuote || inDoubleQuote)\n                continue;\n\n            if (c.equals(open)) {\n                depth++;\n                if (start == -1)\n                    start = pos;\n            }\n            else if (c.equals(close))\n                depth--;\n        }\n\n        if (depth > 0 && last != 0)\n            end = pos; // don't include the outer match pair in the return\n        last = c;\n    } while (depth > 0);\n    final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n    if (depth > 0) {// ran out of queue before seeing enough )\n        Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n    }\n    return out;\n}",
      "public String chompBalanced(char open, char close)  {\n    do {\n        if (isEmpty()) break;\n        Character c = consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals('\\'') && c != open && !inDoubleQuote)\n                inSingleQuote = !inSingleQuote;\n            else if (c.equals('\"') && c != open && !inSingleQuote)\n                inDoubleQuote = !inDoubleQuote;\n            if (inSingleQuote || inDoubleQuote)\n                continue;\n\n            if (c.equals(open)) {\n                depth++;\n                if (start == -1)\n                    start = pos;\n            }\n            else if (c.equals(close))\n                depth--;\n        }\n\n        if (depth > 0 && last != 0)\n            end = pos; // don't include the outer match pair in the return\n        last = c;\n    } while (depth > 0);\n    final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n    if (depth > 0) {// ran out of queue before seeing enough )\n        Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n    }\n    return out;\n}",
      "public String chompBalanced(char open, char close)  {\n    do {\n        if (isEmpty()) break;\n        Character c = consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals('\\'') && c != open && !inDoubleQuote)\n                inSingleQuote = !inSingleQuote;\n            else if (c.equals('\"') && c != open && !inSingleQuote)\n                inDoubleQuote = !inDoubleQuote;\n            if (inSingleQuote || inDoubleQuote)\n                continue;\n\n            if (c.equals(open)) {\n                depth++;\n                if (start == -1)\n                    start = pos;\n            }\n            else if (c.equals(close))\n                depth--;\n        }\n\n        if (depth > 0 && last != 0)\n            end = pos; // don't include the outer match pair in the return\n        last = c;\n    } while (depth > 0);\n    final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n    if (depth > 0) {// ran out of queue before seeing enough )\n        Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n    }\n    return out;\n}",
      "public String chompBalanced(char open, char close)  {\n    do {\n        if (isEmpty()) break;\n        Character c = consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals('\\'') && c != open && !inDoubleQuote)\n                inSingleQuote = !inSingleQuote;\n            else if (c.equals('\"') && c != open && !inSingleQuote)\n                inDoubleQuote = !inDoubleQuote;\n            if (inSingleQuote || inDoubleQuote)\n                continue;\n\n            if (c.equals(open)) {\n                depth++;\n                if (start == -1)\n                    start = pos;\n            }\n            else if (c.equals(close))\n                depth--;\n        }\n\n        if (depth > 0 && last != 0)\n            end = pos; // don't include the outer match pair in the return\n        last = c;\n    } while (depth > 0);\n    final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n    if (depth > 0) {// ran out of queue before seeing enough )\n        Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n    }\n    return out;\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = -1;\n    int depth = 0;\n    int last = 0;\n    do {\n        if (isEmpty()) break;\n        Character c = consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals(open)) {\n                depth++;\n                if (start == -1)\n                    start = pos;\n            }\n            else if (c.equals(close))\n                depth--;\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        }\n    } while (depth > 0);\n    final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n    if (depth > 0) {// ran out of queue before seeing enough )\n        Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n    }\n    return out;\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = -1;\n    int depth = 0;\n    int last = 0;\n    do {\n        if (isEmpty()) break;\n        Character c = consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals('\\'') && c != open && !inDoubleQuote)\n                inSingleQuote = !inSingleQuote;\n            else if (c.equals('\"') && c != open && !inSingleQuote)\n                inDoubleQuote = !inDoubleQuote;\n            if (inSingleQuote || inDoubleQuote)\n                continue;\n\n            if (c.equals(open)) {\n                depth++;\n                if (start == -1)\n                    start = pos;\n            }\n            else if (c.equals(close))\n                depth--;\n        }\n\n        if (depth > 0 && last != 0)\n            end = pos; // don't include the outer match pair in the return\n        last = c;\n    } while (depth > 0);\n    final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n    if (depth > 0) {// ran out of queue before seeing enough )\n        Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n    }\n    return out;\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = -1;\n    int depth = 0;\n    int last = 0;\n    do {\n        if (isEmpty()) break;\n        Character c = consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals('\\'') && c != open && !inDoubleQuote)\n                inSingleQuote = !inSingleQuote;\n            else if (c.equals('\"') && c != open && !inSingleQuote)\n                inDoubleQuote = !inDoubleQuote;\n            if (inSingleQuote || inDoubleQuote)\n                continue;\n\n            if (c.equals(open)) {\n                depth++;\n                if (start == -1)\n                    start = pos;\n            }\n            else if (c.equals(close))\n                depth--;\n        }\n\n        if (depth > 0 && last != 0)\n            end = pos; // don't include the outer match pair in the return\n        last = c;\n    } while (depth > 0);\n    final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n    if (depth > 0) {// ran out of queue before seeing enough )\n        Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n    }\n    return out;\n}",
      "public String chompBalanced(char open, char close)  {\n    int start = -1;\n    int depth = 0;\n    int last = 0;\n    do {\n        if (isEmpty()) break;\n        Character c = consume();\n        if (last == 0 || last != ESC) {\n            if (c.equals(open)) {\n                depth++;\n                if (start == -1)\n                    start = pos;\n            }\n            else if (c.equals(close))\n                depth--;\n            if (depth > 0 && last != 0)\n                end = pos; // don't include the outer match pair in the return\n            last = c;\n        }\n    } while (depth > 0);\n    final String out = (end >= 0) ? queue.substring(start, end) : \"\";\n    if (depth > 0) {// ran out of queue before seeing enough )\n        Validate.fail(\"Did not find balanced marker at '\" + out + \"'\");\n    }\n    return out;\n}"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int n = realEigenvalues.length;\n        final int p = beta.length;\n        final double[][] R = new double[n][n];\n        final double[] RDiag = new double[n];\n        final double[][] Q = new double[n][p];\n        final double[] QDiag = new double[p];\n        int k = 0;\n        for (int i = 0; i < n; i++) {\n            if (realEigenvalues[i] > 0) {\n                for (int j = 0; j < p; j++) {\n                    Q[i][j] = eigenvectors[i].getEntry(j);\n                }\n                RDiag[k] = realEigenvalues[i];\n                k++;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                R[i][j] = 0;\n                for (int k = 0; k < p; k++) {\n                    R[i][j] += Q[i][k] * Q[j][k];\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            R[i][i] = RDiag[i];\n        }\n        final RealMatrix RMat = new Array2DRowRealMatrix(R, false);\n        final RealMatrix QMat = new Array2DRowRealMatrix(Q, false);\n        final RealMatrix QTRMat = QMat.transpose().multiply(RMat).multiply(QMat);\n        final RealMatrix QTRInvMat = QTRMat.inverse();\n        final RealMatrix QTRInvQMat = QMat.transpose().multiply(QTRInvMat);\n        final RealMatrix betaVariance = QTRInvQMat;\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        int m = data.length;\n        int n = data[0].length;\n        int p = beta.length;\n        double[][] X = new double[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                X[i][j] = data[i][j];\n            }\n        }\n        // QR decomposition\n        QRDecomposition qr = new QRDecomposition(new Array2DRowRealMatrix(X));\n        RealMatrix R = qr.getR();\n        int k = Math.min(p, n);\n        RealMatrix Rinv = R.copy();\n        for (int i = 0; i < k; i++) {\n            Rinv.setEntry(i, i, 1 / R.getEntry(i, i));\n        }\n        return Rinv;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int n = data.length;\n        final int p = beta.length;\n        final double[][] x = new double[n][p];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < p; j++) {\n                x[i][j] = data[i][j];\n            }\n        }\n        final RealMatrix xMatrix = new Array2DRowRealMatrix(x);\n        final RealMatrix xTx = xMatrix.transpose().multiply(xMatrix);\n        final RealMatrix xTxInv = xTx.solve(new Array2DRowRealMatrix(p, p));\n        return xTxInv;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        if (X == null) {\n            throw new NullArgumentException(\"X\");\n        }\n        if (beta == null) {\n            throw new NullArgumentException(\"beta\");\n        }\n        if (p == null) {\n            throw new NullArgumentException(\"p\");\n        }\n        if (n == null) {\n            throw new NullArgumentException(\"n\");\n        }\n        if (k == null) {\n            throw new NullArgumentException(\"k\");\n        }\n        if (X.getRowDimension() != n) {\n            throw new DimensionMismatchException(X.getRowDimension(), n);\n        }\n        if (X.getColumnDimension() != k) {\n            throw new DimensionMismatchException(X.getColumnDimension(), k);\n        }\n        if (beta.length != p) {\n            throw new DimensionMismatchException(beta.length, p);\n        }\n        if (p > k) {\n            throw new OutOfRangeException(p, k);\n        }\n        if (n < p) {\n            throw new NumberIsTooSmallException(n, p);\n        }\n        if (k < p) {\n            throw new NumberIsTooSmallException(k, p);\n        }\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(p);\n        }\n        if (n <= 0) {\n            throw new NotStrictlyPositiveException(n);\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(k);\n        }\n        if (p > n) {\n            throw new OutOfRangeException(p, n);\n        }\n        if (p > k) {\n            throw new OutOfRangeException(p, k);\n        }\n        if (n < k) {\n            throw new NumberIsTooSmallException(n, k);\n        }\n        if (k < n) {\n            throw new NumberIsTooSmallException(k, n);\n        }\n        if (p <= 0) {\n            throw new NotStrictlyPositiveException(p);\n        }\n        if (n <= 0) {\n            throw new NotStrictlyPositiveException(n);\n        }\n        if (k <= 0) {\n            throw new NotStrictlyPositiveException(k);\n        }\n        if (p > n) {\n            throw new OutOfRangeException(p, n);\n        }\n        if (p > k) {\n            throw new OutOfRangeException(p, k);\n        }\n        if (n < k) {\n            throw new NumberIsTooSmallException(n, k);\n        }\n}",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        if (X == null) {\n            throw new NullArgumentException(\"X\");\n        }\n        if (y == null) {\n            throw new NullArgumentException(\"y\");\n        }\n        if (beta == null) {\n            throw new NullArgumentException(\"beta\");\n        }\n\n        final int n = X.getRowDimension();\n        final int p = beta.getDimension();\n        final RealMatrix XTX = X.transpose().multiply(X);\n        final RealMatrix R = XTX.solve(new Array2DRowRealMatrix(p, p));\n        final RealMatrix RTR = R.transpose().multiply(R);\n        final RealMatrix betaVariance = RTR.copy();\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        if (beta == null) {\n            throw new NullArgumentException(\"beta\");\n        }\n\n        if (X == null) {\n            throw new NullArgumentException(\"X\");\n        }\n\n        int m = X.getRowDimension();\n        int n = X.getColumnDimension();\n\n        if (beta.length != n) {\n            throw new DimensionMismatchException(beta.length, n);\n        }\n\n        // Calculate the QR decomposition of X\n        QRDecomposition qr = new QRDecomposition(X);\n        RealMatrix R = qr.getR();\n\n        // Calculate the top p rows of R\n        int p = beta.length;\n        RealMatrix Rtop = R.getSubMatrix(0, p - 1, 0, n - 1);\n\n        // Calculate the inverse of Rtop\n        RealMatrix Rinv = Rtop.copy();\n        Rinv = Rinv.inverse();\n\n        // Calculate the variance-covariance matrix of beta\n        RealMatrix betaVariance = Rinv.copy();\n        betaVariance = betaVariance.multiply(Rinv.transpose());\n\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int n = data[0].length;\n        final int p = beta.length;\n        final Array2DRowRealMatrix XTX = new Array2DRowRealMatrix(n, n);\n        final ArrayRealVector betaVec = new ArrayRealVector(beta);\n        final ArrayRealVector XTXbeta = new ArrayRealVector(p);\n        final ArrayRealVector residuals = new ArrayRealVector(n);\n        final ArrayRealVector XTXbetaVec = new ArrayRealVector(p);\n\n        // Calculate XTX\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                XTX.setEntry(i, j, 0);\n                for (int k = 0; k < n; k++) {\n                    XTX.setEntry(i, j, XTX.getEntry(i, j) + data[k][i] * data[k][j]);\n                }\n            }\n        }\n\n        // Calculate XTXbeta\n        for (int i = 0; i < p; i++) {\n            XTXbeta.setEntry(i, 0);\n            for (int j = 0; j < n; j++) {\n                XTXbeta.setEntry(i, 0, XTXbeta.getEntry(i, 0) + data[j][i] * beta[i]);\n            }\n        }\n\n        // Calculate residuals\n        for (int i = 0; i < n; i++) {\n            residuals.setEntry(i, 0);\n            for (int j = 0; j < p; j++) {\n                residuals.setEntry(i, 0, residuals.getEntry(i, 0) + data[i][j] * beta[j]);\n            }\n        }\n\n        // Calculate XTXbetaVec\n        for (int i = 0; i < p; i++) {\n            XTXbetaVec.setEntry(i, 0);\n            for (int j = 0; j < n; j++) {\n                XTXbetaVec.setEntry(i, 0, XTXbetaVec.getEntry(i, 0) + data[j][i] * residuals.getEntry(j, 0));\n            }\n        }\n\n        // Calculate betaVariance\n        final Array2DRowRealMatrix betaVariance = new Array2DRowRealMatrix(p, p);\n        for (int i = 0; i < p; i++) {\n            for (int j = 0;\n}\n}",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        final int n = data[0].length;\n        final int p = beta.length;\n        final RealMatrix XTX = calculateXTX();\n        final RealMatrix R = calculateR();\n        final RealMatrix RTR = R.transpose().multiply(R);\n        final RealMatrix betaVariance = RTR.copy();\n        for (int i = 0; i < p; i++) {\n            for (int j = i; j < p; j++) {\n                betaVariance.setEntry(i, j, betaVariance.getEntry(i, j) / RTR.getEntry(i, i));\n            }\n        }\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        int n = data.length;\n        int p = beta.length;\n        double[][] X = new double[n][p];\n        double[][] Q = new double[n][n];\n        double[][] R = new double[p][p];\n        double[] b = new double[p];\n        double[] r = new double[p];\n        double[] q = new double[n];\n        double[] temp = new double[n];\n        double[] temp2 = new double[p];\n        double[] temp3 = new double[p];\n        double[] temp4 = new double[p];\n        double[] temp5 = new double[p];\n        double[] temp6 = new double[p];\n        double[] temp7 = new double[p];\n        double[] temp8 = new double[p];\n        double[] temp9 = new double[p];\n        double[] temp10 = new double[p];\n        double[] temp11 = new double[p];\n        double[] temp12 = new double[p];\n        double[] temp13 = new double[p];\n        double[] temp14 = new double[p];\n        double[] temp15 = new double[p];\n        double[] temp16 = new double[p];\n        double[] temp17 = new double[p];\n        double[] temp18 = new double[p];\n        double[] temp19 = new double[p];\n        double[] temp20 = new double[p];\n        double[] temp21 = new double[p];\n        double[] temp22 = new double[p];\n        double[] temp23 = new double[p];\n        double[] temp24 = new double[p];\n        double[] temp25 = new double[p];\n        double[] temp26 = new double[p];\n        double[] temp27 = new double[p];\n        double[] temp28 = new double[p];\n        double[] temp29 = new double[p];\n        double[] temp30 = new double[p];\n        double[] temp31 = new double[p];\n        double[] temp32 = new double[p];\n        double[] temp33 = new double[p];\n        double[] temp34 = new double[p];\n        double[] temp35 = new double[p];\n        double[] temp36 = new double[p];\n        double[] temp37 = new double[p];\n        double[] temp38 = new double[p];\n        double[] temp39 = new double[p];\n        double[] temp40 = new double[p];\n        double[] temp41 = new double[p];\n        double[] temp42 = new double[p];\n        double[] temp43 = new double[p];\n}",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        int m = realEigenvalues.length;\n        int nColB = b.getRowDimension();\n        double[][] bp = new double[m][nColB];\n        double[] tmpCol = new double[m];\n        for (int k = 0; k < nColB; ++k) {\n            for (int i = 0; i < m; ++i) {\n                tmpCol[i] = b.getEntry(i, k);\n                bp[i][k] = 0;\n            }\n            for (int i = 0; i < m; ++i) {\n                final ArrayRealVector v = eigenvectors[i];\n                final double[] vData = v.getDataRef();\n                double s = 0;\n                for (int j = 0; j < m; ++j) {\n                    s += v.getEntry(j) * tmpCol[j];\n                }\n                s /= realEigenvalues[i];\n                for (int j = 0; j < m; ++j) {\n                    bp[j][k] += s * vData[j];\n                }\n            }\n        }\n        return new Array2DRowRealMatrix(bp, false);\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n    StringBuffer buf = new StringBuffer();\n    int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n    buf.append(':');\n    FormatUtils.appendPaddedInteger(buf, seconds, 2);\n    offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n    if (offset == 0) {\n        return buf.toString();\n    }\n\n    buf.append('.');\n    FormatUtils.appendPaddedInteger(buf, offset, 3);\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n    if (seconds == 0) {\n        return \"+\" + offset / DateTimeConstants.MILLIS_PER_MINUTE + \":\" + (offset % DateTimeConstants.MILLIS_PER_MINUTE) / DateTimeConstants.MILLIS_PER_SECOND + \"00\";\n    }\n    if (seconds < 0) {\n        return \"-\" + offset / DateTimeConstants.MILLIS_PER_MINUTE + \":\" + (offset % DateTimeConstants.MILLIS_PER_MINUTE) / DateTimeConstants.MILLIS_PER_SECOND + \"00\";\n    }\n    return \"+\" + offset / DateTimeConstants.MILLIS_PER_MINUTE + \":\" + (offset % DateTimeConstants.MILLIS_PER_MINUTE) / DateTimeConstants.MILLIS_PER_SECOND + \"00\";\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    if (offset < 0) {\n        return \"GMT-\" + formatOffset(-offset);\n    } else {\n        return \"GMT+\" + formatOffset(offset);\n    }\n}",
      "private static String printOffset(int offset)  {\n    int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n    StringBuilder buf = new StringBuilder();\n    buf.append(':');\n    FormatUtils.appendPaddedInteger(buf, seconds, 2);\n    offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n    if (offset == 0) {\n        return buf.toString();\n    }\n\n    buf.append('.');\n    FormatUtils.appendPaddedInteger(buf, offset, 3);\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n    int minutes = seconds / 60;\n    int hours = minutes / 60;\n    if (hours > 0) {\n        return hours + \":\" + FormatUtils.padLeft(Integer.toString(minutes % 60), 2, '0') + \":\" + FormatUtils.padLeft(Integer.toString(seconds % 60), 2, '0');\n    } else if (minutes > 0) {\n        return \"0\" + FormatUtils.padLeft(Integer.toString(minutes), 2, '0') + \":\" + FormatUtils.padLeft(Integer.toString(seconds % 60), 2, '0');\n    } else {\n        return \"0\" + FormatUtils.padLeft(Integer.toString(seconds), 2, '0');\n    }\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n    if (seconds == 0) {\n        return \"+\" + offset / DateTimeConstants.MILLIS_PER_MINUTE + \":\" + (offset % DateTimeConstants.MILLIS_PER_MINUTE) / DateTimeConstants.MILLIS_PER_SECOND + \"00\";\n    } else if (seconds < 0) {\n        return \"-\" + offset / DateTimeConstants.MILLIS_PER_MINUTE + \":\" + (offset % DateTimeConstants.MILLIS_PER_MINUTE) / DateTimeConstants.MILLIS_PER_SECOND + \"00\";\n    } else {\n        return \"+\" + offset / DateTimeConstants.MILLIS_PER_MINUTE + \":\" + (offset % DateTimeConstants.MILLIS_PER_MINUTE) / DateTimeConstants.MILLIS_PER_SECOND + \"00\";\n    }\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) {\n        return \"Z\";\n    }\n    if (offset > 0) {\n        return \"+\" + formatOffset(offset);\n    } else {\n        return \"-\" + formatOffset(-offset);\n    }\n}",
      "private static String printOffset(int offset)  {\n    StringBuffer buf = new StringBuffer();\n    int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n    buf.append(':');\n    FormatUtils.appendPaddedInteger(buf, seconds, 2);\n    offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n    if (offset == 0) {\n        return buf.toString();\n    }\n\n    buf.append('.');\n    FormatUtils.appendPaddedInteger(buf, offset, 3);\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    StringBuffer buf = new StringBuffer();\n    int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n    buf.append(':');\n    FormatUtils.appendPaddedInteger(buf, seconds, 2);\n    offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\n    if (offset == 0) {\n        return buf.toString();\n    }\n\n    buf.append('.');\n    FormatUtils.appendPaddedInteger(buf, offset, 3);\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\n    int minutes = seconds / 60;\n    int hours = minutes / 60;\n    minutes %= 60;\n    seconds %= 60;\n\n    StringBuilder buf = new StringBuilder();\n    if (hours != 0) {\n        buf.append(hours);\n        buf.append(':');\n    }\n    if (minutes != 0 || hours != 0) {\n        buf.append(minutes);\n        buf.append(':');\n    }\n    if (seconds != 0) {\n        buf.append(seconds);\n    }\n    return buf.toString();\n}"
    ],
    [
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.rowKeys.indexOf(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.rowKeys.indexOf(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.rowKeys.indexOf(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.rowKeys.indexOf(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.rowKeys.indexOf(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.rowKeys.indexOf(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.rowKeys.indexOf(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.rowKeys.indexOf(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.rowKeys.indexOf(key);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.rowKeys.indexOf(key);\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    return new HashMap<>();\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    return null;\n}\n\n/**\n * A static slot that can be used in a linked list.",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> myFlowSlots = new HashMap<>();\n    // Your code here\n    return myFlowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    return new HashMap<>();\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> myFlowSlots = new HashMap<>();\n    // add code here\n    return myFlowSlots;\n}\n\n/**\n   * Determines whether two slots are meaningfully different for the\n   * purposes of data flow analysis.",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> myFlowSlots = new HashMap<>();\n    // add your code here\n    return myFlowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    return new HashMap<>();\n}\n\n/**\n * Determines whether two slots are meaningfully different for the\n * purposes of data flow analysis.",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    return null;\n}\n\n/**\n * A static slot that can be used in a linked list.",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> myFlowSlots = new HashMap<>();\n    // code here\n    return myFlowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> myFlowSlots = new HashMap<>();\n    // add code here\n    return myFlowSlots;\n}"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    RealMatrix m = new Array2DRowRealMatrix(columnData, true);\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}\n\n/**\n * Create a new RealMatrix with the supplied row and column dimensions.\n *\n * @param rowDimension  the number of rows in the new matrix\n * @param columnDimension  the number of columns in the new matrix\n * @throws NotStrictlyPositiveException if row or column dimension is not positive",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    RealMatrix out = new Array2DRowRealMatrix(columnData, true);\n    return out;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ELEMENT);\n    }\n    RealMatrix out = new Array2DRowRealMatrix(new double[][]{columnData}, true);\n    return out;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}\n\n/**\n * Create a new RealMatrix with the supplied row and column dimensions.\n *\n * @param rowDimension  the number of rows in the new matrix\n * @param columnDimension  the number of columns in the new matrix\n * @throws NotStrictlyPositiveException if row or column dimension is not positive",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    if (columnData.length == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    RealMatrix m = new Array2DRowRealMatrix(new double[][]{columnData}, false);\n    return m;\n}"
    ],
    [
      "public static double atanh(double a)  {\n    if (a > 1.0 || a < -1.0) {\n        throw new ArithmeticException(\"Argument out of range\");\n    }\n    double result;\n    if (a >= 0.5) {\n        double hiPrec[] = new double[2];\n        expm1(a*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 1.0 + ya;\n        double db = -(da - 1.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    } else {\n        double hiPrec[] = new double[2];\n        expm1(a*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        double temp = ya * HEX_40000000;\n        double yaa = ya + temp - temp;\n        double yab = ya - yaa;\n\n        // recip = 1/y\n        double recip = 1.0/ya;\n        temp = recip * HEX_40000000;\n        double recipa = recip + temp - temp;\n        double recipb = recip - recipa;\n\n        // Correct for rounding in division\n}\n}",
      "public static double atanh(double a)  {\n    if (a >= 1.0) {\n        return Math.log(a + FastMath.sqrt(a * a - 1.0));\n    } else if (a <= -1.0) {\n        return -Math.log(-a + FastMath.sqrt(a * a - 1.0));\n    } else {\n        double hiPrec[] = new double[2];\n        expm1(a, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        double temp = ya * HEX_40000000;\n        double yaa = ya + temp - temp;\n        double yab = ya - yaa;\n\n        // recip = 1/y\n        double recip = 1.0/ya;\n        temp = recip * HEX_40000000;\n        double recipa = recip + temp - temp;\n        double recipb = recip - recipa;\n\n        // Correct for rounding in division\n        recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n        // Account for yb\n        recipb += -yb * recip * recip;\n\n        recipa = -recipa;\n        recipb = -recipb;\n\n        // y = y + 1/y\n        temp = ya + recipa;\n        yb += -(temp - ya - recipa);\n        ya = temp;\n        temp = ya + recipb;\n        yb += -(temp - ya - recipb);\n        ya = temp;\n\n        result = ya + yb;\n        result *= 0.5;\n    }\n\n    return result;\n}",
      "public static double atanh(double a)  {\n    if (a >= 1.0) {\n        return Math.log(a + Math.sqrt(a * a - 1.0));\n    } else if (a <= -1.0) {\n        return -Math.log(-a + Math.sqrt(a * a - 1.0));\n    } else {\n        double hiPrec[] = new double[2];\n        expm1(a, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        double temp = ya * HEX_40000000;\n        double yaa = ya + temp - temp;\n        double yab = ya - yaa;\n\n        // recip = 1/y\n        double recip = 1.0/ya;\n        temp = recip * HEX_40000000;\n        double recipa = recip + temp - temp;\n        double recipb = recip - recipa;\n\n        // Correct for rounding in division\n        recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n\n        // Account for yb\n        recipb += -yb * recip * recip;\n\n        recipa = -recipa;\n        recipb = -recipb;\n\n        // y = y + 1/y\n        temp = ya + recipa;\n        yb += -(temp - ya - recipa);\n        ya = temp;\n        temp = ya + recipb;\n        yb += -(temp - ya - recipb);\n        ya = temp;\n\n        result = ya + yb;\n        result *= 0.5;\n    }\n\n    return result;\n}",
      "public static double atanh(double a)  {\n    if (a > 1.0) {\n        return Math.log(a + FastMath.sqrt(a * a - 1.0));\n    } else if (a < -1.0) {\n        return -Math.log(-a + FastMath.sqrt(a * a - 1.0));\n    } else {\n        double hiPrec[] = new double[2];\n        expm1(a, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        double temp = ya * HEX_40000000;\n        double yaa = ya + temp - temp;\n        double yab = ya - yaa;\n\n        // recip = 1/y\n        double recip = 1.0/ya;\n        temp = recip * HEX_40000000;\n        double recipa = recip + temp - temp;\n        double recipb = recip - recipa;\n\n        // Correct for rounding in division\n        recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n        // Account for yb\n        recipb += -yb * recip * recip;\n\n        recipa = -recipa;\n        recipb = -recipb;\n\n        // y = y + 1/y\n        temp = ya + recipa;\n        yb += -(temp - ya - recipa);\n        ya = temp;\n        temp = ya + recipb;\n        yb += -(temp - ya - recipb);\n        ya = temp;\n\n        result = ya + yb;\n        result *= 0.5;\n    }\n\n    return result;\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n\n    if (a > 1.0 || a < -1.0) {\n        throw new ArithmeticException(\"Argument out of range\");\n    }\n\n    if (a == 1.0) {\n        return Double.POSITIVE_INFINITY;\n    }\n\n    if (a == -1.0) {\n        return Double.NEGATIVE_INFINITY;\n    }\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n\n    if (a < 0.0) {\n        a = -a;\n        negate = true;\n    }\n\n    double result;\n    if (a >= 0.5) {\n        double hiPrec[] = new double[2];\n        expm1(a*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 1.0 + ya;\n        double db = -(da - 1.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    }\n    else {\n        double hiPrec[] = new double[2];\n        expm1(a*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < 0) {\n        negate = true;\n        a = -a;\n    }\n    if (a == 1) {\n        return Math.log(1 + 1e-15);\n    }\n    if (a == -1) {\n        return -Math.log(1 + 1e-15);\n    }\n    if (a > 1 || a < -1) {\n        return a;\n    }\n    if (a > 0.5) {\n        double hiPrec[] = new double[2];\n        expm1(a*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        double temp = ya * HEX_40000000;\n        double yaa = ya + temp - temp;\n        double yab = ya - yaa;\n\n        // recip = 1/y\n        double recip = 1.0/ya;\n        temp = recip * HEX_40000000;\n        double recipa = recip + temp - temp;\n        double recipb = recip - recipa;\n\n        // Correct for rounding in division\n        recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n        // Account for yb\n        recipb += -yb * recip * recip;\n\n        recipa = -recipa;\n        recipb = -recipb;\n\n        // y = y + 1/y\n        temp = ya + recipa;\n        yb += -(temp - ya - recipa);\n        ya = temp;\n        temp = ya + recipb;\n        yb += -(temp - ya - recipb);\n        ya = temp;\n\n        result = ya + yb;\n        result *= 0.5;\n    }\n    else {\n        double hiPrec[] = new double[2];\n        expm1(a, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        // Compute expm1(-x) = -expm1(x) / (expm1(x) + 1)\n        double denom = 1.0 + ya;\n}\n}",
      "public static double atanh(double a)  {\n    if (a >= 1.0) {\n        return Math.log(a + Math.sqrt(a * a - 1.0));\n    } else if (a <= -1.0) {\n        return -Math.log(-a + Math.sqrt(a * a - 1.0));\n    } else {\n        double hiPrec[] = new double[2];\n        expm1(a * 0.5, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        double temp = ya * HEX_40000000;\n        double yaa = ya + temp - temp;\n        double yab = ya - yaa;\n\n        // recip = 1/y\n        double recip = 1.0 / ya;\n        temp = recip * HEX_40000000;\n        double recipa = recip + temp - temp;\n        double recipb = recip - recipa;\n\n        // Correct for rounding in division\n        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n        // Account for yb\n        recipb += -yb * recip * recip;\n\n        recipa = -recipa;\n        recipb = -recipb;\n\n        // y = y + 1/y\n        temp = ya + recipa;\n        yb += -(temp - ya - recipa);\n        ya = temp;\n        temp = ya + recipb;\n        yb += -(temp - ya - recipb);\n        ya = temp;\n\n        result = ya + yb;\n        result *= 0.5;\n    }\n\n    return result;\n}",
      "public static double atanh(double a)  {\n    if (a >= 1.0) {\n        return Math.log(a + FastMath.sqrt(a * a - 1.0));\n    } else if (a <= -1.0) {\n        return -Math.log(-a + FastMath.sqrt(a * a - 1.0));\n    } else {\n        double hiPrec[] = new double[2];\n        expm1(a * 0.5, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        double temp = ya * HEX_40000000;\n        double yaa = ya + temp - temp;\n        double yab = ya - yaa;\n\n        // recip = 1/y\n        double recip = 1.0 / ya;\n        temp = recip * HEX_40000000;\n        double recipa = recip + temp - temp;\n        double recipb = recip - recipa;\n\n        // Correct for rounding in division\n        recipb += (1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n\n        // Account for yb\n        recipb += -yb * recip * recip;\n\n        recipa = -recipa;\n        recipb = -recipb;\n\n        // y = y + 1/y\n        temp = ya + recipa;\n        yb += -(temp - ya - recipa);\n        ya = temp;\n        temp = ya + recipb;\n        yb += -(temp - ya - recipb);\n        ya = temp;\n\n        result = ya + yb;\n        result *= 0.5;\n    }\n\n    return result;\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n    if (a < -1.0) {\n        return Math.log(1.0 + a);\n    } else if (a > 1.0) {\n        return Math.log(1.0 - a);\n    } else if (a == 0.0) {\n        return 0.0;\n    } else if (a < 0.0) {\n        a = -a;\n        negate = true;\n    }\n\n    double result;\n    if (a >= 0.5) {\n        double hiPrec[] = new double[2];\n        expm1(a*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        double temp = ya * HEX_40000000;\n        double yaa = ya + temp - temp;\n        double yab = ya - yaa;\n\n        // recip = 1/y\n        double recip = 1.0/ya;\n        temp = recip * HEX_40000000;\n        double recipa = recip + temp - temp;\n        double recipb = recip - recipa;\n\n        // Correct for rounding in division\n        recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n        // Account for yb\n        recipb += -yb * recip * recip;\n\n        recipa = -recipa;\n        recipb = -recipb;\n\n        // y = y + 1/y\n        temp = ya + recipa;\n        yb += -(temp - ya - recipa);\n        ya = temp;\n        temp = ya + recipb;\n        yb += -(temp - ya - recipb);\n        ya = temp;\n\n        result = ya + yb;\n        result *= 0.5;\n    } else {\n        double hiPrec[] = new double[2];\n        expm1(a, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        // Compute expm1(-x) = -expm1(x) / (expm1(x) + 1)\n        double denom = 1.0 + ya;\n}\n}",
      "public static double atanh(double a)  {\n    boolean negate = false;\n\n    if (a < -1.0) {\n        throw new ArithmeticException(\"Argument out of range\");\n    }\n\n    if (a > 1.0) {\n        throw new ArithmeticException(\"Argument out of range\");\n    }\n\n    if (a == 1.0) {\n        return Math.log(1.0 + Math.sqrt(2.0));\n    }\n\n    if (a == -1.0) {\n        return -Math.log(1.0 + Math.sqrt(2.0));\n    }\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n\n    if (a < 0.0) {\n        a = -a;\n        negate = true;\n    }\n\n    double result;\n    if (a >= 0.5) {\n        double hiPrec[] = new double[2];\n        expm1(a*2.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 1.0 + ya;\n        double db = -(da - 1.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        result = ratioa + ratiob;\n    }\n    else {\n        double hiPrec[] = new double[2];\n        expm1(a*2.0, hiPrec);\n\n}\n}"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"normalizedSum is NaN\");\n    }\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"normalizedSum is infinite\");\n    }\n    double sum = 0.0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (sum == 0.0) {\n        throw new MathArithmeticException(\"Array sums to zero\");\n    }\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            result[i] = Double.NaN;\n        } else {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return result;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum is NaN\");\n    }\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum is infinite\");\n    }\n    double sum = 0.0;\n    for (double value : values) {\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (sum == 0.0) {\n        throw new MathArithmeticException(\"Array sums to zero\");\n    }\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = Double.NaN;\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = SUM.evaluate(values);\n    if (Double.isNaN(sum) || sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n    }\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = Double.NaN;\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_MUST_BE_FINITE);\n    }\n    double sum = 0.0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_INFINITY);\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n    }\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = Double.NaN;\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_MUST_BE_FINITE);\n    }\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_MUST_BE_FINITE);\n    }\n    double sum = Sum.evaluate(values);\n    if (Double.isNaN(sum) || Double.isInfinite(sum)) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n    }\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = Double.NaN;\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum cannot be NaN\");\n    }\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum cannot be infinite\");\n    }\n    double sum = SUM.evaluate(values);\n    if (Double.isNaN(sum) || sum == 0) {\n        throw new MathArithmeticException(\"Input array sums to zero\");\n    }\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = Double.NaN;\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"normalizedSum is NaN\");\n    }\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"normalizedSum is infinite\");\n    }\n    double sum = Sum.evaluate(values);\n    if (Double.isNaN(sum) || sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n    }\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = Double.NaN;\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum cannot be NaN\");\n    }\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(\"Target sum cannot be infinite\");\n    }\n    double sum = SUM.sum(values);\n    if (Double.isNaN(sum)) {\n        throw new MathArithmeticException(\"Array contains NaN values\");\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(\"Array sums to zero\");\n    }\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = Double.NaN;\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_IS_NAN);\n    }\n    if (Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_IS_INFINITE);\n    }\n    double sum = 0.0;\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (sum == 0.0) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n    }\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = Double.NaN;\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return out;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZED_SUM_MUST_BE_FINITE);\n    }\n    double sum = SUM.evaluate(values);\n    if (Double.isInfinite(sum) || sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n    }\n    double[] out = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            out[i] = Double.NaN;\n        } else {\n            out[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return out;\n}"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean lastWasGap = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buffer[i] = Character.toTitleCase(ch);\n            lastWasGap = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            uncapitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            uncapitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            uncapitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toUpperCase(ch);\n            uncapitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        } else {\n            buffer[i] = Character.toTitleCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toUpperCase(ch);\n            uncapitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            uncapitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        } else {\n            if (Character.isLowerCase(ch)) {\n                buffer[i] = Character.toUpperCase(ch);\n            }\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toUpperCase(ch);\n            uncapitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return XTOIX.solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return XTOIX.solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return XTOIX.solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return XTOIX.solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return XTOIX.solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return XTOIX.solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix XTOIX = getX().transpose().multiply(getOmegaInverse()).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(getOmegaInverse()).multiply(getY());\n        return XTOIX.solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix X = getX();\n        RealMatrix OmegaInverse = getOmegaInverse();\n        RealMatrix XTOIX = X.transpose().multiply(OmegaInverse).multiply(X);\n        RealMatrix XTOIXInverse = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealMatrix XTOIXInverseX = XTOIXInverse.multiply(X.transpose()).multiply(OmegaInverse);\n        return XTOIXInverseX.multiply(getY());\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return XTOIX.solve(XTOIY);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIY = getX().transpose().multiply(OI).multiply(getY());\n        return XTOIX.solve(XTOIY);\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    return findFirstElementByTagName(\"id\", this).getElementsByAttribute(\"id\", id).first();\n}",
      "public Element getElementById(String id)  {\n    return findFirstElementByTagName(\"div\", this).selectFirst(String.format(\"id=%s\", id));\n}",
      "public Element getElementById(String id)  {\n    return findFirstElementByTagName(\"div\", this).selectFirst(String.format(\"id=%s\", id));\n}",
      "public Element getElementById(String id)  {\n    return findFirstElementByTagName(\"div\", this).selectFirst(String.format(\"id=%s\", id));\n}",
      "public Element getElementById(String id)  {\n    return findFirstElementByTagName(\"id\", this).text(id);\n}\n\n/**\n     * Find an element by class name, including or under this element.\n     * <p>\n     * Note that this finds the first matching class, starting with this element. If you search down from a different\n     * starting point, it is possible to find a different element by class. For unique element by class within a Document,\n     * use {@link Document#getElementsByClassName(String)}\n     * @param className The class name to search for.\n     * @return The first matching element by class, starting with this element, or null if none found.",
      "public Element getElementById(String id)  {\n    return findFirstElementByTagName(\"div\", this).selectFirst(String.format(\"id=%s\", id));\n}",
      "public Element getElementById(String id)  {\n    return findFirstElementByTagName(\"div\", this).text(id);\n}\n\n/**\n     * Find elements that match the {@link Selector} CSS query, with this element as the starting context. Matched elements\n     * may include this element, or any of its children.\n     * <p>\n     * This method is generally more powerful to use than the DOM-type {@code getElementBy*} methods, because\n     * multiple filters can be combined, e.g.:\n     * </p>\n     * <ul>\n     * <li>{@code el.select(\"a[href]\")} - finds links ({@code a} tags with {@code href} attributes)\n     * <li>{@code el.select(\"a[href*=example.com]\")} - finds links pointing to example.com (loosely)\n     * </ul>\n     * <p>\n     * See the query syntax documentation in {@link org.jsoup.select.Selector}.\n     * </p>\n     * \n     * @param cssQuery a {@link Selector} CSS-like query\n     * @return elements that match the query (empty if none match)\n     * @see org.jsoup.select.Selector\n     * @throws Selector.SelectorParseException (unchecked) on an invalid CSS query.",
      "public Element getElementById(String id)  {\n    return findFirstElementByTagName(\"div\", this).text(id);\n}",
      "public Element getElementById(String id)  {\n    return findFirstElementByTagName(\"id\", this).text(id);\n}",
      "public Element getElementById(String id)  {\n    return findFirstElementByTagName(\"id\", this).getElementsByTag(id).first();\n}"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns == null || customPatterns.isEmpty()) {\n        return pattern;\n    }\n\n    final StringBuilder result = new StringBuilder();\n    int pos = 0;\n    while (pos < pattern.length()) {\n        if (pattern.startsWith(START_FE, pos)) {\n            final int start = pos;\n            pos += 2; // skip START_FE\n            seekNonWs(pattern, pos);\n            final int index = readArgumentIndex(pattern, new ParsePosition(pos));\n            pos = next(pos);\n            seekNonWs(pattern, pos);\n            if (pos < pattern.length() && pattern.charAt(pos) == START_FMT) {\n                pos++;\n                final String formatDescription = parseFormatDescription(pattern, new ParsePosition(pos));\n                pos = next(pos);\n                seekNonWs(pattern, pos);\n                if (pos < pattern.length() && pattern.charAt(pos) == END_FE) {\n                    pos++;\n                    result.append(START_FE).append(index).append(START_FMT).append(formatDescription).append(END_FE);\n                } else {\n                    throw new IllegalArgumentException(\"Unterminated format element at position \" + start);\n                }\n            } else {\n                result.append(START_FE).append(index).append(END_FE);\n            }\n        } else {\n            result.append(pattern.charAt(pos));\n            pos++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StrBuilder sb = new StrBuilder();\n    int index = 0;\n    while (index < pattern.length()) {\n        if (pattern.charAt(index) == START_FE) {\n            sb.append(pattern, index, pattern.indexOf(END_FE, index) + 1);\n            index = pattern.indexOf(END_FE, index) + 1;\n            if (customPatterns.size() > 0) {\n                sb.appendSeparator(',', 0);\n                for (String customPattern : customPatterns) {\n                    sb.append(customPattern);\n                    sb.appendSeparator(',', 1);\n                }\n                customPatterns.clear();\n            }\n        } else {\n            sb.append(pattern.charAt(index));\n            index++;\n        }\n    }\n    return sb.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    int fmtCount = 0;\n    for (int i = 0; i < pattern.length(); i++) {\n        char c = pattern.charAt(i);\n        if (c == START_FE) {\n            fmtCount++;\n            result.append(c);\n            result.append(START_FMT);\n            result.append(fmtCount);\n            result.append(END_FE);\n            if (customPatterns.size() > fmtCount - 1) {\n                result.append(customPatterns.get(fmtCount - 1));\n            }\n        } else {\n            result.append(c);\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    if (customPatterns == null || customPatterns.isEmpty()) {\n        return pattern;\n    }\n\n    final StringBuilder result = new StringBuilder();\n    int index = 0;\n    while (index < pattern.length()) {\n        if (index < pattern.length() - 1 && pattern.charAt(index) == START_FE\n                && pattern.charAt(index + 1) == '{') {\n            // Found a custom pattern, so insert it\n            result.append(pattern, index, index + 2);\n            result.append(customPatterns.get(0));\n            index += 2;\n            customPatterns.remove(0);\n        } else {\n            result.append(pattern.charAt(index));\n        }\n        index++;\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    final int length = pattern.length();\n    int pos = 0;\n    while (pos < length) {\n        if (pattern.charAt(pos) == START_FE) {\n            final int start = pos;\n            seekNonWs(pattern, pos);\n            final int index = readArgumentIndex(pattern, pos);\n            stripCustom.append(START_FE).append(index);\n            seekNonWs(pattern, pos);\n            Format format = null;\n            String formatDescription = null;\n            if (c[pos.getIndex()] == START_FMT) {\n                formatDescription = parseFormatDescription(pattern, next(pos));\n                format = getFormat(formatDescription);\n                if (format == null) {\n                    stripCustom.append(START_FMT).append(formatDescription);\n                }\n            }\n            foundFormats.add(format);\n            foundDescriptions.add(format == null ? null : formatDescription);\n            Validate.isTrue(foundFormats.size() == fmtCount);\n            Validate.isTrue(foundDescriptions.size() == fmtCount);\n            if (c[pos.getIndex()] != END_FE) {\n                throw new IllegalArgumentException(\"Unreadable format element at position \" + start);\n            }\n            result.append(pattern, start, pos);\n            pos++;\n        } else {\n            result.append(pattern.charAt(pos));\n            pos++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    final char[] chars = pattern.toCharArray();\n    int pos = 0;\n    while (pos < chars.length) {\n        if (chars[pos] == START_FE) {\n            result.append(chars, pos, pos + 1);\n            pos++;\n            final int start = pos;\n            seekNonWs(pattern, pos);\n            final int index = readArgumentIndex(pattern, pos);\n            stripCustom.append(START_FE).append(index);\n            seekNonWs(pattern, pos);\n            Format format = null;\n            String formatDescription = null;\n            if (chars[pos] == START_FMT) {\n                formatDescription = parseFormatDescription(pattern, next(pos));\n                format = getFormat(formatDescription);\n                if (format == null) {\n                    stripCustom.append(START_FMT).append(formatDescription);\n                }\n            }\n            foundFormats.add(format);\n            foundDescriptions.add(format == null ? null : formatDescription);\n            Validate.isTrue(foundFormats.size() == customPatterns.size());\n            Validate.isTrue(foundDescriptions.size() == customPatterns.size());\n            if (chars[pos] != END_FE) {\n                throw new IllegalArgumentException(\n                        \"Unreadable format element at position \" + start);\n            }\n            result.append(START_FE).append(index).append(END_FE);\n            pos++;\n        } else {\n            result.append(chars[pos]);\n            pos++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    final char[] chars = pattern.toCharArray();\n    int pos = 0;\n    while (pos < chars.length) {\n        if (chars[pos] == START_FE) {\n            result.append(chars, pos, pos + 1);\n            pos++;\n            int index = readArgumentIndex(pattern, new ParsePosition(pos));\n            result.append(START_FE).append(index);\n            pos = seekNonWs(pattern, new ParsePosition(pos));\n            if (chars[pos] == START_FMT) {\n                result.append(START_FMT);\n                pos++;\n                String formatDescription = parseFormatDescription(pattern, new ParsePosition(pos));\n                result.append(formatDescription);\n                pos = seekNonWs(pattern, new ParsePosition(pos));\n                if (chars[pos] != END_FE) {\n                    throw new IllegalArgumentException(\"Unreadable format element at position \" + pos);\n                }\n            }\n            result.append(END_FE);\n            pos++;\n        } else {\n            result.append(chars[pos]);\n            pos++;\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int pos = 0;\n    while (pos < pattern.length()) {\n        char c = pattern.charAt(pos);\n        if (c == START_FE) {\n            int index = readArgumentIndex(pattern, new ParsePosition(pos));\n            pos = next(new ParsePosition(pos));\n            if (c == START_FMT) {\n                String formatDescription = parseFormatDescription(pattern, new ParsePosition(pos));\n                Format format = getFormat(formatDescription);\n                if (format == null) {\n                    result.append(START_FE).append(index).append(START_FMT).append(formatDescription);\n                } else {\n                    result.append(START_FE).append(index).append(START_FMT).append(format.format());\n                }\n            } else {\n                result.append(START_FE).append(index).append(END_FE);\n            }\n        } else {\n            result.append(c);\n        }\n        pos = next(new ParsePosition(pos));\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    int pos = 0;\n    while (pos < pattern.length()) {\n        char c = pattern.charAt(pos);\n        if (c == '{') {\n            int start = pos;\n            pos++;\n            while (pos < pattern.length() && pattern.charAt(pos) != '}') {\n                pos++;\n            }\n            String format = pattern.substring(start + 1, pos);\n            if (customPatterns.contains(format)) {\n                result.append('{').append(format).append('}');\n            } else {\n                result.append(pattern.substring(start, pos + 1));\n            }\n        } else {\n            result.append(c);\n        }\n        pos++;\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    StringBuilder result = new StringBuilder();\n    int pos = 0;\n    while (pos < pattern.length()) {\n        if (pattern.charAt(pos) == START_FE) {\n            int start = pos;\n            pos = readArgumentIndex(pattern, new ParsePosition(pos));\n            result.append(pattern.substring(start, pos));\n            if (customPatterns.size() > 0) {\n                result.append(customPatterns.remove(0));\n            }\n            pos++;\n        } else {\n            result.append(pattern.charAt(pos));\n            pos++;\n        }\n    }\n    return result.toString();\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    Type[] fromTypeArguments = from.getActualTypeArguments();\n    Type[] toTypeArguments = to.getActualTypeArguments();\n    if (fromTypeArguments.length != toTypeArguments.length) {\n      return false;\n    }\n    for (int i = 0; i < fromTypeArguments.length; i++) {\n      Type fromArg = fromTypeArguments[i];\n      Type toArg = toTypeArguments[i];\n      if (!matches(fromArg, toArg, typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Private recursive helper function to actually do the type-safe checking\n   * of assignability.",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    Type[] fromTypeArguments = from.getActualTypeArguments();\n    Type[] toTypeArguments = to.getActualTypeArguments();\n    if (fromTypeArguments.length != toTypeArguments.length) {\n      return false;\n    }\n    for (int i = 0; i < fromTypeArguments.length; i++) {\n      Type fromArg = fromTypeArguments[i];\n      Type toArg = toTypeArguments[i];\n      if (!matches(fromArg, toArg, typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fromArg = fromArgs[i];\n      Type toArg = toArgs[i];\n      if (!matches(fromArg, toArg, typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Checks if two types are the same or are equivalent under a variable mapping\n   * given in the type map that was provided.",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n\n    Type[] fromTypeArguments = from.getActualTypeArguments();\n    Type[] toTypeArguments = to.getActualTypeArguments();\n\n    if (fromTypeArguments.length != toTypeArguments.length) {\n      return false;\n    }\n\n    for (int i = 0; i < fromTypeArguments.length; i++) {\n      if (!matches(fromTypeArguments[i], toTypeArguments[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Private helper function that performs some assignability checks for\n   * the provided GenericArrayType.",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    Type[] fromTypeArguments = from.getActualTypeArguments();\n    Type[] toTypeArguments = to.getActualTypeArguments();\n    if (fromTypeArguments.length != toTypeArguments.length) {\n      return false;\n    }\n    for (int i = 0; i < fromTypeArguments.length; i++) {\n      if (!matches(fromTypeArguments[i], toTypeArguments[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Private recursive helper function to actually do the type-safe checking\n   * of assignability.",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType().equals(to.getRawType())) {\n      Type[] fromArgs = from.getActualTypeArguments();\n      Type[] toArgs = to.getActualTypeArguments();\n      for (int i = 0; i < fromArgs.length; i++) {\n        if (!matches(fromArgs[i], toArgs[i], typeVarMap)) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Private recursive helper function to actually do the type-safe checking\n   * of assignability.",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (!from.getRawType().equals(to.getRawType())) {\n      return false;\n    }\n    Type[] fromTypeArguments = from.getActualTypeArguments();\n    Type[] toTypeArguments = to.getActualTypeArguments();\n    if (fromTypeArguments.length != toTypeArguments.length) {\n      return false;\n    }\n    for (int i = 0; i < fromTypeArguments.length; i++) {\n      Type fromTypeArgument = fromTypeArguments[i];\n      Type toTypeArgument = toTypeArguments[i];\n      if (!matches(fromTypeArgument, toTypeArgument, typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }\n    \n    /**\n     * Removes a converter from the set of converters. If the converter was\n     * not in the set, no changes are made.\n     * \n     * @param converter  the converter to remove, null ignored\n     * @return replaced converter, or null",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}\n\n/**\n     * Decorates the specified iterator to return at most the given number\n     * of elements, skipping all elements until the iterator reaches the\n     * position at {@code offset}.\n     * <p>\n     * The iterator is immediately advanced until it reaches the position at\n     * {@code offset}, incurring O(n) time.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate\n     * @param offset  the index of the first element of the decorated iterator to return\n     * @param max  the maximum number of elements returned by this iterator\n     * @return a new bounded iterator\n     * @throws NullPointerException if the iterator is null\n     * @throws IllegalArgumentException if either offset or max is negative\n     * @since 4.1",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}\n\n/**\n     * Decorates the specified iterator to return at most the given number\n     * of elements, skipping all elements until the iterator reaches the\n     * position at {@code offset}.\n     * <p>\n     * The iterator is immediately advanced until it reaches the position at\n     * {@code offset}, incurring O(n) time.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate\n     * @param offset  the index of the first element of the decorated iterator to return\n     * @param max  the maximum number of elements returned by this iterator\n     * @return a new bounded iterator\n     * @throws NullPointerException if the iterator is null\n     * @throws IllegalArgumentException if either offset or max is negative\n     * @since 4.1",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}\n\n/**\n     * Decorates the specified iterator to return at most the given number\n     * of elements, skipping all elements until the iterator reaches the\n     * position at {@code offset}.\n     * <p>\n     * The iterator is immediately advanced until it reaches the position at\n     * {@code offset}, incurring O(n) time.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate\n     * @param offset  the index of the first element of the decorated iterator to return\n     * @param max  the maximum number of elements returned by this iterator\n     * @return a new bounded iterator\n     * @throws NullPointerException if the iterator is null\n     * @throws IllegalArgumentException if either offset or max is negative\n     * @since 4.1",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}\n\n/**\n     * Decorates the specified iterator to return at most the given number\n     * of elements, skipping all elements until the iterator reaches the\n     * position at {@code offset}.\n     * <p>\n     * The iterator is immediately advanced until it reaches the position at\n     * {@code offset}, incurring O(n) time.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate\n     * @param offset  the index of the first element of the decorated iterator to return\n     * @param max  the maximum number of elements returned by this iterator\n     * @return a new bounded iterator\n     * @throws NullPointerException if the iterator is null\n     * @throws IllegalArgumentException if either offset or max is negative\n     * @since 4.1",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}\n\n/**\n     * Decorates the specified iterator to return at most the given number\n     * of elements, skipping all elements until the iterator reaches the\n     * position at {@code offset}.\n     * <p>\n     * The iterator is immediately advanced until it reaches the position at\n     * {@code offset}, incurring O(n) time.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate\n     * @param offset  the index of the first element of the decorated iterator to return\n     * @param max  the maximum number of elements returned by this iterator\n     * @return a new bounded iterator\n     * @throws NullPointerException if the iterator is null\n     * @throws IllegalArgumentException if either offset or max is negative\n     * @since 4.1",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}\n\n/**\n     * Decorates the specified iterator to return at most the given number\n     * of elements, skipping all elements until the iterator reaches the\n     * position at {@code offset}.\n     * <p>\n     * The iterator is immediately advanced until it reaches the position at\n     * {@code offset}, incurring O(n) time.\n     *\n     * @param <E> the element type\n     * @param iterator  the iterator to decorate\n     * @param offset  the index of the first element of the decorated iterator to return\n     * @param max  the maximum number of elements returned by this iterator\n     * @return a new bounded iterator\n     * @throws NullPointerException if the iterator is null\n     * @throws IllegalArgumentException if either offset or max is negative\n     * @since 4.1",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof Unmodifiable) {\n        @SuppressWarnings(\"unchecked\") // safe to upcast\n        final Iterator<E> tmpIterator = (Iterator<E>) iterator;\n        return tmpIterator;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n    // Create a map to store the color of each node\n    Map<Color, List<N>> colorMap = new HashMap<>();\n    // Iterate over all nodes in the graph\n    for (N n : graph.getNodes()) {\n        // Get the color of the current node\n        Color color = (Color) n.getAnnotation();\n        // If the color is not in the map, add it\n        if (!colorMap.containsKey(color)) {\n            colorMap.put(color, new ArrayList<>());\n        }\n        // Add the current node to the list of nodes with the same color\n        colorMap.get(color).add(n);\n    }\n    // Iterate over all nodes in the graph again\n    for (N n : graph.getNodes()) {\n        // Get the color of the current node\n        Color color = (Color) n.getAnnotation();\n        // If the list of nodes with the same color is not empty\n        if (!colorMap.get(color).isEmpty()) {\n            // Return the first node in the list as the super node\n            return colorMap.get(color).get(0);\n        }\n    }\n    // If no super node is found, return null\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    int color = ((Color) node.getAnnotation()).value;\n    for (UndiGraphNode<N, E> neighbor : node.getNeighborEdgesIterator()) {\n      if (neighbor.getAnnotation() != null && ((Color) neighbor.getAnnotation()).value == color) {\n        return neighbor;\n      }\n    }\n    return node;\n  }",
      "public N getPartitionSuperNode(N node)  {\n    N superNode = null;\n    for (N n : getUndirectedGraphNodes()) {\n      if (n.equals(node)) {\n        superNode = n;\n        break;\n      }\n    }\n    return superNode;\n  }",
      "public N getPartitionSuperNode(N node)  {\n    // Create a map to store the partition super nodes\n    Map<Color, N> partitionSuperNodeMap = new HashMap<>();\n\n    // Iterate over all nodes in the graph\n    for (N n : graph.getNodes()) {\n        // Get the color of the current node\n        Color color = (Color) n.getAnnotation();\n\n        // If the color is not in the map, add it\n        if (!partitionSuperNodeMap.containsKey(color)) {\n            partitionSuperNodeMap.put(color, n);\n        }\n    }\n\n    // Return the super node for the given node\n    return partitionSuperNodeMap.get(node);\n}",
      "public N getPartitionSuperNode(N node)  {\n    // Create a map to store the color of each node\n    Map<Color, List<N>> colorMap = new HashMap<Color, List<N>>();\n\n    // Traverse the graph and color each node\n    for (N n : graph.getNodes()) {\n        Color color = new Color(0);\n        if (colorToNodeMap[color] == null) {\n            // If the color is not used, assign it to the current node\n            colorToNodeMap[color] = n;\n            color.value++;\n        } else {\n            // If the color is used, find the next available color\n            while (colorToNodeMap.containsKey(color)) {\n                color.value++;\n            }\n            colorToNodeMap[color] = n;\n        }\n        // Add the node to the color map\n        if (!colorMap.containsKey(color)) {\n            colorMap.put(color, new ArrayList<N>());\n        }\n        colorMap.get(color).add(n);\n    }\n\n    // Find the super node for each partition\n    Map<Color, N> superNodeMap = new HashMap<Color, N>();\n    for (Map.Entry<Color, List<N>> entry : colorMap.entrySet()) {\n        Color color = entry.getKey();\n        List<N> nodes = entry.getValue();\n        // The first node in the partition becomes the super node\n        superNodeMap.put(color, nodes.get(0));\n    }\n\n    return superNodeMap.get(new Color(0));\n}",
      "public N getPartitionSuperNode(N node)  {\n    N superNode = null;\n    for (N n : getUndirectedGraphNodes()) {\n        if (n.equals(node)) {\n            superNode = n;\n            break;\n        }\n    }\n    return superNode;\n}",
      "public N getPartitionSuperNode(N node)  {\n    // Get the color of the node\n    Color color = (Color) node.getAnnotation();\n    // Get the nodes with the same color\n    List<N> nodesWithSameColor = new ArrayList<>();\n    for (N n : getUndirectedGraphNodes()) {\n        if (n.getAnnotation() == color) {\n            nodesWithSameColor.add(n);\n        }\n    }\n    // Return the first node in the list as the super node\n    return nodesWithSameColor.get(0);\n}",
      "public N getPartitionSuperNode(N node)  {\n    // Initialize a map to store the partition and its super node\n    Map<Color, N> partitionMap = new HashMap<>();\n    // Initialize a set to store the visited nodes\n    Set<N> visited = new HashSet<>();\n    // Perform a depth-first search to find the super node for each partition\n    for (N n : graph.getUndirectedGraphNodes()) {\n        if (!visited.contains(n)) {\n            Color color = getColor(n);\n            if (!partitionMap.containsKey(color)) {\n                partitionMap.put(color, n);\n            }\n        }\n    }\n    // Return the super node for the given node\n    return partitionMap.get(getColor(node));\n}\n\n/**\n * Annotates the graph with a color in a way that no connected node will have\n * the same color. Nodes of the same color cab then be partitioned together and\n * be represented by a super node.",
      "public N getPartitionSuperNode(N node)  {\n    // Map to store the super node for each partition\n    Map<Color, N> superNodeMap = new HashMap<>();\n    // Map to store the nodes in each partition\n    Map<Color, List<N>> partitionMap = new HashMap<>();\n\n    // Iterate over all nodes in the graph\n    for (N n : graph.getNodes()) {\n      // Get the color of the node\n      Color color = (Color) n.getAnnotation();\n      // If the color is not in the partition map, add it\n      if (!partitionMap.containsKey(color)) {\n        partitionMap.put(color, new ArrayList<>());\n      }\n      // Add the node to its partition\n      partitionMap.get(color).add(n);\n    }\n\n    // Iterate over the partitions\n    for (Map.Entry<Color, List<N>> entry : partitionMap.entrySet()) {\n      // Get the first node in the partition\n      N superNode = entry.getValue().get(0);\n      // Add the super node to the super node map\n      superNodeMap.put(entry.getKey(), superNode);\n    }\n\n    // Return the super node for the given node\n    return superNodeMap.get((Color) node.getAnnotation());\n  }",
      "public N getPartitionSuperNode(N node)  {\n    N superNode = null;\n    for (N n : getUndirectedGraphNodes()) {\n        if (n.equals(node)) {\n            superNode = n;\n            break;\n        }\n    }\n    return superNode;\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(ranks[i].getPosition());\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  /**\n     * Returns a list of indexes where <code>ranks</code> is <code>NaN.</code>\n     *\n     * @param ranks array to search for <code>NaNs</code>\n     * @return list of indexes i such that <code>ranks[i] = NaN</code>",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(i);\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(i);\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(ranks[i].getPosition());\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(i);\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(ranks[i].getPosition());\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(i);\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(ranks[i].getPosition());\n        }\n    }\n    return positions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> positions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            positions.add(i);\n        }\n    }\n    return positions;\n}"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n    double[] result = new double[1];\n    result[0] = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        result[0] += f.value(points[i]) * weights[i];\n    }\n    return result[0];\n}",
      "public double integrate(UnivariateFunction f)  {\n    double[] result = new double[1];\n    result[0] = 0.0;\n    for (int i = 0; i < points.length; i++) {\n        result[0] += f.value(points[i]) * weights[i];\n    }\n    return result[0];\n}",
      "public double integrate(UnivariateFunction f)  {\n    double[] result = new double[1];\n    result[0] = 0;\n    for (int i = 0; i < points.length; i++) {\n        result[0] += f.value(points[i]) * weights[i];\n    }\n    return result[0];\n}",
      "public double integrate(UnivariateFunction f)  {\n    double[] points = this.points;\n    double[] weights = this.weights;\n    double integral = 0;\n\n    for (int i = 0; i < points.length; i++) {\n        integral += f.value(points[i]) * weights[i];\n    }\n\n    return integral;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double[] result = new double[1];\n    result[0] = 0;\n    for (int i = 0; i < points.length; i++) {\n        result[0] += f.value(points[i]) * weights[i];\n    }\n    return result[0];\n}",
      "public double integrate(UnivariateFunction f)  {\n    double[] result = new double[1];\n    for (int i = 0; i < points.length; i++) {\n        result[0] += f.value(points[i]) * weights[i];\n    }\n    return result[0];\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += f.value(points[i]) * weights[i];\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double[] result = new double[1];\n    result[0] = 0;\n    for (int i = 0; i < points.length; i++) {\n        result[0] += f.value(points[i]) * weights[i];\n    }\n    return result[0];\n}",
      "public double integrate(UnivariateFunction f)  {\n    double[] result = new double[1];\n    result[0] = 0;\n    for (int i = 0; i < points.length; i++) {\n        result[0] += f.value(points[i]) * weights[i];\n    }\n    return result[0];\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return (map2 == null);\n    }\n    if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return (map2 == null);\n    }\n    if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return map2 == null;\n    }\n    if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return (map2 == null);\n    }\n    if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return (map2 == null);\n    }\n    if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return map2 == null;\n    }\n    if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return (map2 == null);\n    }\n    if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return (map2 == null);\n    }\n    if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return (map2 == null);\n    }\n    if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        return map2 == null;\n    }\n    if (map2 == null) {\n        return false;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String value = expr.getString();\n        if (value.length() > 1) {\n            Node replacement = IR.string(t.getShortString(value));\n            parent.replaceChild(expr, replacement);\n            return replacement;\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isStringLiteral()) {\n        String value = expr.getString();\n        if (value.length() > 2 && value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\")) {\n            value = value.substring(1, value.length() - 1);\n            if (value.length() > 0) {\n                // Check if the string is a valid UTF-8 encoded string\n                try {\n                    byte[] bytes = value.getBytes(\"UTF-8\");\n                    if (bytes.length > 0) {\n                        // Encode the string\n                        StringBuilder encodedValue = new StringBuilder();\n                        for (byte b : bytes) {\n                            encodedValue.append(String.format(\"\\\\u%04x\", b & 0xFF));\n                        }\n                        // Replace the string expression with the encoded string\n                        Node replacementNode = IR.stringLiteral(encodedValue.toString());\n                        parent.replaceChild(expr, replacementNode);\n                        return replacementNode;\n                    }\n                } catch (UnsupportedEncodingException e) {\n                    // Ignore the exception and return the original expression\n                }\n            }\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isStringLiteral()) {\n      String str = expr.getString();\n      if (str.length() > 1) {\n        if (str.startsWith(\"0x\") || str.startsWith(\"0X\")) {\n          // hexadecimal string\n          String hexStr = str.substring(2);\n          if (hexStr.length() % 2 == 0) {\n            // even length\n            String shortHexStr = hexStr.substring(0, 2);\n            replacementNode = IR.hexLiteral(shortHexStr);\n          } else {\n            // odd length\n            String shortHexStr = hexStr.substring(0, 1) + \"0\" + hexStr.substring(1);\n            replacementNode = IR.hexLiteral(shortHexStr);\n          }\n        } else if (str.matches(\"[a-fA-F0-9]+\")) {\n          // base 16 string\n          String shortStr = str.substring(0, 2);\n          replacementNode = IR.hexLiteral(shortStr);\n        } else {\n          // other string\n          replacementNode = IR.stringLiteral(str);\n        }\n      } else {\n        replacementNode = IR.stringLiteral(str);\n      }\n    } else {\n      replacementNode = expr;\n    }\n    if (replacementNode != null) {\n      parent.replaceChild(expr, replacementNode);\n      t.reportCodeChange();\n      return replacementNode;\n    }\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String str = expr.getString();\n        if (str.length() > 2) {\n            // Check if the string is a constant name\n            if (isConstantName(expr, t.getKnownConstants())) {\n                return expr;\n            }\n            // Check if the string is a property name\n            if (t.isProperty(str)) {\n                return expr;\n            }\n            // Check if the string is a method name\n            if (t.isMethod(str)) {\n                return expr;\n            }\n            // Check if the string is a function name\n            if (t.isFunction(str)) {\n                return expr;\n            }\n            // Check if the string is a class name\n            if (t.isClass(str)) {\n                return expr;\n            }\n            // Check if the string is a type name\n            if (t.isType(str)) {\n                return expr;\n            }\n            // Check if the string is a variable name\n            if (t.isVariable(str)) {\n                return expr;\n            }\n            // Check if the string is a field name\n            if (t.isField(str)) {\n                return expr;\n            }\n            // Check if the string is a property name\n            if (t.isProperty(str)) {\n                return expr;\n            }\n            // Check if the string is a method name\n            if (t.isMethod(str)) {\n                return expr;\n            }\n            // Check if the string is a function name\n            if (t.isFunction(str)) {\n                return expr;\n            }\n            // Check if the string is a class name\n            if (t.isClass(str)) {\n                return expr;\n            }\n            // Check if the string is a type name\n            if (t.isType(str)) {\n                return expr;\n            }\n            // Check if the string is a variable name\n            if (t.isVariable(str)) {\n                return expr;\n            }\n            // Check if the string is a field name\n            if (t.isField(str)) {\n                return expr;\n            }\n            // Check if the string is a property name\n            if (t.isProperty(str)) {\n                return expr;\n            }\n            // Check if the string is a method name\n            if (t.isMethod(str)) {\n                return expr;\n            }\n            // Check if the string is a function name\n            if (t.isFunction(str)) {\n                return expr;\n            }\n}\n}\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String value = expr.getString();\n        if (value.length() > 1) {\n            if (value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\")) {\n                value = value.substring(1, value.length() - 1);\n            }\n            return IR.string(value);\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isStringLiteral()) {\n        String value = expr.getString();\n        if (value.length() > 1) {\n            // Check if the string is a valid short encoded string\n            if (isShortEncodedString(value)) {\n                // Replace the string expression with a short encoded string\n                return IR.shortEncodedString(value);\n            }\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isStringLiteral()) {\n      String literal = expr.getString();\n      if (literal.length() > 1) {\n        // Check if the string is a valid short encoded string\n        if (isShortEncodedString(literal)) {\n          // Replace the string expression with a short encoded string\n          return IR.shortEncodedString(literal);\n        }\n      }\n    }\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n      String str = expr.getString();\n      if (str.length() > 1) {\n        if (str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\")) {\n          str = str.substring(1, str.length() - 1);\n        }\n        if (str.startsWith(\"'\") && str.endsWith(\"'\")) {\n          str = str.substring(1, str.length() - 1);\n        }\n        if (str.matches(\"[a-zA-Z0-9_]+\")) {\n          return IR.name(str);\n        }\n      }\n    }\n    return expr;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isString()) {\n        String str = expr.getString();\n        if (str.length() > 2) {\n            // Check if the string is a valid UTF-8 sequence\n            if (isValidUTF8(str)) {\n                // Replace the string with a short encoded string\n                return IR.encodeString(str);\n            }\n        }\n    }\n    return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (expr.isStringLiteral()) {\n      String value = expr.getString();\n      if (value.length() > 1) {\n        String shortValue = encodeString(value);\n        Node replacementNode = IR.stringLiteral(shortValue);\n        parent.replaceChild(expr, replacementNode);\n        return replacementNode;\n      }\n    }\n    return expr;\n  }"
    ],
    [
      "public double[] getCoefficients()  {\n    double[] out = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[coefficients.length];\n    System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n    return out;\n}"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node.isJsDoc()) {\n        Node descNode = node.getChildByName(\"desc\");\n        if (descNode != null) {\n            String desc = extractStringFromStringExprNode(descNode);\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                builder.setIsHidden(true);\n            } else {\n                builder.setDesc(desc);\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Creates a JsMessage for a JS message defined using an assignment to a\n * qualified name (e.g <code>a.b.MSG_X = goog.getMsg(...);</code>).\n *\n * @param builder the message builder\n * @param getPropNode a GETPROP node in a JS message assignment\n * @param assignNode an ASSIGN node, parent of {@code getPropNode}.\n * @throws MalformedException if {@code getPropNode} does not\n *         correspond to a valid JS message node",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node.isVar()) {\n        Node nameNode = node.getFirstChild();\n        String name = nameNode.getString();\n        if (name.equals(builder.getKey() + DESC_SUFFIX)) {\n            Node valueNode = nameNode.getFirstChild();\n            String desc = extractStringFromStringExprNode(valueNode);\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                builder.setIsHidden(true);\n            } else {\n                builder.setDesc(desc);\n            }\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node.isVar()) {\n        Node nameNode = node.getFirstChild();\n        String name = nameNode.getString();\n        if (name.equals(builder.getKey() + DESC_SUFFIX)) {\n            Node valueNode = nameNode.getFirstChild();\n            String desc = extractStringFromStringExprNode(valueNode);\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                builder.setIsHidden(true);\n            } else {\n                builder.setDesc(desc);\n            }\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node.isVar()) {\n        Node nameNode = node.getFirstChild();\n        String name = nameNode.getString();\n        if (name.equals(builder.getKey() + DESC_SUFFIX)) {\n            Node valueNode = nameNode.getFirstChild();\n            String desc = extractStringFromStringExprNode(valueNode);\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                builder.setIsHidden(true);\n            } else {\n                builder.setDesc(desc);\n            }\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node.isVar()) {\n        Node nameNode = node.getFirstChild();\n        String name = nameNode.getString();\n        if (name.equals(builder.getKey() + DESC_SUFFIX)) {\n            Node valueNode = nameNode.getFirstChild();\n            String desc = extractStringFromStringExprNode(valueNode);\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                builder.setIsHidden(true);\n            } else {\n                builder.setDesc(desc);\n            }\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node.isVar()) {\n        Node nameNode = node.getFirstChild();\n        String name = nameNode.getString();\n        if (name.equals(builder.getKey() + DESC_SUFFIX)) {\n            Node valueNode = nameNode.getFirstChild();\n            String desc = extractStringFromStringExprNode(valueNode);\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                builder.setIsHidden(true);\n            } else {\n                builder.setDesc(desc);\n            }\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node.isVar()) {\n        Node nameNode = node.getFirstChild();\n        String name = nameNode.getString();\n        if (name.equals(builder.getKey() + DESC_SUFFIX)) {\n            Node valueNode = nameNode.getFirstChild();\n            String desc = extractStringFromStringExprNode(valueNode);\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                builder.setIsHidden(true);\n            } else {\n                builder.setDesc(desc);\n            }\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node.isVar()) {\n        Node nameNode = node.getFirstChild();\n        String name = nameNode.getString();\n        if (name.equals(builder.getKey() + DESC_SUFFIX)) {\n            Node valueNode = nameNode.getFirstChild();\n            String desc = extractStringFromStringExprNode(valueNode);\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                builder.setIsHidden(true);\n            } else {\n                builder.setDesc(desc);\n            }\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node.isJsDoc()) {\n        for (Node child : node.children()) {\n            if (child.getType() == Token.JSDOC_DESC) {\n                String desc = extractStringFromStringExprNode(child);\n                if (!desc.isEmpty()) {\n                    builder.setDesc(desc);\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n/**\n   * Initializes the meta data in a message builder from a JsDoc or help\n   * variable.\n   *\n   * @param builder the message builder whose meta data will be initialized\n   * @param varNode the JsDoc or help variable\n   * @param parentOfVarNode the parent node of the JsDoc or help variable\n   * @return true if message has JsDoc with valid description in @desc\n   *         annotation",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  {\n    if (node.isVar()) {\n        Node nameNode = node.getFirstChild();\n        String name = nameNode.getString();\n        if (name.equals(builder.getKey() + DESC_SUFFIX)) {\n            Node valueNode = nameNode.getFirstChild();\n            String desc = extractStringFromStringExprNode(valueNode);\n            if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n                builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n                builder.setIsHidden(true);\n            } else {\n                builder.setDesc(desc);\n            }\n            return true;\n        }\n    }\n    return false;\n}"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        clusters.get(clusterIndex).addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}\n\n/**\n * Use K-means++ to choose the initial centers.\n *\n * @param points the points to choose the initial centers from\n * @param k the number of centers to choose\n * @param random random generator to use\n * @return the initial centers",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        clusters.get(clusterIndex).addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}\n\n/**\n * Use K-means++ to choose the initial centers.\n *\n * @param points the points to choose the initial centers from\n * @param k the number of centers to choose\n * @param random random generator to use\n * @return the initial centers",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        clusters.get(clusterIndex).addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}\n\n/**\n * Use K-means++ to choose the initial centers.\n *\n * @param points the points to choose the initial centers from\n * @param k the number of centers to choose\n * @param random random generator to use\n * @return the initial centers",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        clusters.get(clusterIndex).addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}\n\n/**\n * Use K-means++ to choose the initial centers.\n *\n * @param points the points to choose the initial centers from\n * @param k the number of centers to choose\n * @param random random generator to use\n * @return the initial centers",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        clusters.get(clusterIndex).addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}\n\n/**\n * Use K-means++ to choose the initial centers.\n *\n * @param points the points to choose the initial centers from\n * @param k the number of centers to choose\n * @param random random generator to use\n * @return the initial centers",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        clusters.get(clusterIndex).addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}\n\n/**\n * Use K-means++ to choose the initial centers.\n *\n * @param points the points to choose the initial centers from\n * @param k the number of centers to choose\n * @param random random generator to use\n * @return the initial centers",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        clusters.get(clusterIndex).addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}\n\n/**\n * Use K-means++ to choose the initial centers.\n *\n * @param points the points to choose the initial centers from\n * @param k the number of centers to choose\n * @param random random generator to use\n * @return the initial centers",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        clusters.get(clusterIndex).addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}\n\n/**\n * Use K-means++ to choose the initial centers.\n *\n * @param points the points to choose the initial centers from\n * @param k the number of centers to choose\n * @param random random generator to use\n * @return the initial centers",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        clusters.get(clusterIndex).addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}\n\n/**\n * Use K-means++ to choose the initial centers.\n *\n * @param points the points to choose the initial centers from\n * @param k the number of centers to choose\n * @param random random generator to use\n * @return the initial centers",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n        clusters.get(clusterIndex).addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n    return assignedDifferently;\n}\n\n/**\n * Use K-means++ to choose the initial centers.\n *\n * @param points the points to choose the initial centers from\n * @param k the number of centers to choose\n * @param random random generator to use\n * @return the initial centers"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths do not match\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Insufficient data\");\n    }\n    double sumXX = 0;\n    double sumXY = 0;\n    double sumYY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumXX += xArray[i] * xArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumYY += yArray[i] * yArray[i];\n    }\n    double covariance = biasCorrected ? (sumXY - sumXX / xArray.length * sumYY / yArray.length) / (xArray.length - 1) : (sumXY - sumXX / xArray.length * sumYY / yArray.length) / xArray.length;\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths must match\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Array length must be at least 2\");\n    }\n    double sumXX = 0;\n    double sumYY = 0;\n    double sumXY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumXX += xArray[i] * xArray[i];\n        sumYY += yArray[i] * yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n    double meanX = sumXX / xArray.length;\n    double meanY = sumYY / yArray.length;\n    double cov = 0;\n    if (biasCorrected) {\n        cov = (sumXY - sumXX * meanY / xArray.length - sumYY * meanX / yArray.length) / (xArray.length - 1);\n    } else {\n        cov = sumXY / xArray.length - meanX * meanY;\n    }\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths must match\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"There is insufficient data\");\n    }\n    double sumXX = 0, sumYY = 0, sumXY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumXX += xArray[i] * xArray[i];\n        sumYY += yArray[i] * yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n    double covariance = sumXY - sumXX / xArray.length * sumYY / yArray.length;\n    if (biasCorrected) {\n        covariance /= (xArray.length - 1);\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths do not match\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Insufficient data\");\n    }\n    double sumX = 0;\n    double sumY = 0;\n    double sumXY = 0;\n    double sumX2 = 0;\n    double sumY2 = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumX2 += xArray[i] * xArray[i];\n        sumY2 += yArray[i] * yArray[i];\n    }\n    double meanX = sumX / xArray.length;\n    double meanY = sumY / xArray.length;\n    double covariance = 0;\n    if (biasCorrected) {\n        covariance = (sumXY - sumX * meanY - sumY * meanX + sumX * sumY / xArray.length) / (xArray.length - 1);\n    } else {\n        covariance = (sumXY - sumX * meanY - sumY * meanX + sumX * sumY / xArray.length) / xArray.length;\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths must match\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"There is insufficient data\");\n    }\n    double sumXX = 0;\n    double sumYY = 0;\n    double sumXY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumXX += xArray[i] * xArray[i];\n        sumYY += yArray[i] * yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n    double meanX = sumXX / xArray.length;\n    double meanY = sumYY / yArray.length;\n    double cov = 0;\n    if (biasCorrected) {\n        cov = (sumXY - sumXX * sumYY / xArray.length) / (xArray.length - 1);\n    } else {\n        cov = sumXY / xArray.length;\n    }\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths do not match\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Insufficient data\");\n    }\n    double sumXX = 0;\n    double sumXY = 0;\n    double sumYY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumXX += xArray[i] * xArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumYY += yArray[i] * yArray[i];\n    }\n    double covariance = biasCorrected ? (sumXY - sumXX / xArray.length * sumYY / yArray.length) / (xArray.length - 1) : sumXY / xArray.length;\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths do not match\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Insufficient data\");\n    }\n    double sumXX = 0;\n    double sumXY = 0;\n    double sumYY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumXX += xArray[i] * xArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumYY += yArray[i] * yArray[i];\n    }\n    double cov = biasCorrected ? (sumXY - sumXX / xArray.length * sumYY / yArray.length) / (xArray.length - 1) : sumXY / xArray.length;\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths do not match\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"Insufficient data\");\n    }\n    double meanX = 0;\n    double meanY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        meanX += xArray[i];\n        meanY += yArray[i];\n    }\n    meanX /= xArray.length;\n    meanY /= yArray.length;\n    double covariance = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        covariance += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    covariance /= (xArray.length - 1);\n    if (biasCorrected) {\n        covariance /= (1.0 - (1.0 / xArray.length));\n    }\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths must match\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"There is insufficient data\");\n    }\n    double sumXX = 0;\n    double sumYY = 0;\n    double sumXY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumXX += xArray[i] * xArray[i];\n        sumYY += yArray[i] * yArray[i];\n        sumXY += xArray[i] * yArray[i];\n    }\n    double covariance = (biasCorrected) ? (sumXY - sumXX / xArray.length * sumYY / yArray.length) / (xArray.length - 1) : sumXY / xArray.length;\n    return covariance;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\"Array lengths must match\");\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\"There is insufficient data\");\n    }\n    double meanX = 0;\n    double meanY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        meanX += xArray[i];\n        meanY += yArray[i];\n    }\n    meanX /= xArray.length;\n    meanY /= yArray.length;\n    double cov = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        cov += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    cov /= (xArray.length - 1);\n    if (biasCorrected) {\n        cov /= (1 - 1.0 / xArray.length);\n    }\n    return cov;\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"negative skip length\");\n    }\n    ensureOpen();\n    long total = 0;\n    while (total < value) {\n        int len = (int) Math.min(value - total, Integer.MAX_VALUE);\n        if (len > this.tmpbuf.length) {\n            len = this.tmpbuf.length;\n        }\n        len = read(this.tmpbuf, 0, len);\n        if (len == -1) {\n            this.entryEOF = true;\n            break;\n        }\n        total += len;\n    }\n    count(total);\n}\n\n/**\n * Skips the specified number of bytes in the current CPIO entry.\n *\n * @param n the number of bytes to skip\n * @return the actual number of bytes skipped\n * @throws IOException if an I/O error has occurred\n * @throws IllegalArgumentException if n < 0\n */",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"negative skip length\");\n    }\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"negative skip length\");\n    }\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IOException(\"negative skip length\");\n    }\n    ensureOpen();\n    long skipped = 0;\n    while (skipped < value) {\n        int len = (int) Math.min(value - skipped, Integer.MAX_VALUE);\n        if (len > this.tmpbuf.length) {\n            len = this.tmpbuf.length;\n        }\n        len = read(this.tmpbuf, 0, len);\n        if (len == -1) {\n            this.entryEOF = true;\n            break;\n        }\n        skipped += len;\n    }\n    return skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"negative skip length\");\n    }\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IllegalArgumentException(\"negative skip length\");\n    }\n    long skipped = 0;\n    while (skipped < value) {\n        final long rem = value - skipped;\n        final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) {\n            return;\n        }\n        skipped += x;\n    }\n    count(skipped);\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value < 0) {\n        throw new IOException(\"negative skip length\");\n    }\n    ensureOpen();\n    final int max = (int) Math.min(value, Integer.MAX_VALUE);\n    int total = 0;\n\n    while (total < max) {\n        int len = max - total;\n        if (len > this.tmpbuf.length) {\n            len = this.tmpbuf.length;\n        }\n        len = read(this.tmpbuf, 0, len);\n        if (len == -1) {\n            this.entryEOF = true;\n            break;\n        }\n        total += len;\n    }\n    return total;\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    return readField(field, target);\n}\n\n/**\n     * <p>Gets a static Field value by name. Only the specified class will be considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    return readField(field, target);\n}\n\n/**\n     * Gets a static Field value by name. Only the specified class will be considered.\n     * \n     * @param cls\n     *            the class to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    return readField(field, target);\n}\n\n/**\n * <p>Gets a static Field value by name. Only the specified class will be considered.\n * \n * @param cls\n *            the class to reflect, must not be null\n * @param fieldName\n *            the field name to obtain\n * @param forceAccess\n *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    return readField(field, target);\n}\n\n/**\n * Gets a Field value by name. Superclasses will be considered.\n * \n * @param target\n *            the object to reflect, must not be null\n * @param fieldName\n *            the field name to obtain\n * @param forceAccess\n *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    return readField(field, target);\n}\n\n/**\n * <p>Gets a Field value by name. Superclasses will be considered.\n * \n * @param target\n *            the object to reflect, must not be null\n * @param fieldName\n *            the field name to obtain\n * @param forceAccess\n *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    return readField(field, target);\n}\n\n/**\n     * <p>Gets a Field value by name. Superclasses will be considered.\n     * \n     * @param target\n     *            the object to reflect, must not be null\n     * @param fieldName\n     *            the field name to obtain\n     * @param forceAccess\n     *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    return readField(field, target);\n}\n\n/**\n     * Reads an accessible Field.\n     * \n     * @param field\n     *            the field to use\n     * @param target\n     *            the object to call on, may be null for static fields\n     * @return the field value\n     * @throws IllegalArgumentException\n     *             if the field is null\n     * @throws IllegalAccessException\n     *             if the field is not accessible",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    return readField(field, target);\n}\n\n/**\n * Reads the named field. Superclasses will be considered.\n * \n * @param target\n *            the object to reflect, must not be null\n * @param fieldName\n *            the field name to obtain\n * @param forceAccess\n *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    return readField(field, target);\n}\n\n/**\n * Gets a Field value by name. Superclasses will be considered.\n * \n * @param target\n *            the object to reflect, must not be null\n * @param fieldName\n *            the field name to obtain\n * @param forceAccess\n *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    return readField(field, target);\n}\n\n/**\n * Gets a static Field value by name. Only the specified class will be considered.\n * \n * @param cls\n *            the class to reflect, must not be null\n * @param fieldName\n *            the field name to obtain\n * @param forceAccess\n *            whether to break scope restrictions using the <code>setAccessible</code> method. <code>False</code>"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                    CaseFormat.UPPER_UNDERSCORE,\n                    ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(MessageId.generateId(tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(MessageId.generateId(tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                    CaseFormat.UPPER_UNDERSCORE,\n                    ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(MessageId.generateId(tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    return sb.toString();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return tcValue;\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                    CaseFormat.UPPER_UNDERSCORE,\n                    ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(MessageId.generateId(tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(CaseFormat.UPPER_UNDERSCORE, ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    return sb.toString();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                    CaseFormat.UPPER_UNDERSCORE,\n                    ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(MessageId.generateId(tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                    CaseFormat.UPPER_UNDERSCORE,\n                    ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return tcValue;\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        if (part instanceof PlaceholderReference) {\n            sb.append(CaseFormat.LOWER_CAMEL.to(\n                    CaseFormat.UPPER_UNDERSCORE,\n                    ((PlaceholderReference) part).getName()));\n        } else {\n            sb.append(part);\n        }\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(MessageId.generateId(tcValue));\n}"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    RandomAccessFile archive = new RandomAccessFile(new File(\"path\"), \"r\");\n    archive.seek(archive.length() - maxDistanceFromEnd);\n    byte[] buffer = new byte[(int) maxDistanceFromEnd];\n    archive.readFully(buffer);\n    for (int i = 0; i <= minDistanceFromEnd; i++) {\n        if (Arrays.equals(buffer, sig)) {\n            archive.seek(archive.length() - maxDistanceFromEnd + i);\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long pos = archive.length() - 1;\n    while (pos >= minDistanceFromEnd && pos <= maxDistanceFromEnd) {\n        if (Arrays.equals(archive.readFully(pos, sig).array(), sig)) {\n            archive.position(pos);\n            return true;\n        }\n        pos--;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    RandomAccessFile archive = new RandomAccessFile(new File(\"archive.zip\"), \"r\");\n    archive.seek(archive.length() - maxDistanceFromEnd);\n    byte[] buffer = new byte[(int)minDistanceFromEnd];\n    int bytesRead = archive.read(buffer);\n    if (bytesRead < minDistanceFromEnd) {\n        throw new IOException(\"Truncated ZIP file\");\n    }\n    if (Arrays.equals(buffer, sig)) {\n        archive.seek(archive.length() - maxDistanceFromEnd);\n        return true;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long pos = archive.length() - 1;\n    while (pos >= minDistanceFromEnd) {\n        archive.seek(pos);\n        if (readFully(archive, sig)) {\n            return true;\n        }\n        pos--;\n    }\n    return false;\n}\n\n/**\n     * Searches the archive backwards from minDistance to maxDistance\n     * for the given signature, positions the RandomaccessFile right\n     * at the signature if it has been found.",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long pos = file.length() - 1;\n    while (pos >= minDistanceFromEnd) {\n        if (pos < maxDistanceFromEnd) {\n            pos -= 1;\n            continue;\n        }\n        if (readByte() == sig[0] && readByte() == sig[1] && readByte() == sig[2] && readByte() == sig[3]) {\n            file.position(pos - 4);\n            return true;\n        }\n        pos -= 1;\n    }\n    return false;\n}\n\n/**\n     * Searches the archive backwards from minDistance to maxDistance\n     * for the given signature, positions the RandomaccessFile right\n     * at the signature if it has been found.",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    RandomAccessFile raf = new RandomAccessFile(archive, \"r\");\n    raf.seek(raf.length() - maxDistanceFromEnd);\n    byte[] buffer = new byte[(int)minDistanceFromEnd];\n    int bytesRead = raf.read(buffer);\n    if (bytesRead < minDistanceFromEnd) {\n        raf.close();\n        return false;\n    }\n    raf.close();\n    for (int i = bytesRead - minDistanceFromEnd; i >= 0; i--) {\n        if (Arrays.equals(buffer, i, i + sig.length, sig)) {\n            raf = new RandomAccessFile(archive, \"r\");\n            raf.seek(raf.length() - maxDistanceFromEnd + i);\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long position = archive.length() - maxDistanceFromEnd;\n    while (position >= minDistanceFromEnd) {\n        archive.seek(position);\n        int r = archive.readFully(sig);\n        if (r == sig.length) {\n            return true;\n        }\n        position -= 1;\n    }\n    return false;\n}\n\n/**\n * Searches the archive backwards from minDistance to maxDistance\n * for the given signature, positions the RandomaccessFile right\n * at the signature if it has been found.",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long pos = file.length() - maxDistanceFromEnd;\n    while (pos >= minDistanceFromEnd) {\n        file.seek(pos);\n        if (IOUtils.readFully(file, sig, 0, sig.length) == sig.length) {\n            return true;\n        }\n        pos -= 1;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long pos = archive.length() - 1;\n    while (pos >= minDistanceFromEnd && pos <= maxDistanceFromEnd) {\n        archive.position(pos);\n        if (IOUtils.readFully(archive, sig, 0, sig.length) == sig.length) {\n            return true;\n        }\n        pos--;\n    }\n    return false;\n}\n\n/**\n     * Searches the archive backwards from minDistance to maxDistance\n     * for the given signature, positions the RandomaccessFile right\n     * at the signature if it has been found.",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    RandomAccessFile archive = getArchive();\n    long pos = archive.length() - 1;\n    while (pos >= minDistanceFromEnd && pos <= maxDistanceFromEnd) {\n        if (Arrays.equals(archive.readBytes(pos, sig.length), sig)) {\n            archive.position(pos);\n            return true;\n        }\n        pos--;\n    }\n    return false;\n}\n\n/**\n     * Searches the archive backwards from minDistance to maxDistance\n     * for the given signature, positions the RandomaccessFile right\n     * at the signature if it has been found."
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}\n\n/**\n     * Sets the axis location for a domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> not permitted for\n     *     index 0).\n     * @param notify  notify listeners?\n     *\n     * @since 1.0.5\n     *\n     * @see #getRangeAxisLocation(int)\n     * @see #setDomainAxisLocation(int, AxisLocation, boolean)",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}\n\n/**\n     * Sets the axis location for a domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> not permitted for\n     *     index 0).\n     * @param notify  notify listeners?\n     *\n     * @since 1.0.5\n     *\n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}\n\n/**\n     * Sets the axis location for a domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> not permitted for\n     *     index 0).\n     * @param notify  notify listeners?\n     *\n     * @since 1.0.5\n     *\n     * @see #getDomainAxisLocation(int)\n     * @see #setRangeAxisLocation(int, AxisLocation, boolean)",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}\n\n/**\n * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n * to all registered listeners.\n *\n * @param index  the axis index.\n * @param location  the location.\n * @param notify  notify listeners?\n *\n * @see #getDomainAxisLocation(int)\n * @see #setRangeAxisLocation(int, AxisLocation, boolean)",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}\n\n/**\n * Sets the location for a domain axis and sends a {@link PlotChangeEvent}\n * to all registered listeners.\n *\n * @param index  the axis index.\n * @param location  the location.\n * @param notify  notify listeners?\n *\n * @see #getDomainAxisLocation(int)\n * @see #setRangeAxisLocation(int, AxisLocation, boolean)",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location, this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge());\n    }\n    return result;\n}\n\n/**\n     * Sets the axis location for a domain axis and, if requested, sends a\n     * {@link PlotChangeEvent} to all registered listeners.\n     *\n     * @param index  the axis index.\n     * @param location  the location (<code>null</code> not permitted for\n     *     index 0).\n     * @param notify  notify listeners?\n     *\n     * @since 1.0.5\n     *\n     * @see #getRangeAxisLocation(int)\n     * @see #setDomainAxisLocation(int, AxisLocation, boolean)"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public InputStream getDataStream()  {\n    return new MergedStream(_ctxt, _in, _b, _ptr, _end);\n}",
      "public InputStream getDataStream()  {\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    return new MergedStream(_ctxt, _in, _b, _ptr, _end);\n}",
      "public InputStream getDataStream()  {\n    return new MergedStream(_ctxt, _in, _b, _ptr, _end);\n}",
      "public InputStream getDataStream()  {\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    return new MergedStream(_ctxt, _in, _b, _ptr, _end);\n}",
      "public InputStream getDataStream()  {\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    return new MergedStream(_ctxt, _in, _b, _ptr, _end);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return _originalStream;\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    return new Integer(section);\n}\n\n    /**\n     * Returns the default outline paint.\n     *\n     * @return The default outline paint.",
      "protected Comparable getSectionKey(int section)  {\n    // TO DO: implement this method\n    return null;\n}\n\n/**\n     * Returns the default paint for the sections.\n     *\n     * @return The default paint.\n     *\n     * @since 1.0.3",
      "protected Comparable getSectionKey(int section)  {\n    if (section >= 0 && section < this.dataset.getSeriesCount()) {\n        return this.dataset.getSeriesKey(section);\n    }\n}",
      "protected Comparable getSectionKey(int section)  {\n    return new Integer(section);\n}\n\n/**\n     * Returns the default paint for sections.\n     *\n     * @return The default paint.",
      "protected Comparable getSectionKey(int section)  {\n    // implement your code here\n}",
      "protected Comparable getSectionKey(int section)  {\n    // check if the section is within the range of the dataset\n    if (section < 0 || section >= dataset.getSeriesCount()) {\n        // generate a key\n}\n}",
      "protected Comparable getSectionKey(int section)  {\n    return new Integer(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    return new Integer(section);\n}",
      "protected Comparable getSectionKey(int section)  {\n    return new Integer(section);\n}\n\n/**\n     * Returns the default outline paint.\n     *\n     * @return The default outline paint.",
      "protected Comparable getSectionKey(int section)  {\n    return new Integer(section);\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            return Float.isNaN(_value) || Float.isInfinite(_value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Double.isNaN(_value) || Double.isInfinite(_value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Float.isNaN(_value) || Float.isInfinite(_value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Float.isNaN(_value) || Float.isInfinite(_value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Float.isNaN(_value) || Float.isInfinite(_value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Float.isNaN(_value) || Float.isInfinite(_value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Float.isNaN(_value) || Float.isInfinite(_value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Float.isNaN(_value) || Float.isInfinite(_value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Double.isNaN(_value) || Double.isInfinite(_value);\n        }",
      "@Override\n        public boolean isNaN()  {\n            return Double.isNaN(_value) || Double.isInfinite(_value);\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (ignoreCase) {\n        return endsWith(str, prefix, ignoreCase);\n    } else {\n        return CharSequenceUtils.regionMatches(str, 0, prefix, 0, prefix.length());\n    }\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (ignoreCase) {\n        return endsWith(str, prefix, ignoreCase);\n    } else {\n        return CharSequenceUtils.regionMatches(str, 0, prefix, 0, prefix.length());\n    }\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (ignoreCase) {\n        return endsWith(str, prefix, ignoreCase);\n    } else {\n        return CharSequenceUtils.regionMatches(str, 0, prefix, 0, prefix.length());\n    }\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (ignoreCase) {\n        return endsWith(str, prefix, ignoreCase);\n    } else {\n        return CharSequenceUtils.regionMatches(str, 0, prefix, 0, prefix.length());\n    }\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (ignoreCase) {\n        return endsWith(str, prefix, ignoreCase);\n    } else {\n        return CharSequenceUtils.regionMatches(str, 0, prefix, 0, prefix.length());\n    }\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (ignoreCase) {\n        return endsWith(str, prefix, ignoreCase);\n    } else {\n        return CharSequenceUtils.regionMatches(str, 0, prefix, 0, prefix.length());\n    }\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (ignoreCase) {\n        return endsWith(str, prefix, ignoreCase);\n    } else {\n        return CharSequenceUtils.regionMatches(str, 0, prefix, 0, prefix.length());\n    }\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = str.length() - prefix.length();\n    return ignoreCase ? CharSequenceUtils.regionMatches(str, true, strOffset, prefix, 0, prefix.length()) : str.startsWith(prefix);\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    final int strOffset = str.length() - prefix.length();\n    return CharSequenceUtils.regionMatches(str, ignoreCase, strOffset, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (ignoreCase) {\n        return endsWith(str, prefix, ignoreCase);\n    } else {\n        return CharSequenceUtils.regionMatches(str, 0, prefix, 0, prefix.length());\n    }\n}"
    ],
    [
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_STRING) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_BUFFERED;\n    return peekedString;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_STRING) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    return peekedString;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_STRING) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    String result = asDouble + \"\";\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_STRING) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    return peekedString;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_STRING) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_BUFFERED;\n    return peekedString;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_STRING) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a long but was \" + peekedString + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return peekedString;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_STRING) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_STRING) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a string but was \" + peekedString + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return peekedString;\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_STRING) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n  }",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_STRING) {\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return peekedString;\n    } else if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    try {\n      result = Integer.parseInt(peekedString);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return String.valueOf(result);\n    } catch (NumberFormatException ignored) {\n      // Fall back to parse as a double below.\n    }\n\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    result = (int) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n      throw new NumberFormatException(\"Expected a string but was \" + peekedString + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return String.valueOf(result);\n  }"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final String abrevMarker = \"...\";\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + abrevMarker;\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset + maxWidth - 3 < str.length()) {\n        return abrevMarker + abbreviate(str.substring(offset), maxWidth - 3);\n    }\n    return abrevMarker + str.substring(str.length() - (maxWidth - 3));\n}"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!ShapeUtilities.equal(s1[i], s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolFile) {\n      lastSymbolFile = symbolName;\n      Integer index = symbolFileMap.get(symbolName);\n      if (index != null) {\n        lastSymbolFileIndex = index;\n      } else {\n        lastSymbolFileIndex = symbolFileMap.size();\n        symbolFileMap.put(symbolName, lastSymbolFileIndex);\n      }\n    }\n    return lastSymbolFileIndex;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolFile) {\n      lastSymbolFile = symbolName;\n      Integer index = symbolFileMap.get(symbolName);\n      if (index != null) {\n        lastSymbolFileIndex = index;\n      } else {\n        lastSymbolFileIndex = symbolFileMap.size();\n        symbolFileMap.put(symbolName, lastSymbolFileIndex);\n      }\n    }\n    return lastSymbolFileIndex;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolFile) {\n      lastSymbolFile = symbolName;\n      Integer index = symbolFileMap.get(symbolName);\n      if (index != null) {\n        lastSymbolFileIndex = index;\n      } else {\n        lastSymbolFileIndex = symbolFileMap.size();\n        symbolFileMap.put(symbolName, lastSymbolFileIndex);\n      }\n    }\n    return lastSymbolFileIndex;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolFile) {\n      lastSymbolFile = symbolName;\n      Integer index = symbolNameMap.get(symbolName);\n      if (index != null) {\n        lastSymbolFileIndex = index;\n      } else {\n        lastSymbolFileIndex = symbolNameMap.size();\n        symbolNameMap.put(symbolName, lastSymbolFileIndex);\n      }\n    }\n    return lastSymbolFileIndex;\n  }\n\n  /**\n   * Returns either `symbol.getName()` (if `symbol` not null),\n   * or \"[null]\" if `symbol` is null.\n   *\n   * @since 2.9",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolFile) {\n      lastSymbolFile = symbolName;\n      Integer index = symbolFileMap.get(symbolName);\n      if (index != null) {\n        lastSymbolFileIndex = index;\n      } else {\n        lastSymbolFileIndex = symbolFileMap.size();\n        symbolFileMap.put(symbolName, lastSymbolFileIndex);\n      }\n    }\n    return lastSymbolFileIndex;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolFile) {\n      lastSymbolFile = symbolName;\n      Integer index = symbolFileMap.get(symbolName);\n      if (index != null) {\n        lastSymbolFileIndex = index;\n      } else {\n        lastSymbolFileIndex = symbolFileMap.size();\n        symbolFileMap.put(symbolName, lastSymbolFileIndex);\n      }\n    }\n    return lastSymbolFileIndex;\n  }",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolFile) {\n      lastSymbolFile = symbolName;\n      Integer index = symbolFileMap.get(symbolName);\n      if (index != null) {\n        lastSymbolFileIndex = index;\n      } else {\n        lastSymbolFileIndex = symbolFileMap.size();\n        symbolFileMap.put(symbolName, lastSymbolFileIndex);\n      }\n    }\n    return lastSymbolFileIndex;\n  }\n\n  /**\n   * Try to fold .charAt() calls on strings",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolFile) {\n      lastSymbolFile = symbolName;\n      Integer index = symbolNameMap.get(symbolName);\n      if (index != null) {\n        lastSymbolFileIndex = index;\n      } else {\n        lastSymbolFileIndex = symbolNameMap.size();\n        symbolNameMap.put(symbolName, lastSymbolFileIndex);\n      }\n    }\n    return lastSymbolFileIndex;\n  }\n\n  /**\n   * Returns either `symbol.getName()` (if `symbol` not null),\n   * or \"[null]\" if `symbol` is null.\n   *\n   * @since 2.9",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolFile) {\n      lastSymbolFile = symbolName;\n      Integer index = symbolFileMap.get(symbolName);\n      if (index != null) {\n        lastSymbolFileIndex = index;\n      } else {\n        lastSymbolFileIndex = symbolFileMap.size();\n        symbolFileMap.put(symbolName, lastSymbolFileIndex);\n      }\n    }\n    return lastSymbolFileIndex;\n  }\n\n  /**\n   * Returns either `symbol.getName()` (if `symbol` not null),\n   * or \"[null]\" if `symbol` is null.\n   *\n   * @since 2.9",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolFile) {\n      lastSymbolFile = symbolName;\n      Integer index = symbolNameMap.get(symbolName);\n      if (index != null) {\n        lastSymbolFileIndex = index;\n      } else {\n        lastSymbolFileIndex = symbolNameMap.size();\n        symbolNameMap.put(symbolName, lastSymbolFileIndex);\n      }\n    }\n    return lastSymbolFileIndex;\n  }\n\n  /**\n   * Try to fold .charAt() calls on strings"
    ],
    [
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        double result = Double.parseDouble(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a long below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a double but was \" + peekedString + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return asDouble;\n  }",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n    if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    try {\n      double result = Double.parseDouble(peekedString);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } catch (NumberFormatException ignored) {\n      // Fall back to parse as a long below.\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n  }\n\n  peeked = PEEKED_BUFFERED;\n  double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n  peekedString = null;\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return asDouble;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        double result = Double.parseDouble(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a long below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a double but was \" + peekedString + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return asDouble;\n  }",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n    if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    try {\n      double result = Double.parseDouble(peekedString);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } catch (NumberFormatException ignored) {\n      // Fall back to parse as a long below.\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n  }\n\n  peeked = PEEKED_BUFFERED;\n  double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n  long result = (long) asDouble;\n  if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n    throw new NumberFormatException(\"Expected a double but was \" + peekedString + locationString());\n  }\n  peekedString = null;\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return asDouble;\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n    if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    try {\n      double result = Double.parseDouble(peekedString);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } catch (NumberFormatException ignored) {\n      // Fall back to parse as a long below.\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n  }\n\n  peeked = PEEKED_BUFFERED;\n  double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n  long result = (long) asDouble;\n  if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n    throw new NumberFormatException(\"Expected a double but was \" + peekedString + locationString());\n  }\n  peekedString = null;\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return asDouble;\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n    if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    try {\n      double result = Double.parseDouble(peekedString);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } catch (NumberFormatException ignored) {\n      // Fall back to parse as a long below.\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n  }\n\n  peeked = PEEKED_BUFFERED;\n  double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n  long result = (long) asDouble;\n  if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n    throw new NumberFormatException(\"Expected a double but was \" + peekedString + locationString());\n  }\n  peekedString = null;\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return asDouble;\n}",
      "public double nextDouble() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_NUMBER) {\n    peekedString = new String(buffer, pos, peekedNumberLength);\n    pos += peekedNumberLength;\n  } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n    if (p == PEEKED_UNQUOTED) {\n      peekedString = nextUnquotedValue();\n    } else {\n      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    }\n    try {\n      double result = Double.parseDouble(peekedString);\n      peeked = PEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    } catch (NumberFormatException ignored) {\n      // Fall back to parse as a long below.\n    }\n  } else {\n    throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n  }\n\n  peeked = PEEKED_BUFFERED;\n  double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n  long result = (long) asDouble;\n  if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n    throw new NumberFormatException(\"Expected a double but was \" + peekedString + locationString());\n  }\n  peekedString = null;\n  peeked = PEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return asDouble;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        double result = Double.parseDouble(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a long below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a double but was \" + peekedString + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return asDouble;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        double result = Double.parseDouble(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a long below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a double but was \" + peekedString + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return asDouble;\n  }",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_NUMBER) {\n      peekedString = new String(buffer, pos, peekedNumberLength);\n      pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n      if (p == PEEKED_UNQUOTED) {\n        peekedString = nextUnquotedValue();\n      } else {\n        peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n      }\n      try {\n        double result = Double.parseDouble(peekedString);\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n      } catch (NumberFormatException ignored) {\n        // Fall back to parse as a long below.\n      }\n    } else {\n      throw new IllegalStateException(\"Expected a number but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    long result = (long) asDouble;\n    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n      throw new NumberFormatException(\"Expected a double but was \" + peekedString + locationString());\n    }\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return asDouble;\n  }"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final StringBuilder buf = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final StringBuilder buf = new StringBuilder(repeat * str.length());\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  /**\n     * <p>Right pad a String with a specified String.</p>\n     *\n     * <p>The String is padded to the size of {@code size}.</p>\n     *\n     * <pre>\n     * StringUtils.rightPad(null, *, *)      = null\n     * StringUtils.rightPad(\"\", 3, \"z\")      = \"zzz\"\n     * StringUtils.rightPad(\"bat\", 3, \"yz\")  = \"bat\"\n     * StringUtils.rightPad(\"bat\", 5, \"yz\")  = \"batyz\"\n     * StringUtils.rightPad(\"bat\", 8, \"yz\")  = \"batyzyzy\"\n     * StringUtils.rightPad(\"bat\", 1, \"yz\")  = \"bat\"\n     * StringUtils.rightPad(\"bat\", -1, \"yz\") = \"bat\"\n     * StringUtils.rightPad(\"bat\", 5, null)  = \"bat  \"\n     * StringUtils.rightPad(\"bat\", 5, \"\")    = \"bat  \"\n     * </pre>\n     *\n     * @param str  the String to pad out, may be null\n     * @param size  the size to pad to\n     * @param padStr  the String to pad with, null or empty treated as single space\n     * @return right padded String or original String if no padding is necessary,\n     *  {@code null} if null String input",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final StringBuilder buf = new StringBuilder(repeat * str.length());\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final StringBuilder buf = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final StringBuilder buf = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  /**\n     * <p>Repeat a String {@code repeat} times to form a\n     * new String, with a String separator injected each time.</p>\n     *\n     * <pre>\n     * StringUtils.repeat(null, null, 2) = null\n     * StringUtils.repeat(null, \"x\", 2)  = null\n     * StringUtils.repeat(\"\", null, 0)   = \"\"\n     * StringUtils.repeat(\"\", \"\", 2)     = \"\"\n     * StringUtils.repeat(\"\", \"x\", 3)    = \"xxx\"\n     * StringUtils.repeat(\"?\", \", \", 3)  = \"?, ?, ?\"\n     * </pre>\n     *\n     * @param str        the String to repeat, may be null\n     * @param separator  the String to inject, may be null\n     * @param repeat     number of times to repeat str, negative treated as zero\n     * @return a new String consisting of the original String repeated,\n     *  {@code null} if null String input",
      "public static String repeat(final String str, final int repeat)  /**\n     * <p>Repeat a String {@code repeat} times to form a\n     * new String, with a String separator injected each time.</p>\n     *\n     * <pre>\n     * StringUtils.repeat(null, null, 2) = null\n     * StringUtils.repeat(null, \"x\", 2)  = null\n     * StringUtils.repeat(\"\", null, 0)   = \"\"\n     * StringUtils.repeat(\"\", \"\", 2)     = \"\"\n     * StringUtils.repeat(\"\", \"x\", 3)    = \"xxx\"\n     * StringUtils.repeat(\"?\", \", \", 3)  = \"?, ?, ?\"\n     * </pre>\n     *\n     * @param str        the String to repeat, may be null\n     * @param separator  the String to inject, may be null\n     * @param repeat     number of times to repeat str, negative treated as zero\n     * @return a new String consisting of the original String repeated,\n     *  {@code null} if null String input\n     * @since 2.5",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final StringBuilder buf = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return \"\";\n    }\n    final StringBuilder buf = new StringBuilder();\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    try {\n        return (ZipExtraField) Class.forName(\"org.apache.commons.compress.archivers.zip.\" +\n                headerId.getValue() + \"ExtraField\").newInstance();\n    } catch (ClassNotFoundException e) {\n        return new UnrecognizedExtraField();\n    }\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    try {\n        return (ZipExtraField) Class.forName(\"com.packt.zip.extrafields.\" + headerId.toString()).newInstance();\n    } catch (ClassNotFoundException e) {\n        return new UnrecognizedExtraField();\n    }\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    try {\n        return (ZipExtraField) Class.forName(\"com.packt.zip.\" + headerId.getValue())\n                .newInstance();\n    } catch (final ClassNotFoundException e) {\n        return new UnrecognizedExtraField();\n    }\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    try {\n        return (ZipExtraField) Class.forName(\"archivers.zip.extrafields.\" + headerId.getValue() + \"ExtraField\").newInstance();\n    } catch (final ClassNotFoundException e) {\n        return new UnrecognizedExtraField();\n    }\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    try {\n        return (ZipExtraField) Class.forName(\"com.example.\" + headerId.getValue()).newInstance();\n    } catch (final ClassNotFoundException e) {\n        return new UnrecognizedExtraField();\n    }\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    try {\n        return (ZipExtraField) Class.forName(\"com.packt.extrafields.\" + headerId.toString()).newInstance();\n    } catch (final ClassNotFoundException e) {\n        return new UnrecognizedExtraField();\n    }\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    try {\n        return (ZipExtraField) Class.forName(\"archivers.zip.\" + headerId.getValue())\n                .newInstance();\n    } catch (final ClassNotFoundException e) {\n        return new UnrecognizedExtraField();\n    }\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    try {\n        return (ZipExtraField) Class.forName(\"com.example.\" + headerId.getValue()).newInstance();\n    } catch (final ClassNotFoundException e) {\n        return new UnrecognizedExtraField();\n    }\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    try {\n        return (ZipExtraField) Class.forName(\"com.packt.zip.extrafields.\" + headerId.getValue()).newInstance();\n    } catch (final ClassNotFoundException e) {\n        return new UnrecognizedExtraField();\n    }\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    try {\n        return (ZipExtraField) Class.forName(\"archivers.zip.extrafields.\" + headerId.toString()).newInstance();\n    } catch (ClassNotFoundException e) {\n        return new UnrecognizedExtraField();\n    }\n}"
    ],
    [
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (str == null || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (str == null || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }",
      "public static int count(final String str, final String... set)  {\n        if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n            return 0;\n        }\n        final CharSet chars = CharSet.getInstance(set);\n        int count = 0;\n        for (final char c : str.toCharArray()) {\n            if (chars.contains(c)) {\n                count++;\n            }\n        }\n        return count;\n    }"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Object value = map.get(key);\n        if (value instanceof PublicCloneable) {\n            value = ((PublicCloneable) value).clone();\n        }\n        result.put(key, value);\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Map value = (Map) map.get(key);\n        Map cloneValue = (Map) cloneMarkerMap(value);\n        clone.put(key, cloneValue);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Object value = map.get(key);\n        if (value instanceof PublicCloneable) {\n            value = ((PublicCloneable) value).clone();\n        }\n        result.put(key, value);\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Map value = (Map) map.get(key);\n        Map clone = (Map) clone(value);\n        result.put(key, clone);\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Object value = map.get(key);\n        if (value instanceof PublicCloneable) {\n            value = ((PublicCloneable) value).clone();\n        }\n        clone.put(key, value);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Object value = map.get(key);\n        if (value instanceof PublicCloneable) {\n            value = ((PublicCloneable) value).clone();\n        }\n        result.put(key, value);\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Object value = map.get(key);\n        if (value instanceof PublicCloneable) {\n            value = ((PublicCloneable) value).clone();\n        }\n        result.put(key, value);\n    }\n    return result;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        clone.put(key, clone((Map) map.get(key)));\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        clone.put(key, clone((Map) map.get(key)));\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map result = new HashMap();\n    Set keys = map.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Map.Entry entry = (Map.Entry) map.entrySet().iterator().next();\n        result.put(key, entry.getValue());\n    }\n    return result;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryDataLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        rangeCheck(index, size + 1);\n        checkModCount();\n        boolean changed = false;\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E obj = i.next();\n            if (!contains(obj)) {\n                parent.add(index + offset, obj);\n                expectedModCount = parent.modCount;\n                size++;\n                LinkedSubList.this.modCount++;\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        if (index < 0 || index > size) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);\n        }\n        boolean changed = false;\n        for (final E e : coll) {\n            if (!contains(e)) {\n                parent.add(index++, e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        rangeCheck(index, size + coll.size());\n        checkModCount();\n        boolean changed = false;\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E obj = i.next();\n            if (!contains(obj)) {\n                parent.add(index++, obj);\n                changed = true;\n            }\n        }\n        expectedModCount = parent.modCount;\n        size += coll.size();\n        LinkedSubList.this.modCount++;\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        if (index < 0 || index > size) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);\n        }\n        boolean changed = false;\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E obj = i.next();\n            if (!contains(obj)) {\n                parent.add(index++, obj);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        if (index < 0 || index > size) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        boolean changed = false;\n        int i = 0;\n        for (final E e : coll) {\n            if (!contains(e)) {\n                parent.add(index + i++, e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        if (index < 0 || index > size()) {\n            throw new IndexOutOfBoundsException();\n        }\n        boolean changed = false;\n        for (final E e : coll) {\n            if (!contains(e)) {\n                parent.add(index++, e);\n                changed = true;\n            }\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        rangeCheck(index, size + 1);\n        checkModCount();\n        boolean changed = false;\n        for (final E e : coll) {\n            if (!contains(e)) {\n                parent.add(index++, e);\n                changed = true;\n            }\n        }\n        expectedModCount = parent.modCount;\n        size += coll.size();\n        LinkedSubList.this.modCount++;\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        rangeCheck(index, size + coll.size());\n        checkModCount();\n        boolean changed = false;\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E obj = i.next();\n            if (!contains(obj)) {\n                parent.add(index + offset, obj);\n                changed = true;\n            }\n        }\n        expectedModCount = parent.modCount;\n        size += coll.size();\n        LinkedSubList.this.modCount++;\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        rangeCheck(index, size + coll.size());\n        checkModCount();\n        boolean changed = false;\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E obj = i.next();\n            if (!contains(obj)) {\n                parent.add(index++, obj);\n                changed = true;\n            }\n        }\n        expectedModCount = parent.modCount;\n        size += coll.size();\n        LinkedSubList.this.modCount++;\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        rangeCheck(index, size + coll.size());\n        checkModCount();\n        boolean changed = false;\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E obj = i.next();\n            if (!contains(obj)) {\n                parent.add(index + offset, obj);\n                changed = true;\n            }\n        }\n        expectedModCount = parent.modCount;\n        size += coll.size();\n        LinkedSubList.this.modCount++;\n        return changed;\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  {\n    return f.value(x);\n}\n\n/**\n * @param f Function.\n * @param x Argument.\n * @return Derivative of f at x.",
      "private double eval(UnivariateFunction f, double x)  {\n    return f.value(x);\n}\n\n/**\n * @param f Function.\n * @param x Argument.\n * @return Derivative of f at x.\n * @throws TooManyEvaluationsException if the maximal number of evaluations is\n * exceeded.",
      "private double eval(UnivariateFunction f, double x)  {\n    return f.value(x);\n}\n\n/**\n * @param f Function.\n * @param x Argument.\n * @return Derivative of f at x.",
      "private double eval(UnivariateFunction f, double x)  {\n    return f.value(x);\n}\n\n/**\n * @param f Function.\n * @param x Argument.\n * @return Derivative of f at x.",
      "private double eval(UnivariateFunction f, double x)  {\n    return f.value(x);\n}\n\n/**\n * @param f Function.\n * @param x Argument.\n * @return {@code f'(x)}",
      "private double eval(UnivariateFunction f, double x)  {\n    return f.value(x);\n}\n\n/**\n * @param f Function.\n * @param x Argument.\n * @return Derivative of f at x.\n * @throws TooManyEvaluationsException if the maximal number of evaluations is\n     * exceeded.",
      "private double eval(UnivariateFunction f, double x)  {\n    return f.value(x);\n}\n\n/**\n * @param f Function.\n * @param x Argument.\n * @return Derivative of f at x.",
      "private double eval(UnivariateFunction f, double x)  {\n    return f.value(x);\n}\n\n/**\n * @param f Function.\n * @param x Argument.\n * @return {@code f'(x)}",
      "private double eval(UnivariateFunction f, double x)  {\n    return f.value(x);\n}\n\n/**\n * @param f Function.\n * @param x Argument.\n * @return Derivative of f at x.\n * @throws TooManyEvaluationsException if the maximal number of evaluations is\n * exceeded.",
      "private double eval(UnivariateFunction f, double x)  {\n    return f.value(x);\n}\n\n/**\n * @param f Function.\n * @param x Argument.\n * @return Derivative of f at x.\n * @throws TooManyEvaluationsException if the maximal number of evaluations is\n     * exceeded."
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            double[] coefficients = constraint.getCoefficients().toArray();\n            double value = -constraint.getValue();\n            Relationship relationship = constraint.getRelationship().oppositeRelationship();\n            normalizedConstraints.add(new LinearConstraint(coefficients, relationship, value));\n        } else {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            double[] coefficients = constraint.getCoefficients().toArray();\n            double value = -constraint.getValue();\n            Relationship relationship = constraint.getRelationship().oppositeRelationship();\n            normalizedConstraints.add(new LinearConstraint(coefficients, relationship, value));\n        } else {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> newConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            newConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                    constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()));\n        } else {\n            newConstraints.add(constraint);\n        }\n    }\n    return newConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            double[] coefficients = constraint.getCoefficients().toArray();\n            double value = -constraint.getValue();\n            Relationship relationship = constraint.getRelationship().oppositeRelationship();\n            normalizedConstraints.add(new LinearConstraint(coefficients, relationship, value));\n        } else {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                        constraint.getRelationship().oppositeRelationship(),\n                                        -1 * constraint.getValue()));\n        } else {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> newConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            newConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                    constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()));\n        } else {\n            newConstraints.add(constraint);\n        }\n    }\n    return newConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> newConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            newConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                    constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()));\n        } else {\n            newConstraints.add(constraint);\n        }\n    }\n    return newConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                    constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()));\n        } else {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            normalizedConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                    constraint.getRelationship().oppositeRelationship(), -1 * constraint.getValue()));\n        } else {\n            normalizedConstraints.add(constraint);\n        }\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> newConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        if (constraint.getValue() < 0) {\n            newConstraints.add(new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                                   constraint.getRelationship().oppositeRelationship(),\n                                                   -1 * constraint.getValue()));\n        } else {\n            newConstraints.add(constraint);\n        }\n    }\n    return newConstraints;\n}"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound) {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound) {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound) {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound) {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound) {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound) {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound) {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound) {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound) {\n        return true;\n    }\n    return false;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        return false;\n    }\n    if (this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound) {\n        return true;\n    }\n    return false;\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    while (i < len) {\n        if (Character.isWhitespace(str.charAt(i))) {\n            if (match || camelCase) {\n                lastMatch = true;\n                if (list.size() == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        lastMatch = false;\n        match = true;\n        i++;\n    }\n    if (match || camelCase && lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    if (camelCase) {\n        while (i < len) {\n            if (Character.isUpperCase(str.charAt(i))) {\n                if (match || lastMatch) {\n                    list.add(str.substring(start, i));\n                    match = false;\n                    lastMatch = true;\n                }\n                start = ++i;\n                continue;\n            }\n            lastMatch = false;\n            match = true;\n            i++;\n        }\n        if (match || lastMatch) {\n            list.add(str.substring(start, i));\n        }\n    } else {\n        while (i < len) {\n            if (Character.isWhitespace(str.charAt(i)) || Character.isLetter(str.charAt(i))) {\n                if (match || lastMatch) {\n                    list.add(str.substring(start, i));\n                    match = false;\n                    lastMatch = true;\n                }\n                start = ++i;\n                continue;\n            }\n            lastMatch = false;\n            match = true;\n            i++;\n        }\n        if (match || lastMatch) {\n            list.add(str.substring(start, i));\n        }\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    while (i < len) {\n        if (Character.isWhitespace(str.charAt(i))) {\n            if (match || camelCase) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        if (Character.isLetter(str.charAt(i))) {\n            if (Character.isUpperCase(str.charAt(i))) {\n                if (match || camelCase) {\n                    lastMatch = true;\n                    if (sizePlus1++ == max) {\n                        i = len;\n                        lastMatch = false;\n                    }\n                    list.add(str.substring(start, i));\n                    match = false;\n                }\n                start = ++i;\n                continue;\n            }\n        }\n        lastMatch = false;\n        match = true;\n        i++;\n    }\n    if (match || camelCase && lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    while (i < len) {\n        if (Character.isWhitespace(str.charAt(i))) {\n            if (match || camelCase) {\n                lastMatch = true;\n                if (list.size() + 1 == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        lastMatch = false;\n        match = true;\n        i++;\n    }\n    if (match || camelCase && lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    if (str.charAt(0) == Character.UPPERCASE_LETTER) {\n        list.add(String.valueOf(str.charAt(0)));\n        start = 1;\n        match = true;\n        lastMatch = true;\n    }\n    while (i < len) {\n        if (Character.isLetter(str.charAt(i))) {\n            if (match || camelCase) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        lastMatch = false;\n        match = true;\n        i++;\n    }\n    if (match || camelCase && lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    while (i < len) {\n        if (Character.isWhitespace(str.charAt(i))) {\n            if (match || camelCase) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        lastMatch = false;\n        match = true;\n        i++;\n    }\n    if (match || camelCase && lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    if (camelCase) {\n        while (i < len) {\n            if (Character.isUpperCase(str.charAt(i))) {\n                if (match || lastMatch) {\n                    list.add(str.substring(start, i));\n                    match = false;\n                    lastMatch = true;\n                }\n                start = ++i;\n                continue;\n            }\n            if (Character.isLowerCase(str.charAt(i))) {\n                lastMatch = false;\n                match = true;\n                i++;\n                continue;\n            }\n            if (Character.isTitleCase(str.charAt(i))) {\n                if (match || lastMatch) {\n                    list.add(str.substring(start, i));\n                    match = false;\n                    lastMatch = true;\n                }\n                start = ++i;\n                continue;\n            }\n            lastMatch = false;\n            match = true;\n            i++;\n        }\n        if (match || lastMatch) {\n            list.add(str.substring(start, i));\n        }\n    } else {\n        while (i < len) {\n            if (Character.isWhitespace(str.charAt(i))) {\n                if (match || lastMatch) {\n                    list.add(str.substring(start, i));\n                    match = false;\n                    lastMatch = true;\n                }\n                start = ++i;\n                continue;\n            }\n            lastMatch = false;\n            match = true;\n            i++;\n        }\n        if (match || lastMatch) {\n            list.add(str.substring(start, i));\n        }\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    while (i < len) {\n        if (Character.isWhitespace(str.charAt(i))) {\n            if (match || camelCase) {\n                lastMatch = true;\n                if (list.size() + 1 == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        if (Character.isLetter(str.charAt(i))) {\n            if (Character.isUpperCase(str.charAt(i))) {\n                if (match || camelCase) {\n                    lastMatch = true;\n                    if (list.size() + 1 == max) {\n                        i = len;\n                        lastMatch = false;\n                    }\n                    list.add(str.substring(start, i));\n                    match = false;\n                }\n                start = ++i;\n                continue;\n            }\n            if (match || camelCase) {\n                lastMatch = true;\n                if (list.size() + 1 == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        lastMatch = false;\n        match = true;\n        i++;\n    }\n    if (match || camelCase && lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    if (str.charAt(0) == ' ') {\n        start = 1;\n    }\n    while (i < len) {\n        if (Character.isWhitespace(str.charAt(i))) {\n            if (match || camelCase) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        lastMatch = false;\n        match = true;\n        i++;\n    }\n    if (match || camelCase && lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    boolean match = false;\n    boolean lastMatch = false;\n    while (i < len) {\n        if (Character.isWhitespace(str.charAt(i))) {\n            if (match || camelCase) {\n                lastMatch = true;\n                if (sizePlus1++ == max) {\n                    i = len;\n                    lastMatch = false;\n                }\n                list.add(str.substring(start, i));\n                match = false;\n            }\n            start = ++i;\n            continue;\n        }\n        if (Character.isLetter(str.charAt(i))) {\n            if (Character.isUpperCase(str.charAt(i))) {\n                if (match || camelCase) {\n                    lastMatch = true;\n                    if (sizePlus1++ == max) {\n                        i = len;\n                        lastMatch = false;\n                    }\n                    list.add(str.substring(start, i));\n                    match = false;\n                }\n                start = ++i;\n                continue;\n            }\n        }\n        lastMatch = false;\n        match = true;\n        i++;\n    }\n    if (match || camelCase && lastMatch) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}"
    ],
    [
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = ISOChronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, Locale.getDefault(), 1970, 1970);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  /**\n     * Parses a period from the given text, returning a new MutablePeriod.\n     *\n     * @param text  text to parse\n     * @return parsed value in a MutablePeriod object\n     * @throws IllegalArgumentException if any field is out of range",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = ISOChronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, Locale.getDefault(), 0, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = ISOChronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, Locale.getDefault(), 0, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = ISOChronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, Locale.getDefault(), 0, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  /**\n     * Parses a period from the given text, returning a new MutablePeriod.\n     *\n     * @param text  text to parse\n     * @return parsed value in a MutablePeriod object\n     * @throws IllegalArgumentException if any field is out of range",
      "public long parseMillis(String text)  /**\n     * Parses a period from the given text, returning a new MutablePeriod.\n     *\n     * @param text  text to parse\n     * @return parsed value in a MutablePeriod object\n     * @throws IllegalArgumentException if any field is out of range",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = ISOChronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, Locale.getDefault(), 1970, 1970);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = ISOChronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, Locale.getDefault(), 0, 0);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  /**\n     * Parses a period from the given text, returning a new MutablePeriod.\n     *\n     * @param text  text to parse\n     * @return parsed value in a MutablePeriod object\n     * @throws IllegalArgumentException if any field is out of range"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  ",
      "static MinimizedCondition unoptimized(Node n)  {\n    return new MinimizedCondition(\n        new MeasuredNode(n, 0),\n        new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE));\n}",
      "static MinimizedCondition unoptimized(Node n)  ",
      "static MinimizedCondition unoptimized(Node n)  {\n    return new MinimizedCondition(\n        new MeasuredNode(new Node(n.getType()), new Node(Token.SCRIPT)),\n        new MeasuredNode(new Node(Token.SCRIPT), new Node(Token.SCRIPT)));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    return new MinimizedCondition(\n        new MeasuredNode(n.cloneTree(), 0),\n        new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    return new MinimizedCondition(\n        new MeasuredNode(new Node(n.getType()).srcref(n), new Node(Token.SCRIPT).srcref(n)),\n        new MeasuredNode(new Node(Token.SCRIPT).srcref(n), new Node(Token.SCRIPT).srcref(n)));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    return new MinimizedCondition(\n        new MeasuredNode(new Node(Token.SCRIPT), new Node(Token.SCRIPT)),\n        new MeasuredNode(new Node(Token.SCRIPT), new Node(Token.SCRIPT)));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    return new MinimizedCondition(\n        new MeasuredNode(new Node(n.getType()), n),\n        new MeasuredNode(new Node(Token.SCRIPT), n));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    return new MinimizedCondition(\n        new MeasuredNode(n, 0),\n        new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE));\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    return new MinimizedCondition(\n        new MeasuredNode(new Node(Token.SCRIPT), 1000000),\n        new MeasuredNode(new Node(Token.SCRIPT), 1000000));\n}"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E constant : condensed) {\n        result[constant.ordinal() / Long.SIZE] |= 1 << (constant.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    Validate.notNull(enumClass);\n    Validate.notNull(values);\n    asEnum(enumClass);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E constant : condensed) {\n        final int block = constant.ordinal() / Long.SIZE;\n        result[block] |= 1 << (constant.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    Validate.notNull(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E constant : condensed) {\n        result[constant.ordinal() / Long.SIZE] |= 1 << (constant.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    Validate.notNull(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E constant : condensed) {\n        final int block = constant.ordinal() / Long.SIZE;\n        result[block] |= 1 << (constant.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    Validate.notNull(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E constant : condensed) {\n        final int block = constant.ordinal() / Long.SIZE;\n        result[block] |= 1 << (constant.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E constant : condensed) {\n        final int block = constant.ordinal() / Long.SIZE;\n        result[block] |= 1 << (constant.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    Validate.notNull(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E constant : condensed) {\n        final int block = constant.ordinal() / Long.SIZE;\n        result[block] |= 1 << (constant.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    Validate.notNull(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E constant : condensed) {\n        final int block = constant.ordinal() / Long.SIZE;\n        result[block] |= 1 << (constant.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    Validate.notNull(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E constant : condensed) {\n        result[constant.ordinal() / Long.SIZE] |= 1 << (constant.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getDepth();\n    } else if (scope.isPropertyScope()) {\n        int depth = 0;\n        SymbolScope parent = scope.getParentScope();\n        while (parent != null && !parent.isLexicalScope()) {\n            depth++;\n            parent = parent.getParentScope();\n        }\n        return depth + parent.getDepth();\n    } else {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getDepth();\n    } else if (scope.isPropertyScope()) {\n        int depth = 0;\n        while (!scope.isLexicalScope()) {\n            depth++;\n            scope = scope.getParentScope();\n        }\n        return depth + scope.getDepth();\n    } else {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n        SymbolScope lexicalScope = scope.getLexicalScope();\n        return lexicalScope.getScopeDepth() + 1;\n    } else {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getDepth();\n    } else if (scope.isPropertyScope()) {\n        int depth = 0;\n        while (!scope.isLexicalScope()) {\n            depth++;\n            scope = scope.getParentScope();\n        }\n        return depth + scope.getDepth();\n    } else {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n        SymbolScope lexicalScope = scope.getLexicalScope();\n        return lexicalScope.getScopeDepth() + 1;\n    } else {\n        return 0;\n    }\n}\n\n/**\n * Try to fold .split() calls on strings",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n        int depth = 0;\n        SymbolScope current = scope;\n        while (!current.isLexicalScope()) {\n            depth++;\n            current = current.getParentScope();\n        }\n        return depth + current.getScopeDepth();\n    } else {\n        return 0;\n    }\n}\n\n/**\n * Try to fold .split() calls on strings",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n        int depth = 0;\n        SymbolScope parent = scope.getParentScope();\n        while (parent != null && !parent.isLexicalScope()) {\n            depth++;\n            parent = parent.getParentScope();\n        }\n        return depth + parent.getScopeDepth();\n    } else {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n        SymbolScope lexicalScope = scope.getLexicalScope();\n        return lexicalScope.getScopeDepth() + 1;\n    } else {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n        int depth = 0;\n        while (!scope.isLexicalScope()) {\n            depth++;\n            scope = scope.getParentScope();\n        }\n        return depth + scope.getScopeDepth();\n    } else {\n        return 0;\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isLexicalScope()) {\n        return scope.getScopeDepth();\n    } else if (scope.isPropertyScope()) {\n        int depth = 0;\n        while (!scope.isLexicalScope()) {\n            depth++;\n            scope = scope.getParentScope();\n        }\n        return depth + scope.getScopeDepth();\n    } else {\n        return 0;\n    }\n}"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rows; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}\n\n/**\n * Create a data array in blocks layout.\n * <p>\n * This method can be used to create the array argument of the {@link\n * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n * </p>\n * @param rows Number of rows in the new matrix.\n * @param columns Number of columns in the new matrix.\n * @return a new data array in blocks layout.\n * @see #toBlocksLayout(double[][])\n * @see #BlockRealMatrix(int, int, double[][], boolean)",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}\n\n/**\n * Create a data array in blocks layout.\n * <p>\n * This method can be used to create the array argument of the {@link\n * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n * </p>\n * @param rows Number of rows in the new matrix.\n * @param columns Number of columns in the new matrix.\n * @return a new data array in blocks layout.\n * @see #toBlocksLayout(double[][])\n * @see #BlockRealMatrix(int, int, double[][], boolean)",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows = rawData.length;\n    final int columns = rawData[0].length;\n    final int blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rows; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, \"NULL_ELEMENTS_NOT_PERMITTED\");\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, \"Enum value cannot be null\");\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, \"NULL_ELEMENTS_NOT_PERMITTED\");\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, \"NULL_ELEMENTS_NOT_PERMITTED\");\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, \"NULL_ELEMENTS_NOT_PERMITTED\");\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, \"Enum value cannot be null\");\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1 << value.ordinal();\n    }\n    return result;\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp c = a;\n    Dfp y = new Dfp(one);\n    Dfp x = new Dfp(one);\n    Dfp fact = new Dfp(one);\n\n    for (int i = 1; i < 10000; i++) {\n        x = x.multiply(c);\n        y = y.add(x.divide(fact));\n        fact = fact.multiply(new Dfp(i));\n        if (y.equals(new Dfp(y))) {\n            break;\n        }\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getField().getOne();\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a.add(a);\n    c = c.multiply(c);\n\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 1; i < 90; i++) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide(i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp x = a;\n    Dfp y = new Dfp(a.getField(), 1);\n    Dfp c = new Dfp(a.getField(), 1);\n    Dfp fact = new Dfp(a.getField(), 1);\n    Dfp py = new Dfp(y);\n\n    for (int i = 1; i < 10000; i++) {\n        x = x.multiply(a);\n        y = y.add(x.divide(fact));\n        fact = fact.multiply(new Dfp(a.getField(), i+1));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getField().getOne();\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a.add(a);\n    c = c.multiply(c);\n\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 1; i < 90; i++) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i - 1) * i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp x = a;\n    Dfp y = a;\n    Dfp c = a.multiply(a);\n    Dfp fact = a.getOne();\n    Dfp py = new Dfp(y);\n\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i - 1) * i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp x = a;\n    Dfp y = a;\n    Dfp c = a.multiply(a);\n    Dfp fact = a.getOne();\n    Dfp py = new Dfp(y);\n\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i - 1) * i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp x = a;\n    Dfp y = a;\n    Dfp c = a.multiply(a);\n    Dfp fact = a.getOne();\n    Dfp py = new Dfp(y);\n\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i - 1) * i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getOne();\n    Dfp x = one;\n    Dfp y = one;\n    Dfp c = a.add(a.getOne());\n    c = c.multiply(c);\n\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 2; i < 90; i += 2) {\n        x = x.multiply(c);\n        x = x.negate();\n\n        fact = fact.divide((i - 1) * i);  // 1 over fact\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp c = a;\n    Dfp y = new Dfp(one);\n    Dfp py = new Dfp(one);\n    Dfp f = new Dfp(one);\n    Dfp fi = new Dfp(one);\n    Dfp x = new Dfp(one);\n\n    for (int i = 0; i < 10000; i++) {\n        x = x.multiply(c);\n        y = y.add(x.divide(f));\n        fi = fi.add(one);\n        f = f.multiply(fi);\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp c = a;\n    Dfp y = one;\n    Dfp x = one;\n    Dfp fact = one;\n    Dfp py = new Dfp(y);\n\n    for (int i = 1; i < 10000; i++) {\n        x = x.multiply(c);\n        y = y.add(x.divide(fact));\n        fact = fact.multiply((i + 1));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n}"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x) <= threshold) {\n        double inverse = 1 / FastMath.sqrt(y * y + z * z);\n        return new FieldVector3D<>(0, inverse * z, -inverse * y);\n    } else if (FastMath.abs(y) <= threshold) {\n        double inverse = 1 / FastMath.sqrt(x * x + z * z);\n        return new FieldVector3D<>(-inverse * z, 0, inverse * x);\n    }\n    double inverse = 1 / FastMath.sqrt(x * x + y * y);\n    return new FieldVector3D<>(inverse * y, -inverse * x, 0);\n}"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = maximum;\n    T max = minimum;\n    if (other.minimum.compareTo(minimum) < 0) {\n        min = other.minimum;\n    }\n    if (other.maximum.compareTo(maximum) > 0) {\n        max = other.maximum;\n    }\n    return Range.between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"The ranges do not overlap\");\n    }\n    final T min = Math.max(minimum, other.minimum);\n    final T max = Math.min(maximum, other.maximum);\n    return between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = maximum;\n    T max = minimum;\n    if (other.minimum.compareTo(minimum) < 0) {\n        min = other.minimum;\n    }\n    if (other.maximum.compareTo(maximum) > 0) {\n        max = other.maximum;\n    }\n    return Range.between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"The ranges do not overlap\");\n    }\n    T min = maximum;\n    T max = minimum;\n    if (other.minimum.compareTo(minimum) < 0) {\n        min = other.minimum;\n    }\n    if (other.maximum.compareTo(maximum) > 0) {\n        max = other.maximum;\n    }\n    return between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = maximum;\n    T max = minimum;\n    if (other.minimum.compareTo(minimum) < 0) {\n        min = other.minimum;\n    }\n    if (other.maximum.compareTo(maximum) > 0) {\n        max = other.maximum;\n    }\n    return Range.between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = maximum;\n    T max = minimum;\n    if (other.minimum.compareTo(minimum) < 0) {\n        min = other.minimum;\n    }\n    if (other.maximum.compareTo(maximum) > 0) {\n        max = other.maximum;\n    }\n    return Range.between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    final T min = Math.max(minimum, other.minimum);\n    final T max = Math.min(maximum, other.maximum);\n    return between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    T min = maximum;\n    T max = minimum;\n    if (other.minimum.compareTo(minimum) < 0) {\n        min = other.minimum;\n    }\n    if (other.maximum.compareTo(maximum) > 0) {\n        max = other.maximum;\n    }\n    return Range.between(min, max, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    return new Range<T>(Math.max(minimum, other.minimum), Math.min(maximum, other.maximum), comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        return this;\n    }\n    if (!isOverlappedBy(other)) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    return new Range<>(Math.max(minimum, other.minimum), Math.min(maximum, other.maximum), comparator);\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8Generator(out, ctxt);\n}\n    /**\n     * Method for constructing JSON generator for writing JSON content\n     * using specified Writer.\n     *<p>\n     * Underlying stream <b>is NOT owned</b> by the generator constructed,\n     * so that generator will NOT close the Reader when\n     * {@link JsonGenerator#close} is called (unless auto-closing\n     * feature,\n     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature#AUTO_CLOSE_TARGET} is enabled).\n     * Using application needs to close it explicitly.\n     * \n     * @since 2.1\n     *\n     * @param w Writer to use for writing JSON content \n     */",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8Generator(out, ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8Generator(ctxt, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8Generator(out, ctxt);\n}\n    /**\n     * Method for constructing JSON generator for writing JSON content\n     * using specified Writer.\n     *<p>\n     * Underlying stream <b>is NOT owned</b> by the generator constructed,\n     * so that generator will NOT close the Reader when\n     * {@link JsonGenerator#close} is called (unless auto-closing\n     * feature,\n     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature#AUTO_CLOSE_TARGET} is enabled).\n     * Using application needs to close it explicitly.\n     * \n     * @since 2.1\n     *\n     * @param w Writer to use for writing JSON content \n     */",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8Generator(ctxt, out);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8Generator(out, ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8Generator(out, ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8Generator(ctxt, out);\n}\n    /**\n     * Method for constructing JSON generator for writing JSON content\n     * using specified output stream.\n     * Encoding to use must be specified, and needs to be one of available\n     * types (as per JSON specification).\n     *<p>\n     * Underlying stream <b>is NOT owned</b> by the generator constructed,\n     * so that generator will NOT close the output stream when\n     * {@link JsonGenerator#close} is called (unless auto-closing\n     * feature,\n     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature#AUTO_CLOSE_TARGET} is enabled).\n     * Using application needs to close it explicitly if this is the case.\n     *<p>\n     * Note: there are formats that use fixed encoding (like most binary data formats)\n     * and that ignore passed in encoding.\n     *\n     * @param out OutputStream to use for writing JSON content \n     * @param enc Character encoding to use\n     * \n     * @since 2.1\n     */",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8Generator(out, ctxt);\n}\n    /**\n     * Method for constructing JSON generator for writing JSON content\n     * using specified Writer.\n     *<p>\n     * Underlying stream <b>is NOT owned</b> by the generator constructed,\n     * so that generator will NOT close the Reader when\n     * {@link JsonGenerator#close} is called (unless auto-closing\n     * feature,\n     * {@link com.fasterxml.jackson.core.JsonGenerator.Feature#AUTO_CLOSE_TARGET} is enabled).\n     * Using application needs to close it explicitly.\n     * \n     * @since 2.1\n     *\n     * @param w Writer to use for writing JSON content \n     */",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8Generator(out, ctxt);\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type, o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type, o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type, o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type, o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type.getComponentType(), o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type, o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type, o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type, o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isArray()) {\n        return arrayMemberEquals(type, o1, o2);\n    }\n    if (type.isAnnotation()) {\n        return equals((Annotation) o1, (Annotation) o2);\n    }\n    return o1.equals(o2);\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isObject() && type.isObject()) {\n        return type.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    }\n    return type.getNativeType(JSTypeNative.NO_TYPE);\n}\n\n/**\n   * Computes the restricted type of this type knowing that the\n   * {@code ToBoolean} predicate has a specific value. For more information\n   * about the {@code ToBoolean} predicate, see\n   * {@link #getPossibleToBooleanOutcomes}.\n   *\n   * @param outcome the value of the {@code ToBoolean} predicate\n   *\n   * @return the restricted type, or the Any Type if the underlying type could\n   *         not have yielded this ToBoolean value\n   *\n   * TODO(user): Move this method to the SemanticRAI and use the visit\n   * method of types to get the restricted type.",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type;\n    }\n    return type.getNativeType(JSTypeNative.NO_TYPE);\n}\n\n/**\n   * Computes the restricted type of this type knowing that the\n   * {@code ToBoolean} predicate has a specific value. For more information\n   * about the {@code ToBoolean} predicate, see\n   * {@link #getPossibleToBooleanOutcomes}.\n   *\n   * @param outcome the value of the {@code ToBoolean} predicate\n   *\n   * @return the restricted type, or the Any Type if the underlying type could\n   *         not have yielded this ToBoolean value\n   *\n   * TODO(user): Move this method to the SemanticRAI and use the visit\n   * method of types to get the restricted type.\n   */\nstatic JSType getRestrictedTypeGivenToBooleanOutcome(JSType type, boolean outcome) {\n    if (outcome && type == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {\n        return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n    }\n\n    BooleanLiteralSet literals = getPossibleToBooleanOutcomes();\n    if (literals.contains(outcome)) {\n        return type;\n    } else {\n        return getNativeType(JSTypeNative.NO_TYPE);\n    }\n}\n\n/**\n   * Returns a version of {@code type} that is restricted by some knowledge\n   * about the result of the {@code typeof} operation.\n   * <p>\n   * The behavior of the {@code typeof} operator can be summarized by the\n   * following table:\n   * <table>\n   * <tr><th>type</th><th>result</th></tr>\n   * <tr><td>{@code undefined}</td><td>\"undefined\"</td></tr>\n   * <tr><td>{@code null}</td><td>\"object\"</td></tr>\n   * <tr><td>{@code boolean}</td><td>\"boolean\"</td></tr>\n   * <tr><td>{@code number}</td><td>\"number\"</td></tr>\n   * <tr><td>{@code string}</td><td>\"string\"</td></tr>\n   * <tr><td>{@code Object} (which doesn't implement [[Call]])</td>\n   *     <td>\"object\"</td></tr>\n   * <tr><td>{@code Object} (which implements [[Call]])</td>",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type == null) {\n        return type;\n    }\n    if (type.isNoResolvedType()) {\n        return getNativeType(JSTypeNative.NO_TYPE);\n    }\n    return type;\n}\n\n/**\n   * Computes the restricted type of this type knowing that the\n   * {@code ToBoolean} predicate has a specific value. For more information\n   * about the {@code ToBoolean} predicate, see\n   * {@link #getPossibleToBooleanOutcomes}.\n   *\n   * @param outcome the value of the {@code ToBoolean} predicate\n   *\n   * @return the restricted type, or the Any Type if the underlying type could\n   *         not have yielded this ToBoolean value\n   *\n   * TODO(user): Move this method to the SemanticRAI and use the visit\n   * method of types to get the restricted type.",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type == JSTypeNative.NO_RESOLVED_TYPE) {\n        return JSTypeNative.NO_TYPE;\n    }\n    return type;\n}\n\n/**\n   * Computes the restricted type of this type knowing that the\n   * {@code ToBoolean} predicate has a specific value. For more information\n   * about the {@code ToBoolean} predicate, see\n   * {@link #getPossibleToBooleanOutcomes}.\n   *\n   * @param outcome the value of the {@code ToBoolean} predicate\n   *\n   * @return the restricted type, or the Any Type if the underlying type could\n   *         not have yielded this ToBoolean value\n   *\n   * TODO(user): Move this method to the SemanticRAI and use the visit\n   * method of types to get the restricted type.\n   */\nstatic JSType getRestrictedTypeGivenToBooleanOutcome(JSType type, boolean outcome) {\n    if (outcome && type == JSTypeNative.UNKNOWN_TYPE) {\n        return JSTypeNative.CHECKED_UNKNOWN_TYPE;\n    }\n\n    BooleanLiteralSet literals = getPossibleToBooleanOutcomes();\n    if (literals.contains(outcome)) {\n        return type;\n    } else {\n        return JSTypeNative.NO_TYPE;\n    }\n}\n\n/**\n   * Returns a version of {@code type} that is restricted by some knowledge\n   * about the result of the {@code typeof} operation.\n   * <p>\n   * The behavior of the {@code typeof} operator can be summarized by the\n   * following table:\n   * <table>\n   * <tr><th>type</th><th>result</th></tr>\n   * <tr><td>{@code undefined}</td><td>\"undefined\"</td></tr>\n   * <tr><td>{@code null}</td><td>\"object\"</td></tr>\n   * <tr><td>{@code boolean}</td><td>\"boolean\"</td></tr>\n   * <tr><td>{@code number}</td><td>\"number\"</td></tr>\n   * <tr><td>{@code string}</td><td>\"string\"</td></tr>\n   * <tr><td>{@code Object} (which doesn't implement [[Call]])</td>\n   *     <td>\"object\"</td></tr>\n   * <tr><td>{@code Object} (which implements [[Call]])</td>\n   *     <td>\"function\"</td></tr>",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type == null) {\n        return null;\n    }\n    return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n}\n\n/**\n   * Computes the restricted type of this type knowing that the\n   * {@code ToBoolean} predicate has a specific value. For more information\n   * about the {@code ToBoolean} predicate, see\n   * {@link #getPossibleToBooleanOutcomes}.\n   *\n   * @param outcome the value of the {@code ToBoolean} predicate\n   *\n   * @return the restricted type, or the Any Type if the underlying type could\n   *         not have yielded this ToBoolean value\n   *\n   * TODO(user): Move this method to the SemanticRAI and use the visit\n   * method of types to get the restricted type.",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type == null) {\n        return null;\n    }\n    if (type.isNoResolvedType()) {\n        return getNativeType(JSTypeNative.NO_TYPE);\n    }\n    return type;\n}\n\n/**\n   * Computes the restricted type of this type knowing that the\n   * {@code ToBoolean} predicate has a specific value. For more information\n   * about the {@code ToBoolean} predicate, see\n   * {@link #getPossibleToBooleanOutcomes}.\n   *\n   * @param outcome the value of the {@code ToBoolean} predicate\n   *\n   * @return the restricted type, or the Any Type if the underlying type could\n   *         not have yielded this ToBoolean value\n   *\n   * TODO(user): Move this method to the SemanticRAI and use the visit\n   * method of types to get the restricted type.\n   */\nstatic JSType getRestrictedTypeGivenToBooleanOutcome(JSType type, boolean outcome) {\n    if (outcome && type == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {\n        return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n    }\n\n    BooleanLiteralSet literals = getPossibleToBooleanOutcomes();\n    if (literals.contains(outcome)) {\n        return type;\n    } else {\n        return getNativeType(JSTypeNative.NO_TYPE);\n    }\n}\n\n/**\n   * Returns a version of {@code type} that is restricted by some knowledge\n   * about the result of the {@code typeof} operation.\n   * <p>\n   * The behavior of the {@code typeof} operator can be summarized by the\n   * following table:\n   * <table>\n   * <tr><th>type</th><th>result</th></tr>\n   * <tr><td>{@code undefined}</td><td>\"undefined\"</td></tr>\n   * <tr><td>{@code null}</td><td>\"object\"</td></tr>\n   * <tr><td>{@code boolean}</td><td>\"boolean\"</td></tr>\n   * <tr><td>{@code number}</td><td>\"number\"</td></tr>\n   * <tr><td>{@code string}</td><td>\"string\"</td></tr>\n   * <tr><td>{@code Object} (which doesn't implement [[Call]])</td>\n   *     <td>\"object\"</td></tr>",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type.getNativeType(JSTypeNative.NO_TYPE);\n    }\n    return type;\n}\n\n/**\n   * Computes the restricted type of this type knowing that the\n   * {@code ToBoolean} predicate has a specific value. For more information\n   * about the {@code ToBoolean} predicate, see\n   * {@link #getPossibleToBooleanOutcomes}.\n   *\n   * @param outcome the value of the {@code ToBoolean} predicate\n   *\n   * @return the restricted type, or the Any Type if the underlying type could\n   *         not have yielded this ToBoolean value\n   *\n   * TODO(user): Move this method to the SemanticRAI and use the visit\n   * method of types to get the restricted type.\n   */\nstatic JSType getRestrictedTypeGivenToBooleanOutcome(JSType type, boolean outcome) {\n    if (outcome && type == getNativeType(JSTypeNative.UNKNOWN_TYPE)) {\n        return getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);\n    }\n\n    BooleanLiteralSet literals = getPossibleToBooleanOutcomes();\n    if (literals.contains(outcome)) {\n        return type;\n    } else {\n        return getNativeType(JSTypeNative.NO_TYPE);\n    }\n}\n\n/**\n   * Returns a version of {@code type} that is restricted by some knowledge\n   * about the result of the {@code typeof} operation.\n   * <p>\n   * The behavior of the {@code typeof} operator can be summarized by the\n   * following table:\n   * <table>\n   * <tr><th>type</th><th>result</th></tr>\n   * <tr><td>{@code undefined}</td><td>\"undefined\"</td></tr>\n   * <tr><td>{@code null}</td><td>\"object\"</td></tr>\n   * <tr><td>{@code boolean}</td><td>\"boolean\"</td></tr>\n   * <tr><td>{@code number}</td><td>\"number\"</td></tr>\n   * <tr><td>{@code string}</td><td>\"string\"</td></tr>\n   * <tr><td>{@code Object} (which doesn't implement [[Call]])</td>\n   *     <td>\"object\"</td></tr>\n   * <tr><td>{@code Object} (which implements [[Call]])</td>",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isObject() && type.getNativeType(JSTypeNative.NO_OBJECT_TYPE) != null) {\n        return type.getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    }\n    return type.getNativeType(JSTypeNative.NO_TYPE);\n}\n\n/**\n   * Computes the restricted type of this type knowing that the\n   * {@code ToBoolean} predicate has a specific value. For more information\n   * about the {@code ToBoolean} predicate, see\n   * {@link #getPossibleToBooleanOutcomes}.\n   *\n   * @param outcome the value of the {@code ToBoolean} predicate\n   *\n   * @return the restricted type, or the Any Type if the underlying type could\n   *         not have yielded this ToBoolean value\n   *\n   * TODO(user): Move this method to the SemanticRAI and use the visit\n   * method of types to get the restricted type.",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) {\n        return type.getNativeType(JSTypeNative.NO_TYPE);\n    }\n    return type;\n}\n\n/**\n   * Computes the restricted type of this type knowing that the\n   * {@code ToBoolean} predicate has a specific value. For more information\n   * about the {@code ToBoolean} predicate, see\n   * {@link #getPossibleToBooleanOutcomes}.\n   *\n   * @param outcome the value of the {@code ToBoolean} predicate\n   *\n   * @return the restricted type, or the Any Type if the underlying type could\n   *         not have yielded this ToBoolean value\n   *\n   * TODO(user): Move this method to the SemanticRAI and use the visit\n   * method of types to get the restricted type.",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type == JSTypeNative.NO_RESOLVED_TYPE) {\n        return type;\n    }\n    return type.getNativeType(JSTypeNative.NO_TYPE);\n}\n\n/**\n   * Computes the restricted type of this type knowing that the\n   * {@code ToBoolean} predicate has a specific value. For more information\n   * about the {@code ToBoolean} predicate, see\n   * {@link #getPossibleToBooleanOutcomes}.\n   *\n   * @param outcome the value of the {@code ToBoolean} predicate\n   *\n   * @return the restricted type, or the Any Type if the underlying type could\n   *         not have yielded this ToBoolean value\n   *\n   * TODO(user): Move this method to the SemanticRAI and use the visit\n   * method of types to get the restricted type."
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}\n\n/**\n   * If the restrictedType differs from the originalType, then we should\n   * branch the current flow scope and create a new flow scope with the name\n   * declared with the new type.\n   *\n   * We try not to create spurious child flow scopes as this makes type\n   * inference slower.\n   *\n   * We also do not want spurious slots around in type inference, because\n   * we use these as a signal for \"checked unknown\" types. A \"checked unknown\"\n   * type is a symbol that the programmer has already checked and verified that\n   * it's defined, even if we don't know what it is.\n   *\n   * It is OK to pass non-name nodes into this method, as long as you pass\n   * in {@code null} for a restricted type.",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}\n\n/**\n   * If the restrictedType differs from the originalType, then we should\n   * branch the current flow scope and create a new flow scope with the name\n   * declared with the new type.\n   *\n   * We try not to create spurious child flow scopes as this makes type\n   * inference slower.\n   *\n   * We also do not want spurious slots around in type inference, because\n   * we use these as a signal for \"checked unknown\" types. A \"checked unknown\"\n   * type is a symbol that the programmer has already checked and verified that\n   * it's defined, even if we don't know what it is.\n   *\n   * It is OK to pass non-name nodes into this method, as long as you pass\n   * in {@code null} for a restricted type.",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n}\n\n/**\n   * Given 'property in object', ensures that the object has the property in the\n   * informed scope by defining it as a qualified name if the object type lacks\n   * the property and it's not in the blind scope.\n   * @param object The node of the right-side of the in.\n   * @param propertyName The string of the left-side of the in.",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n        FlowScope informed = blindScope.createChildFlowScope();\n        declareNameInScope(informed, node, restrictedType);\n        return informed;\n    }\n    return blindScope;\n  }"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token == JsDocToken.STRING) {\n        if (!\"function\".equals(stream.getString())) {\n            return null;\n        }\n    } else {\n        return null;\n    }\n    skipEOLs();\n    Node typeParameters = parseTypeParameters(next());\n    if (typeParameters == null) {\n        return null;\n    }\n    skipEOLs();\n    if (next() != JsDocToken.LP) {\n        return null;\n    }\n    skipEOLs();\n    if (next() != JsDocToken.STRING) {\n        return null;\n    }\n    if (!\"this\".equals(stream.getString())) {\n        return null;\n    }\n    skipEOLs();\n    if (next() != JsDocToken.COLON) {\n        return null;\n    }\n    skipEOLs();\n    Node typeName = parseTypeName(next());\n    if (typeName == null) {\n        return null;\n    }\n    skipEOLs();\n    if (next() != JsDocToken.COMMA) {\n        return null;\n    }\n    skipEOLs();\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n        return null;\n    }\n    skipEOLs();\n    if (next() != JsDocToken.RP) {\n        return null;\n    }\n    skipEOLs();\n    if (next() != JsDocToken.RP) {\n        return null;\n    }\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n        return null;\n    }\n    return wrapNode(Token.FUNCTION, typeParameters, parametersType, resultType);\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING || !stream.getString().equals(\"function\")) {\n        return null;\n    }\n    skipEOLs();\n    token = next();\n    if (token != JsDocToken.LP) {\n        return null;\n    }\n    skipEOLs();\n    token = next();\n    if (token != JsDocToken.STRING || !token.equals(\"this\")) {\n        return null;\n    }\n    skipEOLs();\n    token = next();\n    if (token != JsDocToken.COLON) {\n        return null;\n    }\n    skipEOLs();\n    Node typeName = parseTypeName(token);\n    if (typeName == null) {\n        return null;\n    }\n    skipEOLs();\n    if (token != JsDocToken.RP) {\n        return null;\n    }\n    skipEOLs();\n    token = next();\n    if (token != JsDocToken.LB) {\n        return null;\n    }\n    skipEOLs();\n    Node parametersType = parseParametersType(token);\n    if (parametersType == null) {\n        return null;\n    }\n    skipEOLs();\n    if (token != JsDocToken.RB) {\n        return null;\n    }\n    skipEOLs();\n    token = next();\n    if (token != JsDocToken.RP) {\n        return null;\n    }\n    skipEOLs();\n    Node resultType = parseResultType(token);\n    if (resultType == null) {\n        return null;\n    }\n    skipEOLs();\n    return newNode(Token.FUNCTION, typeName, parametersType, resultType);\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) {\n        return null;\n    }\n    skipEOLs();\n    token = next();\n    if (token != JsDocToken.LP) {\n        return null;\n    }\n    skipEOLs();\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n        return null;\n    }\n    skipEOLs();\n    if (token != JsDocToken.COMMA) {\n        return null;\n    }\n    skipEOLs();\n    Node thisType = parseTypeName(token);\n    if (thisType == null) {\n        return null;\n    }\n    skipEOLs();\n    if (token != JsDocToken.COLON) {\n        return null;\n    }\n    skipEOLs();\n    Node typeName = parseTypeName(token);\n    if (typeName == null) {\n        return null;\n    }\n    skipEOLs();\n    if (token != JsDocToken.RP) {\n        return null;\n    }\n    skipEOLs();\n    Node parametersType = parseParametersType(token);\n    if (parametersType == null) {\n        return null;\n    }\n    skipEOLs();\n    if (token != JsDocToken.RP) {\n        return null;\n    }\n    skipEOLs();\n    Node resultType = parseResultType(token);\n    if (resultType == null) {\n        return null;\n    }\n    functionType.addChildToBack(typeParameters);\n    functionType.addChildToBack(thisType);\n    functionType.addChildToBack(typeName);\n    functionType.addChildToBack(parametersType);\n    functionType.addChildToBack(resultType);\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token == JsDocToken.STRING) {\n        String string = stream.getString();\n        if (\"function\".equals(string)) {\n            skipEOLs();\n            token = next();\n            if (token == JsDocToken.LP) {\n                skipEOLs();\n                Node typeParameters = parseTypeParameters(next());\n                if (typeParameters == null) {\n                    return null;\n                }\n                skipEOLs();\n                if (token == JsDocToken.STRING) {\n                    String string2 = stream.getString();\n                    if (\"this\".equals(string2)) {\n                        skipEOLs();\n                        token = next();\n                        if (token == JsDocToken.COLON) {\n                            skipEOLs();\n                            Node typeName = parseTypeName(next());\n                            if (typeName == null) {\n                                return null;\n                            }\n                            skipEOLs();\n                            if (token == JsDocToken.COMMA) {\n                                skipEOLs();\n                                Node parametersType = parseParametersType(next());\n                                if (parametersType == null) {\n                                    return null;\n                                }\n                                skipEOLs();\n                                if (token == JsDocToken.RP) {\n                                    skipEOLs();\n                                    Node resultType = parseResultType(next());\n                                    if (resultType == null) {\n                                        return null;\n                                    }\n                                    return wrapNode(Token.FUNCTION, typeParameters, typeName, parametersType, resultType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return null;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING || !stream.getString().equals(\"function\")) {\n      return null;\n    }\n    skipEOLs();\n    token = next();\n    if (token != JsDocToken.LP) {\n      return null;\n    }\n    skipEOLs();\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n      return null;\n    }\n    skipEOLs();\n    if (token != JsDocToken.RP) {\n      return null;\n    }\n    skipEOLs();\n    Node parametersType = parseParametersType(token);\n    if (parametersType == null) {\n      return null;\n    }\n    skipEOLs();\n    if (token != JsDocToken.RP) {\n      return null;\n    }\n    skipEOLs();\n    Node resultType = parseResultType(token);\n    if (resultType == null) {\n      return null;\n    }\n    Node functionType = newNode(Token.FUNCTION);\n    functionType.addChildToBack(typeParameters);\n    functionType.addChildToBack(parametersType);\n    functionType.addChildToBack(resultType);\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    skipEOLs();\n    if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.function\");\n    }\n    next();\n    skipEOLs();\n    Node typeParameters = parseTypeParameters(next());\n    if (typeParameters == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typeparameters\");\n    }\n    skipEOLs();\n    if (token != JsDocToken.LP) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lparen\");\n    }\n    next();\n    skipEOLs();\n    if (token != JsDocToken.STRING || !\"this\".equals(stream.getString())) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n    skipEOLs();\n    if (token != JsDocToken.COLON) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n    skipEOLs();\n    Node typeName = parseTypeName(next());\n    if (typeName == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.typename\");\n    }\n    skipEOLs();\n    if (token != JsDocToken.COMMA) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n    }\n    next();\n    skipEOLs();\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.parameters\");\n    }\n    skipEOLs();\n    if (token != JsDocToken.RP) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rparen\");\n    }\n    next();\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.resulttype\");\n    }\n    functionType.addChildToBack(typeParameters);\n    functionType.addChildToBack(typeName);\n    functionType.addChildToBack(parametersType);\n    functionType.addChildToBack(resultType);\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    if (token != JsDocToken.STRING || !stream.getString().equals(\"function\")) {\n        return null;\n    }\n    skipEOLs();\n    token = next();\n    if (token != JsDocToken.LP) {\n        return null;\n    }\n    skipEOLs();\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n        return null;\n    }\n    skipEOLs();\n    if (token != JsDocToken.STRING || !stream.getString().equals(\"this\")) {\n        return null;\n    }\n    skipEOLs();\n    token = next();\n    if (token != JsDocToken.COLON) {\n        return null;\n    }\n    skipEOLs();\n    Node typeName = parseTypeName(token);\n    if (typeName == null) {\n        return null;\n    }\n    skipEOLs();\n    if (token != JsDocToken.COMMA) {\n        return null;\n    }\n    skipEOLs();\n    Node parametersType = parseParametersType(token);\n    if (parametersType == null) {\n        return null;\n    }\n    skipEOLs();\n    if (token != JsDocToken.RP) {\n        return null;\n    }\n    skipEOLs();\n    Node resultType = parseResultType(token);\n    if (resultType == null) {\n        return null;\n    }\n    functionType.addChildToBack(typeParameters);\n    functionType.addChildToBack(typeName);\n    functionType.addChildToBack(parametersType);\n    functionType.addChildToBack(resultType);\n    return functionType;\n}\n\n/**\n * TypeParameters := '[' TypeParameterList ']'\n * TypeParameterList := TypeParameter | TypeParameter ',' TypeParameterList",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING || !stream.getString().equals(\"function\")) {\n        return null;\n    }\n    skipEOLs();\n    token = next();\n    if (token != JsDocToken.LP) {\n        return null;\n    }\n    skipEOLs();\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n        return null;\n    }\n    skipEOLs();\n    if (token != JsDocToken.STRING || !stream.getString().equals(\"this\")) {\n        return null;\n    }\n    skipEOLs();\n    token = next();\n    if (token != JsDocToken.COLON) {\n        return null;\n    }\n    skipEOLs();\n    Node typeName = parseTypeName(token);\n    if (typeName == null) {\n        return null;\n    }\n    skipEOLs();\n    if (token != JsDocToken.RP) {\n        return null;\n    }\n    skipEOLs();\n    Node parametersType = parseParametersType(token);\n    if (parametersType == null) {\n        return null;\n    }\n    skipEOLs();\n    if (token != JsDocToken.RP) {\n        return null;\n    }\n    skipEOLs();\n    Node resultType = parseResultType(token);\n    if (resultType == null) {\n        return null;\n    }\n    skipEOLs();\n    if (token != JsDocToken.RC) {\n        return null;\n    }\n    skipEOLs();\n    return wrapNode(Token.FUNCTION, typeParameters, typeName, parametersType, resultType);\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token != JsDocToken.STRING || !\"function\".equals(stream.getString())) {\n        return null;\n    }\n    skipEOLs();\n    token = next();\n    if (token != JsDocToken.LP) {\n        return null;\n    }\n    skipEOLs();\n    Node typeParameters = parseTypeParameters(token);\n    if (typeParameters == null) {\n        return null;\n    }\n    skipEOLs();\n    if (token != JsDocToken.STRING || !\"this\".equals(stream.getString())) {\n        return null;\n    }\n    skipEOLs();\n    token = next();\n    if (token != JsDocToken.COLON) {\n        return null;\n    }\n    skipEOLs();\n    Node typeName = parseTypeName(token);\n    if (typeName == null) {\n        return null;\n    }\n    skipEOLs();\n    if (token != JsDocToken.RP) {\n        return null;\n    }\n    skipEOLs();\n    Node parametersType = parseParametersType(token);\n    if (parametersType == null) {\n        return null;\n    }\n    skipEOLs();\n    if (token != JsDocToken.RP) {\n        return null;\n    }\n    skipEOLs();\n    Node resultType = parseResultType(token);\n    if (resultType == null) {\n        return null;\n    }\n    Node functionType = newNode(Token.FUNCTION);\n    functionType.addChildToBack(typeParameters);\n    functionType.addChildToBack(typeName);\n    functionType.addChildToBack(parametersType);\n    functionType.addChildToBack(resultType);\n    return functionType;\n}\n\n/**\n * TypeParameters := '[' TypeParameterList ']'\n * TypeParameterList := TypeParameter | TypeParameter ',' TypeParameterList",
      "private Node parseFunctionType(JsDocToken token)  {\n    if (token == JsDocToken.STRING && stream.getString().equals(\"function\")) {\n        token = next();\n        skipEOLs();\n        if (token != JsDocToken.LP) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n        }\n        token = next();\n        skipEOLs();\n        if (token != JsDocToken.STRING && token != JsDocToken.LB) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n        }\n        String thisType = stream.getString();\n        if (token == JsDocToken.STRING) {\n            token = next();\n        }\n        skipEOLs();\n        if (token != JsDocToken.COMMA) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n        }\n        token = next();\n        skipEOLs();\n        ParametersType parametersType = parseParametersType(token);\n        if (parametersType == null) {\n            return null;\n        }\n        skipEOLs();\n        if (token != JsDocToken.RP) {\n            reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n        }\n        token = next();\n        skipEOLs();\n        ResultType resultType = parseResultType(token);\n        if (resultType == null) {\n            return null;\n        }\n        return newNode(Token.FUNCTION, thisType, parametersType, resultType);\n    }\n    return null;\n}"
    ],
    [
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    return str.replaceAll(\"\\\\s\", \"\");\n}",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        return str.replaceAll(\"\\\\s\", \"\");\n    }",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    return str.replaceAll(\"\\\\s\", \"\");\n}",
      "public static String deleteWhitespace(final String str)  /**\n     * <p>Checks whether a String contains only digits (0-9).</p>\n     *\n     * <pre>\n     * StringUtils.isNumeric(null)   = false\n     * StringUtils.isNumeric(\"\")     = false\n     * StringUtils.isNumeric(\"abc\")  = false\n     * StringUtils.isNumeric(\"123\")  = true\n     * StringUtils.isNumeric(\"123.45\") = false\n     * </pre>\n     *\n     * @param str  the String to check, may be null\n     * @return true if the String contains only digits, false otherwise\n     */\n    //-----------------------------------------------------------------------",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        return str.replaceAll(\"\\\\s+\", \"\");\n    }",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    return str.replaceAll(\"\\\\s\", \"\");\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    return str.replaceAll(\"\\\\s\", \"\");\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    return str.replaceAll(\"\\\\s\", \"\");\n}",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        return str.replaceAll(\"\\\\s+\", \"\");\n    }",
      "public static String deleteWhitespace(final String str)  {\n        if (str == null) {\n            return null;\n        }\n        return str.replaceAll(\"\\\\s\", \"\");\n    }"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    AggregateSummaryStatistics aggregateStatistics = new AggregateSummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregateStatistics.addValue(stat.getMax());\n        aggregateStatistics.addValue(stat.getMean());\n        aggregateStatistics.addValue(stat.getMin());\n        aggregateStatistics.addValue(stat.getN());\n        aggregateStatistics.addValue(stat.getSum());\n        aggregateStatistics.addValue(stat.getVariance());\n    }\n    return aggregateStatistics.getSummaryStatistics();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    AggregatingSummaryStatistics aggregateStatistics = new AggregatingSummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregateStatistics.addValue(stat.getMax());\n        aggregateStatistics.addValue(stat.getMean());\n        aggregateStatistics.addValue(stat.getMin());\n        aggregateStatistics.addValue(stat.getN());\n        aggregateStatistics.addValue(stat.getSum());\n        aggregateStatistics.addValue(stat.getVariance());\n    }\n    return aggregateStatistics.getSummaryStatistics();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    AggregateSummaryStatistics aggregateStatistics = new AggregateSummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregateStatistics.addValue(stat);\n    }\n    return aggregateStatistics.getSummaryStatistics();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    AggregatingSummaryStatistics aggregateStatistics = new AggregatingSummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregateStatistics.addValue(stat.getMax());\n        aggregateStatistics.addValue(stat.getMean());\n        aggregateStatistics.addValue(stat.getMin());\n        aggregateStatistics.addValue(stat.getN());\n        aggregateStatistics.addValue(stat.getSum());\n        aggregateStatistics.addValue(stat.getVariance());\n    }\n    return aggregateStatistics.getStatistics();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregate.addValue(stat.getMean());\n        aggregate.addValue(stat.getVariance());\n        aggregate.addValue(stat.getMin());\n        aggregate.addValue(stat.getMax());\n        aggregate.addValue(stat.getSum());\n        aggregate.addValue(stat.getN());\n    }\n    return aggregate.getSummaryStatistics();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    AggregatingSummaryStatistics aggregator = new AggregatingSummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregator.addValue(stat.getMax());\n        aggregator.addValue(stat.getMean());\n        aggregator.addValue(stat.getMin());\n        aggregator.addValue(stat.getN());\n        aggregator.addValue(stat.getSum());\n        aggregator.addValue(stat.getVariance());\n    }\n    return aggregator.getSummaryStatistics();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregate.addValue(stat);\n    }\n    return aggregate.getSummaryStatistics();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    AggregatingSummaryStatistics aggregator = new AggregatingSummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregator.addValue(stat.getSum());\n        aggregator.addValue(stat.getN());\n        aggregator.addValue(stat.getMin());\n        aggregator.addValue(stat.getMax());\n        aggregator.addValue(stat.getMean());\n        aggregator.addValue(stat.getVariance());\n    }\n    return aggregator.getSummaryStatistics();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    AggregatingSummaryStatistics aggregateStatistics = new AggregatingSummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregateStatistics.addValue(stat.getMean());\n        aggregateStatistics.addValue(stat.getVariance());\n        aggregateStatistics.addValue(stat.getMin());\n        aggregateStatistics.addValue(stat.getMax());\n        aggregateStatistics.addValue(stat.getN());\n        aggregateStatistics.addValue(stat.getSum());\n    }\n    return aggregateStatistics.getSummaryStatistics();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n    AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();\n    for (SummaryStatistics stat : statistics) {\n        aggregate.addValue(stat);\n    }\n    return aggregate.getSummaryStatistics();\n}"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length < 2) {\n        throw new NumberIsTooSmallException(\"Array length must be at least 2\");\n    }\n    double[] differences = new double[sample1.length];\n    for (int i = 0; i < sample1.length; i++) {\n        differences[i] = sample1[i] - sample2[i];\n    }\n    return populationVariance(differences, 0, sample1.length) - meanDifference * meanDifference;\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length < 2) {\n        throw new NumberIsTooSmallException(\"Array length is less than 2\");\n    }\n    double[] differences = new double[sample1.length];\n    for (int i = 0; i < sample1.length; i++) {\n        differences[i] = sample1[i] - sample2[i];\n    }\n    return populationVariance(differences, 0, sample1.length) - meanDifference * meanDifference;\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length < 2) {\n        throw new NumberIsTooSmallException();\n    }\n    double[] diff = new double[sample1.length];\n    for (int i = 0; i < sample1.length; i++) {\n        diff[i] = sample1[i] - sample2[i] - meanDifference;\n    }\n    return StatUtils.populationVariance(diff, 0, sample1.length);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length < 2) {\n        throw new NumberIsTooSmallException();\n    }\n    double[] differences = new double[sample1.length];\n    for (int i = 0; i < sample1.length; i++) {\n        differences[i] = sample1[i] - sample2[i] - meanDifference;\n    }\n    return populationVariance(differences, 0, sample1.length);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(\"Sample arrays length must be at least 2\");\n    }\n    double[] diff = new double[n];\n    for (int i = 0; i < n; i++) {\n        diff[i] = sample1[i] - sample2[i];\n    }\n    double variance = StatUtils.populationVariance(diff, 0, n);\n    return variance;\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length < 2) {\n        throw new NumberIsTooSmallException(\"Array length must be at least 2\");\n    }\n    double[] diff = new double[sample1.length];\n    for (int i = 0; i < sample1.length; i++) {\n        diff[i] = sample1[i] - sample2[i];\n    }\n    return populationVariance(diff, 0, sample1.length) - meanDifference * meanDifference;\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length < 2) {\n        throw new NumberIsTooSmallException(\"Array length must be at least 2\");\n    }\n    double[] diff = new double[sample1.length];\n    for (int i = 0; i < sample1.length; i++) {\n        diff[i] = sample1[i] - sample2[i];\n    }\n    return populationVariance(diff, 0, sample1.length) - meanDifference * meanDifference;\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length < 2) {\n        throw new NumberIsTooSmallException(\"Array length must be at least 2\");\n    }\n    double[] diff = new double[sample1.length];\n    for (int i = 0; i < sample1.length; i++) {\n        diff[i] = sample1[i] - sample2[i];\n    }\n    return populationVariance(diff, 0, sample1.length) - meanDifference * meanDifference;\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException();\n    }\n    double[] differences = new double[n];\n    for (int i = 0; i < n; i++) {\n        differences[i] = sample1[i] - sample2[i];\n    }\n    return populationVariance(differences, 0, n) - meanDifference * meanDifference;\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(\"Sample arrays length must be at least 2\");\n    }\n    double[] diff = new double[n];\n    for (int i = 0; i < n; i++) {\n        diff[i] = sample1[i] - sample2[i];\n    }\n    return populationVariance(diff, 0, n).doubleValue();\n}"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) {\n        Number value = dataset.getValue(s);\n        if (value != null && value.doubleValue() > 0.0) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) {\n        double value = dataset.getValue(s);\n        if (value != null && value >= 0.0) {\n            total += value;\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    int count = dataset.getSeriesCount();\n    for (int i = 0; i < count; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() > 0.0) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) {\n        Number number = dataset.getValue(s);\n        if (number != null) {\n            double value = number.doubleValue();\n            if (value >= 0.0) {\n                total = total + value;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) {\n        Number value = dataset.getValue(s);\n        if (value != null && value.doubleValue() >= 0.0) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    int count = dataset.getEntryCount();\n    for (int i = 0; i < count; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() >= 0.0) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    int count = dataset.getSeriesCount();\n    for (int i = 0; i < count; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() > 0.0) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) {\n        Number number = dataset.getValue(s);\n        if (number != null && number.doubleValue() >= 0.0) {\n            total = total + number.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    int count = dataset.getSeriesCount();\n    for (int i = 0; i < count; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() >= 0.0) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    double total = 0.0;\n    int seriesCount = dataset.getSeriesCount();\n    for (int s = 0; s < seriesCount; s++) {\n        Number number = dataset.getValue(s);\n        if (number != null) {\n            double value = number.doubleValue();\n            if (value >= 0.0) {\n                total = total + value;\n            }\n        }\n    }\n    return total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_UNQUOTED_NAME) {\n      String name = nextQuotedValue(p == PEEKED_SINGLE_QUOTED_NAME ? '\\'' : p == PEEKED_DOUBLE_QUOTED_NAME ? '\"' : '\\0');\n      peeked = PEEKED_NONE;\n      return name;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_UNQUOTED_NAME) {\n      String name = nextQuotedValue(p == PEEKED_SINGLE_QUOTED_NAME ? '\\'' : (p == PEEKED_DOUBLE_QUOTED_NAME ? '\"' : '\\0'));\n      peeked = PEEKED_NONE;\n      return name;\n    } else {\n      throw new IllegalStateException(\"Expected a property name but was \" + peek() + locationString());\n    }\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_UNQUOTED_NAME) {\n      String result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED_NAME ? '\\'' : p == PEEKED_DOUBLE_QUOTED_NAME ? '\"' : '\\0');\n      peeked = PEEKED_NONE;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a property name but was \" + peek() + locationString());\n    }\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_UNQUOTED_NAME) {\n      String name = nextQuotedValue(p == PEEKED_SINGLE_QUOTED_NAME ? '\\'' : p == PEEKED_DOUBLE_QUOTED_NAME ? '\"' : '\\0');\n      peeked = PEEKED_NONE;\n      return name;\n    } else {\n      throw new IllegalStateException(\"Expected a property name but was \" + peek() + locationString());\n    }\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_UNQUOTED_NAME) {\n      String name = nextQuotedValue(p == PEEKED_SINGLE_QUOTED_NAME ? '\\'' : p == PEEKED_DOUBLE_QUOTED_NAME ? '\"' : '\\0');\n      peeked = PEEKED_NONE;\n      return name;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_UNQUOTED_NAME) {\n      String result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED_NAME ? '\\'' : p == PEEKED_DOUBLE_QUOTED_NAME ? '\"' : '\\0');\n      peeked = PEEKED_NONE;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a property name but was \" + peek() + locationString());\n    }\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_UNQUOTED_NAME) {\n      String name = nextQuotedValue(p == PEEKED_SINGLE_QUOTED_NAME ? '\\'' : p == PEEKED_DOUBLE_QUOTED_NAME ? '\"' : '\\0');\n      peeked = PEEKED_NONE;\n      return name;\n    } else {\n      throw new IllegalStateException(\"Expected a property name but was \" + peek() + locationString());\n    }\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_UNQUOTED_NAME) {\n      String result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED_NAME ? '\\'' : p == PEEKED_DOUBLE_QUOTED_NAME ? '\"' : '\\0');\n      peeked = PEEKED_NONE;\n      return result;\n    } else {\n      throw new IllegalStateException(\"Expected a property name but was \" + peek() + locationString());\n    }\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n\n    if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_UNQUOTED_NAME) {\n      String name = nextQuotedValue(p == PEEKED_SINGLE_QUOTED_NAME ? '\\'' : p == PEEKED_DOUBLE_QUOTED_NAME ? '\"' : '\\0');\n      peeked = PEEKED_NONE;\n      return name;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n  }",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n      p = doPeek();\n    }\n    if (p == PEEKED_SINGLE_QUOTED_NAME || p == PEEKED_DOUBLE_QUOTED_NAME || p == PEEKED_UNQUOTED_NAME) {\n      String name = nextQuotedValue(p == PEEKED_SINGLE_QUOTED_NAME ? '\\'' : p == PEEKED_DOUBLE_QUOTED_NAME ? '\"' : '\\0');\n      peeked = PEEKED_NONE;\n      return name;\n    } else {\n      throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n  }"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}\n\n/**\n     * <p>Converts an array of primitive ints to objects.</p>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.</p>\n     *\n     * @param array  a {@code int} array\n     * @return a {@code Integer} array, {@code null} if null array input",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}\n\n/**\n     * <p>Converts an array of primitive ints to objects.</p>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.</p>\n     *\n     * @param array  a {@code int} array\n     * @return a {@code Integer} array, {@code null} if null array input",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}\n\n/**\n     * <p>Converts an array of primitive ints to objects.</p>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.</p>\n     *\n     * @param array  a {@code int} array\n     * @return a {@code Integer} array, {@code null} if null array input"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (endReached) {\n        return -1;\n    }\n    int r = in.read(b, off, len);\n    if (r == -1) {\n        endReached = true;\n    }\n    return r;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (endReached) {\n        return -1;\n    }\n    int r = in.read(b, off, len);\n    if (r == -1) {\n        endReached = true;\n    }\n    return r;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (endReached) {\n        return -1;\n    }\n    int r = in.read(b, off, len);\n    if (r == -1) {\n        endReached = true;\n    }\n    return r;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (endReached) {\n        return -1;\n    }\n    int r = 0;\n    while (r < len) {\n        int count = in.read(b, off + r, len - r);\n        if (count == -1) {\n            endReached = true;\n            return -1;\n        }\n        r += count;\n    }\n    return r;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (endReached) {\n        return -1;\n    }\n    int r = in.read(b, off, len);\n    if (r == -1) {\n        endReached = true;\n    }\n    return r;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (endReached) {\n        return -1;\n    }\n    int r = in.read(b, off, len);\n    if (r == -1) {\n        endReached = true;\n    }\n    return r;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (endReached) {\n        return -1;\n    }\n    int r = 0;\n    while (r < len) {\n        int count = Math.min(len - r, in.read(b, off + r, len - r));\n        if (count == -1) {\n            endReached = true;\n            return -1;\n        }\n        r += count;\n    }\n    return r;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (endReached) {\n        return -1;\n    }\n    int r = readFully(b, off, len);\n    if (r < len) {\n        nextBlock();\n        if (!endReached) {\n            r = readFully(b, off, len);\n        }\n    }\n    return r;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (endReached) {\n        return -1;\n    }\n    int r = 0;\n    while (r < len) {\n        int bytesRead = in.read(b, off + r, len - r);\n        if (bytesRead == -1) {\n            endReached = true;\n            return -1;\n        }\n        r += bytesRead;\n    }\n    return r;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (endReached) {\n        return -1;\n    }\n    int r = in.read(b, off, len);\n    if (r == -1) {\n        endReached = true;\n    }\n    return r;\n}"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.getCall();\n    if (call == null) {\n        return null;\n    }\n    Node arg = getNthSibling(call.getFirstChild().getNext(), argIndex);\n    return arg;\n}\n\n/**\n * Given the function, this returns the nth\n * argument or null if no such parameter exists.\n */\nstatic Node getArgumentForFunction(Node function, int index) {\n    Preconditions.checkState(function.isFunction());\n    return getNthSibling(\n        function.getFirstChild().getNext().getFirstChild(), index);\n}\n\n/**\n * Given the new or call, this returns the nth\n * argument of the call or null if no such argument exists.\n */\nstatic Node getArgumentForCallOrNew(Node call, int index) {\n    Preconditions.checkState(isCallOrNew(call));\n    return getNthSibling(\n      call.getFirstChild().getNext(), index);\n}\n\n/**\n * Returns whether this is a target of a call or new.\n */\nstatic boolean isCallOrNewTarget(Node target) {\n    Node parent = target.getParent();\n    return parent != null\n        && NodeUtil.isCallOrNew(parent)\n        && parent.getFirstChild() == target;\n}\n\n/**\n * Returns whether this is a call or new.\n */\nstatic boolean isCallOrNew(Node node) {\n    return isCallOrNewTarget(node) || isCallOrNewTarget(node.getParent());\n}\n\n/**\n * Given the new or call, this returns the nth\n * argument of the call or null if no such argument exists.\n */\nstatic Node getArgumentForCallOrNewOrDotCall(Node call, int index) {\n    Preconditions.checkState(isCallOrNew(call));\n    return getNthSibling(\n      call.getFirstChild().getNext(), index);\n}\n\n/**\n * Given the first sibling, this returns the nth\n * sibling or null if no such sibling exists.\n * This is like \"getChildAtIndex\" but returns null for non-existent indexes.",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.getCall();\n    if (call == null) {\n        return null;\n    }\n    Node arg = getNthSibling(call.getFirstChild().getNext(), argIndex);\n    return arg;\n}\n\n/**\n * Given the new or call, this returns the nth\n * argument of the call or null if no such argument exists.\n */\nstatic Node getArgumentForCallOrNew(Node call, int index) {\n    Preconditions.checkState(isCallOrNew(call));\n    return getNthSibling(\n        call.getFirstChild().getNext(), index);\n}\n\n/**\n * Given the first sibling, this returns the nth\n * sibling or null if no such sibling exists.\n * This is like \"getChildAtIndex\" but returns null for non-existent indexes.",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.getCall();\n    if (NodeUtil.isCallOrNew(call)) {\n        return NodeUtil.getNthSibling(call.getFirstChild().getNext(), argIndex);\n    } else {\n        return NodeUtil.getArgumentForFunction(site.getFunction(), argIndex);\n    }\n}\n\n/**\n * Remove all the following parameters without side-effects",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.getCall();\n    if (NodeUtil.isCallOrNew(call)) {\n        return NodeUtil.getNthSibling(call.getFirstChild().getNext(), argIndex);\n    } else if (NodeUtil.isDotCall(call)) {\n        return NodeUtil.getNthSibling(call.getFirstChild().getNext().getNext(), argIndex);\n    } else {\n        return null;\n    }\n}\n\n/**\n * Given the function, this returns the nth\n * argument or null if no such parameter exists.\n */\nstatic Node getArgumentForFunction(Node function, int index) {\n    Preconditions.checkState(function.isFunction());\n    return getNthSibling(function.getFirstChild().getNext().getFirstChild(), index);\n}\n\n/**\n * Given the new or call, this returns the nth\n * argument of the call or null if no such argument exists.\n */\nstatic Node getArgumentForCallOrNew(Node call, int index) {\n    Preconditions.checkState(NodeUtil.isCallOrNew(call));\n    return getNthSibling(call.getFirstChild().getNext(), index);\n}\n\n/**\n * Given the new or call, this returns the nth\n * argument of the call or null if no such argument exists.\n */\nstatic Node getArgumentForDotCall(Node call, int index) {\n    Preconditions.checkState(NodeUtil.isDotCall(call));\n    return getNthSibling(call.getFirstChild().getNext().getNext(), index);\n}\n\n/**\n * Returns whether this is a target of a call or new.\n */\nstatic boolean isCallOrNewTarget(Node target) {\n    Node parent = target.getParent();\n    return parent != null\n        && NodeUtil.isCallOrNew(parent)\n        && parent.getFirstChild() == target;\n}\n\n/**\n * Returns whether this is a target of a dot call.\n */\nstatic boolean isDotCallTarget(Node target) {\n    Node parent = target.getParent();\n    return parent != null\n        && NodeUtil.isDotCall(parent)\n        && parent.getFirstChild() == target;\n}\n\n/**\n * Given the function, this returns the nth\n * argument or null if no such parameter exists.\n */\nstatic Node getNthSibling(Node first, int index) {\n    Node sibling = first;\n    while (index != 0 && sibling != null) {\n        sibling = sibling.getNext();\n        index--;\n    }\n    return sibling;\n}\n\n/**\n * Given the function, this returns the nth\n * argument or null if no such parameter exists.\n */\nstatic Node getNthSibling(Node first, int index, boolean isCallOrNew) {\n    Node sibling = first;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.getCall();\n    if (call == null) {\n        return null;\n    }\n    if (isCallOrNew(call)) {\n        return getArgumentForCallOrNew(call, argIndex);\n    } else {\n        return getArgumentForDotCall(call, argIndex);\n    }\n}\n\n/**\n * Given the function, this returns the nth\n * argument or null if no such parameter exists.\n */\nstatic Node getArgumentForFunction(Node function, int index) {\n    Preconditions.checkState(function.isFunction());\n    return getNthSibling(\n        function.getFirstChild().getNext().getFirstChild(), index);\n}\n\n/**\n * Given the new or call, this returns the nth\n * argument of the call or null if no such argument exists.\n */\nstatic Node getArgumentForCallOrNew(Node call, int index) {\n    Preconditions.checkState(isCallOrNew(call));\n    return getNthSibling(\n      call.getFirstChild().getNext(), index);\n}\n\n/**\n * Given the new or call, this returns the nth\n * argument of the call or null if no such argument exists.\n */\nstatic Node getArgumentForDotCall(Node dotCall, int index) {\n    Preconditions.checkState(isDotCall(dotCall));\n    return getNthSibling(\n      dotCall.getFirstChild().getNext(), index);\n}\n\n/**\n * Returns whether this is a target of a call or new.\n */\nstatic boolean isCallOrNewTarget(Node target) {\n    Node parent = target.getParent();\n    return parent != null\n        && NodeUtil.isCallOrNew(parent)\n        && parent.getFirstChild() == target;\n}\n\n/**\n * Returns whether this is a call or new.\n */\nstatic boolean isCallOrNew(Node node) {\n    return isCall(node) || isNew(node);\n}\n\n/**\n * Returns whether this is a dot call.\n */\nstatic boolean isDotCall(Node node) {\n    return node.isDotCall();\n}\n\n/**\n * Given the first sibling, this returns the nth\n * sibling or null if no such sibling exists.",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.getCall();\n    if (NodeUtil.isCallOrNew(call)) {\n        return getArgumentForCallOrNew(call, argIndex);\n    } else {\n        return getArgumentForDotCall(call, argIndex);\n    }\n}\n\n/**\n * Given the function, this returns the nth\n * argument or null if no such parameter exists.\n */\nstatic Node getArgumentForFunction(Node function, int index) {\n    Preconditions.checkState(function.isFunction());\n    return getNthSibling(\n        function.getFirstChild().getNext().getFirstChild(), index);\n}\n\n/**\n * Given the new or call, this returns the nth\n * argument of the call or null if no such argument exists.\n */\nstatic Node getArgumentForCallOrNew(Node call, int index) {\n    Preconditions.checkState(NodeUtil.isCallOrNew(call));\n    return getNthSibling(\n        call.getFirstChild().getNext(), index);\n}\n\n/**\n * Given the new or call, this returns the nth\n * argument of the call or null if no such argument exists.\n */\nstatic Node getArgumentForDotCall(Node call, int index) {\n    Preconditions.checkState(NodeUtil.isDotCall(call));\n    return getNthSibling(\n        call.getFirstChild().getNext(), index);\n}\n\n/**\n * Given the first sibling, this returns the nth\n * sibling or null if no such sibling exists.\n * This is like \"getChildAtIndex\" but returns null for non-existent indexes.",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.getCall();\n    if (NodeUtil.isCallOrNew(call)) {\n        return getArgumentForCallOrNew(call, argIndex);\n    } else {\n        return getArgumentForDotCall(site, argIndex);\n    }\n}\n\n/**\n * Returns the nth argument node given a usage site for a direct function\n * call or for a func.call() node.",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.getCall();\n    if (call == null) {\n        return null;\n    }\n    Node arg = getNthSibling(call.getFirstChild().getNext(), argIndex);\n    return arg;\n}\n\n/**\n * Eliminates the parameter from a function definition.\n * @param function The function node\n * @param argIndex The index of the the argument to remove.\n * @return The Node of the argument removed.",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.getCall();\n    if (call == null) {\n        return null;\n    }\n    if (isCallOrNew(call)) {\n        return getArgumentForCallOrNew(call, argIndex);\n    } else {\n        return getArgumentForDotCall(call, argIndex);\n    }\n}\n\n/**\n * Given the function, this returns the nth\n * argument or null if no such parameter exists.\n */\nstatic Node getArgumentForFunction(Node function, int index) {\n    Preconditions.checkState(function.isFunction());\n    return getNthSibling(\n        function.getFirstChild().getNext().getFirstChild(), index);\n}\n\n/**\n * Given the new or call, this returns the nth\n * argument of the call or null if no such argument exists.\n */\nstatic Node getArgumentForCallOrNew(Node call, int index) {\n    Preconditions.checkState(isCallOrNew(call));\n    return getNthSibling(\n        call.getFirstChild().getNext(), index);\n}\n\n/**\n * Given the new or call, this returns the nth\n * argument of the dot call or null if no such argument exists.\n */\nstatic Node getArgumentForDotCall(Node call, int index) {\n    Preconditions.checkState(isDotCall(call));\n    return getNthSibling(\n        call.getFirstChild().getNext().getNext(), index);\n}\n\n/**\n * Returns whether this is a target of a call or new.\n */\nstatic boolean isCallOrNewTarget(Node target) {\n    Node parent = target.getParent();\n    return parent != null\n        && NodeUtil.isCallOrNew(parent)\n        && parent.getFirstChild() == target;\n}\n\n/**\n * Returns whether this is a target of a dot call.\n */\nstatic boolean isDotCallTarget(Node target) {\n    Node parent = target.getParent();\n    return parent != null\n        && NodeUtil.isDotCall(parent)\n        && parent.getFirstChild() == target;\n}\n\n/**\n * Returns whether this is a call or new.\n */\nstatic boolean isCallOrNew(Node node) {\n    return isCallOrNewTarget(node) || isCallOrNewTarget(node.getNext());\n}\n\n/**\n * Returns whether this is a dot call.\n */\nstatic boolean isDotCall(Node node) {\n    return isDotCallTarget(node) || isDotCallTarget(node.getNext());\n}\n\n/**\n * Given the new or call, this returns the nth\n * argument or null if no such argument exists.\n */\nstatic Node getArgumentForCallOrNew(Node call, int index) {\n    Preconditions.checkState(isCallOrNew(call));\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.getCall();\n    if (call == null) {\n        return null;\n    }\n    if (NodeUtil.isCallOrNew(call)) {\n        return getArgumentForCallOrNew(call, argIndex);\n    } else {\n        return getArgumentForDotCall(call, argIndex);\n    }\n}\n\n/**\n * Given the function, this returns the nth\n * argument or null if no such parameter exists.\n */\nstatic Node getNthSibling(Node first, int index) {\n    Node sibling = first;\n    while (index != 0 && sibling != null) {\n        sibling = sibling.getNext();\n        index--;\n    }\n    return sibling;\n}\n\n/**\n * Given the function, this returns the nth\n * argument or null if no such parameter exists.\n */\nstatic Node getArgumentForFunction(Node function, int index) {\n    Preconditions.checkState(function.isFunction());\n    return getNthSibling(\n        function.getFirstChild().getNext().getFirstChild(), index);\n}\n\n/**\n * Given the new or call, this returns the nth\n * argument of the call or null if no such argument exists.\n */\nstatic Node getArgumentForCallOrNew(Node call, int index) {\n    Preconditions.checkState(isCallOrNew(call));\n    return getNthSibling(\n        call.getFirstChild().getNext(), index);\n}\n\n/**\n * Returns whether this is a target of a call or new.\n */\nstatic boolean isCallOrNewTarget(Node target) {\n    Node parent = target.getParent();\n    return parent != null\n        && NodeUtil.isCallOrNew(parent)\n        && parent.getFirstChild() == target;\n}\n\n/**\n * Returns whether this is a call or new.\n */\nstatic boolean isCallOrNew(Node call) {\n    return NodeUtil.isCallOrNew(call);\n}\n\n/**\n * Given the new or call, this returns the nth\n * argument of the call or null if no such argument exists.\n */\nstatic Node getArgumentForDotCall(Node call, int index) {\n    Node node = call.getFirstChild();\n    while (index > 0 && node != null) {\n        node = node.getNext();\n        index--;\n    }\n    return node;\n}\n\n/**\n * Returns whether this is a target of a call or new.\n */\nstatic boolean isCallOrNewTarget(Node target) {\n    Node parent = target.getParent();\n    return parent != null\n        && NodeUtil.isCallOrNew(parent)\n        && parent.getFirstChild() == target;\n}\n\n/**\n * Returns whether this is a call or new.\n */"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) {\n        JSDocInfo jsDoc = type.getJSDocInfo();\n        if (jsDoc != null && jsDoc.isDeprecated()) {\n            return jsDoc.getDeprecationReason();\n        }\n    }\n    return null;\n}\n\n/**\n   * Returns whether this is a function node annotated as deprecated.",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    return null;\n  }\n\n  /**\n   * Returns whether this is a function node annotated as deprecated.",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) {\n        JSDocInfo info = type.getJSDocInfo();\n        if (info != null && info.isDeprecated()) {\n            if (info.getDeprecationReason() != null) {\n                return info.getDeprecationReason();\n            }\n            return \"\";\n        }\n    }\n    return null;\n}\n\n/**\n * Returns whether this is a function node annotated as deprecated.",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) {\n        JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(type);\n        if (jsDoc != null && jsDoc.isDeprecated()) {\n            if (jsDoc.getDeprecationReason() != null) {\n                return jsDoc.getDeprecationReason();\n            }\n            return \"\";\n        }\n    }\n    return null;\n}\n\n/**\n   * Returns whether this is a function node annotated as deprecated.",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) {\n        JSDocInfo jsDoc = type.getJSDocInfo();\n        if (jsDoc != null && jsDoc.isDeprecated()) {\n            if (jsDoc.getDeprecationReason() != null) {\n                return jsDoc.getDeprecationReason();\n            }\n            return \"\";\n        }\n    }\n    return null;\n  }\n\n  /**\n   * Returns whether this is a function node annotated as deprecated.",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    return null;\n  }\n\n  /**\n   * Returns whether this is a function node annotated as deprecated.",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    return null;\n  }\n\n  /**\n   * Returns whether this is a function node annotated as deprecated.",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) {\n        JSDocInfo info = type.getJSDocInfo();\n        if (info != null && info.isDeprecated()) {\n            if (info.getDeprecationReason() != null) {\n                return info.getDeprecationReason();\n            }\n            return \"\";\n        }\n    }\n    return null;\n}\n\n/**\n   * Returns whether this is a function node annotated as deprecated.",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n        if (info.getDeprecationReason() != null) {\n            return info.getDeprecationReason();\n        }\n        return \"\";\n    }\n    return null;\n}\n\n/**\n * Returns whether this is a function node annotated as deprecated.",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    return null;\n  }\n\n  /**\n   * Returns the deprecation reason for the property if it is marked\n   * as being deprecated. Returns empty string if the property is deprecated\n   * but no reason was given. Returns null if the property is not deprecated."
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    if (tz == null) {\n        return \"\";\n    }\n    String key = daylight ? \"DST_\" : \"\";\n    key += tz.getDisplayName(style, locale);\n    String result = cache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    String result = null;\n    synchronized (cache) {\n        result = cache.get(new TimeZoneDisplayKey(tz, daylight, style, locale));\n        if (result == null) {\n            result = tz.getDisplayName(daylight, style, locale);\n            cache.put(new TimeZoneDisplayKey(tz, daylight, style, locale), result);\n        }\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final String key = daylight ? \"daylight\" : \"standard\";\n    final TimeZoneDisplayKey displayKey = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String result = cache.get(displayKey);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cache.put(displayKey, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    if (tz == null) {\n        return \"\";\n    }\n    final String id = tz.getID();\n    final String displayName;\n    if (daylight) {\n        displayName = tz.getDisplayName(daylight, style, locale);\n    } else {\n        displayName = tz.getDisplayName(false, style, locale);\n    }\n    return displayName;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    String result = null;\n    synchronized (cache) {\n        result = cache.get(new TimeZoneDisplayKey(tz, daylight, style, locale));\n        if (result == null) {\n            result = tz.getDisplayName(daylight, style, locale);\n            cache.put(new TimeZoneDisplayKey(tz, daylight, style, locale), result);\n        }\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    if (tz == null) {\n        return null;\n    }\n    String key = daylight ? \"daylight\" : \"standard\";\n    if (style == TimeZone.LONG) {\n        key += \"Long\";\n    } else if (style == TimeZone.SHORT) {\n        key += \"Short\";\n    }\n    String result = cache.get(key);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cache.put(key, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final String key = daylight ? \"daylight\" : \"standard\";\n    final String tzName = tz.getDisplayName(style, Locale.US);\n    final String cacheKey = tzName + \"_\" + key + \"_\" + style + \"_\" + locale.toString();\n    String result = cache.get(cacheKey);\n    if (result == null) {\n        result = tz.getDisplayName(style, daylight ? TimeZone.getTimeZone(tzName).useDaylightTime() ? TimeZone.LONG : TimeZone.SHORT : style, locale);\n        cache.put(cacheKey, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final String key = daylight ? \"daylight\" : \"standard\";\n    final String[] names = tz.getAvailableIDs();\n    for (String name : names) {\n        if (name.startsWith(\"GMT\")) {\n            continue;\n        }\n        final TimeZone tz2 = TimeZone.getTimeZone(name);\n        if (tz.equals(tz2)) {\n            return tz.getDisplayName(daylight, style, locale);\n        }\n    }\n    return null;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final String cacheKey = new TimeZoneDisplayKey(tz, daylight, style, locale).toString();\n    String result = cache.get(cacheKey);\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cache.put(cacheKey, result);\n    }\n    return result;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    if (tz == null) {\n        return \"\";\n    }\n    String key = daylight ? \"dst\" : \"std\";\n    if (style == TimeZone.LONG) {\n        key += \"L\";\n    } else if (style == TimeZone.SHORT) {\n        key += \"S\";\n    }\n    String result = cache.get(key + tz.getOffset(System.currentTimeMillis()));\n    if (result == null) {\n        result = tz.getDisplayName(daylight, style, locale);\n        cache.put(key + tz.getOffset(System.currentTimeMillis()), result);\n    }\n    return result;\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (this.columnKeys == null) {\n        return -1;\n    }\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.columnKeys.indexOf(key);\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point >= getMin() && point <= getMax()) {\n        if (Math.abs(point - getStartValue()) <= tolerance) {\n            return Location.BOUNDARY;\n        }\n        return Location.INSIDE;\n    }\n    return Location.OUTSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point >= upper - tolerance) {\n        return Location.INSIDE;\n    } else if (point <= lower + tolerance) {\n        return Location.INSIDE;\n    } else if (point >= lower && point <= upper) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.OUTSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point >= lower && point <= upper) {\n        return Location.INSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point >= lower && point <= upper) {\n        return Location.INSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point >= lower && point <= upper) {\n        return Location.INSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point >= getMin() && point <= getMax()) {\n        if (Math.abs(point - getStartValue()) <= tolerance) {\n            return Location.BOUNDARY;\n        }\n        return Location.INSIDE;\n    }\n    return Location.OUTSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower + tolerance) {\n        return Location.INSIDE;\n    }\n    if (point > upper - tolerance) {\n        return Location.INSIDE;\n    }\n    return Location.BOUNDARY;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lower - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upper + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point >= lower && point <= upper) {\n        return Location.INSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    DecimalFormat df0 = new DecimalFormat(\"0\");\n    DecimalFormat df1 = new DecimalFormat(\"#,##0\");\n    units.add(new NumberTickUnit(1e-6, df0, 2));\n    units.add(new NumberTickUnit(1e-5, df0, 2));\n    units.add(new NumberTickUnit(1e-4, df0, 2));\n    units.add(new NumberTickUnit(1e-3, df0, 2));\n    units.add(new NumberTickUnit(1e-2, df0, 2));\n    units.add(new NumberTickUnit(1e-1, df0, 2));\n    units.add(new NumberTickUnit(1, df1, 2));\n    units.add(new NumberTickUnit(10, df1, 2));\n    units.add(new NumberTickUnit(100, df1, 2));\n    units.add(new NumberTickUnit(1000, df1, 2));\n    units.add(new NumberTickUnit(10000, df1, 2));\n    units.add(new NumberTickUnit(100000, df1, 2));\n    units.add(new NumberTickUnit(1000000, df1, 2));\n    units.add(new NumberTickUnit(10000000, df1, 2));\n    units.add(new NumberTickUnit(100000000, df1, 2));\n    units.add(new NumberTickUnit(1000000000, df1, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    DecimalFormat df0 = new DecimalFormat(\"0\");\n    DecimalFormat df1 = new DecimalFormat(\"#,##0\");\n    for (int i = 0; i < 10; i++) {\n        double value = Math.pow(10, i);\n        units.add(new NumberTickUnit(value, df0, 2));\n    }\n    for (int i = 1; i < 10; i++) {\n        double value = Math.pow(10, i);\n        units.add(new NumberTickUnit(value, df1, 2));\n    }\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    DecimalFormat df0 = new DecimalFormat(\"0\");\n    DecimalFormat df1 = new DecimalFormat(\"#,##0\");\n    for (double i = 1; i <= 10000000; i *= 10) {\n        units.add(new NumberTickUnit(i, numberFormat, 2));\n    }\n    for (double i = 0.1; i >= 0.00000001; i /= 10) {\n        units.add(new NumberTickUnit(i, df0, 2));\n    }\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    DecimalFormat df0 = new DecimalFormat(\"0\");\n    DecimalFormat df1 = new DecimalFormat(\"#,##0\");\n    units.add(new NumberTickUnit(0.1, df0, 2));\n    units.add(new NumberTickUnit(1, df0, 2));\n    units.add(new NumberTickUnit(10, df0, 2));\n    units.add(new NumberTickUnit(100, df0, 2));\n    units.add(new NumberTickUnit(1000, df0, 2));\n    units.add(new NumberTickUnit(10000, df0, 2));\n    units.add(new NumberTickUnit(100000, df0, 2));\n    units.add(new NumberTickUnit(1000000, df1, 2));\n    units.add(new NumberTickUnit(10000000, df1, 2));\n    units.add(new NumberTickUnit(100000000, df1, 2));\n    units.add(new NumberTickUnit(1000000000, df1, 2));\n    units.add(new NumberTickUnit(10000000000.0, df1, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    DecimalFormat df0 = new DecimalFormat(\"0\");\n    DecimalFormat df1 = new DecimalFormat(\"#,##0\");\n    units.add(new NumberTickUnit(0.0000001, df0, 2));\n    units.add(new NumberTickUnit(0.000001, df0, 2));\n    units.add(new NumberTickUnit(0.00001, df1, 2));\n    units.add(new NumberTickUnit(0.0001, df1, 2));\n    units.add(new NumberTickUnit(0.001, df1, 2));\n    units.add(new NumberTickUnit(0.01, df1, 2));\n    units.add(new NumberTickUnit(0.1, df1, 2));\n    units.add(new NumberTickUnit(1, df1, 2));\n    units.add(new NumberTickUnit(10, df1, 2));\n    units.add(new NumberTickUnit(100, df1, 2));\n    units.add(new NumberTickUnit(1000, df1, 2));\n    units.add(new NumberTickUnit(10000, df1, 2));\n    units.add(new NumberTickUnit(100000, df1, 2));\n    units.add(new NumberTickUnit(1000000, df1, 2));\n    units.add(new NumberTickUnit(10000000, df1, 2));\n    units.add(new NumberTickUnit(100000000, df1, 2));\n    units.add(new NumberTickUnit(1000000000, df1, 2));\n    units.add(new NumberTickUnit(10000000000.0, df1, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    DecimalFormat df0 = new DecimalFormat(\"0\");\n    DecimalFormat df1 = new DecimalFormat(\"#,##0\");\n    units.add(new NumberTickUnit(0.0001, df0, 2));\n    units.add(new NumberTickUnit(0.001, df0, 2));\n    units.add(new NumberTickUnit(0.01, df0, 2));\n    units.add(new NumberTickUnit(0.1, df0, 2));\n    units.add(new NumberTickUnit(1, df0, 2));\n    units.add(new NumberTickUnit(10, df0, 2));\n    units.add(new NumberTickUnit(100, df0, 2));\n    units.add(new NumberTickUnit(1000, df0, 2));\n    units.add(new NumberTickUnit(10000, df0, 2));\n    units.add(new NumberTickUnit(100000, df0, 2));\n    units.add(new NumberTickUnit(1000000, df1, 2));\n    units.add(new NumberTickUnit(10000000, df1, 2));\n    units.add(new NumberTickUnit(100000000, df1, 2));\n    units.add(new NumberTickUnit(1000000000, df1, 2));\n    units.add(new NumberTickUnit(10000000000.0, df1, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    DecimalFormat df0 = new DecimalFormat(\"0\");\n    DecimalFormat df1 = new DecimalFormat(\"#,##0\");\n    for (double value = 1; value < 100000000; value *= 10) {\n        units.add(new NumberTickUnit(value, numberFormat, 2));\n    }\n    for (double value = 0.1; value > 0.000001; value /= 10) {\n        units.add(new NumberTickUnit(value, df0, 2));\n    }\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    DecimalFormat df0 = new DecimalFormat(\"0\");\n    DecimalFormat df1 = new DecimalFormat(\"#,##0\");\n    units.add(new NumberTickUnit(1e-6, df0, 2));\n    units.add(new NumberTickUnit(1e-5, df0, 2));\n    units.add(new NumberTickUnit(1e-4, df0, 2));\n    units.add(new NumberTickUnit(1e-3, df0, 2));\n    units.add(new NumberTickUnit(1e-2, df0, 2));\n    units.add(new NumberTickUnit(1e-1, df0, 2));\n    units.add(new NumberTickUnit(1, df1, 2));\n    units.add(new NumberTickUnit(10, df1, 2));\n    units.add(new NumberTickUnit(100, df1, 2));\n    units.add(new NumberTickUnit(1000, df1, 2));\n    units.add(new NumberTickUnit(10000, df1, 2));\n    units.add(new NumberTickUnit(100000, df1, 2));\n    units.add(new NumberTickUnit(1000000, df1, 2));\n    units.add(new NumberTickUnit(10000000, df1, 2));\n    units.add(new NumberTickUnit(100000000, df1, 2));\n    units.add(new NumberTickUnit(1000000000, df1, 2));\n    units.add(new NumberTickUnit(10000000000.0, df1, 2));\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    DecimalFormat df0 = new DecimalFormat(\"0\");\n    DecimalFormat df1 = new DecimalFormat(\"#,##0\");\n    for (double value = 1; value < 100000000; value *= 10) {\n        units.add(new NumberTickUnit(value, numberFormat, 2));\n    }\n    return units;\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    DecimalFormat df0 = new DecimalFormat(\"0\");\n    DecimalFormat df1 = new DecimalFormat(\"#,##0\");\n    units.add(new NumberTickUnit(0.1, numberFormat, 2));\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n    units.add(new NumberTickUnit(100000000, numberFormat, 2));\n    units.add(new NumberTickUnit(1000000000, numberFormat, 2));\n    units.add(new NumberTickUnit(10000000000.0, numberFormat, 2));\n    return units;\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double maxNegCoeff = Double.MIN_VALUE;\n    int pivotCol = -1;\n    for (int col = 0; col < tableau.getWidth() - 1; col++) {\n        final double coeff = tableau.getEntry(0, col);\n        if (Precision.compareTo(coeff, 0d, maxUlps) < 0 && coeff < maxNegCoeff) {\n            maxNegCoeff = coeff;\n            pivotCol = col;\n        }\n    }\n    return pivotCol;\n}\n\n/**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoeff = Double.MAX_VALUE;\n    Integer pivotCol = null;\n    for (int col = 0; col < tableau.getWidth(); col++) {\n        if (col >= tableau.getNumObjectiveFunctions()) {\n            final double coeff = tableau.getEntry(0, col);\n            if (Precision.compareTo(coeff, 0d, maxUlps) < 0 && coeff < minCoeff) {\n                minCoeff = coeff;\n                pivotCol = col;\n            }\n        }\n    }\n    return pivotCol;\n}\n\n/**\n     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n     * @param tableau simple tableau for the problem\n     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n     * @return row with the minimum ratio",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double maxNeg = Double.MIN_VALUE;\n    int pivotCol = -1;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) {\n        final double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0 && entry < maxNeg) {\n            maxNeg = entry;\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double maxNeg = Double.MIN_VALUE;\n    Integer pivotCol = null;\n    for (int col = 0; col < tableau.getWidth() - 1; col++) {\n        double entry = tableau.getEntry(0, col);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0 && entry < maxNeg) {\n            maxNeg = entry;\n            pivotCol = col;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoeff = Double.MAX_VALUE;\n    Integer pivotCol = null;\n    for (int col = 0; col < tableau.getWidth() - 1; col++) {\n        final double coeff = tableau.getEntry(0, col);\n        if (Precision.compareTo(coeff, 0d, maxUlps) < 0 && coeff < minCoeff) {\n            minCoeff = coeff;\n            pivotCol = col;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double maxNeg = Double.MIN_VALUE;\n    int pivotCol = -1;\n    for (int i = 0; i < tableau.getWidth() - 1; i++) {\n        double entry = tableau.getEntry(0, i);\n        if (Precision.compareTo(entry, 0d, maxUlps) < 0 && entry < maxNeg) {\n            maxNeg = entry;\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoeff = Double.MAX_VALUE;\n    Integer pivotCol = null;\n    for (int col = 0; col < tableau.getWidth(); col++) {\n        if (col < tableau.getNumObjectiveFunctions()) {\n            final double coeff = tableau.getEntry(0, col);\n            if (Precision.compareTo(coeff, 0d, maxUlps) < 0) {\n                if (coeff < minCoeff) {\n                    minCoeff = coeff;\n                    pivotCol = col;\n                }\n            }\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoeff = Double.MAX_VALUE;\n    Integer pivotCol = null;\n    for (int col = 0; col < tableau.getWidth(); col++) {\n        if (col >= tableau.getNumObjectiveFunctions()) {\n            final double coeff = tableau.getEntry(0, col);\n            if (Precision.compareTo(coeff, 0d, maxUlps) < 0 && coeff < minCoeff) {\n                minCoeff = coeff;\n                pivotCol = col;\n            }\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double maxNegCoeff = Double.MIN_VALUE;\n    Integer pivotCol = null;\n    for (int col = tableau.getNumObjectiveFunctions(); col < tableau.getWidth() - 1; col++) {\n        double coeff = tableau.getEntry(0, col);\n        if (Precision.compareTo(coeff, 0d, maxUlps) < 0 && coeff < maxNegCoeff) {\n            maxNegCoeff = coeff;\n            pivotCol = col;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoeff = Double.MAX_VALUE;\n    Integer pivotCol = null;\n    for (int col = 0; col < tableau.getWidth() - 1; col++) {\n        final double coeff = tableau.getEntry(0, col);\n        if (Precision.compareTo(coeff, 0d, maxUlps) < 0) {\n            if (coeff < minCoeff) {\n                minCoeff = coeff;\n                pivotCol = col;\n            }\n        }\n    }\n    return pivotCol;\n}\n\n/**\n * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n * @param tableau simple tableau for the problem\n * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n * @return row with the minimum ratio"
    ]
  ]
}