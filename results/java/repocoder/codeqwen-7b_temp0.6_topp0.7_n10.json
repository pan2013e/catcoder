{
  "benchmark": "javaeval_repo",
  "lastest_eval": {
    "compile@1": 0.5577889447236178,
    "pass@1": 0.37185929648241206,
    "compile@3": 0.6654103852596315,
    "pass@3": 0.4375628140703517,
    "compile@5": 0.7070670814389405,
    "pass@5": 0.4625508494855229
  },
  "n": 10,
  "k": [
    1,
    3,
    5
  ],
  "fn_codes": [
    [
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }",
      "public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n     {\n        _checkNotNull(type, \"type to register serializer for\");\n        _checkNotNull(ser, \"serializer\");\n        if (_serializers == null) {\n            _serializers = new SimpleSerializers();\n        }\n        _serializers.addSerializer(type, ser);\n        return this;\n    }"
    ],
    [
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}",
      "public Number getPercentComplete(Comparable rowKey, Comparable columnKey)  {\n    Number result = null;\n    int row = getRowIndex(rowKey);\n    TaskSeries series = (TaskSeries) this.data.get(row);\n    Task task = series.get(columnKey.toString());\n    if (task != null) \n    {\n        result = task.getPercentComplete();\n    }\n    return result;\n}"
    ],
    [
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    int index = indexOf(str, 0);\n    if (index >= 0) \n    {\n        deleteImpl(index, index + str.length(), str.length());\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str != null) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + str.length(), str.length());\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    if (str == null) \n    {\n        return this;\n    }\n    final int len = str.length();\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteFirst(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        if (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n        }\n    }\n    return this;\n}"
    ],
    [
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new IteratorIterable<E>(iterator, false);\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() {\n}\n}",
      "public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator)  {\n    if (iterator == null) {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    return new Iterable<E>() \n    {\n}\n}"
    ],
    [
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            d[i][i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        double[] d = new double[m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            d[i] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, true);\n    } else {\n        throw new IllegalArgumentException(\"Input matrix must be a column or a square matrix.\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n        if (m.getColumnDimension() == 1) \n        {\n            double[] d = new double[m.getRowDimension()];\n            for (int r = 0; r < m.getRowDimension(); r++) \n            {\n                d[r] = m.getEntry(r, 0);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        } \n        else if (m.getRowDimension() == m.getColumnDimension()) \n        {\n            double[][] d = new double[m.getRowDimension()][1];\n            for (int r = 0; r < m.getRowDimension(); r++) \n            {\n                d[r][0] = m.getEntry(r, r);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        } \n        else \n        {\n            throw new IllegalArgumentException(\"Input matrix must be a column or square matrix.\");\n        }\n    }",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r][r] = m.getEntry(r, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        double[] d = new double[m.getRowDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            d[r] = m.getEntry(r, r);\n        }\n        return new Array2DRowRealMatrix(d, true);\n    } else {\n        throw new IllegalArgumentException(\"Input matrix must be a column or a square matrix.\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n        if (m.getColumnDimension() == 1) \n        {\n            double[] d = new double[m.getRowDimension()];\n            for (int i = 0; i < m.getRowDimension(); i++) \n            {\n                d[i] = m.getEntry(i, 0);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        } \n        else \n        {\n            double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n            for (int i = 0; i < m.getRowDimension(); i++) \n            {\n                d[i][i] = m.getEntry(i, 0);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        }\n    }",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        double[] d = new double[m.getRowDimension()];\n        for (int i = 0; i < d.length; i++) {\n            d[i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        double[][] d = new double[m.getRowDimension()][1];\n        for (int i = 0; i < d.length; i++) {\n            d[i][0] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        double[] d = new double[m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            d[i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        double[][] d = new double[m.getRowDimension()][1];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            d[i][0] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        throw new IllegalArgumentException(\"Input matrix must be a column matrix or a n-by-n matrix.\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) \n    {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) \n        {\n            d[i][i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } \n    else if (m.getRowDimension() == m.getColumnDimension()) \n    {\n        final double[][] d = new double[m.getRowDimension()][1];\n        for (int i = 0; i < m.getRowDimension(); i++) \n        {\n            d[i][0] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } \n    else \n    {\n        throw new IllegalArgumentException(\"Input matrix must be a column or a square matrix.\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        double[] d = new double[m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            d[i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            d[i][i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        double[] d = new double[m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            d[i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else if (m.getRowDimension() == m.getColumnDimension()) {\n        double[][] d = new double[m.getRowDimension()][1];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            d[i][0] = m.getEntry(i, i);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        throw new IllegalArgumentException(\"Input matrix must be a column matrix or a square matrix.\");\n    }\n}",
      "private static RealMatrix diag(final RealMatrix m)  {\n    if (m.getColumnDimension() == 1) {\n        final double[] d = new double[m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            d[i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    } else {\n        final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            d[i][i] = m.getEntry(i, 0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }\n}"
    ],
    [
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) \n    {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) \n        {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) \n    {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) \n        {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) \n            {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) \n    {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) \n        {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] createBlocksLayout(final int rows, final int columns)  {\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) \n    {\n        final int pStart  = iBlock * BLOCK_SIZE;\n        final int pEnd    = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) \n        {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd   = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}"
    ],
    [
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    } \n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    } \n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    } \n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    } \n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) {\n        field.setAccessible(true);\n    } else {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}",
      "public static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException  {\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"The field must not be null\");\n    }\n    if (!Modifier.isStatic(field.getModifiers())) \n    {\n        throw new IllegalArgumentException(\"The field '\" + field.getName() + \"' is not static\");\n    }\n    if (forceAccess && !field.isAccessible()) \n    {\n        field.setAccessible(true);\n    } \n    else \n    {\n        MemberUtils.setAccessibleWorkaround(field);\n    }\n    return field.get(null);\n}"
    ],
    [
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException\n    {\n        if (id == null) {\n            return getDefault();\n        }\n\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Try to parse as fixed offset\n        int offset = parseOffset(id);\n        if (offset != Integer.MIN_VALUE) {\n            return fixedOffsetZone(id, offset);\n        }\n\n        // Try to parse as time zone\n        try {\n            TimeZone tz = TimeZone.getTimeZone(id);\n            return forTimeZone(tz);\n        } catch (IllegalArgumentException ex) {\n            // Ignore\n        }\n\n        throw new IllegalArgumentException(\"Invalid zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException\n    {\n        if (id == null) {\n            return getDefault();\n        }\n\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Try to load from the file system.\n        if (iFileDir != null) {\n            File file = new File(iFileDir, id);\n            if (file.exists()) {\n                try {\n                    return new FixedDateTimeZone(id, id, file);\n                } catch (IOException ex) {\n                    // Ignore and continue.\n                }\n            }\n        }\n\n        // Try to load from the resource path.\n        InputStream in = null;\n        try {\n            in = openResource(id);\n            if (in != null) {\n                return new FixedDateTimeZone(id, id, in);\n            }\n        } catch (IOException ex) {\n            // Ignore and continue.\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ex) {\n                    // Ignore and continue.\n                }\n            }\n        }\n\n        // Try to load from the resource path with a prefix.\n        try {\n            in = openResource(\"leap/\" + id);\n            if (in != null) {\n                return new FixedDateTimeZone(id, id, in);\n            }\n        } catch (IOException ex) {\n            // Ignore and continue.\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ex) {\n                    // Ignore and continue.\n                }\n            }\n}\n}",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException\n    {\n        if (id == null) {\n            return getDefault();\n        }\n\n        DateTimeZone tz = cProvider.getZone(id);\n        if (tz != null) {\n            return tz;\n        }\n\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffsetMillis(parseOffset(id));\n        }\n\n        throw new IllegalArgumentException(\"Cannot parse time zone: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException\n    {\n        if (id == null) {\n            return getDefault();\n        }\n\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        try {\n            return fixedOffsetZone(id, parseOffset(id));\n        } catch (IllegalArgumentException ex) {\n            // try as a zone name\n        }\n\n        throw new IllegalArgumentException(\"Cannot parse DateTimeZone: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.length() < 3) {\n            throw new IllegalArgumentException(\"Invalid ID: \" + id);\n        }\n        if (id.charAt(0) == '+' || id.charAt(0) == '-') {\n            return forOffsetMillis(parseOffset(id));\n        }\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException\n    {\n        if (id == null) {\n            return getDefault();\n        }\n\n        DateTimeZone dtz = cProvider.getZone(id);\n        if (dtz != null) {\n            return dtz;\n        }\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException\n    {\n        if (id == null) {\n            return getDefault();\n        }\n\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Check if a fixed offset\n        int offset = parseOffset(id);\n        if (offset != Integer.MIN_VALUE) {\n            return fixedOffsetZone(id, offset);\n        }\n\n        throw new IllegalArgumentException(\"Invalid time zone id: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        try {\n            return fixedOffsetZone(id, parseOffset(id));\n        } catch (IllegalArgumentException ex) {\n            // Ignore\n        }\n\n        throw new IllegalArgumentException(\"Unknown time zone ID: \" + id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException\n    {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffsetMillis(parseOffset(id));\n        }\n        return getProvider().getZone(id);\n    }",
      "@FromString\n    public static DateTimeZone forID(String id)  throws IllegalArgumentException {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            return forOffsetString(id);\n        }\n        if (id.length() < 4) {\n            throw new IllegalArgumentException(\"Invalid ID: \" + id);\n        }\n        if (id.charAt(2) != ':') {\n            throw new IllegalArgumentException(\"Invalid ID: \" + id);\n        }\n        int offset = 0;\n        if (id.charAt(0) == '+') {\n            offset = 1;\n        }\n        offset += 3;\n        int hours = Integer.parseInt(id.substring(offset, offset + 2));\n        int minutes = Integer.parseInt(id.substring(offset + 3, offset + 5));\n        if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {\n            throw new IllegalArgumentException(\"Invalid ID: \" + id);\n        }\n        return forOffsetMillis(hours * 60 * 60 * 1000 + minutes * 60 * 1000);\n    }"
    ],
    [
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[i] = result.mant[i] * x;\n    }\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x >= 0 && x < RADIX) {\n        int carry = 0;\n        for (int i = mant.length-1; i >= 0; i--) {\n            final int product = mant[i] * x + carry;\n            mant[i] = product % RADIX;\n            carry = product / RADIX;\n        }\n        if (carry != 0) {\n            mant[mant.length-1] = carry;\n        }\n        return this;\n    } else {\n        return multiply(newInstance(x));\n    }\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return newInstance(getZero());\n    }\n\n    Dfp result = newInstance(this);\n\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[i] *= x;\n    }\n\n    int carry = 0;\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[i] += carry;\n        carry = result.mant[i] / RADIX;\n        result.mant[i] %= RADIX;\n    }\n\n    if (carry != 0) {\n        result.mant[mant.length] = carry;\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return newInstance(getZero());\n    }\n\n    Dfp result = newInstance(this);\n    int carry = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int product = result.mant[i] * x + carry;\n        result.mant[i] = product % RADIX;\n        carry = product / RADIX;\n    }\n\n    if (carry != 0) {\n        result.mant[0] = carry;\n        result.exp++;\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    int result[] = new int[mant.length+1];\n    int carry = 0;\n    for (int i = 0; i < mant.length; i++) \n    {\n        result[i] = mant[i] * x + carry;\n        carry = result[i] / RADIX;\n        result[i] %= RADIX;\n    }\n    result[mant.length] = carry;\n    return newInstance(result, exp);\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n\n    int rl = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = rl*RADIX + result.mant[i];\n        final int rh = r / x;\n        rl = r - rh * x;\n        result.mant[i] = rh;\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    int rl = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = rl*RADIX + result.mant[i];\n        final int rh = r / divisor;\n        rl = r - rh * divisor;\n        result.mant[i] = rh;\n    }\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    int[] product = new int[mant.length + 1];\n    int carry = 0;\n\n    for (int i = 0; i < mant.length; i++) {\n        final int productDigit = mant[i] * x + carry;\n        product[i] = productDigit % RADIX;\n        carry = productDigit / RADIX;\n    }\n    product[mant.length] = carry;\n\n    Dfp result = newInstance(this);\n    result.mant = product;\n    result.exp += 1;\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    if (x == 0) {\n        return getZero();\n    }\n\n    Dfp result = newInstance(this);\n\n    int rl = 0;\n    for (int i = mant.length-1; i >= 0; i--) {\n        final int r = rl*RADIX + result.mant[i];\n        final int rh = r / x;\n        rl = r - rh * x;\n        result.mant[i] = rh;\n    }\n\n    // Check for overflow\n    if (rl != 0) {\n        result = result.add(newInstance(rl));\n    }\n\n    return result;\n}",
      "private Dfp multiplyFast(final int x)  {\n    Dfp result = newInstance(this);\n\n    for (int i = 0; i < mant.length; i++) {\n        result.mant[i] = result.mant[i] * x;\n    }\n\n    return result;\n}"
    ],
    [
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }",
      "@SuppressWarnings(\"unchecked\")\n    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map)  {\n        if (map.isEmpty()) \n        {\n            return (Map<K, V>) map;\n        }\n        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) \n        {\n            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n        }\n        return result;\n    }"
    ],
    [
      "private Node createExternFunction(Node exportedFunction)  {\n    // The function name to use in the externs file.\n    String functionName = exportedFunction.getFirstChild().getString();\n\n    // Create a new function node with the same name and parameters.\n    Node externFunction = IR.function(\n        IR.name(functionName),\n        exportedFunction.getSecondChild().cloneTree(),\n        IR.block());\n\n    // Copy the function's JSDoc information.\n    JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n    builder.copyFromJsDoc(exportedFunction.getJSDocInfo());\n\n    // Check for missing parameter or return types.\n    if (!builder.hasParameterType() || !builder.hasReturnType()) {\n      compiler.report(JSError.make(\n          exportedFunction, MISSING_EXPORT_TYPE, functionName));\n    }\n\n    // Set the function's JSDoc information.\n    externFunction.setJSDocInfo(builder.build());\n\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node functionNode = exportedFunction.getFirstChild();\n    Node functionName = functionNode.getFirstChild();\n    Node newFunctionNode = IR.function(IR.name(\"\"), IR.paramList(), IR.block());\n    newFunctionNode.setJSType(functionNode.getJSType());\n    Node newFunctionName = newFunctionNode.getFirstChild();\n    newFunctionName.setString(functionName.getString());\n    Node newFunctionParams = newFunctionNode.getSecondChild();\n    Node oldFunctionParams = functionNode.getSecondChild();\n    Node oldFunctionBody = functionNode.getLastChild();\n    Node newFunctionBody = newFunctionNode.getLastChild();\n    newFunctionBody.setJSType(oldFunctionBody.getJSType());\n    newFunctionBody.setIsSyntheticBlock(true);\n    Node oldParam = oldFunctionParams.getFirstChild();\n    Node newParam = newFunctionParams.getFirstChild();\n    while (oldParam != null) {\n        Node newParamName = newParam.getFirstChild();\n        newParamName.setString(oldParam.getFirstChild().getString());\n        newParam = newParam.getNext();\n        oldParam = oldParam.getNext();\n    }\n    Node oldBody = oldFunctionBody.getFirstChild();\n    while (oldBody != null) {\n        oldBody = oldBody.getNext();\n    }\n    if (oldBody == null) {\n        newFunctionBody.addChildToBack(IR.empty());\n    }\n    return newFunctionNode;\n}",
      "private Node createExternFunction(Node exportedFunction)  throws MalformedException {\n      // Create a new function node with the same name and parameters.\n      Node functionNode = IR.function(\n          exportedFunction.getFirstChild().cloneTree(),\n          IR.block());\n\n      // Copy the function's type information.\n      JSDocInfo info = exportedFunction.getJSDocInfo();\n      if (info != null) {\n        functionNode.setJSDocInfo(info.clone());\n      }\n\n      // If the function is missing return type, add a warning.\n      if (info == null || !info.hasReturnType()) {\n        compiler.report(JSError.make(\n            exportedFunction, MISSING_RETURN_TYPE));\n      }\n\n      // If the function is missing parameter types, add a warning.\n      if (info == null || !info.hasParameterTypes()) {\n        compiler.report(JSError.make(\n            exportedFunction, MISSING_PARAMETER_TYPES));\n      }\n\n      return functionNode;\n    }",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = exportedFunction.cloneTree();\n    function.setType(Token.FUNCTION);\n    function.setIsSyntheticBlock(true);\n    Node name = function.getFirstChild();\n    Node params = name.getNext();\n    Node body = params.getNext();\n    Node returnType = body.getNext();\n    Node paramType = returnType.getNext();\n\n    // If the function is missing return type, add a warning.\n    if (returnType == null) {\n        compiler.report(JSError.make(\n                name, MISSING_RETURN_TYPE, name.getString()));\n    }\n\n    // If the function is missing parameter types, add a warning.\n    for (Node param = params; param != null; param = param.getNext()) {\n        if (paramType == null) {\n            compiler.report(JSError.make(\n                    name, MISSING_PARAM_TYPE, name.getString()));\n            break;\n        }\n        paramType = paramType.getNext();\n    }\n\n    // Remove the body and parameter types.\n    body.detach();\n    paramType.detach();\n\n    // Add a warning if the function is missing parameter types.\n    if (paramType == null) {\n        compiler.report(JSError.make(\n                name, MISSING_PARAM_TYPE, name.getString()));\n    }\n\n    // Add a warning if the function is missing return type.\n    if (returnType == null) {\n        compiler.report(JSError.make(\n                name, MISSING_RETURN_TYPE, name.getString()));\n    }\n\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    // Create a new function node.\n    Node newFunction = IR.function(IR.name(\"\"), IR.block());\n    newFunction.setJSType(exportedFunction.getJSType());\n\n    // Copy the parameters from the exported function.\n    Node paramList = exportedFunction.getFirstChild().getNext();\n    Node newParamList = newFunction.getFirstChild().getNext();\n    for (Node param = paramList.getFirstChild();\n         param != null;\n         param = param.getNext()) {\n        Node newParam = param.cloneTree();\n        newParam.setJSType(param.getJSType());\n        newParamList.addChildToBack(newParam);\n    }\n\n    // Copy the return type from the exported function.\n    JSType returnType = exportedFunction.getJSType().getReturnType();\n    if (returnType != null) {\n        JSTypeRegistry typeRegistry = compiler.getTypeRegistry();\n        JSType newReturnType = typeRegistry.createNullableType(returnType);\n        newFunction.setJSType(typeRegistry.createFunctionType(\n            newReturnType, newFunction.getFirstChild().getNext()));\n    } else {\n        compiler.reportWarning(\n            JSError.make(MISSING_RETURN_TYPE, exportedFunction.getSourceFileName(),\n                exportedFunction.getLineno(), exportedFunction.getCharno()));\n    }\n\n    // Copy the source info from the exported function.\n    newFunction.copyInformationFrom(exportedFunction);\n\n    return newFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  throws MalformedException {\n  // Get the function name\n  String functionName = NodeUtil.getFunctionName(exportedFunction);\n\n  // Get the function parameters\n  Node parameters = exportedFunction.getFirstChild().getNext();\n\n  // Get the function body\n  Node body = exportedFunction.getLastChild();\n\n  // Create the new function node\n  Node newFunctionNode = IR.function(IR.name(\"\"), parameters, body);\n\n  // Set the function name\n  newFunctionNode.getFirstChild().setString(functionName);\n\n  // Copy the function type\n  JSDocInfo jsDoc = exportedFunction.getJSDocInfo();\n  if (jsDoc != null) {\n    JSType type = jsDoc.getType();\n    if (type != null) {\n      newFunctionNode.setJSDocInfo(new JSDocInfo());\n      newFunctionNode.getJSDocInfo().setReturnType(type);\n      for (Node param : NodeUtil.getFunctionParameters(exportedFunction)) {\n        newFunctionNode.getJSDocInfo().setParameterType(\n            param.getString(), type);\n      }\n    }\n  }\n\n  // Return the new function node\n  return newFunctionNode;\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node function = exportedFunction.cloneTree();\n    Node functionName = function.getFirstChild();\n    functionName.setString(exportedFunction.getFirstChild().getString() + \"$externs\");\n    function.removeFirstChild();\n    function.setType(Token.FUNCTION);\n    Node body = IR.block();\n    function.addChildToBack(body);\n    Node nameNode = function.getFirstChild();\n    Node name = nameNode.getFirstChild();\n    Node args = nameNode.getNext();\n    Node arg = args.getFirstChild();\n    while (arg != null)\n    {\n        Node argName = arg.getFirstChild();\n        argName.setString(argName.getString() + \"$externs\");\n        arg = arg.getNext();\n    }\n    Node returnType = null;\n    Node paramType = null;\n    Node returnNode = NodeUtil.getFunctionReturn(function);\n    if (returnNode != null)\n    {\n        returnType = returnNode.getFirstChild();\n    }\n    Node paramNode = NodeUtil.getFunctionParameters(function);\n    Node param = paramNode.getFirstChild();\n    while (param != null)\n    {\n        paramType = param.getFirstChild();\n        param = param.getNext();\n    }\n    if (returnType == null)\n    {\n        compiler.reportWarning(\n                \"Missing return type for exported function \" + name.getString(),\n                exportedFunction);\n    }\n    if (paramType == null)\n    {\n        compiler.reportWarning(\n                \"Missing parameter type for exported function \" + name.getString(),\n                exportedFunction);\n    }\n    return function;\n}",
      "private Node createExternFunction(Node exportedFunction)  throws MalformedException {\n    // The function name to export\n    String functionName = exportedFunction.getFirstChild().getString();\n\n    // The function body to export\n    Node functionBody = exportedFunction.getLastChild();\n\n    // Create a new function node with the same name and parameters\n    Node newFunctionNode = IR.function(\n        IR.name(functionName),\n        NodeUtil.getFunctionParameters(exportedFunction),\n        IR.block());\n\n    // Copy the function type from the original function\n    JSDocInfo originalDocInfo = NodeUtil.getBestJSDocInfo(exportedFunction);\n    if (originalDocInfo != null) {\n      JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n      if (originalDocInfo.hasReturnType()) {\n        builder.recordReturnType(originalDocInfo.getReturnType());\n      }\n      if (originalDocInfo.getParameterCount() > 0) {\n        for (String param : originalDocInfo.getParameterNames()) {\n          builder.recordParameter(param, null);\n        }\n      }\n      newFunctionNode.setJSDocInfo(builder.build());\n    }\n\n    // Copy the function name from the original function\n    newFunctionNode.getFirstChild().setString(functionName);\n\n    // Copy the function name from the original function\n    newFunctionNode.getFirstChild().setString(functionName);\n\n    // Copy the function name from the original function\n    newFunctionNode.getFirstChild().setString(functionName);\n\n    // Copy the function name from the original function\n    newFunctionNode.getFirstChild().setString(functionName);\n\n    // Copy the function name from the original function\n    newFunctionNode.getFirstChild().setString(functionName);\n\n    // Copy the function name from the original function\n    newFunctionNode.getFirstChild().setString(functionName);\n\n    // Copy the function name from the original function\n    newFunctionNode.getFirstChild().setString(functionName);\n\n    // Copy the function name from the original function\n    newFunctionNode.getFirstChild().setString(functionName);\n\n    // Copy the function name from the original function\n}",
      "private Node createExternFunction(Node exportedFunction)  {\n    Node functionNode = exportedFunction.getFirstChild();\n    Node nameNode = functionNode.getFirstChild();\n    Node paramList = functionNode.getChildAt(1);\n    Node returnType = functionNode.getChildAt(2);\n    Node paramType = functionNode.getChildAt(3);\n\n    Node externFunction = IR.function(nameNode.cloneTree(),\n                                    IR.paramList(),\n                                    IR.block());\n    externFunction.setJSType(functionNode.getJSType());\n\n    // If the function is missing a return type, add a warning.\n    if (returnType == null) {\n        compiler.report(JSError.make(exportedFunction,\n                MISSING_RETURN_TYPE));\n    }\n\n    // If the function is missing a parameter type, add a warning.\n    if (paramType == null) {\n        compiler.report(JSError.make(exportedFunction,\n                MISSING_PARAMETER_TYPE));\n    }\n\n    return externFunction;\n}",
      "private Node createExternFunction(Node exportedFunction)  throws MalformedException {\n    Node function = exportedFunction.cloneTree();\n    Node functionName = function.getFirstChild();\n    Node name = NodeUtil.newName(compiler, functionName.getString(), function);\n    function.replaceChild(functionName, name);\n    function.setType(Token.FUNCTION);\n    Node body = IR.block();\n    function.addChildToBack(body);\n    NodeUtil.markNewScopesChanged(body, compiler);\n    NodeUtil.setFunctionBody(function, body);\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n    NodeUtil.setFunctionParameters(function, function.getSecondChild());\n}"
    ],
    [
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        double[] sigma = new double[params.length];\n        RealMatrix cov = computeCovariances(params, covarianceSingularityThreshold);\n        for (int i = 0; i < params.length; i++) {\n            sigma[i] = Math.sqrt(cov.getEntry(i, i));\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        // Compute the covariance matrix.\n        RealMatrix cov = computeCovariances(params, covarianceSingularityThreshold);\n\n        // Compute the standard deviations.\n        double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; ++i) {\n            sigma[i] = Math.sqrt(cov.getEntry(i, i));\n        }\n\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    // compute the covariance matrix\n    RealMatrix cov = computeCovariances(params, covarianceSingularityThreshold);\n    // get the diagonal elements of the covariance matrix\n    double[] diag = cov.getColumn(0);\n    // compute the square roots of the diagonal elements\n    double[] sigma = new double[diag.length];\n    for (int i = 0; i < diag.length; i++) {\n        sigma[i] = Math.sqrt(diag[i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        // compute the covariance matrix\n        RealMatrix cov = computeCovariances(params, covarianceSingularityThreshold);\n        // get the diagonal elements of the covariance matrix\n        double[] diag = cov.getColumn(0);\n        // compute the square roots of the diagonal elements\n        double[] sigma = new double[diag.length];\n        for (int i = 0; i < diag.length; i++) {\n            sigma[i] = Math.sqrt(diag[i]);\n        }\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    // Compute the covariance matrix.\n    RealMatrix cov = computeCovariances(params, covarianceSingularityThreshold);\n    // Compute the diagonal elements of the covariance matrix.\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; ++i) {\n        sigma[i] = Math.sqrt(cov.getEntry(i, i));\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    // Compute the covariance matrix.\n    RealMatrix cov = computeCovariances(params, covarianceSingularityThreshold);\n    // Compute the standard deviations.\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = Math.sqrt(cov.getEntry(i, i));\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[][] cov = computeCovariances(params, covarianceSingularityThreshold);\n    int dim = cov.length;\n    double[] sigma = new double[dim];\n    for (int i = 0; i < dim; ++i) {\n        sigma[i] = Math.sqrt(cov[i][i]);\n    }\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n        // compute the covariance matrix\n        RealMatrix cov = computeCovariances(params, covarianceSingularityThreshold);\n\n        // compute the eigenvalues and eigenvectors of the covariance matrix\n        EigenDecomposition ed = new EigenDecomposition(cov);\n\n        // check if the covariance matrix is singular\n        if (!ed.isNonSingular()) {\n            throw new SingularMatrixException();\n        }\n\n        // get the eigenvalues and eigenvectors\n        double[] eigenvalues = ed.getRealEigenvalues();\n        ArrayRealVector[] eigenvectors = ed.getEigenvectors();\n\n        // compute the standard deviations\n        double[] sigma = new double[params.length];\n        for (int i = 0; i < params.length; i++) {\n            sigma[i] = Math.sqrt(eigenvalues[i]);\n        }\n\n        return sigma;\n    }",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    // compute the covariance matrix\n    double[][] cov = computeCovariances(params, covarianceSingularityThreshold);\n\n    // compute the standard deviations\n    double[] sigma = new double[params.length];\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = Math.sqrt(cov[i][i]);\n    }\n\n    return sigma;\n}",
      "public double[] computeSigma(double[] params,\n                                 double covarianceSingularityThreshold)  throws SingularMatrixException {\n    double[] sigma = new double[params.length];\n    RealMatrix cov = computeCovariances(params, covarianceSingularityThreshold);\n    for (int i = 0; i < params.length; i++) {\n        sigma[i] = Math.sqrt(cov.getEntry(i, i));\n    }\n    return sigma;\n}"
    ],
    [
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) \n        {\n            throw new IllegalArgumentException(\"Cyclic substitution in variable '\" + varName + \"'\");\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution in variable '\" + varName + \"'\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic substitution in variable '\" + varName + \"'\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) \n        {\n            throw new IllegalArgumentException(\"Cyclic substitution in variable '\" + varName + \"'\");\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution in variable '\" + varName + \"'\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalStateException(\"Cyclic substitution in variable '\" + varName + \"'\");\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) \n        {\n            throw new IllegalArgumentException(\"Cyclic substitution in variable '\" + varName + \"'\");\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) \n        {\n            throw new IllegalArgumentException(\"Cyclic substitution in variable '\" + varName + \"'\");\n        }\n    }",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n        if (priorVariables.contains(varName)) {\n            throw new IllegalStateException(\"Cyclic substitution in variable '\" + varName + \"'\");\n        }\n    }\n}",
      "private void checkCyclicSubstitution(final String varName, final List<String> priorVariables)  {\n    if (priorVariables.contains(varName)) {\n        throw new IllegalArgumentException(\"Cyclic substitution in variable '\" + varName + \"'\");\n    }\n}"
    ],
    [
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> dependencies = new ArrayList<>();\n    Set<INPUT> visited = new HashSet<>();\n    \n    for (INPUT root : roots) {\n        getDependenciesOf(root, dependencies, visited, sorted);\n    }\n    \n    return dependencies;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<>();\n    Set<INPUT> visited = new HashSet<>();\n\n    for (INPUT root : roots) {\n        addDependencies(root, result, visited, sorted);\n    }\n\n    return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> dependencies = new ArrayList<>();\n    for (INPUT root : roots) {\n        dependencies.addAll(getDependenciesOf(root, sorted));\n    }\n    return dependencies;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> result = new ArrayList<>();\n    Set<INPUT> visited = new HashSet<>();\n\n    for (INPUT root : roots) {\n        getDependenciesOf(root, result, visited, sorted);\n    }\n\n    return result;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> dependencies = new ArrayList<>();\n    Set<INPUT> visited = new HashSet<>();\n    for (INPUT root : roots) {\n        getDependenciesOf(root, dependencies, visited, sorted);\n    }\n    return dependencies;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    List<INPUT> dependencies = Lists.newArrayList();\n    Set<INPUT> visited = Sets.newHashSet();\n\n    for (INPUT root : roots) {\n      getDependenciesOf(root, visited, dependencies);\n    }\n\n    if (sorted) {\n      return topologicalStableSort(dependencies, getDependenciesMap(inputs));\n    } else {\n      return Collections.unmodifiableList(dependencies);\n    }\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> dependencies = new ArrayList<>();\n    Set<INPUT> visited = new HashSet<>();\n\n    for (INPUT root : roots) {\n        getDependenciesOfHelper(root, dependencies, visited, sorted);\n    }\n\n    return dependencies;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  {\n    List<INPUT> dependencies = new ArrayList<>();\n    Set<INPUT> visited = new HashSet<>();\n\n    for (INPUT root : roots) {\n        getDependenciesOf(root, dependencies, visited, sorted);\n    }\n\n    return dependencies;\n}",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    Set<INPUT> visited = Sets.newHashSet();\n    List<INPUT> result = Lists.newArrayList();\n\n    for (INPUT root : roots) {\n      getDependenciesOf(root, visited, result);\n    }\n\n    if (sorted) {\n      result = topologicalStableSort(result, getDependenciesMap(inputs));\n    }\n\n    return Collections.unmodifiableList(result);\n  }",
      "public List<INPUT> getDependenciesOf(List<INPUT> roots, boolean sorted)  throws CircularDependencyException {\n    List<INPUT> dependencies = Lists.newArrayList();\n    Set<INPUT> visited = Sets.newHashSet();\n    for (INPUT root : roots) {\n      getDependenciesOf(root, visited, dependencies, sorted);\n    }\n    return dependencies;\n  }"
    ],
    [
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String uncapitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean uncapitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            uncapitalizeNext = true;\n        } else if (uncapitalizeNext) {\n            buffer[i] = Character.toLowerCase(ch);\n            uncapitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.getField().getRadixDigits()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getDigit(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getDigit(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.getField().getRadixDigits()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.mant[i];\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.mant[i];\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = new char[a.getField().getRadixDigits()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.mant[i];\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.mant[i];\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    char[] buf = new char[a.getField().getRadixDigits()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getDigit(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.getDigit(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    return split(a.getField(), a.toString());\n}",
      "protected static Dfp[] split(final Dfp a)  {\n    Dfp result[] = new Dfp[2];\n    char[] buf;\n    boolean leading = true;\n    int sp = 0;\n    int sig = 0;\n\n    buf = new char[a.toString().length()];\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n\n        if (buf[i] >= '1' && buf[i] <= '9') {\n            leading = false;\n        }\n\n        if (buf[i] == '.') {\n            sig += (400 - sig) % 4;\n            leading = false;\n        }\n\n        if (sig == (a.getField().getRadixDigits() / 2) * 4) {\n            sp = i;\n            break;\n        }\n\n        if (buf[i] >= '0' && buf[i] <= '9' && !leading) {\n            sig ++;\n        }\n    }\n\n    result[0] = a.getField().newDfp(new String(buf, 0, sp));\n\n    for (int i = 0; i < buf.length; i++) {\n        buf[i] = a.toString().charAt(i);\n        if (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\n            buf[i] = '0';\n        }\n    }\n\n    result[1] = a.getField().newDfp(new String(buf));\n\n    return result;\n}"
    ],
    [
      "public String cssSelector()  {\n    // todo: handle namespaces\n    if (hasAttr(\"id\"))\n        return \"#\" + getAttr(\"id\");\n    StringBuilder selector = new StringBuilder();\n    Element parent = parent();\n    if (parent != null)\n        selector.append(parent.cssSelector()).append(\" > \");\n    selector.append(tagName());\n    if (hasAttr(\"class\"))\n        selector.append(\".\").append(getAttr(\"class\").replace(\" \", \".\"));\n    if (siblingIndex() > 0)\n        selector.append(\":nth-child(\").append(siblingIndex() + 1).append(\")\");\n    return selector.toString();\n}",
      "public String cssSelector()  {\n        // todo: should this be a method on Node?\n        if (hasAttr(\"id\"))\n            return \"#\" + attr(\"id\");\n\n        Element parent = parent();\n        if (parent == null)\n            return tagName();\n\n        Elements siblings = parent.children();\n        int siblingIndex = siblings.indexOf(this);\n        StringBuilder selector = new StringBuilder(parent.cssSelector());\n        selector.append(\" > \");\n        selector.append(tagName());\n        if (hasAttr(\"class\"))\n            selector.append(\".\").append(attr(\"class\").replace(\" \", \".\"));\n        if (siblingIndex > 0)\n            selector.append(\":nth-child(\").append(siblingIndex + 1).append(\")\");\n        return selector.toString();\n    }",
      "public String cssSelector()  {\n    StringBuilder selector = new StringBuilder();\n    if (hasId()) {\n        selector.append(\"#\").append(id());\n    } else {\n        if (parent() != null) {\n            selector.append(parent().cssSelector()).append(\" > \");\n        }\n        selector.append(tagName());\n        if (hasClass()) {\n            for (String className : classNameList()) {\n                selector.append(\".\").append(className);\n            }\n        }\n        if (siblingIndex() > 0) {\n            selector.append(\":nth-child(\").append(siblingIndex()).append(\")\");\n        }\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n        // todo: implement\n        return \"\";\n    }",
      "public String cssSelector()  {\n    if (hasAttr(\"id\")) \n    {\n        return \"#\" + attr(\"id\");\n    } \n    else \n    {\n        StringBuilder selector = new StringBuilder();\n        Element parent = parent();\n        if (parent != null) \n        {\n            selector.append(parent.cssSelector()).append(\" > \");\n        }\n        selector.append(tagName());\n        if (hasAttr(\"class\")) \n        {\n            selector.append(\".\").append(attr(\"class\").replace(\" \", \".\"));\n        }\n        if (siblingIndex() > 0) \n        {\n            selector.append(\":nth-child(\").append(siblingIndex() + 1).append(\")\");\n        }\n        return selector.toString();\n    }\n}",
      "public String cssSelector()  {\n    if (hasAttr(\"id\")) \n    {\n        return \"#\" + attr(\"id\");\n    } \n    else \n    {\n        Element parent = parent();\n        if (parent == null) \n        {\n            return tagName();\n        } \n        else \n        {\n            StringBuilder selector = new StringBuilder(parent.cssSelector());\n            selector.append('>');\n            String unique = uniqueCssSelector();\n            selector.append(unique);\n            return selector.toString();\n        }\n    }\n}",
      "public String cssSelector()  {\n    if (hasAttr(\"id\"))\n        return \"#\" + attr(\"id\");\n\n    StringBuilder selector = new StringBuilder();\n    Element el = this;\n    while (el != null)\n    {\n        if (el.parent() != null)\n        {\n            selector.insert(0, \" > \");\n            String siblingSelector = el.siblingIndex() > 0 ? \":nth-child(\" + el.siblingIndex() + \")\" : \"\";\n            selector.insert(0, el.tagName() + siblingSelector);\n        }\n        el = el.parent();\n    }\n    return selector.toString();\n}",
      "public String cssSelector()  {\n    // todo: implement\n    return null;\n}",
      "public String cssSelector()  {\n    if (hasId())\n        return \"#\" + id();\n    else\n    {\n        StringBuilder selector = new StringBuilder();\n        Element parent = parent();\n        if (parent != null)\n        {\n            selector.append(parent.cssSelector());\n            selector.append(\" > \");\n        }\n        selector.append(tagName());\n        if (classNames().size() > 0)\n        {\n            for (String className : classNames())\n                selector.append(\".\").append(className);\n        }\n        if (attributes().size() > 0)\n        {\n            for (Attribute attribute : attributes())\n            {\n                if (attribute.getValue().contains(\" \"))\n                    selector.append(\"[\").append(attribute.getKey()).append(\"='\").append(attribute.getValue()).append(\"']\");\n                else\n                    selector.append(\"[\").append(attribute.getKey()).append(\"='\").append(attribute.getValue()).append(\"']\");\n            }\n        }\n        return selector.toString();\n    }\n}",
      "public String cssSelector()  {\n    if (hasId())\n        return \"#\" + id();\n\n    StringBuilder selector = new StringBuilder();\n    Element parent = parent();\n    if (parent != null)\n        selector.append(parent.cssSelector()).append(\" > \");\n\n    selector.append(tagName());\n    if (hasClass())\n        selector.append(\".\").append(classNames().replace(\" \", \".\"));\n\n    if (parent != null) {\n        int index = parent.childElementIndex(this);\n        if (index > 0)\n            selector.append(\":nth-child(\").append(index + 1).append(\")\");\n    }\n\n    return selector.toString();\n}"
    ],
    [
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost++;\n    }\n    if (n.isParenthesized()) {\n        cost++;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n      case Token.NOT:\n        cost++;\n        break;\n      case Token.AND:\n      case Token.OR:\n        cost += 2;\n        break;\n      default:\n        break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n      case Token.NOT:\n        cost++;\n        break;\n      case Token.LPAREN:\n      case Token.RPAREN:\n        cost++;\n        break;\n      default:\n        break;\n    }\n    return cost;\n  }",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) \n    {\n        case Token.NOT:\n            cost = 1;\n            break;\n        case Token.AND:\n        case Token.OR:\n            cost = 2;\n            break;\n        default:\n            break;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost++;\n    }\n    if (n.getParent() != null && n.getParent().isNot()) {\n        cost++;\n    }\n    if (n.getParent() != null && n.getParent().isParenthesized()) {\n        cost++;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) {\n      case Token.NOT:\n        cost = 1;\n        break;\n      case Token.NEG:\n        cost = 1;\n        break;\n      default:\n        break;\n    }\n    return cost;\n  }",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    switch (n.getType()) \n    {\n        case Token.NOT:\n            cost = 1;\n            break;\n        case Token.NEG:\n            cost = 1;\n            break;\n        case Token.HOOK:\n            cost = 1;\n            break;\n        case Token.OR:\n            cost = 1;\n            break;\n        case Token.AND:\n            cost = 1;\n            break;\n        case Token.EQ:\n            cost = 1;\n            break;\n        case Token.NE:\n            cost = 1;\n            break;\n        case Token.LT:\n            cost = 1;\n            break;\n        case Token.LE:\n            cost = 1;\n            break;\n        case Token.GT:\n            cost = 1;\n            break;\n        case Token.GE:\n            cost = 1;\n            break;\n        case Token.SHEQ:\n            cost = 1;\n            break;\n        case Token.SHNE:\n            cost = 1;\n            break;\n        case Token.INSTANCEOF:\n            cost = 1;\n            break;\n        case Token.IN:\n            cost = 1;\n            break;\n        case Token.ADD:\n            cost = 1;\n            break;\n        case Token.SUB:\n            cost = 1;\n            break;\n        case Token.MUL:\n            cost = 1;\n            break;\n        case Token.DIV:\n            cost = 1;\n            break;\n        case Token.MOD:\n            cost = 1;\n            break;\n        case Token.LSH:\n            cost = 1;\n            break;\n        case Token.RSH:\n            cost = 1;\n            break;\n        case Token.URSH:\n            cost = 1;\n            break;\n        case Token.BITOR:\n            cost = 1;\n            break;\n        case Token.BITXOR:\n            cost = 1;\n            break;\n        case Token.BITAND:\n            cost = 1;\n            break;\n}\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) \n    {\n        cost++;\n    }\n    if (n.getParent() != null && n.getParent().isParentheses()) \n    {\n        cost++;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost++;\n    }\n    if (n.isParenthesized()) {\n        cost++;\n    }\n    return cost;\n}",
      "private static int estimateCostOneLevel(Node n)  {\n    int cost = 0;\n    if (n.isNot()) {\n        cost++;\n    }\n    if (n.isParenthesized()) {\n        cost++;\n    }\n    return cost;\n}"
    ],
    [
      "public StrBuilder reverse()  {\n    if (size > 1) \n    {\n        final char thisBuf[] = this.buffer;\n        for (int i = 0, j = size - 1; i < j; i++, j--) \n        {\n            final char swap = thisBuf[i];\n            thisBuf[i] = thisBuf[j];\n            thisBuf[j] = swap;\n        }\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size < 2) \n    {\n        return this;\n    }\n    \n    final char[] buffer = this.buffer;\n    for (int i = 0, j = size - 1; i < j; i++, j--) \n    {\n        char tmp = buffer[i];\n        buffer[i] = buffer[j];\n        buffer[j] = tmp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    char tmp;\n    while (left < right) \n    {\n        tmp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = tmp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    if (size > 1) \n    {\n        final char thisBuf[] = this.buffer;\n        for (int i = 0; i < size / 2; i++) \n        {\n            final char swap = thisBuf[i];\n            thisBuf[i] = thisBuf[size - i - 1];\n            thisBuf[size - i - 1] = swap;\n        }\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    final int len = size;\n    final char thisBuf[] = buffer;\n    for (int i = 0; i < len / 2; i++) \n    {\n        char swap = thisBuf[i];\n        thisBuf[i] = thisBuf[len - i - 1];\n        thisBuf[len - i - 1] = swap;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int len = size();\n    char[] buf = buffer();\n    for (int i = 0; i < len / 2; i++) \n    {\n        char tmp = buf[i];\n        buf[i] = buf[len - i - 1];\n        buf[len - i - 1] = tmp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    final char[] buffer = this.buffer;\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        final char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        char temp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = temp;\n        left++;\n        right--;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int len = size();\n    for (int i = 0; i < len / 2; i++) \n    {\n        char tmp = buffer[i];\n        buffer[i] = buffer[len - i - 1];\n        buffer[len - i - 1] = tmp;\n    }\n    return this;\n}",
      "public StrBuilder reverse()  {\n    int left = 0;\n    int right = size - 1;\n    while (left < right) \n    {\n        char tmp = buffer[left];\n        buffer[left] = buffer[right];\n        buffer[right] = tmp;\n        left++;\n        right--;\n    }\n    return this;\n}"
    ],
    [
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static boolean equalsIncludingNaN(double[] x, double[] y)  {\n    if ((x == null) || (y == null)) \n    {\n        return !((x == null) ^ (y == null));\n    }\n    if (x.length != y.length) \n    {\n        return false;\n    }\n    for (int i = 0; i < x.length; ++i) \n    {\n        if (!Precision.equalsIncludingNaN(x[i], y[i])) \n        {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > text().length())\n        throw new IllegalArgumentException(\"Offset must be between 0 and text length\");\n\n    TextNode first = new TextNode(text().substring(0, offset));\n    TextNode second = new TextNode(text().substring(offset));\n    replaceWith(first);\n    first.after(second);\n    return second;\n}",
      "public TextNode splitText(int offset)  {\n        if (offset < 0 || offset > text().length())\n            throw new IllegalArgumentException(\"Split offset must be within text length\");\n\n        TextNode first = new TextNode(text().substring(0, offset));\n        TextNode second = new TextNode(text().substring(offset));\n        replaceWith(first);\n        first.appendTo(second);\n        return second;\n    }",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > val.length())\n        throw new IllegalArgumentException(\"Offset must be between 0 and the length of the text\");\n\n    TextNode newNode = new TextNode(val.substring(offset));\n    parent.insertAfter(newNode, this);\n    val = val.substring(0, offset);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > text().length())\n        throw new IllegalArgumentException(\"Offset must be between 0 and the text length\");\n\n    TextNode first = new TextNode(text().substring(0, offset));\n    TextNode second = new TextNode(text().substring(offset));\n\n    replaceWith(first, second);\n\n    return second;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > text().length())\n        throw new IllegalArgumentException(\"Offset must be between 0 and text length\");\n\n    TextNode first = new TextNode(text().substring(0, offset));\n    TextNode second = new TextNode(text().substring(offset));\n    replaceWith(first, second);\n    return second;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > text().length())\n        throw new IllegalArgumentException(\"Split offset must be between 0 and the length of the text\");\n\n    TextNode first = new TextNode(text().substring(0, offset));\n    TextNode second = new TextNode(text().substring(offset));\n    replaceWith(first, second);\n    return second;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > val.length())\n        throw new IllegalArgumentException(\"Offset must be between 0 and the text length\");\n\n    TextNode newNode = new TextNode(val.substring(offset));\n    parent.insertAfter(newNode, this);\n    val = val.substring(0, offset);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > val.length()) throw new IllegalArgumentException(\"Split offset must be between 0 and text length\");\n    TextNode newNode = new TextNode(val.substring(offset));\n    parent.insertChild(index + 1, newNode);\n    val = val.substring(0, offset);\n    return newNode;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > text().length())\n        throw new IllegalArgumentException(\"Offset must be between 0 and the text length\");\n\n    TextNode first = new TextNode(text().substring(0, offset));\n    TextNode second = new TextNode(text().substring(offset));\n    replaceWith(first, second);\n    return second;\n}",
      "public TextNode splitText(int offset)  {\n    if (offset < 0 || offset > text().length())\n        throw new IllegalArgumentException(\"Offset must be between 0 and text length\");\n\n    TextNode first = new TextNode(text().substring(0, offset));\n    TextNode second = new TextNode(text().substring(offset));\n    replaceWith(first);\n    first.after(second);\n    return second;\n}"
    ],
    [
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n    }\n    return helper.list();\n}"
    ],
    [
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[BYTE];\n        putBigInteger(value, result, 0);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[8];\n        ByteUtils.toLittleEndian(result, value, 0, 8);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    putBigInteger(value, result, 0);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[8];\n    ByteUtils.toLittleEndian(result, value, 0, 8);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[BYTE_COUNT];\n        ByteUtils.toLittleEndian(result, value, 0, BYTE_COUNT);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[8];\n        ByteUtils.toLittleEndian(result, value, 0, 8);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[BYTE_COUNT];\n    ByteUtils.toLittleEndian(result, value, 0, BYTE_COUNT);\n    return result;\n}",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[8];\n        putBigInteger(value, result, 0);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n        final byte[] result = new byte[8];\n        putBigInteger(value, result, 0);\n        return result;\n    }",
      "public static byte[] getBytes(final BigInteger value)  {\n    final byte[] result = new byte[BYTE];\n    putBigInteger(value, result, 0);\n    return result;\n}"
    ],
    [
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  ",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for (int i = 0; i < sz; i++) {\n        if (chars.contains(chrs[i])) {\n            buffer.append(chrs[i]);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  ",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    for (int i = 0; i < sz; i++) {\n        if (chars.contains(chrs[i])) {\n            buffer.append(chrs[i]);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    final char[] chrs = str.toCharArray();\n    final int sz = chrs.length;\n    char ch = ' ';\n    for (int i = 0; i < sz; i++) {\n        ch = chrs[i];\n        // Compare with contains() last for performance.\n        if (chars.contains(ch)) {\n            buffer.append(ch);\n        }\n    }\n    return buffer.toString();\n}",
      "public static String keep(final String str, final String... set)  ",
      "public static String keep(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return str;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    final StringBuilder buffer = new StringBuilder(str.length());\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            buffer.append(c);\n        }\n    }\n    return buffer.toString();\n}"
    ],
    [
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n        if (!isSymmetric()) {\n            throw new MathUnsupportedOperationException(\n                LocalizedCoreFormats.NOT_SYMMETRIC_MATRIX);\n        }\n        if (!isPositiveDefinite()) {\n            throw new MathUnsupportedOperationException(\n                LocalizedCoreFormats.NOT_POSITIVE_DEFINITE_MATRIX);\n        }\n\n        final int n = getColumnDimension();\n        final double[][] sqrtData = new double[n][n];\n        for (int i = 0; i < n; ++i) {\n            sqrtData[i][i] = Math.sqrt(getEntry(i, i));\n        }\n\n        return new Array2DRowRealMatrix(sqrtData, false);\n    }\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n        if (!isSymmetric()) {\n            throw new MathUnsupportedOperationException(\n                LocalizedFormats.NOT_SYMMETRIC_MATRIX);\n        }\n        if (!isPositiveDefinite()) {\n            throw new MathUnsupportedOperationException(\n                LocalizedFormats.NOT_POSITIVE_DEFINITE_MATRIX);\n        }\n\n        final int n = getRowDimension();\n        final double[][] sqrtData = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                sqrtData[i][j] = 0.0;\n            }\n        }\n\n        // Perform the Cholesky decomposition on the matrix.\n        final CholeskyDecomposition chol = new CholeskyDecomposition(this);\n        final RealMatrix l = chol.getL();\n        final RealMatrix lT = l.transpose();\n\n        // Compute the square-root matrix.\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                sqrtData[i][j] = l.getEntry(i, j) * lT.getEntry(j, i);\n            }\n        }\n\n        return new Array2DRowRealMatrix(sqrtData, false);\n    }\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_SYMMETRIC_MATRIX);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_POSITIVE_DEFINITE_MATRIX);\n    }\n\n    final int n = getRowDimension();\n    final double[][] sqrtData = new double[n][n];\n    final double[] eigenvalues = getRealEigenvalues();\n    for (int i = 0; i < n; ++i) {\n        sqrtData[i][i] = Math.sqrt(eigenvalues[i]);\n    }\n    return new Array2DRowRealMatrix(sqrtData, false);\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_SYMMETRIC_MATRIX);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_POSITIVE_DEFINITE_MATRIX);\n    }\n\n    final int n = getColumnDimension();\n    final double[][] sqrtData = new double[n][n];\n\n    // Compute the Cholesky decomposition.\n    final CholeskyDecomposition chol = new CholeskyDecomposition(this);\n    final RealMatrix l = chol.getL();\n\n    // Compute the square-root.\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            sqrtData[i][j] = l.getEntry(i, j) / Math.sqrt(l.getEntry(j, j));\n        }\n    }\n\n    return new Array2DRowRealMatrix(sqrtData, false);\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_SYMMETRIC_MATRIX);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_POSITIVE_DEFINITE_MATRIX);\n    }\n\n    final int m = getRowDimension();\n    final int n = getColumnDimension();\n    final double[][] sqrtData = new double[m][n];\n\n    // Perform Cholesky decomposition.\n    final CholeskyDecomposition c = new CholeskyDecomposition(this);\n    final RealMatrix l = c.getL();\n    final RealMatrix lT = l.transpose();\n\n    // Compute square root.\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            sqrtData[i][j] = l.getEntry(i, j) * lT.getEntry(j, i);\n        }\n    }\n\n    return new Array2DRowRealMatrix(sqrtData, false);\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_SYMMETRIC_MATRIX);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_POSITIVE_DEFINITE_MATRIX);\n    }\n\n    final int m = getRowDimension();\n    final int n = getColumnDimension();\n    final double[][] sqrtData = new double[m][n];\n    final double[] eigenvalues = getRealEigenvalues();\n    final RealMatrix eigenvectors = getV();\n    for (int i = 0; i < m; ++i) {\n        final ArrayRealVector v = eigenvectors.getRowVector(i);\n        final double[] vData = v.getDataRef();\n        double s = 0;\n        for (int j = 0; j < m; ++j) {\n            s += v.getEntry(j) * sqrtData[j][i];\n        }\n        s = Math.sqrt(eigenvalues[i] - s * s);\n        for (int j = 0; j < m; ++j) {\n            sqrtData[j][i] += s * vData[j];\n        }\n    }\n\n    return new Array2DRowRealMatrix(sqrtData, false);\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_SYMMETRIC_MATRIX);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_POSITIVE_DEFINITE_MATRIX);\n    }\n\n    final int n = getColumnDimension();\n    final double[][] sqrtData = new double[n][n];\n\n    // Compute the Cholesky decomposition of the matrix.\n    final CholeskyDecomposition chol = new CholeskyDecomposition(this);\n\n    // Copy the upper triangular part of the Cholesky decomposition\n    // into the square-root matrix.\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            sqrtData[i][j] = chol.getU().getEntry(i, j);\n        }\n    }\n\n    return new Array2DRowRealMatrix(sqrtData, false);\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n        if (!isSymmetric()) {\n            throw new MathUnsupportedOperationException(\n                LocalizedFormats.NOT_SYMMETRIC_MATRIX);\n        }\n        if (!isPositiveDefinite()) {\n            throw new MathUnsupportedOperationException(\n                LocalizedFormats.NOT_POSITIVE_DEFINITE_MATRIX);\n        }\n\n        final int n = getColumnDimension();\n        final double[][] sqrtData = new double[n][n];\n\n        // Compute the Cholesky decomposition of the matrix.\n        final CholeskyDecomposition c = new CholeskyDecomposition(this);\n\n        // Compute the square root matrix.\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                sqrtData[i][j] = c.getL().getEntry(i, j) * c.getL().getEntry(j, j);\n            }\n        }\n\n        return new Array2DRowRealMatrix(sqrtData, false);\n    }\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_SYMMETRIC_MATRIX);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_POSITIVE_DEFINITE_MATRIX);\n    }\n\n    final int n = getColumnDimension();\n    final double[][] sqrtData = new double[n][n];\n\n    // Create the Cholesky decomposition of the matrix.\n    final CholeskyDecomposition chol = new CholeskyDecomposition(this);\n\n    // Copy the square root of the diagonal elements.\n    final double[] diag = chol.getDiagonal();\n    for (int i = 0; i < n; i++) {\n        sqrtData[i][i] = Math.sqrt(diag[i]);\n    }\n\n    // Create the square root of the off-diagonal elements.\n    final RealMatrix l = chol.getL();\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            sqrtData[i][j] = l.getEntry(i, j) * sqrtData[j][j];\n            sqrtData[j][i] = sqrtData[i][j];\n        }\n    }\n\n    return new Array2DRowRealMatrix(sqrtData, false);\n}",
      "public RealMatrix getSquareRoot()  throws MathUnsupportedOperationException {\n    if (!isSymmetric()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_SYMMETRIC_MATRIX);\n    }\n    if (!isPositiveDefinite()) {\n        throw new MathUnsupportedOperationException(\n            LocalizedFormats.NOT_POSITIVE_DEFINITE_MATRIX);\n    }\n\n    final int n = getColumnDimension();\n    final double[][] sqrtData = new double[n][n];\n    final double[] eigenvalues = getRealEigenvalues();\n    for (int i = 0; i < n; ++i) {\n        sqrtData[i][i] = Math.sqrt(eigenvalues[i]);\n    }\n    return new Array2DRowRealMatrix(sqrtData, false);\n}"
    ],
    [
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n            return ctxt.handleUnexpectedToken(_containerType.getRawClass(), p);\n        }\n        Map<Object,Object> result = (Map<Object,Object>) _valueInstantiator.createUsingDefault(ctxt);\n        return deserialize(p, ctxt, result);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // Ok: must point to START_OBJECT, FIELD_NAME or END_OBJECT\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) {\n            // (empty) String may be ok however; or single-String-arg ctor\n            if (t == JsonToken.VALUE_STRING) {\n                return _valueInstantiator.createFromString(ctxt, p.getText());\n            }\n            // slightly redundant (since String was passed above), but also handles empty array case:\n            return _deserializeFromEmpty(p, ctxt);\n        }\n        final Map<Object,Object> result = (Map<Object,Object>) _valueInstantiator.createUsingDefault(ctxt);\n        _readAndBind(p, ctxt, result);\n        return result;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        // Ok: must point to START_OBJECT or FIELD_NAME\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n            return (Map<Object,Object>) ctxt.handleUnexpectedToken(getMapClass(), p);\n        }\n        final Map<Object,Object> result = (Map<Object,Object>) _valueInstantiator.createUsingDefault(ctxt);\n        if (_standardStringKey) {\n            _readAndBindStringKeyMap(p, ctxt, result);\n            return result;\n        }\n        _readAndBind(p, ctxt, result);\n        return result;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n            return ctxt.handleUnexpectedToken(_containerType.getRawClass(), p);\n        }\n        final Map<Object,Object> result = (Map<Object,Object>) _valueInstantiator.createUsingDefault(ctxt);\n        if (_standardStringKey) {\n            _readAndBindStringKeyMap(p, ctxt, result);\n            return result;\n        }\n        _readAndBind(p, ctxt, result);\n        return result;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n            return (Map<Object,Object>) ctxt.handleUnexpectedToken(getMapClass(), p);\n        }\n        final Map<Object,Object> result = (Map<Object,Object>) _valueInstantiator.createUsingDefault(ctxt);\n        if (_standardStringKey) {\n            _readAndBindStringKeyMap(p, ctxt, result);\n            return result;\n        }\n        _readAndBind(p, ctxt, result);\n        return result;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n            return (Map<Object,Object>) ctxt.handleUnexpectedToken(getMapClass(), p);\n        }\n        // 21-Apr-2017, tatu: Need separate methods to do proper merging\n        if (_standardStringKey) {\n            return _readAndUpdateStringKeyMap(p, ctxt, null);\n        }\n        return _readAndUpdate(p, ctxt, null);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n            return (Map<Object,Object>) ctxt.handleUnexpectedToken(getMapClass(), p);\n        }\n        // 21-Apr-2017, tatu: Need separate methods to do proper merging\n        if (_standardStringKey) {\n            return _readAndUpdateStringKeyMap(p, ctxt, (Map<Object,Object>) _valueInstantiator.createUsingDefault(ctxt));\n        }\n        return _readAndUpdate(p, ctxt, (Map<Object,Object>) _valueInstantiator.createUsingDefault(ctxt));\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n            return ctxt.handleUnexpectedToken(getMapClass(), p);\n        }\n        final Map<Object,Object> result = (Map<Object,Object>) _valueInstantiator.createUsingDefault(ctxt);\n        if (_standardStringKey) {\n            _readAndBindStringKeyMap(p, ctxt, result);\n            return result;\n        }\n        _readAndBind(p, ctxt, result);\n        return result;\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_NULL) {\n            return _valueInstantiator.createUsingDefault(ctxt);\n        }\n        if (_nonStandardKeyDeserializer != null) {\n            return _deserializeUsingNonDefaultKeyDeserializer(p, ctxt);\n        }\n        if (_standardStringKey) {\n            return _deserializeFromString(p, ctxt);\n        }\n        if (_keyDeserializer == null) {\n            return _deserializeFromNumber(p, ctxt);\n        }\n        return _deserializeFromAny(p, ctxt, t);\n    }",
      "private final Object vanillaDeserialize(JsonParser p,\n    \t\tDeserializationContext ctxt, JsonToken t)\n        throws IOException\n     {\n        if (t == JsonToken.VALUE_NULL) {\n            return _valueInstantiator.createUsingDefault(ctxt);\n        }\n        if (_nonStandardKey) {\n            return _deserializeUsingNonDefaultKey(p, ctxt);\n        }\n        if (_standardStringKey) {\n            return _deserializeUsingStringKey(p, ctxt);\n        }\n        return _deserializeFromOther(p, ctxt, t);\n    }"
    ],
    [
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"Sample arrays must not be empty\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0d;\n    for (int i = 0; i < n; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException();\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    if (sample1.length == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"The sample arrays are empty.\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"Sample arrays must not be empty\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"The sample arrays are empty\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0d;\n    for (int i = 0; i < n; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n == 0) {\n        throw new NoDataException();\n    }\n    double sum = 0d;\n    for (int i = 0; i < n; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}",
      "public static double sumDifference(final double[] sample1, final double[] sample2)\n    throws DimensionMismatchException, NoDataException  {\n    if (sample1.length == 0 || sample2.length == 0) {\n        throw new NoDataException(\"At least one of the samples is empty\");\n    }\n    if (sample1.length != sample2.length) {\n        throw new DimensionMismatchException(sample1.length, sample2.length);\n    }\n    double sum = 0d;\n    for (int i = 0; i < sample1.length; i++) {\n        sum += sample1[i] - sample2[i];\n    }\n    return sum;\n}"
    ],
    [
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int chunkSize = fullChunk.length;\n        if (_size > 0) {\n            // First, check if we can reuse the last chunk\n            if (_tail.value.length == chunkSize) {\n                _tail.value = fullChunk;\n                return _tail.value;\n            }\n            // Nope, need to allocate a new buffer\n            _tail = new LinkedNode<Object[]>(fullChunk, _tail);\n        } else {\n            _head = _tail = new LinkedNode<Object[]>(fullChunk, null);\n        }\n        _size += chunkSize;\n        return _tail.value;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int newSize = _size + fullChunk.length;\n        if (newSize < 0) {\n            throw new OutOfMemoryError(\"Tried to grow ObjectBuffer by \"+fullChunk.length+\" entries; current size: \"+_size);\n        }\n        // First, check if we can just append to existing tail\n        if (_tail != null) {\n            int tailSize = _tail._array.length;\n            if (tailSize >= newSize) {\n                System.arraycopy(fullChunk, 0, _tail._array, _size, fullChunk.length);\n                _size = newSize;\n                return _tail._array;\n            }\n        }\n        // Nope, need to allocate new tail\n        Object[] newTail = new Object[Math.max(SMALL_CHUNK, Math.min(MAX_CHUNK, newSize))];\n        System.arraycopy(fullChunk, 0, newTail, 0, fullChunk.length);\n        _size = newSize;\n        _addTail(newTail);\n        return newTail;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int chunkSize = fullChunk.length;\n        if (_head == null) {\n            _head = _tail = new LinkedNode<Object[]>(fullChunk);\n        } else {\n            _tail.setNext(new LinkedNode<Object[]>(fullChunk));\n            _tail = _tail.getNext();\n        }\n        _size += chunkSize;\n        if (chunkSize < SMALL_CHUNK) {\n            return new Object[SMALL_CHUNK];\n        }\n        if (chunkSize < MAX_CHUNK) {\n            return new Object[chunkSize << 1];\n        }\n        return new Object[MAX_CHUNK];\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (fullChunk == null || fullChunk.length == 0) {\n            return _freeBuffer;\n        }\n        int newSize = _size + fullChunk.length;\n        Object[] result = _freeBuffer;\n        if (result == null || result.length < newSize) {\n            result = new Object[Math.max(newSize, SMALL_CHUNK)];\n        }\n        System.arraycopy(fullChunk, 0, result, _size, fullChunk.length);\n        _size = newSize;\n        _freeBuffer = null;\n        return result;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int len = fullChunk.length;\n        if (len <= 0) {\n            return fullChunk;\n        }\n        Object[] newBuf = _allocateChunk(len);\n        _copyTo(newBuf, len, fullChunk, 0);\n        return newBuf;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        if (fullChunk == null || fullChunk.length == 0) {\n            return _freeBuffer;\n        }\n        if (_freeBuffer == fullChunk) {\n            _freeBuffer = null;\n        }\n        int totalSize = _size + fullChunk.length;\n        if (totalSize < SMALL_CHUNK) {\n            // Use smaller chunk size for small arrays\n            totalSize = SMALL_CHUNK;\n        } else if (totalSize > MAX_CHUNK) {\n            // Cap at maximum chunk size\n            totalSize = MAX_CHUNK;\n        }\n        Object[] newBuffer = new Object[totalSize];\n        _copyTo(newBuffer, totalSize, fullChunk, fullChunk.length);\n        _size += fullChunk.length;\n        return newBuffer;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int newSize = _size + fullChunk.length;\n        if (newSize > MAX_CHUNK) {\n            throw new IllegalStateException(String.format(\n\"Cannot append chunk with %d entries; limit is %d\",\nfullChunk.length, MAX_CHUNK));\n        }\n        if (_head == null) {\n            _head = _tail = new LinkedNode<Object[]>(fullChunk);\n        } else {\n            _tail = _tail.append(fullChunk);\n        }\n        _size = newSize;\n        return fullChunk;\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int chunkSize = fullChunk.length;\n        int totalSize = _size + chunkSize;\n        if (totalSize > MAX_CHUNK) {\n            throw new IllegalStateException(\"ObjectBuffer.appendCompletedChunk() would exceed maximum buffer size of \"+MAX_CHUNK+\" entries\");\n        }\n        if (_head == null) {\n            _head = new LinkedNode<Object[]>(fullChunk);\n            _tail = _head;\n        } else {\n            _tail.append(fullChunk);\n            if (chunkSize > SMALL_CHUNK) {\n                _tail = new LinkedNode<Object[]>(null);\n            }\n        }\n        _size += chunkSize;\n        return _tail.getArray();\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int len = fullChunk.length;\n        if (len == 0) {\n            return fullChunk;\n        }\n        if (_head == null) {\n            _head = new LinkedNode<Object[]>(fullChunk);\n            _tail = _head;\n        } else {\n            _tail = _tail.next = new LinkedNode<Object[]>(fullChunk);\n        }\n        _size += len;\n        // Let's try to avoid too large buffers; if so, try to reclaim\n        if (_size > MAX_CHUNK) {\n            _freeBuffer = _head.value;\n            _head = _head.next;\n            _size -= len;\n        }\n        return new Object[Math.max(12, len)];\n    }",
      "public Object[] appendCompletedChunk(Object[] fullChunk)\n     {\n        int chunkSize = fullChunk.length;\n        int totalSize = chunkSize + _size;\n        if (totalSize > MAX_CHUNK) {\n            throw new IllegalStateException(String.format(\n\"Can not buffer more than %d entries (tried to append %d entries)\",\nMAX_CHUNK, chunkSize));\n        }\n        if (_head == null) {\n            _head = new LinkedNode<Object[]>(fullChunk);\n            _tail = _head;\n        } else {\n            _tail = _tail.append(fullChunk);\n        }\n        _size += chunkSize;\n        return new Object[chunkSize];\n    }"
    ],
    [
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        parsePatternTo(builder, pattern);\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        parsePatternTo(builder, pattern);\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n        parsePatternTo(bld, pattern);\n        return bld.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        parsePatternTo(builder, pattern);\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    parsePatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        if (pattern == null) {\n            throw new IllegalArgumentException(\"Pattern must not be null\");\n        }\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        parsePatternTo(builder, pattern);\n        return builder.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder();\n        parsePatternTo(bld, pattern);\n        return bld.toFormatter();\n    }",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    appendPatternTo(builder, pattern);\n    return builder.toFormatter();\n}",
      "private static DateTimeFormatter createFormatterForPattern(String pattern)  {\n        DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n        appendPatternTo(builder, pattern);\n        return builder.toFormatter();\n    }"
    ],
    [
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.MUL) {\n    return newNode(Token.MUL);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.FUNCTION) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.PIPE) {\n    return parseUnionType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else {\n    return reportGenericTypeSyntaxWarning();\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.MUL) \n    {\n        return newNode(Token.MUL);\n    } \n    else if (token == JsDocToken.NULL) \n    {\n        return newNode(Token.NULL);\n    } \n    else if (token == JsDocToken.UNDEFINED) \n    {\n        return newNode(Token.UNDEFINED);\n    } \n    else if (token == JsDocToken.FUNCTION) \n    {\n        return parseFunctionType(next());\n    } \n    else if (token == JsDocToken.LC) \n    {\n        return parseRecordType(next());\n    } \n    else if (token == JsDocToken.LB) \n    {\n        return parseArrayType(next());\n    } \n    else if (token == JsDocToken.STRING) \n    {\n        return parseTypeName(token);\n    } \n    else \n    {\n        return reportGenericTypeSyntaxWarning();\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.MUL) {\n        return newNode(Token.MUL);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.STRING) {\n        return parseTypeName(token);\n    } else if (token == JsDocToken.FUNCTION) {\n        return parseFunctionType(token);\n    } else if (token == JsDocToken.OR) {\n        return parseUnionType(token);\n    } else if (token == JsDocToken.LC) {\n        return parseRecordType(token);\n    } else if (token == JsDocToken.LS) {\n        return parseArrayType(token);\n    } else {\n        return reportGenericTypeSyntaxWarning();\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  switch (token) \n  {\n    case ASTERISK:\n      return newNode(Token.QMARK);\n    case NULL:\n      return newNode(Token.NULL);\n    case UNDEFINED:\n      return newNode(Token.VOID);\n    case STRING:\n      return parseTypeName(token);\n    case FUNCTION:\n      return parseFunctionType(token);\n    case UNION:\n      return parseUnionType(token);\n    case RECORD:\n      return parseRecordType(token);\n    case ARRAY:\n      return parseArrayType(token);\n    default:\n      return reportGenericTypeSyntaxWarning();\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.MUL) {\n        return newNode(Token.MUL);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.STRING) {\n        return parseTypeName(token);\n    } else if (token == JsDocToken.FUNCTION) {\n        return parseFunctionType(token);\n    } else if (token == JsDocToken.LB) {\n        return parseUnionType(token);\n    } else if (token == JsDocToken.LC) {\n        return parseRecordType(token);\n    } else if (token == JsDocToken.LB) {\n        return parseArrayType(token);\n    } else {\n        return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.MUL) {\n    return newNode(Token.MUL);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.FUNCTION) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseUnionType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else {\n    return reportGenericTypeSyntaxWarning();\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.MUL) {\n        return newNode(Token.MUL);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.STRING) {\n        return parseTypeName(token);\n    } else if (token == JsDocToken.FUNCTION) {\n        return parseFunctionType(token);\n    } else if (token == JsDocToken.OR) {\n        return parseUnionType(token);\n    } else if (token == JsDocToken.LC) {\n        return parseRecordType(token);\n    } else if (token == JsDocToken.LB) {\n        return parseArrayType(token);\n    } else {\n        return reportGenericTypeSyntaxWarning();\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n    if (token == JsDocToken.MUL) {\n        return newNode(Token.MUL);\n    } else if (token == JsDocToken.NULL) {\n        return newNode(Token.NULL);\n    } else if (token == JsDocToken.UNDEFINED) {\n        return newNode(Token.UNDEFINED);\n    } else if (token == JsDocToken.STRING) {\n        return parseTypeName(token);\n    } else if (token == JsDocToken.FUNCTION) {\n        return parseFunctionType(token);\n    } else if (token == JsDocToken.LC) {\n        return parseUnionType(token);\n    } else if (token == JsDocToken.LC) {\n        return parseRecordType(token);\n    } else if (token == JsDocToken.LS) {\n        return parseArrayType(token);\n    } else {\n        return null;\n    }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.STAR) \n  {\n    return newNode(Token.STAR);\n  } \n  else if (token == JsDocToken.NULL) \n  {\n    return newNode(Token.NULL);\n  } \n  else if (token == JsDocToken.UNDEFINED) \n  {\n    return newNode(Token.UNDEFINED);\n  } \n  else \n  {\n    return parseTypeName(token);\n  }\n}",
      "private Node parseBasicTypeExpression(JsDocToken token)  {\n  if (token == JsDocToken.MUL) {\n    return newNode(Token.MUL);\n  } else if (token == JsDocToken.NULL) {\n    return newNode(Token.NULL);\n  } else if (token == JsDocToken.UNDEFINED) {\n    return newNode(Token.UNDEFINED);\n  } else if (token == JsDocToken.STRING) {\n    return parseTypeName(token);\n  } else if (token == JsDocToken.FUNCTION) {\n    return parseFunctionType(token);\n  } else if (token == JsDocToken.PIPE) {\n    return parseUnionType(token);\n  } else if (token == JsDocToken.LC) {\n    return parseRecordType(token);\n  } else if (token == JsDocToken.LB) {\n    return parseArrayType(token);\n  } else {\n    return reportGenericTypeSyntaxWarning();\n  }\n}"
    ],
    [
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) \n    {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) {\n    throw new IllegalStateException();\n  }\n  if (stackSize == 0) {\n    throw new IllegalStateException(\"JsonWriter is closed.\");\n  }\n  deferredName = name;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) \n    {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException();\n    }\n    if (stackSize == 0) \n    {\n        throw new IllegalStateException(\"JsonWriter is closed.\");\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n    if (name == null) \n    {\n        throw new NullPointerException(\"name == null\");\n    }\n    if (deferredName != null) \n    {\n        throw new IllegalStateException(\"Nested object keys are not allowed in \" + mode);\n    }\n    deferredName = name;\n    return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) {\n    throw new IllegalStateException();\n  }\n  if (stackSize == 0) {\n    throw new IllegalStateException(\"JsonWriter is closed.\");\n  }\n  deferredName = name;\n  return this;\n}",
      "public JsonWriter name(String name) throws IOException  {\n  if (name == null) \n  {\n    throw new NullPointerException(\"name == null\");\n  }\n  if (deferredName != null) \n  {\n    throw new IllegalStateException(\"Nested keys are not allowed in JSON\");\n  }\n  deferredName = name;\n  return this;\n}"
    ],
    [
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value > 0.0) \n                {\n                    positive[groupIndex[series]] = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) \n                {\n                    negative[groupIndex[series]] = negative[groupIndex[series]] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) \n        {\n            minimum = Math.min(minimum, negative[g]);\n        }\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (minimum == Double.POSITIVE_INFINITY) \n    {\n        return null;\n    } \n    else \n    {\n        return new Double(minimum);\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                double value = number.doubleValue();\n                if (value > 0.0) \n                {\n                    positive[groupIndex[series]] = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) \n                {\n                    negative[groupIndex[series]] = negative[groupIndex[series]] + value;\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) \n        {\n            minimum = Math.min(minimum, negative[g]);\n        }\n    }\n    if (minimum == Double.POSITIVE_INFINITY) \n    {\n        return null;\n    } \n    else \n    {\n        return new Double(minimum);\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[groupIndex[series]]\n                             = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) {\n                    negative[groupIndex[series]]\n                             = negative[groupIndex[series]] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum = Math.min(minimum, negative[g]);\n        }\n    }\n    if (minimum == Double.POSITIVE_INFINITY) {\n        return null;\n    }\n    else {\n        return new Double(minimum);\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double[] positive = new double[groupCount];\n        double[] negative = new double[groupCount];\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                if (value > 0.0) {\n                    positive[groupIndex[series]]\n                             = positive[groupIndex[series]] + value;\n                }\n                if (value < 0.0) {\n                    negative[groupIndex[series]]\n                             = negative[groupIndex[series]] + value;\n                    // '+', remember value is negative\n                }\n            }\n        }\n        for (int g = 0; g < groupCount; g++) {\n            minimum = Math.min(minimum, negative[g]);\n        }\n    }\n    if (minimum == Double.POSITIVE_INFINITY) {\n        return null;\n    }\n    else {\n        return new Double(minimum);\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) {\n        result = new Double(minimum);\n    }\n    return result;\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (minimum == Double.POSITIVE_INFINITY) \n    {\n        return null;\n    } \n    else \n    {\n        return new Double(minimum);\n    }\n}",
      "public static Number findMinimumStackedRangeValue(CategoryDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Number result = null;\n    boolean hasValidData = false;\n    double minimum = Double.POSITIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) \n    {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) \n        {\n            Number number = dataset.getValue(series, item);\n            if (number != null) \n            {\n                hasValidData = true;\n                double value = number.doubleValue();\n                if (value < 0.0) \n                {\n                    total = total + value;\n                }\n            }\n        }\n        minimum = Math.min(minimum, total);\n    }\n    if (hasValidData) \n    {\n        result = new Double(minimum);\n    }\n    return result;\n}"
    ],
    [
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    try \n    {\n        final boolean[] primitive = ArrayUtils.toPrimitive(array);\n        return or(primitive) ? Boolean.TRUE : Boolean.FALSE;\n    } \n    catch (final NullPointerException ex) \n    {\n        throw new IllegalArgumentException(\"The array must not contain any null elements\");\n    }\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element == null) \n        {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n        if (element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element == null) \n        {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n        if (element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element == null) \n        {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n        if (element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}",
      "public static Boolean or(final Boolean... array)  {\n    if (array == null) \n    {\n        throw new IllegalArgumentException(\"The Array must not be null\");\n    }\n    if (array.length == 0) \n    {\n        throw new IllegalArgumentException(\"Array is empty\");\n    }\n    for (final Boolean element : array) \n    {\n        if (element == null) \n        {\n            throw new IllegalArgumentException(\"The array must not contain any null elements\");\n        }\n        if (element) \n        {\n            return Boolean.TRUE;\n        }\n    }\n    return Boolean.FALSE;\n}"
    ],
    [
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final char[] buffer = str.toCharArray();\n    final StringBuilder result = new StringBuilder(buffer.length);\n    result.append(Character.toUpperCase(buffer[0]));\n    for (int i = 1; i < buffer.length; i++) {\n        if (delimLen != -1) {\n            for (int j = 0; j < delimLen; j++) {\n                if (buffer[i] == delimiters[j]) {\n                    result.append(Character.toUpperCase(buffer[i + 1]));\n                    i++;\n                    break;\n                }\n            }\n        } else {\n            if (Character.isWhitespace(buffer[i])) {\n                result.append(Character.toUpperCase(buffer[i + 1]));\n            }\n        }\n    }\n    return result.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final char[] buffer = str.toCharArray();\n        final StringBuilder initials = new StringBuilder(buffer.length);\n        boolean nextIsInitial = true;\n        for (final char c : buffer) {\n            if (nextIsInitial && Character.isLetter(c)) {\n                initials.append(c);\n                nextIsInitial = false;\n            } else if (isDelimiter(c, delimiters)) {\n                nextIsInitial = true;\n            }\n        }\n        return initials.toString();\n    }",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasSpace = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasSpace = true;\n        } else if (lastWasSpace) {\n            buf[count++] = ch;\n            lastWasSpace = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final char[] buffer = str.toCharArray();\n        final StringBuilder initials = new StringBuilder(buffer.length);\n        boolean nextIsInit = true;\n        for (int i = 0; i < buffer.length; i++) {\n            if (isDelimiter(buffer[i], delimiters)) {\n                nextIsInit = true;\n            } else if (nextIsInit) {\n                initials.append(buffer[i]);\n                nextIsInit = false;\n            }\n        }\n        return initials.toString();\n    }",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2];\n    int count = 0;\n    boolean lastWasWhite = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasWhite = true;\n        } else if (lastWasWhite) {\n            buf[count++] = ch;\n            lastWasWhite = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n        if (StringUtils.isEmpty(str)) {\n            return str;\n        }\n        final int strLen = str.length();\n        final char[] buf = new char[strLen / 2];\n        int count = 0;\n        boolean lastWasGap = true;\n        for (int i = 0; i < strLen; i++) {\n            final char ch = str.charAt(i);\n            if (isDelimiter(ch, delimiters)) {\n                lastWasGap = true;\n            } else if (lastWasGap) {\n                if (count < buf.length) {\n                    buf[count++] = Character.toUpperCase(ch);\n                    lastWasGap = false;\n                }\n            }\n        }\n        return new String(buf, 0, count);\n    }",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    final StringBuilder buffer = new StringBuilder();\n    final char[] chars = str.toCharArray();\n    boolean nextIsInit = true;\n    for (final char c : chars) {\n        if (isDelimiter(c, delimiters)) {\n            nextIsInit = true;\n        } else if (nextIsInit) {\n            buffer.append(c);\n            nextIsInit = false;\n        }\n    }\n    return buffer.toString();\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2 + 1];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            buf[count++] = ch;\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2];\n    int count = 0;\n    boolean lastWasWhite = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasWhite = true;\n        } else if (lastWasWhite) {\n            buf[count++] = ch;\n            lastWasWhite = false;\n        }\n    }\n    return new String(buf, 0, count);\n}",
      "public static String initials(final String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str)) {\n        return str;\n    }\n    final int strLen = str.length();\n    final char[] buf = new char[strLen / 2];\n    int count = 0;\n    boolean lastWasGap = true;\n    for (int i = 0; i < strLen; i++) {\n        final char ch = str.charAt(i);\n        if (isDelimiter(ch, delimiters)) {\n            lastWasGap = true;\n        } else if (lastWasGap) {\n            if (count < buf.length) {\n                buf[count++] = ch;\n            }\n            lastWasGap = false;\n        }\n    }\n    return new String(buf, 0, count);\n}"
    ],
    [
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        Number n = data.getValue(r, column);\n        if (n != null) {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculateColumnTotal(Values2D data, int column)  {\n    if (data == null) \n    {\n        throw new IllegalArgumentException(\"Null 'data' argument.\");\n    }\n    double total = 0.0;\n    int rowCount = data.getRowCount();\n    for (int r = 0; r < rowCount; r++) \n    {\n        Number n = data.getValue(r, column);\n        if (n != null) \n        {\n            total += n.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) \n    {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = screenPoint.getX() - insets.left;\n    double y = screenPoint.getY() - insets.top;\n    return new Point2D.Double(x / this.scaleX, y / this.scaleY);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) \n    {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = screenPoint.getX() - insets.left;\n    double y = screenPoint.getY() - insets.top;\n    return new Point2D.Double(x / this.scaleX, y / this.scaleY);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) \n    {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = screenPoint.getX() - insets.left;\n    double y = screenPoint.getY() - insets.top;\n    return new Point2D.Double(x / this.scaleX, y / this.scaleY);\n}",
      "public Point2D translateScreenToJava2D(Point screenPoint)  {\n    if (screenPoint == null) \n    {\n        throw new IllegalArgumentException(\"Null 'screenPoint' argument.\");\n    }\n    Insets insets = getInsets();\n    double x = (screenPoint.getX() - insets.left) / this.scaleX;\n    double y = (screenPoint.getY() - insets.top) / this.scaleY;\n    return new Point2D.Double(x, y);\n}"
    ],
    [
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }",
      "@Override\n    public BigFraction parse(final String source) throws MathParseException  {\n        final ParsePosition parsePosition = new ParsePosition(0);\n        final BigFraction result = parse(source, parsePosition);\n        if (parsePosition.getIndex() == 0) \n        {\n            throw new MathParseException(source, parsePosition.getErrorIndex(), BigFraction.class);\n        }\n        return result;\n    }"
    ],
    [
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) {\n        return new ListOrderedSet<E>(list, new ArrayList<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final Set<E> set = new HashSet<E>();\n    final ListOrderedSet<E> sl = new ListOrderedSet<E>(list, set);\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    if (list.isEmpty()) \n    {\n        return new ListOrderedSet<E>(list, new HashSet<E>());\n    }\n    final List<E> temp = new ArrayList<E>(list);\n    list.clear();\n    final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n    sl.addAll(temp);\n    return sl;\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<E>(list);\n    list.clear();\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<E>(list);\n    list.clear();\n    return new ListOrderedSet<E>(set, list);\n}",
      "public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<E>(list);\n    list.clear();\n    return new ListOrderedSet<E>(set, list);\n}"
    ],
    [
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            result = Range.combine(result, plot.getDataRange(axis));\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range range = plot.getDataRange(axis);\n            if (result == null) {\n                result = range;\n            } else {\n                result = result.combine(range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (result == null) {\n                result = more;\n            } else {\n                result = result.combine(more);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range range = plot.getDataRange(axis);\n            if (result == null) {\n                result = range;\n            }\n            else {\n                result = result.combine(range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range range = plot.getDataRange(axis);\n            if (result == null) {\n                result = range;\n            }\n            else {\n                result = result.combine(range);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            result = Range.combine(result, plot.getDataRange(axis));\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (result == null) \n            {\n                result = more;\n            } \n            else \n            {\n                result = result.combine(more);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            result = Range.combine(result, plot.getDataRange(axis));\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) \n    {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) \n        {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range more = plot.getDataRange(axis);\n            if (result == null) \n            {\n                result = more;\n            } \n            else \n            {\n                result = result.combine(more);\n            }\n        }\n    }\n    return result;\n}",
      "public Range getDataRange(ValueAxis axis)  {\n    Range result = null;\n    if (this.subplots != null) {\n        Iterator iterator = this.subplots.iterator();\n        while (iterator.hasNext()) {\n            CategoryPlot plot = (CategoryPlot) iterator.next();\n            Range range = plot.getDataRange(axis);\n            if (result == null) {\n                result = range;\n            } else {\n                result = result.combine(range);\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = Math.log(val) / Math.log(10); //invert adjustedPow10\n    } \n    else \n    {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = (Math.log(val) / LOG10_VALUE) + 1.0; //invert adjustedPow10\n    }\n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = (Math.log(val) / LOG10_VALUE) + 1.0; //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = Math.log(val) / Math.log(10); //invert adjustedPow10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = Math.log(val) / Math.log(10); //invert adjustedPow10\n    }\n    else {\n        res = Math.log(val) / Math.log(10);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = Math.log(val) / Math.log(10); //invert adjustedPow10\n    }\n    else \n    {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) {\n        res = Math.log(val) / Math.log(10); //invert adjustedPow10\n    }\n    else {\n        res = Math.log10(val);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = (Math.log(val) / LOG10_VALUE) + 1.0; //invert adjustedPow10\n    } \n    else \n    {\n        res = Math.log(val) / LOG10_VALUE;\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = (Math.log(val) / Math.log(10)) + 1.0; //invert adjustedPow10\n    } \n    else \n    {\n        res = Math.log(val) / Math.log(10);\n    }\n    return negFlag ? (-res) : res;\n}",
      "public double adjustedLog10(double val)  {\n    boolean negFlag = (val < 0.0);\n    if (negFlag) \n    {\n        val = -val; // if negative then set flag and make positive\n    }\n    double res;\n    if (val < 10.0) \n    {\n        res = Math.log(val) / Math.log(10.0);\n        res = res * (1.0 - (1.0 / val)); //invert adjustPow10\n    } \n    else \n    {\n        res = Math.log(val) / Math.log(10.0);\n    }\n    return negFlag ? (-res) : res;\n}"
    ],
    [
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (ControlFlowGraph.Branch branch : cfg.getBranches()) {\n        if (branch.getControlFlowEdgeType() != ControlFlowEdge.ControlFlowEdgeType.FALL_THROUGH) {\n            continue;\n        }\n\n        Node fallThrough = branch.getTarget().getFirstChild();\n        if (fallThrough == null || !fallThrough.isReturn()) {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (ControlFlowGraph.Branch branch : cfg.getBranches()) {\n        if (branch.getType() != ControlFlowGraph.Branch.Type.RETURN) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (ControlFlowGraph.Branch branch : cfg.getBranches()) {\n        if (branch.getType() != ControlFlowGraph.Branch.Type.RETURN) {\n            continue;\n        }\n\n        Node returnNode = branch.getTarget().getLastChild();\n        if (!NodeUtil.isReturn(returnNode)) {\n            continue;\n        }\n\n        // If the return is conditional, then there may be a path that does not\n        // return.\n        if (returnNode.getFirstChild() != null) {\n            continue;\n        }\n\n        // If the return is not in the same function as the branch, then there\n        // may be a path that does not return.\n        if (!nodeHasAncestor(returnNode, branch.getSource().getParent())) {\n            continue;\n        }\n\n        // If the return is in a finally block, then there may be a path that\n        // does not return.\n        if (NodeUtil.isFunction(branch.getSource().getParent())) {\n            Node finallyBlock = NodeUtil.getFunctionBody(branch.getSource().getParent()).getNext();\n            if (finallyBlock != null && finallyBlock.isFinally()) {\n                continue;\n            }\n        }\n\n        return false;\n    }\n\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (ControlFlowGraph<Node>.Block block : cfg.getBlocks()) \n    {\n        if (block.getControlFlowEdgeTo(block.getSuccessor()) != ControlFlowEdge.ControlFlowEdgeType.FALL_THROUGH) \n        {\n            continue;\n        }\n\n        Node lastStatement = block.getLastNode();\n        if (lastStatement == null || !lastStatement.isReturn()) \n        {\n            return false;\n        }\n    }\n\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (BasicBlock block : cfg.getBlocks()) {\n        if (block.getControlFlowEdgeTo(block.getSuccessor(0)) == ControlFlowEdge.ControlFlowEdgeType.EXIT) {\n            continue;\n        }\n        Node last = NodeUtil.getEndNode(block.getLastNode());\n        if (!last.isReturn()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (ControlFlowGraph<Node>.Block block : cfg.getBlocks()) {\n        Node last = block.getLastNode();\n        if (last != null && !last.isReturn()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (ControlFlowGraph.Branch branch : cfg.getBranches()) {\n        if (branch.getType() != ControlFlowGraph.Branch.Type.IF) {\n            continue;\n        }\n\n        Node ifNode = branch.getControlNode().getParent();\n        if (ifNode.getLastChild().getType() != Token.BLOCK) {\n            continue;\n        }\n\n        Node thenBlock = ifNode.getLastChild();\n        Node elseBlock = ifNode.getNext();\n\n        // If the else block is empty, then we know that the if block\n        // will always return.\n        if (elseBlock.getType() == Token.BLOCK &&\n            elseBlock.getFirstChild() == null) {\n            continue;\n        }\n\n        // If the then block has a return statement, then we know that\n        // the if block will always return.\n        if (NodeUtil.has(thenBlock, new Predicate<Node>() {\n}\n}\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (ControlFlowGraph.Branch branch : cfg.getBranches()) {\n        if (branch.getControlFlowEdgeType() != ControlFlowEdge.Type.EXIT) {\n            continue;\n        }\n        Node exitNode = branch.getTarget().getLast();\n        if (!NodeUtil.isReturnStatement(exitNode)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (ControlFlowGraph.Branch branch : cfg.getBranches()) {\n        if (branch.getType() != ControlFlowGraph.Branch.Type.RETURN) {\n            continue;\n        }\n        for (ControlFlowGraph.Branch exit : cfg.getExits(branch)) {\n            if (exit.getType() != ControlFlowGraph.Branch.Type.EXIT) {\n                continue;\n            }\n            if (exit.getTarget() != cfg.getImplicitReturn()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}",
      "private static boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg)  {\n    for (ControlFlowGraph<Node>.Block block : cfg.getBlocks()) {\n        if (block.getControlFlowGraph().getEntry() != block) {\n            if (!block.getControlFlowGraph().getExit().isExit()) {\n                return false;\n            }\n        }\n    }\n    return true;\n}"
    ],
    [
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp x[] = new Dfp[2];\n        Dfp y[] = new Dfp[2];\n        Dfp fact[] = new Dfp[2];\n        Dfp py[] = new Dfp[2];\n        Dfp fact2[] = new Dfp[2];\n        Dfp fact3[] = new Dfp[2];\n        Dfp fact4[] = new Dfp[2];\n        Dfp fact5[] = new Dfp[2];\n        Dfp fact6[] = new Dfp[2];\n        Dfp fact7[] = new Dfp[2];\n        Dfp fact8[] = new Dfp[2];\n        Dfp fact9[] = new Dfp[2];\n        Dfp fact10[] = new Dfp[2];\n        Dfp fact11[] = new Dfp[2];\n        Dfp fact12[] = new Dfp[2];\n        Dfp fact13[] = new Dfp[2];\n        Dfp fact14[] = new Dfp[2];\n        Dfp fact15[] = new Dfp[2];\n        Dfp fact16[] = new Dfp[2];\n        Dfp fact17[] = new Dfp[2];\n        Dfp fact18[] = new Dfp[2];\n        Dfp fact19[] = new Dfp[2];\n        Dfp fact20[] = new Dfp[2];\n        Dfp fact21[] = new Dfp[2];\n        Dfp fact22[] = new Dfp[2];\n        Dfp fact23[] = new Dfp[2];\n        Dfp fact24[] = new Dfp[2];\n        Dfp fact25[] = new Dfp[2];\n        Dfp fact26[] = new Dfp[2];\n        Dfp fact27[] = new Dfp[2];\n        Dfp fact28[] = new Dfp[2];\n        Dfp fact29[] = new Dfp[2];\n        Dfp fact30[] = new Dfp[2];\n        Dfp fact31[] = new Dfp[2];\n        Dfp fact32[] = new Dfp[2];\n        Dfp fact33[] = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        // Check the arguments somewhat here\n        if (a[0].isZero() || a[1].negativeOrNull() || a[1].isNaN()) {\n            // negative, zero or NaN\n            a[0].getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return a;\n        }\n\n        if (a[0].classify() == Dfp.INFINITE) {\n            return a;\n        }\n\n        // Compute the value of x such that a = (x+1)/(x-1)\n        Dfp x[] = new Dfp[2];\n        x[0] = a[0].subtract(a[1]);\n        x[1] = a[0].add(a[1]);\n        resplit(x);\n\n        // Compute the value of ln(x+1) - ln(x-1)\n        Dfp y[] = new Dfp[2];\n        y[0] = x[0].multiply(x[1]);\n        y[1] = x[0].multiply(x[1]);\n        resplit(y);\n\n        // Compute the value of ln(a)\n        Dfp z[] = new Dfp[2];\n        z[0] = y[0].divide(2);\n        z[1] = y[1].divide(2);\n        return z;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp x[] = new Dfp[2];\n        Dfp y[] = new Dfp[2];\n        Dfp fact[] = new Dfp[2];\n        Dfp py[] = new Dfp[2];\n\n        x[0] = a[0].subtract(a[1]);\n        x[1] = a[0].add(a[1]);\n        fact[0] = x[0].multiply(x[1]);\n        fact[1] = x[0].multiply(x[1]);\n        y[0] = x[0].multiply(x[1]);\n        y[1] = x[0].multiply(x[1]);\n        py[0] = y[0];\n        py[1] = y[1];\n\n        for (int i = 1; i < 90; i++) {\n            x[0] = x[0].multiply(a[0]);\n            x[1] = x[1].multiply(a[1]);\n            fact[0] = fact[0].divide(i);\n            fact[1] = fact[1].divide(i);\n            y[0] = y[0].add(x[0].multiply(fact[0]));\n            y[1] = y[1].add(x[1].multiply(fact[1]));\n            if (y[0].equals(py[0]) && y[1].equals(py[1])) {\n                break;\n            }\n            py[0] = y[0];\n            py[1] = y[1];\n        }\n\n        return y;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp x[] = new Dfp[2];\n        Dfp y[] = new Dfp[2];\n        Dfp fact[] = new Dfp[2];\n        Dfp py[] = new Dfp[2];\n        Dfp[] xs = new Dfp[2];\n        Dfp[] ys = new Dfp[2];\n        Dfp[] tmpX = new Dfp[2];\n        Dfp[] tmpY = new Dfp[2];\n        Dfp[] tmpFact = new Dfp[2];\n        Dfp[] tmpPy = new Dfp[2];\n\n        // x = (a-1)/(a+1)\n        splitSubtract(a, a.getOne(), x);\n        splitDivide(x, a.getOne().add(a.getOne()), x);\n\n        // y = ln(x+1) - ln(x-1)\n        splitAdd(x, x.getOne(), tmpX);\n        splitSubtract(x, x.getOne(), tmpY);\n        splitDivide(tmpX, tmpY, tmpFact);\n        splitMult(tmpFact, x.getOne(), tmpPy);\n        splitAdd(tmpPy, tmpPy, tmpFact);\n        splitAdd(tmpFact, tmpFact, tmpPy);\n        splitAdd(tmpPy, tmpPy, tmpFact);\n        splitAdd(tmpFact, tmpFact, tmpPy);\n        splitAdd(tmpPy, tmpPy, tmpFact);\n        splitAdd(tmpFact, tmpFact, tmpPy);\n        splitAdd(tmpPy, tmpFact, y);\n\n        // Now we want to find the value of x such that a = (x+1)/(x-1).\n        // This is easily solved to find that x = (a-1)/(a+1).\n        splitSubtract(a, a.getOne(), xs);\n        splitDivide(xs, a.getOne().add(a.getOne()), xs);\n\n        // y = ln(x+1) - ln(x-1)\n        splitAdd(xs, xs.getOne(), tmpX);\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp x[] = new Dfp[2];\n        Dfp y[] = new Dfp[2];\n        Dfp fact[] = new Dfp[2];\n        Dfp py[] = new Dfp[2];\n        Dfp xi[] = new Dfp[2];\n        Dfp xi2[] = new Dfp[2];\n        Dfp yi[] = new Dfp[2];\n        Dfp yi2[] = new Dfp[2];\n        Dfp facti[] = new Dfp[2];\n        Dfp facti2[] = new Dfp[2];\n        Dfp facti3[] = new Dfp[2];\n        Dfp facti4[] = new Dfp[2];\n        Dfp facti5[] = new Dfp[2];\n        Dfp facti6[] = new Dfp[2];\n        Dfp facti7[] = new Dfp[2];\n        Dfp facti8[] = new Dfp[2];\n        Dfp facti9[] = new Dfp[2];\n        Dfp facti10[] = new Dfp[2];\n        Dfp facti11[] = new Dfp[2];\n        Dfp facti12[] = new Dfp[2];\n        Dfp facti13[] = new Dfp[2];\n        Dfp facti14[] = new Dfp[2];\n        Dfp facti15[] = new Dfp[2];\n        Dfp facti16[] = new Dfp[2];\n        Dfp facti17[] = new Dfp[2];\n        Dfp facti18[] = new Dfp[2];\n        Dfp facti19[] = new Dfp[2];\n        Dfp facti20[] = new Dfp[2];\n        Dfp facti21[] = new Dfp[2];\n        Dfp facti22[] = new Dfp[2];\n        Dfp facti23[] = new Dfp[2];\n        Dfp facti24[] = new Dfp[2];\n        Dfp facti25[] = new Dfp[2];\n        Dfp facti26[] = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        // Check the arguments somewhat here\n        if (a[0].equals(a[0].getZero()) || a[0].lessThan(a[0].getZero()) || a[0].isNaN()) {\n            // negative, zero or NaN\n            a[0].getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return a[0].dotrap(DfpField.FLAG_INVALID, \"ln\", a[0], a[0].newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (a[0].classify() == Dfp.INFINITE) {\n            return a;\n        }\n\n        // Compute the value of x such that a = (x+1)/(x-1)\n        Dfp x[] = new Dfp[2];\n        x[0] = a[0].subtract(a[1]);\n        x[1] = a[0].add(a[1]);\n\n        // Compute the value of ln(x+1) - ln(x-1)\n        Dfp[] y = new Dfp[2];\n        y[0] = x[0].divide(x[1]);\n        y[0] = y[0].add(y[0]);\n        y[0] = y[0].add(y[0]);\n        y[0] = y[0].add(y[0]);\n        y[0] = y[0].add(y[0]);\n        y[0] = y[0].add(y[0]);\n        y[0] = y[0].add(y[0]);\n        y[0] = y[0].add(y[0]);\n        y[0] = y[0].add(y[0]);\n        y[0] = y[0].add(y[0]);\n        y[0] = y[0].add(y[0]);\n        y[0] = y[0].add(y[0]);\n        y[0] = y[0].add(y[0]);\n        y[0] = y[0].add(y[0]);\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        // Check the arguments somewhat here\n        if (a[0].isZero() || a[0].negativeOrNull() || a[0].isNaN()) {\n            // negative, zero or NaN\n            a[0].getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return a[0].dotrap(DfpField.FLAG_INVALID, \"ln\", a[0], a[0].newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (a[0].classify() == Dfp.INFINITE) {\n            return a;\n        }\n\n        // Compute (a-1)/(a+1) in split form\n        Dfp[] x = new Dfp[2];\n        x[0] = a[0].subtract(a[1]);\n        x[1] = a[0].add(a[1]);\n        resplit(x);\n\n        // Compute (a-1)/(a+1) * 2 in split form\n        Dfp[] y = new Dfp[2];\n        splitMult(x, a[0].getTwo(), y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        // Compute the series expansion in split form\n        Dfp[] z = new Dfp[2];\n        z[0] = x[0];\n        z[1] = x[1];\n        for (int i = 1; i < 90; i++) {\n            x = x.multiply(a);\n            fact = fact.divide(i);\n            y = y.add(x.multiply(fact));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp x[] = new Dfp[2];\n        Dfp y[] = new Dfp[2];\n        Dfp fact[] = new Dfp[2];\n        Dfp xs[] = new Dfp[2];\n        Dfp ys[] = new Dfp[2];\n\n        // Check the arguments somewhat here\n        if (a[0].isZero() || a[1].negativeOrNull() || a[1].isNaN()) {\n            // negative, zero or NaN\n            a[0].getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n            return a[0].dotrap(DfpField.FLAG_INVALID, \"ln\", a[0], a[0].newInstance((byte)1, Dfp.QNAN));\n        }\n\n        if (a[0].classify() == Dfp.INFINITE) {\n            return a;\n        }\n\n        x[0] = a[0].divide(a[1].add(a[1]));\n        x[1] = a[1].divide(a[1].add(a[1]));\n\n        fact[0] = a[0].getOne();\n        fact[1] = a[1].getOne();\n\n        for (int i = 1; i < 90; i++) {\n            x[0] = x[0].multiply(a[0]);\n            fact[0] = fact[0].divide(i);\n            x[1] = x[1].multiply(a[1]);\n            fact[1] = fact[1].divide(i);\n            y[0] = y[0].add(x[0].multiply(fact[0]));\n            y[1] = y[1].add(x[1].multiply(fact[1]));\n            if (y[0].equals(ys[0]) && y[1].equals(ys[1])) {\n                break;\n            }\n            ys[0] = y[0];\n            ys[1] = y[1];\n        }\n\n        return ys;\n    }",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp x[] = new Dfp[2];\n        Dfp y[] = new Dfp[2];\n        Dfp z[] = new Dfp[2];\n        Dfp w[] = new Dfp[2];\n        Dfp u[] = new Dfp[2];\n        Dfp v[] = new Dfp[2];\n        Dfp t[] = new Dfp[2];\n        Dfp p[] = new Dfp[2];\n        Dfp q[] = new Dfp[2];\n        Dfp r[] = new Dfp[2];\n        Dfp s[] = new Dfp[2];\n        Dfp n[] = new Dfp[2];\n        Dfp m[] = new Dfp[2];\n        Dfp t1[] = new Dfp[2];\n        Dfp t2[] = new Dfp[2];\n        Dfp t3[] = new Dfp[2];\n        Dfp t4[] = new Dfp[2];\n        Dfp t5[] = new Dfp[2];\n        Dfp t6[] = new Dfp[2];\n        Dfp t7[] = new Dfp[2];\n        Dfp t8[] = new Dfp[2];\n        Dfp t9[] = new Dfp[2];\n        Dfp t10[] = new Dfp[2];\n        Dfp t11[] = new Dfp[2];\n        Dfp t12[] = new Dfp[2];\n        Dfp t13[] = new Dfp[2];\n        Dfp t14[] = new Dfp[2];\n        Dfp t15[] = new Dfp[2];\n        Dfp t16[] = new Dfp[2];\n        Dfp t17[] = new Dfp[2];\n        Dfp t18[] = new Dfp[2];\n        Dfp t19[] = new Dfp[2];\n        Dfp t20[] = new Dfp[2];\n        Dfp t21[] = new Dfp[2];\n        Dfp t22[] = new Dfp[2];\n        Dfp t23[] = new Dfp[2];\n        Dfp t24[] = new Dfp[2];\n}",
      "protected static Dfp[] logInternal(final Dfp a[])  {\n        Dfp[] x = new Dfp[2];\n        Dfp[] y = new Dfp[2];\n        Dfp[] z = new Dfp[2];\n        Dfp[] fact = new Dfp[2];\n        Dfp[] py = new Dfp[2];\n        Dfp[] py2 = new Dfp[2];\n        Dfp[] py3 = new Dfp[2];\n        Dfp[] py4 = new Dfp[2];\n        Dfp[] py5 = new Dfp[2];\n        Dfp[] py6 = new Dfp[2];\n        Dfp[] py7 = new Dfp[2];\n        Dfp[] py8 = new Dfp[2];\n        Dfp[] py9 = new Dfp[2];\n        Dfp[] py10 = new Dfp[2];\n        Dfp[] py11 = new Dfp[2];\n        Dfp[] py12 = new Dfp[2];\n        Dfp[] py13 = new Dfp[2];\n        Dfp[] py14 = new Dfp[2];\n        Dfp[] py15 = new Dfp[2];\n        Dfp[] py16 = new Dfp[2];\n        Dfp[] py17 = new Dfp[2];\n        Dfp[] py18 = new Dfp[2];\n        Dfp[] py19 = new Dfp[2];\n        Dfp[] py20 = new Dfp[2];\n        Dfp[] py21 = new Dfp[2];\n        Dfp[] py22 = new Dfp[2];\n        Dfp[] py23 = new Dfp[2];\n        Dfp[] py24 = new Dfp[2];\n        Dfp[] py25 = new Dfp[2];\n        Dfp[] py26 = new Dfp[2];\n        Dfp[] py27 = new Dfp[2];\n        Dfp[] py28 = new Dfp[2];\n        Dfp[] py29 = new Dfp[2];\n        Dfp[] py30 = new Dfp[2];\n        Dfp[] py31 = new Dfp[2];\n        Dfp[] py32 = new Dfp[2];\n}"
    ],
    [
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  ",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"null keys not allowed\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"null values not allowed\");\n        }\n\n        purgeBeforeWrite();\n        final Collection<V> coll = getMap().get(key);\n        if (coll == null) {\n            return false;\n        }\n        boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            AbstractMultiValuedMap.this.remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  ",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  ",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  ",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n    purgeBeforeWrite();\n    final Entry<K, V> entry = getEntry(key);\n    if (entry == null) {\n        return false;\n    }\n    if (value == null) {\n        return false;\n    }\n    if (entry.getValue().equals(value)) {\n        entry.setValue(null);\n        return true;\n    }\n    return false;\n}",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"null keys not allowed\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"null values not allowed\");\n        }\n\n        purgeBeforeWrite();\n        final Collection<V> coll = getMap().get(key);\n        if (coll == null) {\n            return false;\n        }\n\n        boolean result = coll.remove(value);\n        if (coll.isEmpty()) {\n            AbstractMultiValuedMap.this.remove(key);\n        }\n        return result;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"null keys not allowed\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"null values not allowed\");\n        }\n\n        purgeBeforeWrite();\n        final Entry<K, V> entry = getEntry(key);\n        if (entry == null) {\n            return false;\n        }\n        if (entry.getValue() != value) {\n            return false;\n        }\n        entry.setValue(null);\n        if (entry.getValue() == null) {\n            remove(key);\n        }\n        return true;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        purgeBeforeWrite();\n        final Entry<K, V> entry = getEntry(key);\n        if (entry == null) {\n            return false;\n        }\n        if (value == null) {\n            return false;\n        }\n        if (entry.getValue().equals(value)) {\n            entry.setValue(null);\n            return true;\n        }\n        return false;\n    }",
      "@Override\n    public boolean removeMapping(final Object key, final Object value)  {\n        if (key == null) {\n            throw new NullPointerException(\"null keys not allowed\");\n        }\n        if (value == null) {\n            throw new NullPointerException(\"null values not allowed\");\n        }\n\n        purgeBeforeWrite();\n        final Entry<K, V> entry = getEntry(key);\n        if (entry == null) {\n            return false;\n        }\n        if (entry.getValue() == value) {\n            entry.setValue(null);\n            if (entry.getKey() == null) {\n                entry.setKey(null);\n                return true;\n            }\n        }\n        return false;\n    }"
    ],
    [
      "private Node transformAsString(AstNode n)  {\n      if (n.getType() == Token.NAME) {\n        n.setType(Token.STRING);\n      }\n      return transformAsString(n);\n    }",
      "private Node transformAsString(AstNode n)  {\n        if (n.getType() == Token.NAME) {\n            n.setType(Token.STRING);\n        }\n        return transformToString(n);\n    }",
      "private Node transformAsString(AstNode n)  {\n        if (n instanceof Name) \n        {\n            n = new StringLiteral(n.getLineno(), n.getCharno(), n.getString());\n        }\n        return n;\n    }",
      "private Node transformAsString(AstNode n)  {\n      if (n instanceof Name) {\n        n = new StringLiteral(((Name) n).getIdentifier());\n      }\n      if (n instanceof StringLiteral) {\n        StringLiteral sl = (StringLiteral) n;\n        if (!sl.hasQuotes()) {\n          sl.setQuoted(true);\n        }\n      }\n      return n;\n    }",
      "private Node transformAsString(AstNode n)  {\n        if (n.getType() == Token.NAME) {\n            n.setType(Token.STRING);\n        }\n        return transformToString(n);\n    }",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) {\n        n.setType(Token.STRING);\n    }\n    return transformToString(n);\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n instanceof Name) \n    {\n        n = new StringLiteral(n.getLineno(), n.getCharno());\n        n.setValue(((Name) n).getIdentifier());\n    }\n    return n;\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n.getType() == Token.NAME) \n    {\n        n.setType(Token.STRING);\n    }\n    return transformAsString(n);\n}",
      "private Node transformAsString(AstNode n)  {\n    if (n instanceof Name) \n    {\n        n = new StringLiteral(n.getLineno(), n.getCharno(), ((Name) n).getIdentifier());\n    }\n    return n;\n}",
      "private Node transformAsString(AstNode n)  {\n        if (n instanceof Name) \n        {\n            n = new StringLiteral(n.getLineno(), n.getCharno());\n            ((StringLiteral) n).setValue(((Name) n).getIdentifier());\n        }\n        if (n instanceof StringLiteral) \n        {\n            ((StringLiteral) n).setQuoted(true);\n        }\n        return n;\n    }"
    ],
    [
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null dataset.\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Null category.\");\n    }\n    if (includedRows == null) {\n        throw new IllegalArgumentException(\"Null includedRows array.\");\n    }\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null dataset.\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Null category.\");\n    }\n    if (includedRows == null) {\n        throw new IllegalArgumentException(\"Null includedRows array.\");\n    }\n\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}",
      "protected List createStackedValueList(CategoryDataset dataset,\n            Comparable category, int[] includedRows, double base,\n            boolean asPercentages)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null dataset.\");\n    }\n    if (category == null) {\n        throw new IllegalArgumentException(\"Null category.\");\n    }\n    if (includedRows == null) {\n        throw new IllegalArgumentException(\"Null includedRows array.\");\n    }\n    List result = new ArrayList();\n    double posBase = base;\n    double negBase = base;\n    double total = 0.0;\n    if (asPercentages) {\n        total = DataUtilities.calculateColumnTotal(dataset,\n                dataset.getColumnIndex(category), includedRows);\n    }\n    int baseIndex = -1;\n    int rowCount = includedRows.length;\n    for (int i = 0; i < rowCount; i++) {\n        int r = includedRows[i];\n        Number n = dataset.getValue(dataset.getRowKey(r), category);\n        if (n == null) {\n            continue;\n        }\n        double v = n.doubleValue();\n        if (asPercentages) {\n            v = v / total;\n        }\n        if ((v > 0.0) || (!this.ignoreZeroValues && v >= 0.0)) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            posBase = posBase + v;\n            result.add(new Object[] {new Integer(r), new Double(posBase)});\n        }\n        else if (v < 0.0) {\n            if (baseIndex < 0) {\n                result.add(new Object[] {null, new Double(base)});\n                baseIndex = 0;\n            }\n            negBase = negBase + v; // '+' because v is negative\n            result.add(0, new Object[] {new Integer(-r - 1),\n                    new Double(negBase)});\n            baseIndex++;\n        }\n    }\n    return result;\n}"
    ],
    [
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        shadowChildrenRef = new SoftReference<List<Element>>(childElements());\n    }\n    List<Element> shadowChildren = shadowChildrenRef.get();\n    if (shadowChildren == null) {\n        shadowChildren = new ArrayList<Element>(childElements());\n        shadowChildrenRef = new SoftReference<List<Element>>(shadowChildren);\n    }\n    return shadowChildren;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null)\n    {\n        shadowChildrenRef = new WeakReference<List<Element>>(childElementsListImpl());\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null)\n    {\n        shadowChildrenRef = new SoftReference<List<Element>>(childElementsListImpl());\n    }\n    List<Element> shadowChildren = shadowChildrenRef.get();\n    if (shadowChildren == null)\n    {\n        shadowChildren = childElementsListImpl();\n        shadowChildrenRef = new SoftReference<List<Element>>(shadowChildren);\n    }\n    return shadowChildren;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        List<Element> children = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                children.add((Element) node);\n        }\n        shadowChildrenRef = new SoftReference<>(children);\n    }\n\n    List<Element> children = shadowChildrenRef.get();\n    if (children == null) {\n        // list was gc'd, rebuild\n        children = new ArrayList<>();\n        for (Node node : childNodes) {\n            if (node instanceof Element)\n                children.add((Element) node);\n        }\n        shadowChildrenRef = new SoftReference<>(children);\n    }\n\n    return children;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n        List<Element> children = new ArrayList<>();\n        for (Node child : childNodes) {\n            if (child instanceof Element) {\n                children.add((Element) child);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(children);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null || shadowChildrenRef.get() == null) {\n        shadowChildrenRef = new WeakReference<>(childElements());\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null)\n    {\n        List<Element> children = new ArrayList<>();\n        for (Node child : childNodes)\n        {\n            if (child instanceof Element)\n            {\n                children.add((Element) child);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(children);\n    }\n    else\n    {\n        List<Element> children = shadowChildrenRef.get();\n        if (children == null)\n        {\n            children = new ArrayList<>();\n            for (Node child : childNodes)\n            {\n                if (child instanceof Element)\n                {\n                    children.add((Element) child);\n                }\n            }\n            shadowChildrenRef = new WeakReference<>(children);\n        }\n    }\n    return Collections.unmodifiableList(shadowChildrenRef.get());\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null)\n    {\n        shadowChildrenRef = new SoftReference<>(childElements());\n    }\n    List<Element> children = shadowChildrenRef.get();\n    if (children == null)\n    {\n        children = childElements();\n        shadowChildrenRef = new SoftReference<>(children);\n    }\n    return children;\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null)\n    {\n        List<Element> shadowChildren = new ArrayList<>();\n        for (Node node : childNodes())\n        {\n            if (node instanceof Element)\n            {\n                shadowChildren.add((Element) node);\n            }\n        }\n        shadowChildrenRef = new WeakReference<>(shadowChildren);\n    }\n    return shadowChildrenRef.get();\n}",
      "private List<Element> childElementsList()  {\n    if (shadowChildrenRef == null) {\n        List<Element> shadowChildren = new ArrayList<>();\n        for (Node child : childNodes) {\n            if (child instanceof Element)\n                shadowChildren.add((Element) child);\n        }\n        shadowChildrenRef = new SoftReference<>(shadowChildren);\n    }\n    List<Element> shadowChildren = shadowChildrenRef.get();\n    if (shadowChildren == null) {\n        shadowChildren = new ArrayList<>();\n        for (Node child : childNodes) {\n            if (child instanceof Element)\n                shadowChildren.add((Element) child);\n        }\n        shadowChildrenRef = new SoftReference<>(shadowChildren);\n    }\n    return shadowChildren;\n}"
    ],
    [
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return Math.abs(hash % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode() % buckets.length;\n    if (hash < 0) {\n        hash += buckets.length;\n    }\n    return hash;\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return Math.abs(hash % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return Math.abs(hash % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    return Math.abs(hash % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode();\n    hash = hash & 0x7FFFFFFF;\n    hash = hash % buckets.length;\n    return hash;\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode() % buckets.length;\n    if (hash < 0) {\n        hash += buckets.length;\n    }\n    return hash;\n}",
      "private int getHash(final Object key)  {\n    return Math.abs(key.hashCode() % buckets.length);\n}",
      "private int getHash(final Object key)  {\n    int hash = key.hashCode() % buckets.length;\n    if (hash < 0) {\n        hash += buckets.length;\n    }\n    return hash;\n}"
    ],
    [
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r >= c - k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r >= c - k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix triu(final RealMatrix m, int k)  {\n    final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n    for (int r = 0; r < m.getRowDimension(); r++) {\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            if (r <= c + k) {\n                d[r][c] = m.getEntry(r, c);\n            } else {\n                d[r][c] = 0;\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}"
    ],
    [
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (left.skew == Skew.BALANCED) \n            {\n                rotateCW();\n                skew = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n                return true;\n            } \n            else if (left.skew == Skew.BALANCED) \n            {\n                rotateCW();\n                skew = Skew.RIGHT_HIGH;\n                right.skew = Skew.LEFT_HIGH;\n                return false;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n                return true;\n            }\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return true;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return false;\n    }\n}",
      "private boolean rebalanceRightShrunk()  {\n    switch (skew) \n    {\n        case LEFT_HIGH:\n            if (left.skew == Skew.LEFT_HIGH) \n            {\n                rotateCW();\n                skew      = Skew.BALANCED;\n                right.skew = Skew.BALANCED;\n            } \n            else \n            {\n                final Skew s = left.right.skew;\n                left.rotateCCW();\n                rotateCW();\n                switch (s) \n                {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                }\n                skew = Skew.BALANCED;\n            }\n            return false;\n        case RIGHT_HIGH:\n            skew = Skew.BALANCED;\n            return false;\n        default:\n            skew = Skew.LEFT_HIGH;\n            return true;\n    }\n}"
    ],
    [
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    double eps = norm * 1.0e-14;\n    while (idx < matrixT.length - 1 &&\n           FastMath.abs(matrixT[idx][idx - 1]) > eps) {\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx < matrixT.length - 1 &&\n           (FastMath.abs(matrixT[idx][idx]) + FastMath.abs(matrixT[idx + 1][idx + 1])) * epsilon >= norm) \n    {\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx < matrixT.length - 1 &&\n           (FastMath.abs(matrixT[idx][idx]) + FastMath.abs(matrixT[idx + 1][idx + 1])) * epsilon >= norm) \n    {\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    double eps = 1e-14;\n    while (idx < matrixT.length - 1 && FastMath.abs(matrixT[idx][idx - 1]) > eps * norm) \n    {\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    double eps = FastMath.ulp(norm);\n    double tst1 = norm + eps;\n    while (idx < matrixT.length - 1) \n    {\n        if (FastMath.abs(matrixT[idx][idx + 1]) <= eps * (FastMath.abs(matrixT[idx][idx]) + FastMath.abs(matrixT[idx + 1][idx + 1]))) \n        {\n            break;\n        }\n        idx++;\n    }\n    if (idx == matrixT.length - 1 && FastMath.abs(matrixT[idx][idx + 1]) <= eps * (FastMath.abs(matrixT[idx][idx]) + FastMath.abs(matrixT[idx + 1][idx + 1]))) \n    {\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx < matrixT.length - 1 &&\n           (FastMath.abs(matrixT[idx][idx]) + FastMath.abs(matrixT[idx + 1][idx + 1])) *\n               FastMath.abs(matrixT[idx][idx + 1]) <=\n           epsilon * norm * norm) {\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx < matrixT.length - 1) \n    {\n        final double epsilon = norm * 1e-14;\n        final double z = matrixT[idx][idx - 1];\n        final double r = shift.x - z;\n        double s = shift.y - z;\n        final double hVec = (r * s - shift.w) / matrixT[idx + 1][idx] + matrixT[idx][idx + 1];\n        final double lhs = FastMath.abs(matrixT[idx][idx - 1]) * (FastMath.abs(hVec) + FastMath.abs(matrixT[idx + 1][idx + 1]));\n        final double rhs = FastMath.abs(hVec) * (FastMath.abs(matrixT[idx - 1][idx - 1]) +\n                                                  FastMath.abs(z) +\n                                                  FastMath.abs(matrixT[idx + 1][idx + 1]));\n\n        if (lhs < epsilon * rhs) \n        {\n            break;\n        }\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    double eps = FastMath.ulp(norm);\n    while (idx < matrixT.length - 1) \n    {\n        double eps1 = eps * FastMath.abs(matrixT[idx][idx]) * norm;\n        double eps2 = eps * FastMath.abs(matrixT[idx + 1][idx + 1]) * norm;\n        double eps3 = eps * FastMath.abs(matrixT[idx][idx + 1]) * (FastMath.abs(matrixT[idx][idx]) + FastMath.abs(matrixT[idx + 1][idx + 1]));\n        if (FastMath.abs(matrixT[idx + 1][idx]) * (FastMath.abs(matrixT[idx][idx + 1]) + FastMath.abs(matrixT[idx + 1][idx + 1])) < eps1 ||\n            FastMath.abs(matrixT[idx][idx + 1]) < eps2 ||\n            FastMath.abs(matrixT[idx][idx + 1]) * eps3 < eps1) \n        {\n            break;\n        }\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    while (idx < matrixT.length - 1 &&\n           (FastMath.abs(matrixT[idx][idx - 1]) + FastMath.abs(matrixT[idx + 1][idx])) *\n               FastMath.abs(matrixT[idx][idx]) < epsilon * norm) {\n        idx++;\n    }\n    return idx;\n}",
      "private int findSmallSubDiagonalElement(final int startIdx, final double norm)  {\n    int idx = startIdx;\n    double eps = norm * 1e-14;\n    while (idx < matrixT.length - 1) \n    {\n        double s = FastMath.abs(matrixT[idx][idx]) + FastMath.abs(matrixT[idx + 1][idx + 1]);\n        if (FastMath.abs(matrixT[idx][idx + 1]) < eps * s) \n        {\n            break;\n        }\n        idx++;\n    }\n    return idx;\n}"
    ],
    [
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}",
      "public Node getNotSmaller(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) < 0) \n        {\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        } \n        else \n        {\n            candidate = node;\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}"
    ],
    [
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        final int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}",
      "public StrBuilder deleteAll(final String str)  {\n    final int len = (str == null ? 0 : str.length());\n    if (len > 0) \n    {\n        int index = indexOf(str, 0);\n        while (index >= 0) \n        {\n            deleteImpl(index, index + len, len);\n            index = indexOf(str, index);\n        }\n    }\n    return this;\n}"
    ],
    [
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transformDispatcher.processNode(node, true);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transformDispatcher.processName(node, true);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transformDispatcher.processNode(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transformDispatcher.processName(node, true);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transformDispatcher.processNodeWithInlineJsDoc(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transformDispatcher.processName(node, true);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transformDispatcher.processNode(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transformDispatcher.processName(node, true);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transformDispatcher.processNode(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}",
      "private Node transformNodeWithInlineJsDoc(AstNode node)  {\n    Node irNode = transformDispatcher.processName(node, true);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) \n    {\n        irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n}"
    ],
    [
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n        if (list == null) \n        {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n        final Set<E> set = new HashSet<E>(list);\n\n        return new SetUniqueList<E>(set, list);\n    }",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n        if (list == null) {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n        final Set<E> set = new HashSet<E>(list);\n\n        return new SetUniqueList<E>(set, list);\n    }",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n        if (list == null) \n        {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n        final Set<E> set = new HashSet<E>(list);\n        return new SetUniqueList<E>(set, list);\n    }",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n        if (list == null) {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n        final Set<E> set = new HashSet<E>(list);\n\n        return new SetUniqueList<E>(set, list);\n    }",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n        if (list == null) {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n        final Set<E> set = new HashSet<E>(list);\n\n        return new SetUniqueList<E>(set, list);\n    }",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n    return new SetUniqueList<E>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    final Set<E> set = new HashSet<E>(list);\n    list.retainAll(set);\n    return new SetUniqueList<E>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n    if (list == null) \n    {\n        throw new NullPointerException(\"List must not be null\");\n    }\n    CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n    final Set<E> set = new HashSet<E>(list);\n\n    return new SetUniqueList<E>(set, list);\n}",
      "public static <E> SetUniqueList<E> setUniqueList(final List<E> list)  {\n        if (list == null) \n        {\n            throw new NullPointerException(\"List must not be null\");\n        }\n        final Set<E> set = new HashSet<E>(list);\n        final List<E> list2 = new ArrayList<E>(set);\n        return new SetUniqueList<E>(set, list2);\n    }"
    ],
    [
      "private Node parseArrayType(JsDocToken token)  {\n  if (token != JsDocToken.LB) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lb\");\n  }\n\n  skipEOLs();\n  Node elementTypeList = parseElementTypeList(next());\n\n  if (elementTypeList == null) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.element.type.list\");\n  }\n\n  skipEOLs();\n  if (!match(JsDocToken.RB)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n\n  next();\n  return elementTypeList;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Preconditions.checkArgument(token == JsDocToken.LB);\n\n  skipEOLs();\n\n  Node arrayType = newNode(Token.LB);\n\n  Node expr = null;\n  do {\n    if (expr != null) {\n      skipEOLs();\n      token = next();\n      Preconditions.checkState(\n          token == JsDocToken.COMMA || token == JsDocToken.ELLIPSIS);\n\n      if (token == JsDocToken.ELLIPSIS) {\n        token = next();\n        if (token == JsDocToken.RB) {\n          // EMPTY represents the UNKNOWN type in the Type AST.\n          return wrapNode(Token.ELLIPSIS, IR.empty());\n        }\n      }\n      skipEOLs();\n      token = next();\n    }\n    expr = parseTypeExpression(token);\n    if (expr == null) {\n      return null;\n    }\n\n    arrayType.addChildToBack(expr);\n    // We support commas for backwards compatibility.\n  } while (match(JsDocToken.COMMA, JsDocToken.ELLIPSIS));\n\n  if (!match(JsDocToken.RB)) {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n  next();\n\n  return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node expr = null;\n    do \n    {\n        if (expr != null) \n        {\n            skipEOLs();\n            token = next();\n            Preconditions.checkState(\n                token == JsDocToken.COMMA || token == JsDocToken.ELLIPSIS);\n\n            boolean isEllipsis = token == JsDocToken.ELLIPSIS;\n            if (isEllipsis && match(JsDocToken.ELLIPSIS)) \n            {\n                // We support double ellipsis for backwards compatibility.\n                next();\n            }\n            skipEOLs();\n            token = next();\n        }\n        expr = parseTypeExpression(token);\n        if (expr == null) \n        {\n            return null;\n        }\n\n        arrayType.addChildToBack(expr);\n        // We support commas for backwards compatibility.\n    } while (match(JsDocToken.COMMA, JsDocToken.ELLIPSIS));\n\n    if (!match(JsDocToken.RB)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  Preconditions.checkArgument(token == JsDocToken.LB);\n\n  skipEOLs();\n\n  boolean restArg = false;\n  token = next();\n  if (token == JsDocToken.ELLIPSIS) \n  {\n    token = next();\n    if (token == JsDocToken.RB) \n    {\n      // EMPTY represents the UNKNOWN type in the Type AST.\n      return wrapNode(Token.ELLIPSIS, IR.empty());\n    }\n    restArg = true;\n  }\n\n  Node typeNode = parseTypeExpression(token);\n  if (typeNode != null) \n  {\n    skipEOLs();\n    if (restArg) \n    {\n      typeNode = wrapNode(Token.ELLIPSIS, typeNode);\n    }\n\n    if (!match(JsDocToken.RB)) \n    {\n      reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    } \n    else \n    {\n      next();\n    }\n  }\n\n  return typeNode;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n  if (token != JsDocToken.LB) \n  {\n    return null;\n  }\n  \n  skipEOLs();\n  Node elementTypeList = parseElementTypeList(next());\n  \n  if (elementTypeList == null) \n  {\n    return null;\n  }\n  \n  if (!match(JsDocToken.RB)) \n  {\n    return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n  }\n  \n  next();\n  return elementTypeList;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    if (token != JsDocToken.LB) \n    {\n        return null;\n    }\n    skipEOLs();\n    Node arrayType = newNode(Token.LB);\n    Node expr = null;\n    do \n    {\n        if (expr != null) \n        {\n            skipEOLs();\n            token = next();\n            Preconditions.checkState(\n                token == JsDocToken.COMMA || token == JsDocToken.ELLIPSIS);\n            if (token == JsDocToken.ELLIPSIS) \n            {\n                next();\n            }\n            skipEOLs();\n            token = next();\n        }\n        expr = parseTypeExpression(token);\n        if (expr == null) \n        {\n            return null;\n        }\n        arrayType.addChildToBack(expr);\n        // We support commas for backwards compatibility.\n    } while (match(JsDocToken.COMMA, JsDocToken.ELLIPSIS));\n\n    if (!match(JsDocToken.RB)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node expr = null;\n    do \n    {\n        if (expr != null) \n        {\n            skipEOLs();\n            token = next();\n            Preconditions.checkState(\n                token == JsDocToken.PIPE || token == JsDocToken.COMMA);\n\n            boolean isPipe = token == JsDocToken.PIPE;\n            if (isPipe && match(JsDocToken.PIPE)) \n            {\n                // We support double pipes for backwards compatibility.\n                next();\n            }\n            skipEOLs();\n            token = next();\n        }\n        expr = parseTypeExpression(token);\n        if (expr == null) \n        {\n            return null;\n        }\n\n        arrayType.addChildToBack(expr);\n        // We support commas for backwards compatibility.\n    } while (match(JsDocToken.PIPE, JsDocToken.COMMA));\n\n    if (!match(JsDocToken.RB)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    }\n    next();\n\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    Node arrayType = newNode(Token.LB);\n    Node expr = null;\n\n    if (token == JsDocToken.ELLIPSIS) {\n        token = next();\n        expr = parseTypeExpression(token);\n        if (expr == null) {\n            return null;\n        }\n        arrayType.addChildToBack(wrapNode(Token.ELLIPSIS, expr));\n    } else {\n        do {\n            if (expr != null) {\n                skipEOLs();\n                token = next();\n                Preconditions.checkState(\n                    token == JsDocToken.COMMA || token == JsDocToken.ELLIPSIS);\n\n                boolean isComma = token == JsDocToken.COMMA;\n                if (isComma && match(JsDocToken.COMMA)) {\n                    // We support commas for backwards compatibility.\n                    next();\n                }\n                skipEOLs();\n                token = next();\n            }\n            expr = parseTypeExpression(token);\n            if (expr == null) {\n                return null;\n            }\n\n            arrayType.addChildToBack(expr);\n            // We support commas for backwards compatibility.\n        } while (match(JsDocToken.COMMA, JsDocToken.ELLIPSIS));\n    }\n\n    if (!match(JsDocToken.RB)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    } else {\n        next();\n    }\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    if (token != JsDocToken.LB) \n    {\n        return null;\n    }\n\n    Node arrayType = newNode(Token.LB);\n    Node elementType = parseElementType(next());\n\n    if (elementType == null) \n    {\n        return null;\n    }\n\n    arrayType.addChildToBack(elementType);\n    while (match(JsDocToken.COMMA)) \n    {\n        next();\n        skipEOLs();\n        elementType = parseElementType(next());\n\n        if (elementType == null) \n        {\n            return null;\n        }\n\n        arrayType.addChildToBack(elementType);\n    }\n\n    if (!match(JsDocToken.RB)) \n    {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    } \n    else \n    {\n        next();\n    }\n\n    return arrayType;\n}",
      "private Node parseArrayType(JsDocToken token)  {\n    if (token != JsDocToken.LB) \n    {\n        return null;\n    }\n\n    skipEOLs();\n    Node arrayType = newNode(Token.LB);\n\n    Node elementType = parseTypeExpression(next());\n    if (elementType == null) \n    {\n        return null;\n    }\n    arrayType.addChildToBack(elementType);\n\n    while (match(JsDocToken.COMMA)) \n    {\n        next();\n        skipEOLs();\n        elementType = parseTypeExpression(next());\n        if (elementType == null) \n        {\n            return null;\n        }\n        arrayType.addChildToBack(elementType);\n    }\n\n    if (!match(JsDocToken.RB)) \n    {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n    } else \n    {\n        next();\n    }\n\n    return arrayType;\n}"
    ],
    [
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}",
      "public Vector3D getAxis()  {\n    double norm = Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3);\n    return new Vector3D(q1 / norm, q2 / norm, q3 / norm);\n}"
    ],
    [
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                // if the next octet is a CR we have found a soft line break\n                if (bytes[++i] == CR) \n                {\n                    continue;\n                }\n                final int u = Utils.digit16(bytes[i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid quoted-printable encoding\", e);\n            }\n        } \n        else if (b != CR && b != LF) \n        {\n            // every other octet is appended except for CR & LF\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        final int b = bytes[i];\n        if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                final int u = Utils.digit16(bytes[i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } \n        else \n        {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                final int u = Utils.digit16(bytes[i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } \n        else \n        {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                final int u = Utils.digit16(bytes[i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } \n        else \n        {\n            // every other octet is appended except for CR & LF\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        final int b = bytes[i];\n        if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                final int u = Utils.digit16(bytes[i + 1]);\n                final int l = Utils.digit16(bytes[i + 2]);\n                buffer.write((char) ((u << 4) + l));\n                i += 2;\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } \n        else \n        {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                // if the next octet is a CR we have found a soft line break\n                if (bytes[++i] == CR) \n                {\n                    continue;\n                }\n                final int u = Utils.digit16(bytes[i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } \n        else if (b != CR && b != LF) \n        {\n            // every other octet is appended except for CR & LF\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        final int b = bytes[i];\n        if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                final int u = Utils.digit16(bytes[i + 1]);\n                final int l = Utils.digit16(bytes[i + 2]);\n                buffer.write((char) ((u << 4) + l));\n                i += 2;\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } \n        else \n        {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        final int b = bytes[i];\n        if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                final int u = Utils.digit16(bytes[i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } \n        else \n        {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        final int b = bytes[i];\n        if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                final int u = Utils.digit16(bytes[i]);\n                final int l = Utils.digit16(bytes[++i]);\n                buffer.write((char) ((u << 4) + l));\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } \n        else \n        {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}",
      "public static final byte[] decodeUrl(final byte[] bytes) throws DecoderException  {\n    if (bytes == null) \n    {\n        return null;\n    }\n    final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    for (int i = 0; i < bytes.length; i++) \n    {\n        final int b = bytes[i];\n        if (b == '+') \n        {\n            buffer.write(' ');\n        } \n        else if (b == ESCAPE_CHAR) \n        {\n            try \n            {\n                final int u = Utils.digit16(bytes[i + 1]);\n                final int l = Utils.digit16(bytes[i + 2]);\n                buffer.write((char) ((u << 4) + l));\n                i += 2;\n            } \n            catch (final ArrayIndexOutOfBoundsException e) \n            {\n                throw new DecoderException(\"Invalid URL encoding\", e);\n            }\n        } \n        else \n        {\n            buffer.write(b);\n        }\n    }\n    return buffer.toByteArray();\n}"
    ],
    [
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter removePeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        \n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static final boolean isContiguous(ReadablePartial partial)  if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) {\n        DateTimeField field = partial.getField(i);\n        DateTimeField nextField = partial.getField(i + 1);\n        if (field.getMaximumValue() != nextField.getMinimumValue()) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    if (size <= 1) {\n        return true;\n    }\n    int[] values = new int[size];\n    for (int i = 0; i < size; i++) {\n        values[i] = partial.getValue(i);\n    }\n    DateTimeField field1 = partial.getField(0);\n    DateTimeField field2 = partial.getField(1);\n    if (field1.getRangeEnd(values[0]) == field2.getRangeStart(values[1])) {\n        return true;\n    }\n    return false;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    if (size <= 1) {\n        return true;\n    }\n    DateTimeField field1 = partial.getField(0);\n    DateTimeField field2 = partial.getField(1);\n    return field1.getRangeDurationField().equals(field2.getDurationField());\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial cannot be null\");\n        }\n        int size = partial.size();\n        if (size < 2) {\n            return true;\n        }\n        DateTimeFieldType lastType = partial.getFieldType(0);\n        int lastMax = partial.getMaximumValue(lastType);\n        for (int i = 1; i < size; i++) {\n            DateTimeFieldType type = partial.getFieldType(i);\n            if (lastMax != partial.getMinimumValue(type)) {\n                return false;\n            }\n            lastType = type;\n            lastMax = partial.getMaximumValue(lastType);\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeFieldType[] types = new DateTimeFieldType[size];\n    for (int i = 0; i < size; i++) {\n        types[i] = partial.getFieldType(i);\n    }\n    for (int i = 0; i < size - 1; i++) {\n        DateTimeFieldType type1 = types[i];\n        DateTimeFieldType type2 = types[i + 1];\n        if (type1.getRangeDurationFieldType() != type2) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    for (int i = 0; i < size - 1; i++) {\n        DateTimeField field = partial.getField(i);\n        DateTimeField nextField = partial.getField(i + 1);\n        if (field.getMaximumValue(partial) != nextField.getMinimumValue(partial)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeField field1 = partial.getField(0);\n    DateTimeField field2 = partial.getField(1);\n    if (field1.getRangeEnd(partial.getValue(0)) == field2.getRangeStart(partial.getValue(1))) {\n        return true;\n    }\n    return false;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n        if (partial == null) {\n            throw new IllegalArgumentException(\"Partial cannot be null\");\n        }\n        int size = partial.size();\n        if (size <= 1) {\n            return true;\n        }\n        for (int i = 0; i < size - 1; i++) {\n            DateTimeField field = partial.getField(i);\n            DateTimeField nextField = partial.getField(i + 1);\n            if (field.getMaximumValue(partial) != nextField.getMinimumValue(partial)) {\n                return false;\n            }\n        }\n        return true;\n    }",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    if (size <= 1) {\n        return true;\n    }\n    DateTimeFieldType[] types = new DateTimeFieldType[size];\n    for (int i = 0; i < size; i++) {\n        types[i] = partial.getFieldType(i);\n    }\n    for (int i = 0; i < size - 1; i++) {\n        if (!types[i].getRangeDurationField().equals(types[i + 1])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "public static final boolean isContiguous(ReadablePartial partial)  {\n    if (partial == null) {\n        throw new IllegalArgumentException(\"Partial cannot be null\");\n    }\n    int size = partial.size();\n    if (size < 2) {\n        return true;\n    }\n    DateTimeField field1 = partial.getField(size - 1);\n    DateTimeField field2 = partial.getField(size - 2);\n    return field1.getMaximumValue(partial) == field2.getMinimumValue(partial);\n}"
    ],
    [
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) \n    {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}",
      "public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b)  {\n    final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n    for (final O obj : helper) {\n        helper.setCardinality(obj, helper.max(obj));\n    }\n    return helper.list();\n}"
    ],
    [
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<Node>();\n    Node param = params.getFirstChild();\n    while (param != null) \n    {\n        strings.add(Node.newString(param.getString()));\n        param = param.getNext();\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param : params.children()) \n  {\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null) \n    {\n        strings.add(IR.string(param.getString()));\n        param = param.getNext();\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param : params.children()) \n  {\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node param : params.children()) {\n        strings.add(Node.newString(param.getString()));\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node param : params.children()) \n    {\n        strings.add(IR.string(param.getString()));\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    for (Node param : params.children()) {\n        strings.add(Node.newString(param.getString()));\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n    List<Node> strings = new ArrayList<>();\n    Node param = params.getFirstChild();\n    while (param != null)\n    {\n        strings.add(Node.newString(param.getString()));\n        param = param.getNext();\n    }\n    return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  Node param = params.getFirstChild();\n  while (param != null) {\n    strings.add(Node.newString(param.getString()));\n    param = param.getNext();\n  }\n  return strings;\n}",
      "private static List<Node> createStringsFromParamList(Node params)  {\n  List<Node> strings = new ArrayList<>();\n  for (Node param : params.children()) {\n    strings.add(IR.string(param.getString()));\n  }\n  return strings;\n}"
    ],
    [
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) {\n            str.getChars(0, width, buffer, size);\n        } else {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}",
      "public StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar)  {\n    if (width > 0) \n    {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        if (str == null) \n        {\n            str = \"\";\n        }\n        final int strLen = str.length();\n        if (strLen >= width) \n        {\n            str.getChars(0, width, buffer, size);\n        } \n        else \n        {\n            final int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) \n            {\n                buffer[size + strLen + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n}"
    ],
    [
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    str = uncapitalize(str, delimiters);\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    str = uncapitalize(str, delimiters);\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final String[] words = str.split(\"\\\\s+\");\n    for (int i = 0; i < words.length; i++) {\n        words[i] = capitalize(words[i], delimiters);\n    }\n    return String.join(\" \", words);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final StringBuilder buffer = new StringBuilder(str.length());\n    boolean nextTitleCase = true;\n    for (char c : str.toCharArray()) {\n        if (delimiters != null && ArrayUtils.contains(delimiters, c)) {\n            nextTitleCase = true;\n        } else if (nextTitleCase) {\n            c = Character.toTitleCase(c);\n            nextTitleCase = false;\n        } else {\n            c = Character.toLowerCase(c);\n        }\n        buffer.append(c);\n    }\n    return buffer.toString();\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    str = uncapitalize(str, delimiters);\n    int i = 0;\n    for (int len = str.length(); i < len; i++) {\n        if (Character.isLetter(str.charAt(i))) {\n            str = str.substring(0, i) + Character.toTitleCase(str.charAt(i)) + str.substring(i + 1);\n        }\n    }\n    return str;\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) {\n        return str;\n    }\n    str = uncapitalize(str, delimiters);\n    return capitalize(str, delimiters);\n}",
      "public static String capitalizeFully(String str, final char... delimiters)  {\n    if (StringUtils.isEmpty(str) || delimiters == null || delimiters.length == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        } else {\n            buffer[i] = Character.toLowerCase(ch);\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "private static synchronized String getConvertedId(String id)  {\n    if (iConversionMap == null) {\n        try {\n            iConversionMap = loadConversionMap(openResource(\"ConversionMap\"));\n        } catch (IOException ex) {\n            iConversionMap = Collections.EMPTY_MAP;\n        }\n    }\n    return iConversionMap.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n        if (iConvertedIds == null) {\n            iConvertedIds = new HashMap<String, String>();\n            InputStream in = null;\n            try {\n                in = openResource(\"ConvertedIds\");\n                BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    int pos = line.indexOf('=');\n                    if (pos >= 0) {\n                        String oldId = line.substring(0, pos).trim();\n                        String newId = line.substring(pos + 1).trim();\n                        iConvertedIds.put(oldId, newId);\n                    }\n                }\n            } catch (IOException ex) {\n                // ignore\n            } finally {\n                try {\n                    if (in != null) {\n                        in.close();\n                    }\n                } catch (IOException ex) {\n                    // ignore\n                }\n            }\n        }\n        return iConvertedIds.get(id);\n    }\n}",
      "private static synchronized String getConvertedId(String id)  {\n        if (iConvertedIds == null) {\n            iConvertedIds = new HashMap<String, String>();\n            InputStream is = null;\n            try {\n                is = openResource(\"ConvertedIds\");\n                BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    int i = line.indexOf('=');\n                    if (i > 0) {\n                        String oldId = line.substring(0, i).trim();\n                        String newId = line.substring(i + 1).trim();\n                        iConvertedIds.put(oldId, newId);\n                    }\n                }\n            } catch (IOException ex) {\n                // ignore\n            } finally {\n                try {\n                    if (is != null) {\n                        is.close();\n                    }\n                } catch (IOException ex) {\n                    // ignore\n                }\n            }\n        }\n        return iConvertedIds.get(id);\n    }\n}",
      "private static synchronized String getConvertedId(String id)  {\n        if (iConvertedIds == null) {\n            iConvertedIds = new HashMap<String, String>();\n            try {\n                InputStream is = openResource(\"ConvertedIds\");\n                BufferedReader rdr = new BufferedReader(new InputStreamReader(is));\n                String line;\n                while ((line = rdr.readLine()) != null) {\n                    int i = line.indexOf('=');\n                    if (i > 0) {\n                        String oldId = line.substring(0, i).trim();\n                        String newId = line.substring(i + 1).trim();\n                        iConvertedIds.put(oldId, newId);\n                    }\n                }\n                rdr.close();\n            } catch (IOException ex) {\n                // ignore\n            }\n        }\n        return iConvertedIds.get(id);\n    }",
      "private static synchronized String getConvertedId(String id)  {\n        if (iConvertedIds == null) {\n            iConvertedIds = new HashMap<String, String>();\n            InputStream is = null;\n            try {\n                is = openResource(\"ConvertedIds\");\n                BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    int pos = line.indexOf('\\t');\n                    if (pos >= 0) {\n                        iConvertedIds.put(line.substring(0, pos), line.substring(pos + 1));\n                    }\n                }\n            } catch (IOException ex) {\n                System.err.println(\"Error reading ConvertedIds: \" + ex.getMessage());\n            } finally {\n                closeResource(is);\n            }\n        }\n        return iConvertedIds.get(id);\n    }\n}",
      "private static synchronized String getConvertedId(String id)  {\n        if (iConvertedIds == null) {\n            iConvertedIds = new HashMap<String, String>();\n            InputStream in = null;\n            try {\n                in = openResource(\"ConvertedIds.txt\");\n                BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    int index = line.indexOf('=');\n                    if (index >= 0) {\n                        String oldId = line.substring(0, index).trim();\n                        String newId = line.substring(index + 1).trim();\n                        iConvertedIds.put(oldId, newId);\n                    }\n                }\n            } catch (IOException ex) {\n                // Ignore, just means no conversion table available\n            } finally {\n                close(in);\n            }\n        }\n        return iConvertedIds.get(id);\n    }",
      "private static synchronized String getConvertedId(String id)  {\n    if (iConvertedIds == null) {\n        iConvertedIds = new HashMap<String, String>();\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(\n                ZoneInfoProvider.class.getResourceAsStream(\"converted_ids.txt\")));\n            String line;\n            while ((line = in.readLine()) != null) {\n                if (line.length() > 0 && line.charAt(0) != '#') {\n                    int i = line.indexOf('=');\n                    if (i > 0) {\n                        iConvertedIds.put(line.substring(0, i).trim(), line.substring(i + 1).trim());\n                    }\n                }\n            }\n            in.close();\n        } catch (IOException ex) {\n            System.err.println(\"Error reading converted ids: \" + ex.toString());\n        }\n    }\n    return iConvertedIds.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n    if (iConvertedIds == null) {\n        iConvertedIds = new HashMap<String, String>();\n        InputStream in = null;\n        try {\n            in = openResource(\"OldTZIDs.txt\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                int i = line.indexOf('#');\n                if (i >= 0) {\n                    line = line.substring(0, i);\n                }\n                line = line.trim();\n                if (line.length() > 0) {\n                    String[] parts = line.split(\"\\\\s+\");\n                    if (parts.length == 2) {\n                        iConvertedIds.put(parts[0], parts[1]);\n                    }\n                }\n            }\n        } catch (IOException ex) {\n            System.err.println(\"Error reading OldTZIDs.txt: \" + ex.getMessage());\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ex) {\n                    // Ignore\n                }\n            }\n        }\n    }\n    return iConvertedIds.get(id);\n}",
      "private static synchronized String getConvertedId(String id)  {\n        if (iConvertedIds == null) {\n            iConvertedIds = new HashMap<String, String>();\n            InputStream is = null;\n            try {\n                is = openResource(\"ConvertedIds\");\n                BufferedReader rdr = new BufferedReader(new InputStreamReader(is));\n                String line;\n                while ((line = rdr.readLine()) != null) {\n                    int pos = line.indexOf('=');\n                    if (pos > 0) {\n                        iConvertedIds.put(line.substring(0, pos), line.substring(pos + 1));\n                    }\n                }\n            } catch (IOException ex) {\n                System.err.println(\"Error reading ConvertedIds file: \" + ex.getMessage());\n            } finally {\n                try {\n                    if (is != null) {\n                        is.close();\n                    }\n                } catch (IOException ex) {\n                    System.err.println(\"Error closing ConvertedIds file: \" + ex.getMessage());\n                }\n            }\n        }\n        return iConvertedIds.get(id);\n    }\n}",
      "private static synchronized String getConvertedId(String id)  {\n        if (iConvertedIds == null) {\n            iConvertedIds = new HashMap<String, String>();\n            InputStream is = null;\n            try {\n                is = openResource(\"ConvertedIds\");\n                BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    int pos = line.indexOf('=');\n                    if (pos >= 0) {\n                        String oldId = line.substring(0, pos).trim();\n                        String newId = line.substring(pos + 1).trim();\n                        iConvertedIds.put(oldId, newId);\n                    }\n                }\n            } catch (IOException ex) {\n                System.err.println(\"Error reading ConvertedIds: \" + ex.getMessage());\n            } finally {\n                try {\n                    if (is != null) {\n                        is.close();\n                    }\n                } catch (IOException ex) {\n                    System.err.println(\"Error closing ConvertedIds: \" + ex.getMessage());\n                }\n            }\n        }\n        return iConvertedIds.get(id);\n    }\n}"
    ],
    [
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Check if the parameter array has the correct dimension.\n    if (params.length != getStartPoint().length) {\n        throw new DimensionMismatchException(params.length, getStartPoint().length);\n    }\n\n    // Compute the Jacobian matrix.\n    final RealMatrix jacobian = computeJacobian(params);\n\n    // Compute the square root of the diagonal elements of the weight matrix.\n    final double[] sqrtDiagWeights = new double[jacobian.getColumnDimension()];\n    final RealMatrix weightMatrix = getWeight();\n    for (int i = 0; i < sqrtDiagWeights.length; i++) {\n        sqrtDiagWeights[i] = Math.sqrt(weightMatrix.getEntry(i, i));\n    }\n\n    // Compute the weighted Jacobian.\n    final RealMatrix weightedJacobian = jacobian.operate(new ArrayRealVector(sqrtDiagWeights, false).getColumnMatrix());\n\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Number of observed data.\n    final int nR = targetValues.length;\n    // Number of model parameters.\n    final int nC = params.length;\n\n    // Check if the Jacobian dimension matches the problem dimension.\n    if (nC != jacobian.getColumnDimension()) {\n        throw new DimensionMismatchException(jacobian.getColumnDimension(), nC);\n    }\n\n    // Compute the Jacobian matrix.\n    for (int i = 0; i < nR; ++i) {\n        double[] jacobianRow = jacobian.getRow(i);\n        computeRow(params, i, jacobianRow);\n    }\n\n    // Compute the weighted Jacobian matrix.\n    return MatrixUtils.createRealDiagonalMatrix(residualsWeights).multiply(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Number of observed data.\n    final int nR = targetValues.length;\n    // Number of model parameters.\n    final int nC = params.length;\n\n    // Check if the number of parameters is correct.\n    if (nC != getNumberOfParameters()) {\n        throw new DimensionMismatchException(nC, getNumberOfParameters());\n    }\n\n    // Compute the Jacobian matrix.\n    final RealMatrix jacobian = computeJacobian(params);\n\n    // Compute the square root of the diagonal elements of the weight matrix.\n    final double[] sqrtWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        sqrtWeights[i] = Math.sqrt(residualsWeights[i]);\n    }\n\n    // Multiply the Jacobian matrix by the square root of the diagonal elements\n    // of the weight matrix.\n    final RealMatrix weightedJacobian = jacobian.multiply(new Array2DRowRealMatrix(sqrtWeights));\n\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Number of observed data.\n    final int nR = targetValues.length;\n    // Number of model parameters.\n    final int nC = params.length;\n\n    // Check that the Jacobian dimension matches the problem dimension.\n    if (nC != getJacobianColumnDimension()) {\n        throw new DimensionMismatchException(nC, getJacobianColumnDimension());\n    }\n\n    // Evaluate the model at the given parameters.\n    final double[] model = computeModel(params);\n\n    // Compute the Jacobian matrix.\n    final RealMatrix jacobian = new Array2DRowRealMatrix(nR, nC);\n    for (int i = 0; i < nR; i++) {\n        final double[] row = jacobian.getRow(i);\n        computeRow(params, model, i, row);\n    }\n\n    // Compute the weighted Jacobian.\n    final RealMatrix weightedJacobian = jacobian.multiply(weightMatrix);\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Number of observed data.\n    final int nR = targetValues.length;\n    // Number of parameters.\n    final int nC = params.length;\n\n    // Check that the Jacobian dimension matches the problem dimension.\n    if (nC != jacobian.getColumnDimension()) {\n        throw new DimensionMismatchException(jacobian.getColumnDimension(), nC);\n    }\n\n    // Compute the Jacobian.\n    for (int i = 0; i < nR; i++) {\n        double[] jacobianRow = jacobian.getRow(i);\n        computeRow(params, i, jacobianRow);\n    }\n\n    // Compute the weighted Jacobian.\n    return weightMatrix.multiply(jacobian);\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Compute the Jacobian matrix.\n    final RealMatrix jacobian = computeJacobian(params);\n\n    // Compute the square root of the diagonal elements of the weight matrix.\n    final double[] sqrtWeights = new double[nR];\n    for (int i = 0; i < nR; i++) {\n        sqrtWeights[i] = Math.sqrt(weightMatrix.getEntry(i, i));\n    }\n\n    // Multiply the Jacobian by the square root of the diagonal elements of the weight matrix.\n    final RealMatrix weightedJacobian = jacobian.operate(new ArrayRealVector(sqrtWeights, false).getColumnMatrix(0));\n\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    final int nR = targetValues.length;\n    final int nC = params.length;\n    final RealMatrix weightedJacobian = new Array2DRowRealMatrix(nR, nC);\n    for (int i = 0; i < nR; i++) {\n        final double[] jacobianRow = weightedJacobian.getRow(i);\n        final double[] grad = computeGradient(params);\n        final double weight = residualsWeights[i];\n        for (int j = 0; j < nC; j++) {\n            jacobianRow[j] = weight * grad[j];\n        }\n    }\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    final int nR = targetValues.length;\n    final int nC = params.length;\n    final double[] residuals = new double[nR];\n    final RealMatrix jacobian = MatrixUtils.createRealMatrix(nR, nC);\n    computeResidualsAndJacobian(params, residuals, jacobian);\n    final RealMatrix weightedJacobian = jacobian.multiply(\n            DiagonalMatrix.createDiagonalMatrix(residualsWeights));\n    return weightedJacobian;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    final int n = params.length;\n    final int m = getTarget().length;\n    if (n != getStartPoint().length) {\n        throw new DimensionMismatchException(n, getStartPoint().length);\n    }\n    final RealMatrix jac = new Array2DRowRealMatrix(m, n);\n    final double[] residuals = new double[m];\n    computeResiduals(computeObjectiveValue(params), residuals);\n    for (int i = 0; i < m; ++i) {\n        final double weight = getWeight().getEntry(i, i);\n        final double[] row = jac.getRow(i);\n        computeRow(params, i, weight, row);\n    }\n    return jac;\n}",
      "protected RealMatrix computeWeightedJacobian(double[] params)  throws DimensionMismatchException {\n    // Check that the parameter array has the correct dimension.\n    if (params.length != getStartPoint().length) {\n        throw new DimensionMismatchException(params.length, getStartPoint().length);\n    }\n\n    // Compute the Jacobian.\n    final RealMatrix jacobian = computeJacobian(params);\n\n    // Compute the square root of the weight matrix.\n    final RealMatrix sqrtWeightMatrix = getWeight().getCholeskyDecomposition().getL();\n\n    // Multiply the Jacobian by the square root of the weight matrix.\n    return sqrtWeightMatrix.multiply(jacobian);\n}"
    ],
    [
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (values[i] == null) {\n            values[i] = values[least];\n            values[least] = null;\n            least = i;\n        } else if (comparator.compare(values[i], values[least]) < 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n        if (comparator == null) {\n            throw new NullPointerException(\"No comparator set\");\n        }\n        int least = 0;\n        for (int i = 1; i < values.length; i++) {\n            if (values[i] == null) {\n                values[i] = values[least];\n                values[least] = null;\n                least = i;\n            } else if (comparator.compare(values[i], values[least]) < 0) {\n                least = i;\n            }\n        }\n        return least;\n    }",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (values[i] == null) {\n            values[i] = values[least];\n            values[least] = null;\n            least = i;\n        } else if (comparator.compare(values[i], values[least]) < 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int min = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (values[i] == null) {\n            values[i] = initialValue();\n        }\n        if (comparator.compare(values[i], values[min]) < 0) {\n            min = i;\n        }\n    }\n    return min;\n}",
      "private int least()  {\n        int least = 0;\n        for (int i = 1; i < values.length; i++) {\n            if (values[i] == null) {\n                values[i] = values[least];\n                values[least] = null;\n                least = i;\n            } else if (comparator.compare(values[i], values[least]) < 0) {\n                least = i;\n            }\n        }\n        return least;\n    }",
      "private int least()  {\n    int least = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (values[i] == null) {\n            values[i] = values[least];\n            values[least] = null;\n            least = i;\n        } else if (comparator.compare(values[i], values[least]) < 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    int least = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (values[i] == null) {\n            values[i] = values[least];\n            values[least] = null;\n            least = i;\n        } else if (comparator.compare(values[i], values[least]) < 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n    if (comparator == null) {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = 0;\n    for (int i = 1; i < values.length; i++) {\n        if (values[i] == null) {\n            values[i] = values[least];\n            values[least] = null;\n            least = i;\n        } else if (comparator.compare(values[i], values[least]) < 0) {\n            least = i;\n        }\n    }\n    return least;\n}",
      "private int least()  {\n        if (comparator == null) \n        {\n            throw new NullPointerException(\"No comparator set\");\n        }\n\n        int index = 0;\n        for (int i = 1; i < values.length; i++) \n        {\n            if (values[i] == null) \n            {\n                values[i] = initialValue();\n            }\n\n            if (comparator.compare(values[i], values[index]) < 0) \n            {\n                index = i;\n            }\n        }\n\n        return index;\n    }",
      "private int least()  {\n    if (comparator == null) \n    {\n        throw new NullPointerException(\"No comparator set\");\n    }\n    int least = 0;\n    for (int i = 1; i < values.length; i++) \n    {\n        if (values[i] == null) \n        {\n            set(i);\n        }\n        if (comparator.compare(values[i], values[least]) < 0) \n        {\n            least = i;\n        }\n    }\n    return least;\n}"
    ],
    [
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_CHILD) {\n            return new ChildNodePointer(parentPointer, step.getNodeTest());\n        }\n        else if (axis == Compiler.AXIS_ATTRIBUTE) {\n            return new AttributeNodePointer(parentPointer, step.getNodeTest());\n        }\n        else if (axis == Compiler.AXIS_SELF\n                && step.getNodeTest() instanceof NodeTypeTest\n                && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n            return parentPointer;\n        }\n        else if (axis == Compiler.AXIS_PARENT\n                && step.getNodeTest() instanceof NodeTypeTest\n                && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n            return parentPointer.getParent();\n        }\n        else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF\n                && step.getNodeTest() instanceof NodeTypeTest\n                && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                    == Compiler.NODE_TYPE_NODE\n                && (step.getPredicates() == null || step.getPredicates().length == 0)) {\n            return parentPointer;\n        }\n        else {\n            throw new IllegalArgumentException(\"Invalid axis: \" + axis);\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        int axis = step.getAxis();\n        NodeTest nodeTest = step.getNodeTest();\n        if (axis == Compiler.AXIS_CHILD) {\n            return new ChildNodePointer(parentPointer, nodeTest);\n        }\n        else if (axis == Compiler.AXIS_ATTRIBUTE) {\n            return new AttributeNodePointer(parentPointer, nodeTest);\n        }\n        else if (axis == Compiler.AXIS_SELF\n                && nodeTest instanceof NodeTypeTest\n                && ((NodeTypeTest) nodeTest).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n            return parentPointer;\n        }\n        else if (axis == Compiler.AXIS_PARENT\n                && nodeTest instanceof NodeTypeTest\n                && ((NodeTypeTest) nodeTest).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n            return parentPointer.getParentPointer();\n        }\n        else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF\n                && nodeTest instanceof NodeTypeTest\n                && ((NodeTypeTest) nodeTest).getNodeType()\n                    == Compiler.NODE_TYPE_NODE\n                && (step.getPredicates() == null || step.getPredicates().length == 0)) {\n            return parentPointer;\n        }\n        else {\n            throw new IllegalArgumentException(\"Invalid axis: \" + axis);\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    int axis = step.getAxis();\n    NodeTest nodeTest = step.getNodeTest();\n    NodePointer childPointer;\n    if (axis == Compiler.AXIS_CHILD) {\n        childPointer = new ChildNodePointer(parentPointer, nodeTest);\n    }\n    else if (axis == Compiler.AXIS_ATTRIBUTE) {\n        childPointer = new AttributeNodePointer(parentPointer, nodeTest);\n    }\n    else if (axis == Compiler.AXIS_SELF\n            && nodeTest instanceof NodeTypeTest\n            && ((NodeTypeTest) nodeTest).getNodeType()\n                == Compiler.NODE_TYPE_NODE) {\n        childPointer = new SelfNodePointer(parentPointer);\n    }\n    else if (axis == Compiler.AXIS_PARENT\n            && nodeTest instanceof NodeTypeTest\n            && ((NodeTypeTest) nodeTest).getNodeType()\n                == Compiler.NODE_TYPE_NODE) {\n        childPointer = new ParentNodePointer(parentPointer);\n    }\n    else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF\n            && nodeTest instanceof NodeTypeTest\n            && ((NodeTypeTest) nodeTest).getNodeType()\n                == Compiler.NODE_TYPE_NODE\n            && (step.getPredicates() == null || step.getPredicates().length == 0)) {\n        childPointer = new DescendantOrSelfNodePointer(parentPointer);\n    }\n    else {\n        throw new IllegalArgumentException(\"Invalid axis: \" + axis);\n    }\n    return childPointer;\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        int axis = step.getAxis();\n        NodeTest nodeTest = step.getNodeTest();\n        NodePointer childPointer;\n        if (axis == Compiler.AXIS_CHILD) {\n            childPointer = new ChildNodePointer(parentPointer, nodeTest);\n        }\n        else if (axis == Compiler.AXIS_ATTRIBUTE) {\n            childPointer = new AttributeNodePointer(parentPointer, nodeTest);\n        }\n        else if (axis == Compiler.AXIS_SELF\n                && nodeTest instanceof NodeTypeTest\n                && ((NodeTypeTest) nodeTest).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n            childPointer = parentPointer;\n        }\n        else if (axis == Compiler.AXIS_PARENT\n                && nodeTest instanceof NodeTypeTest\n                && ((NodeTypeTest) nodeTest).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n            childPointer = parentPointer.getParentPointer();\n        }\n        else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF\n                && nodeTest instanceof NodeTypeTest\n                && ((NodeTypeTest) nodeTest).getNodeType()\n                    == Compiler.NODE_TYPE_NODE\n                && (step.getPredicates() == null || step.getPredicates().length == 0)) {\n            childPointer = parentPointer;\n        }\n        else {\n            throw new IllegalArgumentException(\"Unsupported axis: \" + axis);\n        }\n        return childPointer;\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        int axis = step.getAxis();\n        NodeTest nodeTest = step.getNodeTest();\n        if (axis == Compiler.AXIS_CHILD) {\n            return new ChildNodePointer(parentPointer, nodeTest);\n        }\n        else if (axis == Compiler.AXIS_ATTRIBUTE) {\n            return new AttributeNodePointer(parentPointer, nodeTest);\n        }\n        else if (axis == Compiler.AXIS_SELF\n                && nodeTest instanceof NodeTypeTest\n                && ((NodeTypeTest) nodeTest).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n            return new SelfNodePointer(parentPointer);\n        }\n        else if (axis == Compiler.AXIS_PARENT\n                && nodeTest instanceof NodeTypeTest\n                && ((NodeTypeTest) nodeTest).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n            return new ParentNodePointer(parentPointer);\n        }\n        else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF\n                && nodeTest instanceof NodeTypeTest\n                && ((NodeTypeTest) nodeTest).getNodeType()\n                    == Compiler.NODE_TYPE_NODE\n                && (step.getPredicates() == null || step.getPredicates().length == 0)) {\n            return new DescendantOrSelfNodePointer(parentPointer);\n        }\n        else {\n            throw new IllegalArgumentException(\"Invalid axis: \" + axis);\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_CHILD) {\n            return new ChildNodePointer(parentPointer, step.getNodeTest());\n        }\n        else if (axis == Compiler.AXIS_ATTRIBUTE) {\n            return new AttributeNodePointer(parentPointer, step.getNodeTest());\n        }\n        else if (axis == Compiler.AXIS_SELF\n                && step.getNodeTest() instanceof NodeTypeTest\n                && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n            return parentPointer;\n        }\n        else if (axis == Compiler.AXIS_PARENT\n                && step.getNodeTest() instanceof NodeTypeTest\n                && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n            return parentPointer.getParentPointer();\n        }\n        else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF\n                && step.getNodeTest() instanceof NodeTypeTest\n                && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                    == Compiler.NODE_TYPE_NODE\n                && (step.getPredicates() == null || step.getPredicates().length == 0)) {\n            return parentPointer;\n        }\n        else {\n            throw new IllegalArgumentException(\"Unsupported axis: \" + axis);\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        int axis = step.getAxis();\n        NodeTest nodeTest = step.getNodeTest();\n        if (axis == Compiler.AXIS_CHILD) {\n            return new ChildNodePointer(parentPointer, nodeTest);\n        }\n        else if (axis == Compiler.AXIS_ATTRIBUTE) {\n            return new AttributeNodePointer(parentPointer, nodeTest);\n        }\n        else if (axis == Compiler.AXIS_SELF\n                && nodeTest instanceof NodeTypeTest\n                && ((NodeTypeTest) nodeTest).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n            return parentPointer;\n        }\n        else if (axis == Compiler.AXIS_PARENT\n                && nodeTest instanceof NodeTypeTest\n                && ((NodeTypeTest) nodeTest).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n            return parentPointer.getParent();\n        }\n        else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF\n                && nodeTest instanceof NodeTypeTest\n                && ((NodeTypeTest) nodeTest).getNodeType()\n                    == Compiler.NODE_TYPE_NODE\n                && (step.getPredicates() == null || step.getPredicates().length == 0)) {\n            return parentPointer;\n        }\n        else {\n            throw new IllegalArgumentException(\"Unsupported axis: \" + axis);\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_CHILD) {\n            return new ChildNodePointer(parentPointer, step.getNodeTest());\n        }\n        else if (axis == Compiler.AXIS_ATTRIBUTE) {\n            return new AttributeNodePointer(parentPointer, step.getNodeTest());\n        }\n        else if (axis == Compiler.AXIS_SELF\n                && step.getNodeTest() instanceof NodeTypeTest\n                && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n            return new SelfNodePointer(parentPointer);\n        }\n        else if (axis == Compiler.AXIS_PARENT\n                && step.getNodeTest() instanceof NodeTypeTest\n                && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n            return new ParentNodePointer(parentPointer);\n        }\n        else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF\n                && step.getNodeTest() instanceof NodeTypeTest\n                && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                    == Compiler.NODE_TYPE_NODE\n                && (step.getPredicates() == null || step.getPredicates().length == 0)) {\n            return new DescendantOrSelfNodePointer(parentPointer);\n        }\n        else {\n            throw new IllegalArgumentException(\"Invalid axis: \" + axis);\n        }\n    }",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n    int axis = step.getAxis();\n    NodeTest nodeTest = step.getNodeTest();\n    if (axis == Compiler.AXIS_CHILD) {\n        return new ChildNodePointer(parentPointer, nodeTest);\n    }\n    else if (axis == Compiler.AXIS_ATTRIBUTE) {\n        return new AttributeNodePointer(parentPointer, nodeTest);\n    }\n    else if (axis == Compiler.AXIS_SELF\n            && nodeTest instanceof NodeTypeTest\n            && ((NodeTypeTest) nodeTest).getNodeType()\n                == Compiler.NODE_TYPE_NODE) {\n        return new SelfNodePointer(parentPointer);\n    }\n    else if (axis == Compiler.AXIS_PARENT\n            && nodeTest instanceof NodeTypeTest\n            && ((NodeTypeTest) nodeTest).getNodeType()\n                == Compiler.NODE_TYPE_NODE) {\n        return new ParentNodePointer(parentPointer);\n    }\n    else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF\n            && nodeTest instanceof NodeTypeTest\n            && ((NodeTypeTest) nodeTest).getNodeType()\n                == Compiler.NODE_TYPE_NODE\n            && (step.getPredicates() == null || step.getPredicates().length == 0)) {\n        return new DescendantOrSelfNodePointer(parentPointer);\n    }\n    else {\n        throw new IllegalArgumentException(\"Unsupported axis: \" + axis);\n    }\n}",
      "private static NodePointer createChildPointerForStep(\n                PropertyOwnerPointer parentPointer, Step step)  {\n        int axis = step.getAxis();\n        if (axis == Compiler.AXIS_CHILD) {\n            return new ChildNodePointer(parentPointer, step.getNodeTest());\n        }\n        else if (axis == Compiler.AXIS_ATTRIBUTE) {\n            return new AttributeNodePointer(parentPointer, step.getNodeTest());\n        }\n        else if (axis == Compiler.AXIS_SELF\n                && step.getNodeTest() instanceof NodeTypeTest\n                && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n            return new SelfNodePointer(parentPointer);\n        }\n        else if (axis == Compiler.AXIS_PARENT\n                && step.getNodeTest() instanceof NodeTypeTest\n                && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                    == Compiler.NODE_TYPE_NODE) {\n            return new ParentNodePointer(parentPointer);\n        }\n        else if (axis == Compiler.AXIS_DESCENDANT_OR_SELF\n                && step.getNodeTest() instanceof NodeTypeTest\n                && ((NodeTypeTest) step.getNodeTest()).getNodeType()\n                    == Compiler.NODE_TYPE_NODE\n                && (step.getPredicates() == null || step.getPredicates().length == 0)) {\n            return new DescendantOrSelfNodePointer(parentPointer);\n        }\n        else {\n            throw new IllegalArgumentException(\"Invalid axis: \" + axis);\n        }\n    }"
    ],
    [
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double inf = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
      "public double getInf()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  inf  = Double.POSITIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        inf  = op.getLocation().getX();\n        node = op.isDirect() ? node.getMinus() : node.getPlus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}"
    ],
    [
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= createStrategy(field, definingCalendar, locale);\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            strategy= inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    if (field == Calendar.ZONE_OFFSET || field == Calendar.DST_OFFSET) {\n        return new TimeZoneStrategy(field);\n    }\n    final Locale locale = definingCalendar.getLocale();\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if (strategy == null) {\n        strategy = createStrategy(field, definingCalendar, locale);\n        final Strategy inCache = cache.putIfAbsent(locale, strategy);\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    if (field == Calendar.ZONE_OFFSET || field == Calendar.DST_OFFSET) {\n        return new TimeZoneStrategy(field);\n    }\n    final Locale locale = definingCalendar.getLocale();\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if (strategy == null) {\n        strategy = field == Calendar.MONTH ? new TextStrategy(field, definingCalendar, locale) : new TextStrategy(field, definingCalendar, locale);\n        final Strategy inCache = cache.putIfAbsent(locale, strategy);\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final Strategy strategy= getCache(field).get(parser.getLocale());\n    if(strategy==null) {\n        final Strategy newStrategy= field==Calendar.ZONE_OFFSET ? new TimeZoneStrategy(parser.getTimeZone()) :\n                new TextStrategy(field, definingCalendar, parser.getLocale());\n        final Strategy existingStrategy= getCache(field).putIfAbsent(parser.getLocale(), newStrategy);\n        return existingStrategy==null ? newStrategy : existingStrategy;\n    }\n    return strategy;\n}\n    }",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if (strategy == null) {\n        strategy = createStrategy(field, definingCalendar, locale);\n        final Strategy inCache = cache.putIfAbsent(locale, strategy);\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    if (field == Calendar.ZONE_OFFSET || field == Calendar.DST_OFFSET) {\n        return new TimeZoneStrategy(field);\n    }\n    return getCache(field).computeIfAbsent(parser.getLocale(),\n            key -> new TextStrategy(field, definingCalendar, key));\n}\n    }",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final Strategy strategy= getCache(field).get(locale);\n    if(strategy==null) {\n        final Strategy newStrategy;\n        if(field==Calendar.ZONE_OFFSET || field==Calendar.DST_OFFSET) {\n            newStrategy= new TimeZoneStrategy(locale);\n        }\n        else {\n            newStrategy= new TextStrategy(field, definingCalendar, locale);\n        }\n        final Strategy existingStrategy= getCache(field).putIfAbsent(locale, newStrategy);\n        return existingStrategy==null ? newStrategy : existingStrategy;\n    }\n    return strategy;\n}\n    }",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(parser.getLocale());\n    if(strategy==null) {\n        strategy= field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy(parser.getTimeZone()) :\n            field == Calendar.DST_OFFSET ? new TimeZoneStrategy(TimeZone.getDefault()) :\n            new TextStrategy(field, definingCalendar, parser.getLocale());\n        final Strategy inCache= cache.putIfAbsent(parser.getLocale(), strategy);\n        if(inCache!=null) {\n            strategy= inCache;\n        }\n    }\n    return strategy;\n}\n    }",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache = getCache(field);\n    Strategy strategy = cache.get(locale);\n    if (strategy == null) {\n        strategy = createStrategy(field, definingCalendar, locale);\n        final Strategy inCache = cache.putIfAbsent(locale, strategy);\n        if (inCache != null) {\n            strategy = inCache;\n        }\n    }\n    return strategy;\n}",
      "private Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar)  {\n    final ConcurrentMap<Locale, Strategy> cache= getCache(field);\n    Strategy strategy= cache.get(locale);\n    if(strategy==null) {\n        strategy= createStrategy(field, definingCalendar, locale);\n        final Strategy inCache= cache.putIfAbsent(locale, strategy);\n        if(inCache!=null) {\n            strategy= inCache;\n        }\n    }\n    return strategy;\n}"
    ],
    [
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    // Your code here\n}",
      "private boolean setNextObject()  {\n    // Your code here\n}",
      "private boolean setNextObject()  {\n    // [insert code here]\n}",
      "private boolean setNextObject()  {\n    // [INSERT CODE HERE]\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        E object = iterator.next();\n        if (predicate.test(object)) \n        {\n            nextObject = object;\n            nextObjectSet = true;\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    while (iterator.hasNext()) \n    {\n        nextObject = iterator.next();\n        if (predicate.test(nextObject)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean setNextObject()  {\n    // [INSERT]\n}",
      "private boolean setNextObject()  {\n    // Your code here\n}"
    ],
    [
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        double lB = CMAESOptimizer.this.getLowerBound()[i];\n        double uB = CMAESOptimizer.this.getUpperBound()[i];\n        if (x[i] < lB) \n        {\n            repaired[i] = lB;\n        } \n        else if (x[i] > uB) \n        {\n            repaired[i] = uB;\n        } \n        else \n        {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lowerBound[i]) {\n            repaired[i] = lowerBound[i];\n        } else if (x[i] > upperBound[i]) {\n            repaired[i] = upperBound[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        double lB = CMAESOptimizer.this.getLowerBound()[i];\n        double uB = CMAESOptimizer.this.getUpperBound()[i];\n        repaired[i] = (x[i] < lB) ? lB : (x[i] > uB) ? uB : x[i];\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    final double[] repaired = new double[x.length];\n\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        double lB = CMAESOptimizer.this.getLowerBound()[i];\n        double uB = CMAESOptimizer.this.getUpperBound()[i];\n        if (x[i] < lB) {\n            repaired[i] = lB;\n        } else if (x[i] > uB) {\n            repaired[i] = uB;\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) \n    {\n        double lB = CMAESOptimizer.this.getLowerBound()[i];\n        double uB = CMAESOptimizer.this.getUpperBound()[i];\n        repaired[i] = (x[i] < lB) ? lB : (x[i] > uB) ? uB : x[i];\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    final double[] lB = CMAESOptimizer.this.getLowerBound();\n    final double[] uB = CMAESOptimizer.this.getUpperBound();\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < lB[i]) {\n            repaired[i] = lB[i];\n        } else if (x[i] > uB[i]) {\n            repaired[i] = uB[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}",
      "private double[] repair(final double[] x)  {\n    double[] repaired = new double[x.length];\n    for (int i = 0; i < x.length; i++) {\n        if (x[i] < getLowerBound()[i]) {\n            repaired[i] = getLowerBound()[i];\n        } else if (x[i] > getUpperBound()[i]) {\n            repaired[i] = getUpperBound()[i];\n        } else {\n            repaired[i] = x[i];\n        }\n    }\n    return repaired;\n}"
    ],
    [
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    // transform the matrix to Schur form\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    matrixT = transformer.getT().getData();\n    matrixP = transformer.getP().getData();\n    cachedT = null;\n    cachedP = null;\n    cachedPt = null;\n\n    // transform matrix\n    transform();\n\n    // find eigenvalues\n    findEigenValuesFromSchur(transformer);\n\n    return transformer;\n}\n    }",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    // transform the matrix to Schur form\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    matrixT = transformer.getT().getData();\n    matrixP = transformer.getP().getData();\n    cachedT = null;\n    cachedP = null;\n    cachedPt = null;\n\n    // transform matrix\n    transform();\n\n    // calculate eigenvalues\n    calculateEigenvalues();\n\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n        // transform the matrix to Schur form\n        SchurTransformer schur = new SchurTransformer(matrix);\n        matrixT = schur.getT().getData();\n        matrixP = schur.getP().getData();\n        cachedT = null;\n        cachedP = null;\n        cachedPt = null;\n\n        // transform matrix\n        transform();\n\n        // find eigenvalues\n        findEigenValuesFromSchur(schur);\n\n        return schur;\n    }",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    // transform the matrix to tridiagonal\n    transformToTridiagonal(matrix);\n\n    // transform the tridiagonal matrix to Schur form\n    return new SchurTransformer(transformer.getT());\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n        // transform the matrix to Schur\n        SchurTransformer transformer = new SchurTransformer(matrix);\n        matrixT = transformer.getT().getData();\n        matrixP = transformer.getP().getData();\n        cachedT = null;\n        cachedP = null;\n        cachedPt = null;\n\n        // transform matrix\n        transform();\n\n        return transformer;\n    }",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    // transform the matrix to Schur form\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    matrixT = transformer.getT().getData();\n    matrixP = transformer.getP().getData();\n    cachedT = null;\n    cachedP = null;\n    cachedPt = null;\n\n    // transform matrix\n    transform();\n\n    // calculate eigenvalues\n    calculateEigenvalues();\n\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    // transform the matrix to Schur\n    SchurTransformer schur = new SchurTransformer(matrix);\n    matrixT = schur.getT().getData();\n    matrixP = schur.getP().getData();\n    cachedT = null;\n    cachedP = null;\n    cachedPt = null;\n\n    // transform matrix\n    transform();\n\n    // find eigenvalues\n    findEigenValuesFromSchur(schur);\n\n    return schur;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n    // transform the matrix to Schur\n    SchurTransformer transformer = new SchurTransformer(matrix);\n    matrixT = transformer.getT().getData();\n    matrixP = transformer.getP().getData();\n    cachedT = null;\n    cachedP = null;\n    cachedPt = null;\n\n    // transform matrix\n    transform();\n\n    return transformer;\n}",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n        // transform the matrix to Schur form\n        SchurTransformer transformer = new SchurTransformer(matrix);\n        matrixT = transformer.getT().getData();\n        matrixP = transformer.getP().getData();\n        cachedT = null;\n        cachedP = null;\n        cachedPt = null;\n\n        // transform matrix\n        transform();\n\n        // calculate eigenvalues\n        calculateEigenvalues();\n\n        return transformer;\n    }",
      "private SchurTransformer transformToSchur(final RealMatrix matrix)  throws MathArithmeticException {\n        // transform the matrix to tridiagonal\n        transformToTridiagonal(matrix);\n\n        // transform the matrix to Schur form\n        SchurTransformer schur = new SchurTransformer(matrixT);\n        matrixT = schur.getT().getData();\n        matrixP = schur.getP().getData();\n        cachedT = null;\n        cachedP = null;\n        cachedPt = null;\n\n        // find eigenvalues\n        findEigenValuesFromSchur(schur);\n\n        return schur;\n    }"
    ],
    [
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        final long value = values[i];\n        final E[] constants = enumClass.getEnumConstants();\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((value & 1L << j) != 0) {\n                result.add(constants[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = values.length - 1; i >= 0; i--) {\n        long value = values[i];\n        while (value != 0) {\n            final int index = (int) (value & Long.MAX_VALUE);\n            result.add(enumClass.getEnumConstants()[index]);\n            value >>>= Long.SIZE;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        while (value != 0) {\n            final int index = (int) (value & -value);\n            result.add(enumClass.getEnumConstants()[index + i * Long.SIZE]);\n            value &= value - 1;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        final long value = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((value & 1L << j) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        while (value != 0) {\n            final int index = (int) (value & -value);\n            result.add(enumClass.getEnumConstants()[index + i * Long.SIZE]);\n            value &= value - 1;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = values.length - 1; i >= 0; i--) {\n        final long value = values[i];\n        for (int j = Long.SIZE - 1; j >= 0; j--) {\n            if ((value & (1L << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[i * Long.SIZE + j]);\n            }\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = 0; i < values.length; i++) {\n        long value = values[i];\n        while (value != 0) {\n            final int index = (int) (value & (Long.SIZE - 1));\n            result.add(enumClass.getEnumConstants()[index + i * Long.SIZE]);\n            value >>>= Long.SIZE;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = values.length - 1; i >= 0; i--) {\n        long value = values[i];\n        while (value != 0) {\n            final int index = (int) (value & Long.MAX_VALUE);\n            result.add(enumClass.getEnumConstants()[index]);\n            value >>>= Long.SIZE;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = values.length - 1; i >= 0; i--) {\n        final long value = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((value & 1) == 1) {\n                result.add(enumClass.getEnumConstants()[(i * Long.SIZE + j)]);\n            }\n            value >>= 1;\n        }\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> EnumSet<E> processBitVectors(final Class<E> enumClass, long... values)  {\n    checkBitVectorable(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> result = EnumSet.noneOf(enumClass);\n    for (int i = values.length - 1; i >= 0; i--) {\n        final long value = values[i];\n        for (int j = 0; j < Long.SIZE; j++) {\n            if ((value & (1L << j)) != 0) {\n                result.add(enumClass.getEnumConstants()[((values.length - 1 - i) * Long.SIZE) + j]);\n            }\n        }\n    }\n    return result;\n}"
    ],
    [
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == getZone()) {\n            return oldInstant;\n        }\n        return newZone.convertLocalToUTC(getZone().convertUTCToLocal(oldInstant), false);\n    }",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localInstant = getZone().convertLocalToUTC(oldInstant, false);\n    return newZone.convertUTCToLocal(localInstant);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n        newZone = DateTimeUtils.getZone(newZone);\n        long localMillis = getZone().convertUTCToLocal(oldInstant);\n        return newZone.convertLocalToUTC(localMillis, false);\n    }",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    if (newZone == getZone()) {\n        return oldInstant;\n    }\n    return newZone.convertLocalToUTC(newZone.convertUTCToLocal(oldInstant), false);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    if (newZone == null) {\n        newZone = DateTimeZone.getDefault();\n    }\n    long localInstant = getZone().convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(localInstant, false);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == getZone()) {\n            return oldInstant;\n        }\n        \n        long localMillis = getZone().convertLocalToUTC(oldInstant, false);\n        return newZone.convertUTCToLocal(localMillis);\n    }",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n        newZone = DateTimeUtils.getZone(newZone);\n        if (newZone == getZone()) {\n            return oldInstant;\n        }\n        \n        long localMillis = getZone().convertUTCToLocal(oldInstant);\n        return newZone.convertLocalToUTC(localMillis, false);\n    }",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n    newZone = DateTimeUtils.getZone(newZone);\n    long localMillis = getZone().convertUTCToLocal(oldInstant);\n    return newZone.convertLocalToUTC(localMillis, false);\n}",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        long localInstant = getZone().convertLocalToUTC(oldInstant, false);\n        return newZone.convertUTCToLocal(localInstant);\n    }",
      "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant)  {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        long localMillis = getZone().convertUTCToLocal(oldInstant);\n        return newZone.convertLocalToUTC(localMillis, false);\n    }"
    ],
    [
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    calendar.set(unit.getCalendarField(), value);\n    calendar.add(unit.getCalendarField(), count);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    calendar.set(unit.getCalendarField(), value);\n    calendar.add(Calendar.MILLISECOND, -1);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count);\n    calendar.set(unit.getCalendarField(), value);\n    calendar.add(unit.getCalendarField(), 1);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count - 1) / count);\n    switch (unit.getCalendarField()) {\n        case Calendar.MILLISECOND:\n            calendar.set(Calendar.MILLISECOND, value);\n            break;\n        case Calendar.SECOND:\n            calendar.set(Calendar.SECOND, value);\n            break;\n        case Calendar.MINUTE:\n            calendar.set(Calendar.MINUTE, value);\n            break;\n        case Calendar.HOUR_OF_DAY:\n            calendar.set(Calendar.HOUR_OF_DAY, value);\n            break;\n        case Calendar.DAY_OF_MONTH:\n            calendar.set(Calendar.DAY_OF_MONTH, value);\n            break;\n        case Calendar.MONTH:\n            calendar.set(Calendar.MONTH, value);\n            break;\n        case Calendar.YEAR:\n            calendar.set(Calendar.YEAR, value);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Invalid calendar field.\");\n    }\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count - 1) / count);\n    calendar.set(unit.getCalendarField(), value);\n    calendar.set(Calendar.MILLISECOND, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.DAY_OF_MONTH, 1);\n    calendar.set(Calendar.MONTH, 0);\n    calendar.set(Calendar.YEAR, 1970);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n    calendar.set(unit.getCalendarField(), value);\n    calendar.set(Calendar.MILLISECOND, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.DAY_OF_MONTH, 1);\n    calendar.set(Calendar.MONTH, 0);\n    calendar.set(Calendar.YEAR, 1970);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count - 1) / count);\n    switch (unit.getCalendarField()) {\n        case Calendar.MILLISECOND:\n            calendar.set(Calendar.MILLISECOND, value);\n            break;\n        case Calendar.SECOND:\n            calendar.set(Calendar.SECOND, value);\n            break;\n        case Calendar.MINUTE:\n            calendar.set(Calendar.MINUTE, value);\n            break;\n        case Calendar.HOUR_OF_DAY:\n            calendar.set(Calendar.HOUR_OF_DAY, value);\n            break;\n        case Calendar.DAY_OF_MONTH:\n            calendar.set(Calendar.DAY_OF_MONTH, value);\n            break;\n        case Calendar.MONTH:\n            calendar.set(Calendar.MONTH, value);\n            break;\n        case Calendar.YEAR:\n            calendar.set(Calendar.YEAR, value);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unsupported calendar field.\");\n    }\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count - 1) / count);\n    switch (unit.getCalendarField()) {\n        case Calendar.MILLISECOND:\n            calendar.set(Calendar.MILLISECOND, value);\n            break;\n        case Calendar.SECOND:\n            calendar.set(Calendar.SECOND, value);\n            break;\n        case Calendar.MINUTE:\n            calendar.set(Calendar.MINUTE, value);\n            break;\n        case Calendar.HOUR_OF_DAY:\n            calendar.set(Calendar.HOUR_OF_DAY, value);\n            break;\n        case Calendar.DAY_OF_MONTH:\n            calendar.set(Calendar.DAY_OF_MONTH, value);\n            break;\n        case Calendar.MONTH:\n            calendar.set(Calendar.MONTH, value);\n            break;\n        case Calendar.YEAR:\n            calendar.set(Calendar.YEAR, value);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Invalid calendar field.\");\n    }\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * ((current + count - 1) / count);\n    calendar.set(unit.getCalendarField(), value);\n    calendar.set(Calendar.MILLISECOND, 0);\n    calendar.set(Calendar.SECOND, 0);\n    calendar.set(Calendar.MINUTE, 0);\n    calendar.set(Calendar.HOUR_OF_DAY, 0);\n    calendar.set(Calendar.DAY_OF_MONTH, 1);\n    calendar.set(Calendar.MONTH, 0);\n    calendar.set(Calendar.YEAR, 1970);\n    return calendar.getTime();\n}",
      "protected Date nextStandardDate(Date date, DateTickUnit unit)  {\n    int milliseconds;\n    int seconds;\n    int minutes;\n    int hours;\n    int days;\n    int months;\n    int years;\n\n    Calendar calendar = Calendar.getInstance(this.timeZone, this.locale);\n    calendar.setTime(date);\n    int count = unit.getMultiple();\n    int current = calendar.get(unit.getCalendarField());\n    int value = count * (current / count) + count;\n    switch (unit.getCalendarField()) {\n        case Calendar.MILLISECOND:\n            milliseconds = value;\n            seconds = calendar.get(Calendar.SECOND);\n            minutes = calendar.get(Calendar.MINUTE);\n            hours = calendar.get(Calendar.HOUR_OF_DAY);\n            days = calendar.get(Calendar.DAY_OF_MONTH);\n            months = calendar.get(Calendar.MONTH);\n            years = calendar.get(Calendar.YEAR);\n            break;\n        case Calendar.SECOND:\n            milliseconds = 0;\n            seconds = value;\n            minutes = calendar.get(Calendar.MINUTE);\n            hours = calendar.get(Calendar.HOUR_OF_DAY);\n            days = calendar.get(Calendar.DAY_OF_MONTH);\n            months = calendar.get(Calendar.MONTH);\n            years = calendar.get(Calendar.YEAR);\n            break;\n        case Calendar.MINUTE:\n            milliseconds = 0;\n            seconds = 0;\n            minutes = value;\n            hours = calendar.get(Calendar.HOUR_OF_DAY);\n            days = calendar.get(Calendar.DAY_OF_MONTH);\n            months = calendar.get(Calendar.MONTH);\n            years = calendar.get(Calendar.YEAR);\n            break;\n        case Calendar.HOUR_OF_DAY:\n            milliseconds = 0;\n            seconds = 0;\n            minutes = 0;\n            hours = value;\n}\n}"
    ],
    [
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n        if (variableResolver != null) {\n            return variableResolver.lookup(variableName);\n        }\n        return null;\n    }",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n        if (variableResolver != null) {\n            return variableResolver.lookup(variableName);\n        }\n        return null;\n    }",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver != null) {\n        return variableResolver.lookup(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n        return getVariableResolver().lookup(variableName);\n    }",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver != null) {\n        return variableResolver.lookup(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n        if (variableResolver != null) {\n            return variableResolver.lookup(variableName);\n        }\n        return null;\n    }",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    return variableResolver != null ? variableResolver.lookup(variableName) : null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver != null) {\n        return variableResolver.lookup(variableName);\n    }\n    return null;\n}",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n        if (variableResolver != null) {\n            return variableResolver.lookup(variableName);\n        }\n        return null;\n    }",
      "protected String resolveVariable(final String variableName, final StrBuilder buf, final int startPos, final int endPos)  {\n    if (variableResolver != null) {\n        return variableResolver.lookup(variableName);\n    }\n    return null;\n}"
    ],
    [
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    str = str.toUpperCase(Locale.ENGLISH);\n    final StringBuilder sx = new StringBuilder();\n    sx.append(str.charAt(0));\n    char last = ' ';\n    for (int i = 1; i < str.length(); i++) \n    {\n        final char c = str.charAt(i);\n        final char mapped = map(c);\n        if (mapped != ' ' && mapped != last) \n        {\n            sx.append(mapped);\n            last = mapped;\n        }\n    }\n    while (sx.length() < 4) \n    {\n        sx.append('0');\n    }\n    return sx.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase(Locale.ENGLISH);\n    final char firstChar = str.charAt(0);\n    final StringBuilder sb = new StringBuilder(SOUNDEX_LENGTH);\n    sb.append(firstChar);\n    char lastDigit = '0';\n    for (int i = 1; i < str.length() && sb.length() < SOUNDEX_LENGTH; i++) {\n        final char currentChar = str.charAt(i);\n        final char digit = getSoundexDigit(currentChar);\n        if (digit != '0' && digit != lastDigit) {\n            sb.append(digit);\n            lastDigit = digit;\n        }\n    }\n    while (sb.length() < SOUNDEX_LENGTH) {\n        sb.append('0');\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase(Locale.ENGLISH);\n    final StringBuilder sb = new StringBuilder();\n    sb.append(str.charAt(0));\n    char lastChar = str.charAt(0);\n    for (int i = 1; i < str.length(); i++) {\n        final char c = str.charAt(i);\n        if (contains(SOUNDEX_MAPPING, c)) {\n            if (!c.equals(lastChar)) {\n                sb.append(c);\n            }\n            lastChar = c;\n        } else {\n            throw new IllegalArgumentException(\"Character '\" + c + \"' is not mapped\");\n        }\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    str = str.toUpperCase(Locale.ENGLISH);\n    final StringBuilder sb = new StringBuilder();\n    sb.append(str.charAt(0));\n    char last = SOUNDEX_MAP.get(str.charAt(0));\n    for (int i = 1; i < str.length(); i++) \n    {\n        final char c = str.charAt(i);\n        final char mapped = SOUNDEX_MAP.get(c);\n        if (mapped != '0' && mapped != last) \n        {\n            sb.append(mapped);\n        }\n        last = mapped;\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase(Locale.ENGLISH);\n    final StringBuilder sb = new StringBuilder(4);\n    sb.append(str.charAt(0));\n    char lastChar = str.charAt(0);\n    int loc = 1;\n    while (loc < str.length()) {\n        char c = str.charAt(loc);\n        if (contains(SOUND_EX_MAPPING, c)) {\n            char mappedChar = SOUND_EX_MAPPING.charAt(c - 'A');\n            if (mappedChar != lastChar) {\n                sb.append(mappedChar);\n                lastChar = mappedChar;\n            }\n        } else {\n            throw new IllegalArgumentException(\"Invalid character for Soundex: \" + c);\n        }\n        loc++;\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    if (str.length() == 0) \n    {\n        return str;\n    }\n    str = str.toUpperCase(Locale.ENGLISH);\n    char firstChar = str.charAt(0);\n    StringBuilder encoded = new StringBuilder(8);\n    encoded.append(firstChar);\n    int lastAppendPos = 0;\n    for (int i = 1; i < str.length(); i++) \n    {\n        char c = str.charAt(i);\n        int soundexChar = getSoundexChar(c);\n        if (soundexChar != -1) \n        {\n            if (soundexChar != lastAppendPos) \n            {\n                encoded.append(soundexChar);\n                lastAppendPos = soundexChar;\n            }\n        } \n        else \n        {\n            throw new IllegalArgumentException(\"Illegal character: \" + c);\n        }\n    }\n    if (encoded.length() == 1) \n    {\n        encoded.append('0');\n    }\n    return encoded.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    str = str.toUpperCase();\n    final StringBuilder sb = new StringBuilder();\n    sb.append(str.charAt(0));\n    char last = Soundex.CODE_FOR_SILENT_LETTER;\n    for (int i = 1; i < str.length(); i++) \n    {\n        final char c = str.charAt(i);\n        final char code = Soundex.getCode(c);\n        if (code != Soundex.CODE_FOR_SILENT_LETTER && code != last) \n        {\n            sb.append(code);\n        }\n        last = code;\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase(Locale.ENGLISH);\n    final StringBuilder sx = new StringBuilder();\n    sx.append(str.charAt(0));\n    char last = SOUNDEX_MAP[str.charAt(0) - 'A'];\n    for (int i = 1; i < str.length(); i++) {\n        final char current = SOUNDEX_MAP[str.charAt(i) - 'A'];\n        if (current != last && current != '0') {\n            sx.append(current);\n        }\n        last = current;\n    }\n    while (sx.length() < SOUNDEX_LENGTH) {\n        sx.append('0');\n    }\n    return sx.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) {\n        return null;\n    }\n    str = str.toUpperCase(Locale.ENGLISH);\n    final char[] chars = str.toCharArray();\n    final StringBuilder sb = new StringBuilder(chars[0]);\n    final char[] encoded = new char[chars.length];\n    encoded[0] = chars[0];\n    for (int i = 1; i < chars.length; i++) {\n        final char c = chars[i];\n        if (contains(SOUNDEX_MAPPING, c)) {\n            encoded[i] = c;\n        } else {\n            encoded[i] = '0';\n        }\n    }\n    for (int i = 1; i < encoded.length; i++) {\n        if (encoded[i] != '0') {\n            if (!encoded[i].equals(encoded[i - 1])) {\n                sb.append(encoded[i]);\n            }\n        }\n    }\n    return sb.toString();\n}",
      "public String soundex(String str)  {\n    if (str == null) \n    {\n        return null;\n    }\n    str = str.toUpperCase(Locale.ENGLISH);\n    if (str.length() == 0) \n    {\n        return str;\n    }\n    final StringBuilder sb = new StringBuilder();\n    sb.append(str.charAt(0));\n    char last = SoundexUtils.map(str.charAt(0));\n    for (int i = 1; i < str.length(); i++) \n    {\n        final char current = SoundexUtils.map(str.charAt(i));\n        if (current != SoundexUtils.NONE && current != last) \n        {\n            sb.append(current);\n        }\n        last = current;\n    }\n    return sb.toString();\n}"
    ],
    [
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_STRING) {\n        return _stringType;\n    }\n    if (clz == CLASS_INTEGER) {\n        return _intType;\n    }\n    if (clz == CLASS_LONG) {\n        return _longType;\n    }\n    if (clz == CLASS_DOUBLE) {\n        return _doubleType;\n    }\n    if (clz == CLASS_BOOLEAN) {\n        return _booleanType;\n    }\n    if (clz == CLASS_OBJECT) {\n        return _objectType;\n    }\n    if (clz == CLASS_CHAR_SEQUENCE) {\n        return _charSequenceType;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_STRING) {\n        return _stringType;\n    }\n    if (clz == CLASS_OBJECT) {\n        return _objectType;\n    }\n    if (clz == CLASS_BOOLEAN) {\n        return _booleanType;\n    }\n    if (clz == CLASS_INTEGER) {\n        return _intType;\n    }\n    if (clz == CLASS_LONG) {\n        return _longType;\n    }\n    if (clz == CLASS_DOUBLE) {\n        return _doubleType;\n    }\n    if (clz == CLASS_CHAR_SEQUENCE) {\n        return _charSequenceType;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_STRING) {\n        return _stringType;\n    }\n    if (clz == CLASS_INTEGER) {\n        return _intType;\n    }\n    if (clz == CLASS_LONG) {\n        return _longType;\n    }\n    if (clz == CLASS_DOUBLE) {\n        return _doubleType;\n    }\n    if (clz == CLASS_BOOLEAN) {\n        return _booleanType;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_STRING) {\n        return _stringType;\n    }\n    if (clz == CLASS_INTEGER) {\n        return _intType;\n    }\n    if (clz == CLASS_LONG) {\n        return _longType;\n    }\n    if (clz == CLASS_DOUBLE) {\n        return _doubleType;\n    }\n    if (clz == CLASS_BOOLEAN) {\n        return _booleanType;\n    }\n    if (clz == CLASS_DATE) {\n        return _dateType;\n    }\n    if (clz == CLASS_UUID) {\n        return _uuidType;\n    }\n    if (clz == CLASS_LOCALE) {\n        return _localeType;\n    }\n    if (clz == CLASS_CLASS) {\n        return _classType;\n    }\n    if (clz == CLASS_OBJECT) {\n        return _objectType;\n    }\n    if (clz == CLASS_ENUM) {\n        return _enumType;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_OBJECT) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_STRING || clz == CLASS_CHAR_SEQUENCE) {\n        return TypeFactory.simpleType(String.class);\n    }\n    if (clz == CLASS_ITERABLE) {\n        return TypeFactory.simpleType(Iterable.class);\n    }\n    if (clz == CLASS_MAP_ENTRY) {\n        return TypeFactory.simpleType(Map.Entry.class);\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // First, check if we have a pre-defined mapping:\n    JavaType type = _findWellKnownSimple(clz);\n    if (type != null) {\n        return type;\n    }\n    // Then, check if it's a well-known abstract type\n    type = _findWellKnownAbstract(clz);\n    if (type != null) {\n        return type;\n    }\n    // And finally, if it's a concrete type, we can try to find\n    // a concrete type mapping.\n    if (ClassUtil.isConcrete(clz)) {\n        type = _findWellKnownConcrete(clz);\n    }\n    return type;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // 21-Mar-2016, tatu: As per [databind#1759], need to handle \"boxed\" types\n    //    as well, since they are often used interchangeably.\n    if (clz.isPrimitive()) {\n        clz = ClassUtil.boxType(clz);\n    }\n    if (clz == CLASS_OBJECT) {\n        return TypeFactory.unknownType();\n    }\n    if (clz == CLASS_STRING) {\n        return TypeFactory.defaultInstance().constructType(String.class);\n    }\n    if (clz == CLASS_BOOLEAN) {\n        return TypeFactory.defaultInstance().constructType(Boolean.class);\n    }\n    if (clz == CLASS_INTEGER) {\n        return TypeFactory.defaultInstance().constructType(Integer.class);\n    }\n    if (clz == CLASS_LONG) {\n        return TypeFactory.defaultInstance().constructType(Long.class);\n    }\n    if (clz == CLASS_DOUBLE) {\n        return TypeFactory.defaultInstance().constructType(Double.class);\n    }\n    if (clz == CLASS_CHAR_SEQUENCE) {\n        return TypeFactory.defaultInstance().constructType(CharSequence.class);\n    }\n    if (clz == CLASS_NUMBER) {\n        return TypeFactory.defaultInstance().constructType(Number.class);\n    }\n    if (clz == CLASS_DATE) {\n        return TypeFactory.defaultInstance().constructType(Date.class);\n    }\n    if (clz == CLASS_URL) {\n        return TypeFactory.defaultInstance().constructType(URL.class);\n    }\n    if (clz == CLASS_URI) {\n        return TypeFactory.defaultInstance().constructType(URI.class);\n    }\n    if (clz == CLASS_UUID) {\n        return TypeFactory.defaultInstance().constructType(UUID.class);\n    }\n    if (clz == CLASS_CLASS) {\n        return TypeFactory.defaultInstance().constructType(Class.class);\n    }\n    if (clz == CLASS_FILE) {\n}\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    // 07-Dec-2015, tatu: As per [databind#1405] need to consider\n    //    all \"known\" types, not just the ones that are explicitly\n    //    registered.\n    if (clz == String.class) {\n        return _stringType;\n    }\n    if (clz == Integer.class) {\n        return _intType;\n    }\n    if (clz == Long.class) {\n        return _longType;\n    }\n    if (clz == Double.class) {\n        return _doubleType;\n    }\n    if (clz == Boolean.class) {\n        return _booleanType;\n    }\n    if (clz == BigDecimal.class) {\n        return _bigDecimalType;\n    }\n    if (clz == BigInteger.class) {\n        return _bigIntType;\n    }\n    if (clz == Date.class) {\n        return _dateType;\n    }\n    if (clz == Calendar.class) {\n        return _calendarType;\n    }\n    if (clz == UUID.class) {\n        return _uuidType;\n    }\n    if (clz == Locale.class) {\n        return _localeType;\n    }\n    if (clz == Currency.class) {\n        return _currencyType;\n    }\n    if (clz == TimeZone.class) {\n        return _timeZoneType;\n    }\n    if (clz == Character.class) {\n        return _charType;\n    }\n    if (clz == Byte.class) {\n        return _byteType;\n    }\n    if (clz == Short.class) {\n        return _shortType;\n    }\n    if (clz == Float.class) {\n        return _floatType;\n    }\n    if (clz == Class.class) {\n        return _classType;\n    }\n    if (clz == URI.class) {\n        return _uriType;\n    }\n    if (clz == URL.class) {\n        return _urlType;\n    }\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_STRING) {\n        return _stringType;\n    }\n    if (clz == CLASS_OBJECT) {\n        return _objectType;\n    }\n    if (clz == CLASS_INTEGER) {\n        return _intType;\n    }\n    if (clz == CLASS_LONG) {\n        return _longType;\n    }\n    if (clz == CLASS_DOUBLE) {\n        return _doubleType;\n    }\n    if (clz == CLASS_BOOLEAN) {\n        return _booleanType;\n    }\n    if (clz == CLASS_DATE) {\n        return _dateType;\n    }\n    if (clz == CLASS_URI) {\n        return _uriType;\n    }\n    if (clz == CLASS_URL) {\n        return _urlType;\n    }\n    if (clz == CLASS_LOCALE) {\n        return _localeType;\n    }\n    if (clz == CLASS_TIMEZONE) {\n        return _timeZoneType;\n    }\n    if (clz == CLASS_CLASS) {\n        return _classType;\n    }\n    return null;\n}",
      "protected JavaType _findWellKnownSimple(Class<?> clz)  {\n    if (clz == CLASS_STRING) {\n        return _stringType;\n    }\n    if (clz == CLASS_CHAR_SEQUENCE) {\n        return _stringType;\n    }\n    if (clz == CLASS_BIG_INTEGER) {\n        return _bigIntType;\n    }\n    if (clz == CLASS_BIG_DECIMAL) {\n        return _bigDecType;\n    }\n    if (clz == CLASS_DATE) {\n        return _dateType;\n    }\n    if (clz == CLASS_TIMESTAMP) {\n        return _tsType;\n    }\n    if (clz == CLASS_URL) {\n        return _urlType;\n    }\n    if (clz == CLASS_URI) {\n        return _uriType;\n    }\n    if (clz == CLASS_UUID) {\n        return _uuidType;\n    }\n    if (clz == CLASS_LOCALE) {\n        return _localeType;\n    }\n    if (clz == CLASS_CLASS) {\n        return _classType;\n    }\n    if (clz == CLASS_OBJECT) {\n        return _objectType;\n    }\n    if (clz == CLASS_ENUM) {\n        return _enumType;\n    }\n    return null;\n}"
    ],
    [
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign()) \n    {\n        Node lhs = n.getFirstChild();\n        if (lhs.isGetProp()) \n        {\n            Node prop = lhs.getLastChild();\n            Node obj = lhs.getFirstChild();\n            if (obj.isThis()) \n            {\n                return new PrototypeMemberDeclaration(prop.getString(), n.getLastChild());\n            }\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign()) {\n        Node lhs = n.getFirstChild();\n        if (lhs.isGetProp() && lhs.getFirstChild().isThis()) {\n            Node rhs = n.getLastChild();\n            if (rhs.isName() &&\n                rhs.getString().equals(paramNode.getString())) {\n                Node propertyName = lhs.getLastChild();\n                return new PrototypeMemberDeclaration(propertyName);\n            }\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign()) {\n        Node lhs = n.getFirstChild();\n        if (lhs.isGetProp()) {\n            Node obj = lhs.getFirstChild();\n            if (obj.isThis()) {\n                return new PrototypeMemberDeclaration(lhs.getLastChild().getString(), n.getLastChild());\n            }\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign()) {\n        Node lhs = n.getFirstChild();\n        if (lhs.isGetProp()) {\n            Node obj = lhs.getFirstChild();\n            if (obj.isThis()) {\n                Node prop = lhs.getLastChild();\n                return new PrototypeMemberDeclaration(prop.getString(), n.getLastChild());\n            }\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign()) {\n        Node lhs = n.getFirstChild();\n        if (lhs.isGetProp() && lhs.getFirstChild().isThis()) {\n            Node rhs = n.getLastChild();\n            if (rhs.isName() &&\n                rhs.getString().equals(paramNode.getString())) {\n                Node propertyName = lhs.getLastChild();\n                return new PrototypeMemberDeclaration(propertyName);\n            }\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign()) {\n        Node lhs = n.getFirstChild();\n        if (lhs.isGetProp() && lhs.getFirstChild().isThis()) {\n            Node rhs = n.getLastChild();\n            if (rhs.isName() && rhs.getString().equals(n.getString())) {\n                Node propertyName = lhs.getLastChild();\n                return new PrototypeMemberDeclaration(propertyName, rhs);\n            }\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign()) {\n        Node lhs = n.getFirstChild();\n        if (lhs.isGetProp()) {\n            Node obj = lhs.getFirstChild();\n            if (obj.isThis()) {\n                return new PrototypeMemberDeclaration(lhs.getLastChild().getString(), n.getLastChild());\n            }\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign()) \n    {\n        Node lhs = n.getFirstChild();\n        if (lhs.isGetProp()) \n        {\n            Node obj = lhs.getFirstChild();\n            if (obj.isThis()) \n            {\n                String propName = lhs.getLastChild().getString();\n                Node rhs = n.getLastChild();\n                if (rhs.isFunction()) \n                {\n                    return new PrototypeMemberDeclaration(propName, rhs);\n                }\n            }\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign()) {\n        Node lhs = n.getFirstChild();\n        if (lhs.isGetProp()) {\n            Node obj = lhs.getFirstChild();\n            if (obj.isThis()) {\n                Node prop = lhs.getLastChild();\n                Node rhs = n.getLastChild();\n                return new PrototypeMemberDeclaration(prop.getString(), rhs);\n            }\n        }\n    }\n    return null;\n}",
      "private static PrototypeMemberDeclaration extractDeclaration(Node n)  {\n    if (n.isAssign()) \n    {\n        Node lhs = n.getFirstChild();\n        if (lhs.isGetProp() && lhs.getFirstChild().isThis()) \n        {\n            Node rhs = n.getLastChild();\n            if (rhs.isName() && rhs.getString().equals(n.getString())) \n            {\n                Node propertyName = lhs.getLastChild();\n                return new PrototypeMemberDeclaration(propertyName, rhs);\n            }\n        }\n    }\n    return null;\n}"
    ],
    [
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rows = mat.getRowDimension();\n    final int cols = mat.getColumnDimension();\n    final double[][] data = new double[rows * n][cols * m];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            for (int r = 0; r < n; r++) {\n                for (int c = 0; c < m; c++) {\n                    data[i + r * rows][j + c * cols] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    final int rows = mat.getRowDimension();\n    final int cols = mat.getColumnDimension();\n    final double[][] data = new double[rows * n][cols * m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int r = 0; r < rows; r++) {\n                for (int c = 0; c < cols; c++) {\n                    data[i * rows + r][j * cols + c] = mat.getEntry(r, c);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    double[][] d = new double[mat.getRowDimension()*n][mat.getColumnDimension()*m];\n    for (int i = 0; i < mat.getRowDimension(); i++) {\n        for (int j = 0; j < mat.getColumnDimension(); j++) {\n            for (int r = 0; r < n; r++) {\n                for (int c = 0; c < m; c++) {\n                    d[i*n+r][j*m+c] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    double[][] d = new double[mat.getRowDimension() * n][mat.getColumnDimension() * m];\n    for (int i = 0; i < mat.getRowDimension(); i++) {\n        for (int j = 0; j < mat.getColumnDimension(); j++) {\n            for (int r = 0; r < n; r++) {\n                for (int c = 0; c < m; c++) {\n                    d[i * n + r][j * m + c] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(d, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int row = mat.getRowDimension();\n    int col = mat.getColumnDimension();\n    double[][] result = new double[row*n][col*m];\n    for(int i=0; i<row; i++)\n    {\n        for(int j=0; j<col; j++)\n        {\n            for(int k=0; k<n; k++)\n            {\n                for(int l=0; l<m; l++)\n                {\n                    result[i*n+k][j*m+l] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(result);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    double[][] d = mat.getData();\n    double[][] rep = new double[n * d.length][m * d[0].length];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int k = 0; k < d.length; k++) {\n                for (int l = 0; l < d[0].length; l++) {\n                    rep[i * d.length + k][j * d[0].length + l] = d[k][l];\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(rep, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    double[][] data = new double[n * rows][m * cols];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int k = 0; k < rows; k++) {\n                for (int l = 0; l < cols; l++) {\n                    data[i * rows + k][j * cols + l] = mat.getEntry(k, l);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    double[][] data = new double[rows * n][cols * m];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            for (int k = 0; k < n; k++) {\n                for (int l = 0; l < m; l++) {\n                    data[i + k * rows][j + l * cols] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    double[][] data = new double[rows * n][cols * m];\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            for (int r = 0; r < n; r++) {\n                for (int c = 0; c < m; c++) {\n                    data[i + r * rows][j + c * cols] = mat.getEntry(i, j);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(data, false);\n}",
      "private static RealMatrix repmat(final RealMatrix mat, int n, int m)  {\n    int rows = mat.getRowDimension();\n    int cols = mat.getColumnDimension();\n    double[][] result = new double[rows * n][cols * m];\n    for (int i = 0; i < n; i++) \n    {\n        for (int j = 0; j < m; j++) \n        {\n            for (int k = 0; k < rows; k++) \n            {\n                for (int l = 0; l < cols; l++) \n                {\n                    result[i * rows + k][j * cols + l] = mat.getEntry(k, l);\n                }\n            }\n        }\n    }\n    return new Array2DRowRealMatrix(result, false);\n}"
    ],
    [
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}",
      "public Node getNotLarger(final T reference)  {\n    Node candidate = null;\n    for (Node node = top; node != null;) \n    {\n        if (node.element.compareTo(reference) > 0) \n        {\n            if (node.left == null) \n            {\n                return candidate;\n            }\n            node = node.left;\n        } \n        else \n        {\n            candidate = node;\n            if (node.right == null) \n            {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}"
    ],
    [
      "private long getBytesInflated()  {\n    return Math.min(current.bytesReadFromStream,\n                    current.entry.getCompressedSize());\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesInflated();\n    if (bytesInflated < current.bytesReadFromStream) {\n        bytesInflated += (1L << 32);\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    return (long) Math.min(current.entry.getCompressedSize(), current.bytesReadFromStream) - inf.getBytesInflated();\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesInflated();\n    if (bytesInflated < current.bytesReadFromStream) {\n        bytesInflated += Integer.MAX_VALUE;\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    return Math.min(current.bytesReadFromStream, Integer.MAX_VALUE);\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesInflated();\n    if (bytesInflated < current.bytesReadFromStream) {\n        bytesInflated += (1L << 32);\n    }\n    return bytesInflated;\n}",
      "private long getBytesInflated()  {\n    if (inf.finished()) \n    {\n        return inf.getTotalIn();\n    } \n    else \n    {\n        return Math.min(inf.getTotalIn(), current.bytesReadFromStream);\n    }\n}",
      "private long getBytesInflated()  {\n    if (inflater != null) \n    {\n        return Math.min(inflater.getBytesRead(), inflater.getBytesWritten());\n    }\n    return 0;\n}",
      "private long getBytesInflated()  {\n    if (inflater.getBytesInflated() < (inflater.getBytesRead() - lastReadBytes)) \n    {\n        return inflater.getBytesInflated() + (inflater.getBytesRead() - lastReadBytes);\n    } \n    else \n    {\n        return inflater.getBytesInflated();\n    }\n}",
      "private long getBytesInflated()  {\n    long bytesInflated = inf.getBytesInflated();\n    if (bytesInflated < current.bytesReadFromStream)\n    {\n        bytesInflated += (current.bytesReadFromStream - bytesInflated)\n                         % (1L << 32);\n    }\n    return bytesInflated;\n}"
    ],
    [
      "public static boolean sizeIsEmpty(final Object object)  if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  {\n    if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}",
      "public static boolean sizeIsEmpty(final Object object)  if (object == null) {\n        return true;\n    }\n    if (object instanceof Map<?,?>) {\n        return ((Map<?, ?>) object).isEmpty();\n    } else if (object instanceof Collection<?>) {\n        return ((Collection<?>) object).isEmpty();\n    } else if (object instanceof Iterable<?>) {\n        return IterableUtils.isEmpty((Iterable<?>) object);\n    } else if (object instanceof Object[]) {\n        return ((Object[]) object).length == 0;\n    } else if (object instanceof Iterator<?>) {\n        return !((Iterator<?>) object).hasNext();\n    } else if (object instanceof Enumeration<?>) {\n        return !((Enumeration<?>) object).hasMoreElements();\n    } else {\n        try {\n            return Array.getLength(object) == 0;\n        } catch (final IllegalArgumentException ex) {\n            throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n        }\n    }\n}"
    ],
    [
      "public static boolean isValidQualifiedName(String name)  {\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n  // so that the results are different for es5 and es3.\n  // TODO(nicksantos): This should be moved into a \"Language\" API,\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name) && !name.isEmpty();\n  }\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n    // so that the results are different for es5 and es3.\n    // TODO(nicksantos): This should be moved into a \"Language\" API,\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name) && !name.isEmpty();\n  }\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n  }\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name) || isValidPropertyName(name);\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n  }\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name);\n  }\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name) && !name.isEmpty();\n  }\n}",
      "public static boolean isValidQualifiedName(String name)  {\n    return isValidSimpleName(name) ||\n        (name.length() > 1 &&\n         name.charAt(0) == '.' &&\n         isValidQualifiedName(name.substring(1)));\n  }\n}"
    ],
    [
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = il;\n    double p = matrixT[il][il];\n    double q = matrixT[il + 1][il];\n    double r = matrixT[il + 2][il];\n    double s = p + q + r;\n    double t = p - s;\n    double u = q - s;\n    double v = r - s;\n    double w = FastMath.sqrt(t * t + u * u + v * v);\n    if (t >= 0.0) {\n        w = -w;\n    }\n    hVec[0] = t + w;\n    hVec[1] = u + w;\n    hVec[2] = v + w;\n    if (FastMath.abs(hVec[0]) > FastMath.abs(hVec[1]) && FastMath.abs(hVec[0]) > FastMath.abs(hVec[2])) {\n        im = il + 1;\n        p = matrixT[il][il + 1];\n        q = matrixT[il + 1][il + 1];\n        r = matrixT[il + 2][il + 1];\n    } else if (FastMath.abs(hVec[1]) > FastMath.abs(hVec[2])) {\n        im = il + 2;\n        p = matrixT[il][il + 2];\n        q = matrixT[il + 1][il + 2];\n        r = matrixT[il + 2][il + 2];\n    }\n    shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n    if (!Precision.equals(shift.x, 0.0, epsilon)) {\n        p = p / shift.x;\n        q = q / shift.x;\n        r = r / shift.x;\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = matrixT[il][il];\n    double q = matrixT[il + 1][il];\n    double r = matrixT[il + 2][il];\n\n    shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n    if (!Precision.equals(shift.x, 0.0, epsilon)) {\n        p = p / shift.x;\n        q = q / shift.x;\n        r = r / shift.x;\n    }\n\n    hVec[0] = p;\n    hVec[1] = q;\n    hVec[2] = r;\n\n    return il + 1;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = il;\n    double p = matrixT[il][il];\n    double q = matrixT[il + 1][il];\n    double r = matrixT[il + 2][il];\n    double t = matrixT[il + 3][il];\n    double s = FastMath.sqrt(p * p + q * q + r * r + t * t);\n    if (s == 0.0) {\n        return im;\n    }\n    p = p / s;\n    q = q / s;\n    r = r / s;\n    t = t / s;\n    shift.x = p + shift.x;\n    shift.y = q + shift.y;\n    shift.z = r + shift.z;\n    shift.w = t + shift.w;\n    hVec[0] = p;\n    hVec[1] = q;\n    hVec[2] = r;\n    hVec[3] = t;\n    if (p < 0.0) {\n        im = im + 1;\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = matrixT[iu][iu];\n    double q = matrixT[iu - 1][iu];\n    double r = matrixT[iu - 2][iu];\n    double s = matrixT[iu - 2][iu - 1];\n\n    shift.x = FastMath.abs(s) + FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n    if (!Precision.equals(shift.x, 0.0, epsilon)) {\n        p = p / shift.x;\n        q = q / shift.x;\n        r = r / shift.x;\n        s = s / shift.x;\n    }\n\n    double z = FastMath.sqrt(p * p + q * q + r * r + s * s);\n    if (p >= 0.0) {\n        z = p + z;\n    } else {\n        z = p - z;\n    }\n\n    hVec[0] = z;\n    hVec[1] = q;\n    hVec[2] = r;\n    hVec[3] = s;\n\n    return il;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = il;\n    if (il < iu - 1) {\n        double p = matrixT[il][il];\n        double q = matrixT[il + 1][il];\n        double r = matrixT[il + 2][il];\n        shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n        if (!Precision.equals(shift.x, 0.0, epsilon)) {\n            p = p / shift.x;\n            q = q / shift.x;\n            r = r / shift.x;\n        }\n        if (shift.x == 0.0) {\n            im = il + 1;\n        } else {\n            hVec[0] = p;\n            hVec[1] = q;\n            hVec[2] = r;\n        }\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    final int n = matrixT.length;\n    double p = matrixT[iu][iu - 1];\n    double q = matrixT[iu + 1][iu - 1];\n    double r = (iu + 2 < n) ? matrixT[iu + 2][iu - 1] : 0.0;\n    shift.x = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n    if (!Precision.equals(shift.x, 0.0, epsilon)) {\n        p = p / shift.x;\n        q = q / shift.x;\n        r = r / shift.x;\n    }\n    double s = FastMath.sqrt(p * p + q * q + r * r);\n    if (p < 0.0) {\n        s = -s;\n    }\n    if (s != 0.0) {\n        p = p + s;\n        shift.x = p / s;\n        shift.y = q / s;\n        double z = r / s;\n        q = q / p;\n        r = r / p;\n\n        // Row modification\n        for (int j = iu - 1; j < n; j++) {\n            double[] row = matrixT[j];\n            double t = row[iu - 1];\n            row[iu - 1] = q * t + p * row[iu];\n            row[iu] = q * row[iu] - p * t;\n        }\n\n        // Column modification\n        for (int i = 0; i <= iu; i++) {\n            double[] col = matrixT[i];\n            double t = col[iu - 1];\n            col[iu - 1] = q * t + p * col[iu];\n            col[iu] = q * col[iu] - p * t;\n        }\n\n        // Accumulate transformations\n        for (int i = 0; i <= n - 1; i++) {\n            double[] row = matrixP[i];\n            double t = row[iu - 1];\n}\n}\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = il;\n    double p = matrixT[il][il];\n    double q = matrixT[il + 1][il];\n    double r = matrixT[il + 2][il];\n    double s = FastMath.abs(p) + FastMath.abs(q) + FastMath.abs(r);\n    if (s == 0.0) {\n        // No transformation needed\n        return im;\n    }\n    p = p / s;\n    q = q / s;\n    r = r / s;\n    hVec[0] = p;\n    hVec[1] = q;\n    hVec[2] = r;\n    shift.x = p * p + q * q + r * r;\n    shift.y = 0.0;\n    shift.z = 0.0;\n    double tau = FastMath.sqrt(shift.x * shift.x + shift.y * shift.y + shift.z * shift.z);\n    if (tau == 0.0) {\n        // No transformation needed\n        return im;\n    }\n    tau = 1.0 / tau;\n    shift.x = shift.x * tau;\n    shift.y = shift.y * tau;\n    shift.z = shift.z * tau;\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = il;\n    if (il < iu - 1) {\n        final double x = matrixT[il][il];\n        final double y = matrixT[il + 1][il];\n        final double z = matrixT[il + 2][il];\n        final double s = FastMath.abs(x) + FastMath.abs(y) + FastMath.abs(z);\n        if (!Precision.equals(s, 0.0, epsilon)) {\n            hVec[0] = x / s;\n            hVec[1] = y / s;\n            hVec[2] = z / s;\n        } else {\n            hVec[0] = 1.0;\n            hVec[1] = 0.0;\n            hVec[2] = 0.0;\n        }\n        im = il + 1;\n    } else {\n        hVec[0] = 1.0;\n        hVec[1] = 0.0;\n        hVec[2] = 0.0;\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = il;\n    double p = matrixT[il][il];\n    double q = matrixT[il + 1][il];\n    double r = matrixT[il + 2][il];\n    double s = p * p + q * q + r * r;\n    if (s == 0.0) {\n        im++;\n    } else {\n        shift.x = FastMath.sqrt(s);\n        if (p >= 0.0) {\n            shift.x = p + shift.x;\n        } else {\n            shift.x = p - shift.x;\n        }\n        final double x = matrixT[iu][iu - 1];\n        final double t = FastMath.abs(x) + FastMath.abs(shift.x);\n        p = x / t;\n        q = shift.x / t;\n        final double u = FastMath.sqrt(p * p + q * q);\n        p = p / u;\n        q = q / u;\n        hVec[0] = p;\n        hVec[1] = q;\n        hVec[2] = r;\n    }\n    return im;\n}",
      "private int initQRStep(int il, final int iu, final ShiftInfo shift, double[] hVec)  {\n    int im = il;\n    if (il == iu) {\n        // Single element\n        hVec[0] = matrixT[iu][iu];\n        hVec[1] = 0.0;\n        hVec[2] = 0.0;\n    } else {\n        // Compute the Householder transformation\n        double x = matrixT[iu][iu - 1];\n        double y = matrixT[iu][iu];\n        double z = matrixT[iu - 1][iu - 1];\n        double s = FastMath.abs(x) + FastMath.abs(y) + FastMath.abs(z);\n        if (s == 0.0) {\n            // All elements are zero\n            hVec[0] = 0.0;\n            hVec[1] = 0.0;\n            hVec[2] = 0.0;\n        } else {\n            x = x / s;\n            y = y / s;\n            z = z / s;\n            double r = FastMath.sqrt(x * x + y * y + z * z);\n            if (x < 0.0) {\n                r = -r;\n            }\n            p = x + r;\n            q = y;\n            r = z;\n            hVec[0] = p;\n            hVec[1] = q;\n            hVec[2] = r;\n        }\n    }\n    return im;\n}"
    ],
    [
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) {\n        if (child instanceof TextNode) {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) \n    {\n        if (child instanceof TextNode) \n        {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) {\n        if (child instanceof TextNode) {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) \n    {\n        if (child instanceof TextNode) \n        {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) {\n        if (child instanceof TextNode) {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) \n    {\n        if (child instanceof TextNode) \n        {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) \n    {\n        if (child instanceof TextNode) \n        {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) \n    {\n        if (child instanceof TextNode) \n        {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) \n    {\n        if (child instanceof TextNode) \n        {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}",
      "public List<TextNode> textNodes()  {\n    List<TextNode> textNodes = new ArrayList<>();\n    for (Node child : childNodes) \n    {\n        if (child instanceof TextNode) \n        {\n            textNodes.add((TextNode) child);\n        }\n    }\n    return Collections.unmodifiableList(textNodes);\n}"
    ],
    [
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inExceptionSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inExceptionSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inIncludeSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inIncludeSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (!segment.inExceptionSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}",
      "public boolean inIncludeSegments()  {\n    for (Segment segment = getSegment(this.segmentStart);\n        segment.getSegmentStart() < this.segmentEnd;\n        segment.inc()) \n    {\n        if (segment.inExceptionSegments()) \n        {\n            return (false);\n        }\n    }\n    return true;\n}"
    ],
    [
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    DurationFieldType[] types = new DurationFieldType[start.size()];\n    int[] values = new int[start.size()];\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        if (start.getFieldType(i) != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        types[i] = start.getFieldType(i).getDurationType();\n        if (i > 0 && types[i - 1] == types[i]) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not have overlapping fields\");\n        }\n        values[i] = end.getValue(i) - start.getValue(i);\n    }\n    return zeroInstance.getValue(types, values);\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  throws IllegalArgumentException {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        if (zeroInstance == null) {\n            throw new IllegalArgumentException(\"Zero instance must not be null\");\n        }\n        DurationFieldType[] types = new DurationFieldType[start.size()];\n        int[] values = new int[start.size()];\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n            types[i] = start.getFieldType(i).getDurationType();\n            values[i] = end.getValue(i) - start.getValue(i);\n        }\n        return zeroInstance.toPeriod(types).getValue(0);\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    int[] values = new int[start.size()];\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        if (start.getFieldType(i) != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        values[i] = end.getValue(i) - start.getValue(i);\n    }\n    return zeroInstance.toPeriod(values).getPeriodType().size();\n}",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  throws IllegalArgumentException {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        int[] values = new int[start.size()];\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n            values[i] = end.getValue(i) - start.getValue(i);\n        }\n        return zeroInstance.toPeriod(values).getPeriodType().size();\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  throws IllegalArgumentException {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        DurationFieldType[] types = new DurationFieldType[start.size()];\n        int[] values = new int[start.size()];\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n            types[i] = start.getFieldType(i).getDurationType();\n            if (i > 0 && types[i - 1] == types[i]) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must not have overlapping fields\");\n            }\n            values[i] = end.getValue(i) - start.getValue(i);\n        }\n        return zeroInstance.withValues(types, values).getPeriod();\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  throws IllegalArgumentException {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        DurationFieldType[] types = new DurationFieldType[start.size()];\n        int[] values = new int[start.size()];\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n            types[i] = start.getFieldType(i).getDurationType();\n            if (i > 0 && types[i - 1] == types[i]) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must not have overlapping fields\");\n            }\n            values[i] = end.getValue(i) - start.getValue(i);\n        }\n        return zeroInstance.getValue(types, values);\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  throws IllegalArgumentException {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        DurationFieldType[] types = new DurationFieldType[start.size()];\n        int[] values = new int[start.size()];\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n            types[i] = start.getFieldType(i).getDurationType();\n            values[i] = end.getValue(i) - start.getValue(i);\n        }\n        return zeroInstance.withFields(types, values).getPeriod();\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  throws IllegalArgumentException {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        if (zeroInstance == null) {\n            throw new IllegalArgumentException(\"ReadablePeriod object must not be null\");\n        }\n        int[] values = new int[start.size()];\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n            values[i] = end.getValue(i) - start.getValue(i);\n        }\n        return zeroInstance.getValue(0);\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  throws IllegalArgumentException {\n        if (start == null || end == null) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n        }\n        if (start.size() != end.size()) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        int[] values = new int[start.size()];\n        for (int i = 0, isize = start.size(); i < isize; i++) {\n            if (start.getFieldType(i) != end.getFieldType(i)) {\n                throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n            }\n            values[i] = end.getValue(i) - start.getValue(i);\n        }\n        return zeroInstance.getValue(0);\n    }",
      "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance)  {\n    if (start == null || end == null) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must not be null\");\n    }\n    if (start.size() != end.size()) {\n        throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n    }\n    DurationFieldType[] types = new DurationFieldType[start.size()];\n    int[] values = new int[start.size()];\n    for (int i = 0, isize = start.size(); i < isize; i++) {\n        if (start.getFieldType(i) != end.getFieldType(i)) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must have the same set of fields\");\n        }\n        types[i] = start.getFieldType(i).getDurationType();\n        if (i > 0 && types[i - 1] == types[i]) {\n            throw new IllegalArgumentException(\"ReadablePartial objects must not have overlapping fields\");\n        }\n        values[i] = end.getValue(i) - start.getValue(i);\n    }\n    return zeroInstance.withPeriodFields(types, values);\n}"
    ],
    [
      "public LegendTitle getLegend(int index)  {\n    if ((index < 0) || (index >= getLegendCount())) {\n        throw new IllegalArgumentException(\"Index out of range.\");\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if ((index < 0) || (index >= getLegendCount())) {\n        throw new IllegalArgumentException(\"Index out of range.\");\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if ((index < 0) || (index >= getLegendCount())) {\n        throw new IllegalArgumentException(\"Index out of range.\");\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if ((index < 0) || (index >= getLegendCount())) \n    {\n        throw new IllegalArgumentException(\"Index out of range.\");\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if ((index < 0) || (index >= getLegendCount())) {\n        throw new IllegalArgumentException(\"Index out of range.\");\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if ((index < 0) || (index >= getLegendCount())) \n    {\n        throw new IllegalArgumentException(\"Index out of range.\");\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if ((index < 0) || (index >= getLegendCount())) \n    {\n        throw new IllegalArgumentException(\"Index out of range.\");\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if ((index < 0) || (index >= getLegendCount())) {\n        throw new IllegalArgumentException(\"Index out of range.\");\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if ((index < 0) || (index >= getLegendCount())) \n    {\n        throw new IllegalArgumentException(\"Index out of range.\");\n    }\n    return (LegendTitle) this.legends.get(index);\n}",
      "public LegendTitle getLegend(int index)  {\n    if ((index < 0) || (index >= getLegendCount())) {\n        throw new IllegalArgumentException(\"Index out of range.\");\n    }\n    return (LegendTitle) this.legends.get(index);\n}"
    ],
    [
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    ZipArchiveEntry[] entriesOfThatName = new ZipArchiveEntry[0];\n    if (nameMap.containsKey(name)) {\n        entriesOfThatName = nameMap.get(name).toArray(entriesOfThatName);\n        Arrays.sort(entriesOfThatName, offsetComparator);\n    }\n    return Arrays.asList(entriesOfThatName);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    ZipArchiveEntry[] entriesOfThatName = new ZipArchiveEntry[0];\n    if (nameMap.containsKey(name)) \n    {\n        entriesOfThatName = nameMap.get(name).toArray(entriesOfThatName);\n        Arrays.sort(entriesOfThatName, offsetComparator);\n    }\n    return Arrays.asList(entriesOfThatName);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    ZipArchiveEntry[] entriesOfThatName = new ZipArchiveEntry[0];\n    if (nameMap.containsKey(name)) {\n        entriesOfThatName = nameMap.get(name).toArray(entriesOfThatName);\n        Arrays.sort(entriesOfThatName, offsetComparator);\n    }\n    return Arrays.asList(entriesOfThatName);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    ZipArchiveEntry[] entriesOfThatName = new ZipArchiveEntry[0];\n    if (nameMap.containsKey(name)) \n    {\n        entriesOfThatName = nameMap.get(name).toArray(entriesOfThatName);\n        Arrays.sort(entriesOfThatName, offsetComparator);\n    }\n    return Arrays.asList(entriesOfThatName);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    ZipArchiveEntry[] entriesOfThatName = new ZipArchiveEntry[0];\n    if (nameMap.containsKey(name)) {\n        entriesOfThatName = nameMap.get(name).toArray(entriesOfThatName);\n        Arrays.sort(entriesOfThatName, offsetComparator);\n    }\n    return Arrays.asList(entriesOfThatName);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    ZipArchiveEntry[] entriesOfThatName = new ZipArchiveEntry[0];\n    if (nameMap.containsKey(name)) \n    {\n        entriesOfThatName = nameMap.get(name).toArray(entriesOfThatName);\n        Arrays.sort(entriesOfThatName, offsetComparator);\n    }\n    return Arrays.asList(entriesOfThatName);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    ZipArchiveEntry[] entriesOfThatName = new ZipArchiveEntry[0];\n    if (nameMap.containsKey(name)) \n    {\n        entriesOfThatName = nameMap.get(name).toArray(entriesOfThatName);\n        Arrays.sort(entriesOfThatName, offsetComparator);\n    }\n    return Arrays.asList(entriesOfThatName);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    ZipArchiveEntry[] entriesOfThatName = new ZipArchiveEntry[0];\n    if (nameMap.containsKey(name)) {\n        entriesOfThatName = nameMap.get(name).toArray(entriesOfThatName);\n        Arrays.sort(entriesOfThatName, offsetComparator);\n    }\n    return Arrays.asList(entriesOfThatName);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    ZipArchiveEntry[] entriesOfThatName = new ZipArchiveEntry[0];\n    if (nameMap.containsKey(name)) {\n        entriesOfThatName = nameMap.get(name).toArray(entriesOfThatName);\n        Arrays.sort(entriesOfThatName, offsetComparator);\n    }\n    return Arrays.asList(entriesOfThatName);\n}",
      "public Enumeration<ZipArchiveEntry> getEntriesInPhysicalOrder()  {\n    ZipArchiveEntry[] entriesOfThatName = new ZipArchiveEntry[0];\n    if (nameMap.containsKey(name)) \n    {\n        entriesOfThatName = nameMap.get(name).toArray(entriesOfThatName);\n        Arrays.sort(entriesOfThatName, offsetComparator);\n    }\n    return Arrays.asList(entriesOfThatName);\n}"
    ],
    [
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) \n    {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) \n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } \n      else \n      {\n        next();\n      }\n    }\n\n    return typeNode;\n  } \n  else \n  {\n    return parseTopLevelTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTopLevelTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTopLevelTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTopLevelTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) \n    {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) \n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } \n      else \n      {\n        next();\n      }\n    }\n\n    return typeNode;\n  } \n  else \n  {\n    return parseTopLevelTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) \n    {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) \n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } \n      else \n      {\n        next();\n      }\n    }\n\n    return typeNode;\n  } \n  else \n  {\n    return parseTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTopLevelTypeExpression(token);\n    }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n  if (token == JsDocToken.LC) \n  {\n    skipEOLs();\n    Node typeNode = parseTopLevelTypeExpression(next());\n    if (typeNode != null) \n    {\n      skipEOLs();\n      if (!match(JsDocToken.RC)) \n      {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } \n      else \n      {\n        next();\n      }\n    }\n\n    return typeNode;\n  } \n  else \n  {\n    return parseTopLevelTypeExpression(token);\n  }\n}",
      "private Node parseParamTypeExpressionAnnotation(JsDocToken token)  {\n    if (token == JsDocToken.LC) \n    {\n        skipEOLs();\n        Node typeNode = parseTopLevelTypeExpression(next());\n        if (typeNode != null) \n        {\n            skipEOLs();\n            if (!match(JsDocToken.RC)) \n            {\n                reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n            } \n            else \n            {\n                next();\n            }\n        }\n\n        return typeNode;\n    } \n    else \n    {\n        return parseTopLevelTypeExpression(token);\n    }\n}"
    ],
    [
      "static List<String> getStackFrameList(final Throwable t)  {\n        final String stackTrace = getStackTrace(t);\n        final String linebreak = System.getProperty(\"line.separator\");\n        final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n        final List<String> list = new ArrayList<String>();\n        boolean traceStarted = false;\n        while (frames.hasMoreTokens()) {\n            final String token = frames.nextToken();\n            final int at = token.indexOf(\"at\");\n            if (at != -1 && token.substring(0, at).trim().length() == 0) {\n                traceStarted = true;\n                list.add(token);\n            } else if (traceStarted) {\n                break;\n            }\n        }\n        return list;\n    }",
      "static List<String> getStackFrameList(final Throwable t)  {\n        final String stackTrace = getStackTrace(t);\n        final String linebreak = System.getProperty(\"line.separator\");\n        final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n        final List<String> list = new ArrayList<String>();\n        boolean traceStarted = false;\n        while (frames.hasMoreTokens()) {\n            final String token = frames.nextToken();\n            final int at = token.indexOf(\"at\");\n            if (at != -1 && token.substring(0, at).trim().length() == 0) {\n                traceStarted = true;\n                list.add(token);\n            } else if (traceStarted) {\n                break;\n            }\n        }\n        return list;\n    }",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = System.getProperty(\"line.separator\");\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n            traceStarted = true;\n        }\n        if (traceStarted) {\n            list.add(token);\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n        final String stackTrace = getStackTrace(t);\n        final String linebreak = System.getProperty(\"line.separator\");\n        final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n        final List<String> list = new ArrayList<String>();\n        boolean traceStarted = false;\n        while (frames.hasMoreTokens()) {\n            final String token = frames.nextToken();\n            final int at = token.indexOf(\"at\");\n            if (at != -1 && token.substring(0, at).trim().isEmpty()) {\n                traceStarted = true;\n            }\n            if (traceStarted) {\n                list.add(token);\n            }\n        }\n        return list;\n    }",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    final String stackTrace = getStackTraceAsString(t);\n    final String linebreak = System.getProperty(\"line.separator\");\n    final String[] lines = stackTrace.split(linebreak);\n    for (final String line : lines) {\n        final int at = line.indexOf(\"at\");\n        if (at != -1) {\n            list.add(line.substring(at + 1));\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = System.getProperty(\"line.separator\");\n    final String[] stackFrames = stackTrace.split(linebreak);\n    for (final String stackFrame : stackFrames) {\n        final int at = stackFrame.indexOf(\"at\");\n        if (at != -1) {\n            list.add(stackFrame.substring(at + 4));\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    final String stackTrace = getStackTraceAsString(t);\n    final String lines[] = stackTrace.split(\"\\n\");\n    for (final String line : lines) {\n        final int at = line.indexOf(\"at\");\n        if (at != -1) {\n            list.add(line.substring(at + 1).trim());\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n        final List<String> list = new ArrayList<String>();\n        final String stackTrace = t.getStackTraceAsString();\n        final String linebreak = System.getProperty(\"line.separator\");\n        final String[] stackFrames = stackTrace.split(linebreak);\n        for (final String stackFrame : stackFrames) {\n            if (stackFrame.indexOf(\"at \") != -1) {\n                list.add(stackFrame);\n            }\n        }\n        return list;\n    }",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final String stackTrace = getStackTrace(t);\n    final String linebreak = System.getProperty(\"line.separator\");\n    final StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);\n    final List<String> list = new ArrayList<String>();\n    boolean traceStarted = false;\n    while (frames.hasMoreTokens()) {\n        final String token = frames.nextToken();\n        final int at = token.indexOf(\"at\");\n        if (at != -1 && token.substring(0, at).trim().length() == 0) {\n            traceStarted = true;\n        }\n        if (traceStarted) {\n            list.add(token);\n        }\n    }\n    return list;\n}",
      "static List<String> getStackFrameList(final Throwable t)  {\n    final List<String> list = new ArrayList<String>();\n    final String stackTrace = getStackTraceAsString(t);\n    final String linebreak = System.getProperty(\"line.separator\");\n    final String[] stackFrames = stackTrace.split(linebreak);\n    for (final String stackFrame : stackFrames) {\n        if (stackFrame.indexOf(\"at \") != -1) {\n            list.add(stackFrame);\n        }\n    }\n    return list;\n}"
    ],
    [
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}",
      "public boolean nextBoolean() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_TRUE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return true;\n    } \n    else if (p == PEEKED_FALSE) \n    {\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return false;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a boolean but was \" + peek() + locationString());\n    }\n}"
    ],
    [
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) \n    {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) \n    {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}",
      "public static String center(String str, final int size, final char padChar)  {\n    if (str == null || size <= 0) {\n        return str;\n    }\n    final int strLen = str.length();\n    final int pads = size - strLen;\n    if (pads <= 0) {\n        return str;\n    }\n    str = leftPad(str, strLen + pads / 2, padChar);\n    str = rightPad(str, size, padChar);\n    return str;\n}"
    ],
    [
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg = call.getFirstChild().getNext(); arg != null; arg = arg.getNext()) \n    {\n        if (NodeUtil.nodeTypeMayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg = call.getFirstChild().getNext();\n         arg != null; arg = arg.getNext()) \n    {\n        if (NodeUtil.nodeTypeMayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node args = call.getFirstChild().getNext();\n    for (Node arg = args; arg != null; arg = arg.getNext()) \n    {\n        if (NodeUtil.nodeTypeMayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg = call.getFirstChild().getNext(); arg != null; arg = arg.getNext()) \n    {\n        if (NodeUtil.nodeTypeMayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg = call.getFirstChild().getNext(); arg != null; arg = arg.getNext()) \n    {\n        if (NodeUtil.nodeTypeMayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg = call.getFirstChild().getNext(); arg != null; arg = arg.getNext()) \n    {\n        if (NodeUtil.nodeTypeMayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    for (Node arg = call.getFirstChild().getNext(); arg != null; arg = arg.getNext()) {\n        if (NodeUtil.nodeTypeMayHaveSideEffects(arg)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node args = call.getFirstChild().getNext();\n    for (Node arg = args; arg != null; arg = arg.getNext()) \n    {\n        if (NodeUtil.nodeTypeMayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node args = call.getFirstChild().getNext();\n    for (Node arg = args; arg != null; arg = arg.getNext()) {\n        if (NodeUtil.nodeTypeMayHaveSideEffects(arg)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean argsMayHaveSideEffects(Node call)  {\n    Node args = call.getLastChild();\n    for (Node arg = args.getFirstChild(); arg != null; arg = arg.getNext()) \n    {\n        if (NodeUtil.nodeTypeMayHaveSideEffects(arg)) \n        {\n            return true;\n        }\n    }\n    return false;\n}"
    ],
    [
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}",
      "public FieldMatrix<T> getP()  {\n    if ((cachedP == null) && !singular) \n    {\n        final int m = pivot.length;\n        cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            cachedP.setEntry(i, pivot[i], field.getOne());\n        }\n    }\n    return cachedP;\n}"
    ],
    [
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) \n    {\n        sum += element.getLocalFileDataLength().getValue();\n    }\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) \n    {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] local = data[i].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n            start += local.length;\n        }\n    }\n    if (lastIsUnparseableHolder) \n    {\n        final byte[] local = data[data.length - 1].getLocalFileDataData();\n        if (local != null) \n        {\n            System.arraycopy(local, 0, result, start, local.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double sup = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
      "public double getSup()  {\n    BSPTree<Euclidean1D> node = getTree(false);\n    double  sup  = Double.NEGATIVE_INFINITY;\n    while (node.getCut() != null) \n    {\n        final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n        sup  = op.getLocation().getX();\n        node = op.isDirect() ? node.getPlus() : node.getMinus();\n    }\n    return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}"
    ],
    [
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        while (true) {\n            if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            } else if (readEndOfLine(ch)) {\n                token.type = EORECORD;\n                return token;\n            } else if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // There is data at EOF\n                return token;\n            } else if (isEscape(ch)) {\n                final int unescaped = readEscape();\n                if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                    token.content.append((char) ch).append((char) reader.getLastChar());\n                } else {\n                    token.content.append((char) unescaped);\n                }\n            } else {\n                token.content.append((char) ch);\n            }\n            ch = reader.read();\n        }\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        final long startLineNumber = this.getCurrentLineNumber();\n        while (true) {\n            if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            } else if (readEndOfLine(ch)) {\n                token.type = EORECORD;\n                return token;\n            } else if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // There is data at EOF\n                return token;\n            } else if (isEscape(ch)) {\n                final int unescaped = readEscape();\n                if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                    token.content.append((char) ch).append((char) reader.getLastChar());\n                } else {\n                    token.content.append((char) unescaped);\n                }\n            } else {\n                token.content.append((char) ch);\n            }\n            ch = reader.read();\n        }\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) {\n        if (isDelimiter(ch)) {\n            token.type = TOKEN;\n            return token;\n        } else if (readEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        } else if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        } else if (isEscape(ch)) {\n            final int unescaped = readEscape();\n            if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                token.content.append((char) ch).append((char) reader.getLastChar());\n            } else {\n                token.content.append((char) unescaped);\n            }\n        } else {\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        while (true) {\n            if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            } else if (readEndOfLine(ch)) {\n                token.type = EORECORD;\n                return token;\n            } else if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // there is data at EOF\n                return token;\n            } else if (isEscape(ch)) {\n                final int unescaped = readEscape();\n                if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                    token.content.append((char) ch).append((char) reader.getLastChar());\n                } else {\n                    token.content.append((char) unescaped);\n                }\n            } else {\n                token.content.append((char) ch);\n            }\n            ch = reader.read();\n        }\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (!isDelimiter(ch) && !readEndOfLine(ch) && !isEndOfFile(ch)) {\n        if (isEscape(ch)) {\n            final int unescaped = readEscape();\n            if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                token.content.append((char) ch).append((char) reader.getLastChar());\n            } else {\n                token.content.append((char) unescaped);\n            }\n        } else {\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n    if (isDelimiter(ch)) {\n        token.type = TOKEN;\n    } else if (readEndOfLine(ch)) {\n        token.type = EORECORD;\n    } else if (isEndOfFile(ch)) {\n        token.type = EOF;\n        token.isReady = true; // There is data at EOF\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (!isDelimiter(ch) && !readEndOfLine(ch) && !isEndOfFile(ch)) {\n        if (isEscape(ch)) {\n            final int unescaped = readEscape();\n            if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                token.content.append((char) ch).append((char) reader.getLastChar());\n            } else {\n                token.content.append((char) unescaped);\n            }\n        } else {\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n    if (isDelimiter(ch)) {\n        token.type = TOKEN;\n    } else if (readEndOfLine(ch)) {\n        token.type = EORECORD;\n    } else if (isEndOfFile(ch)) {\n        token.type = EOF;\n        token.isReady = true; // There is data at EOF\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n        while (true) {\n            if (isDelimiter(ch)) {\n                token.type = TOKEN;\n                return token;\n            } else if (readEndOfLine(ch)) {\n                token.type = EORECORD;\n                return token;\n            } else if (isEndOfFile(ch)) {\n                token.type = EOF;\n                token.isReady = true; // There is data at EOF\n                return token;\n            } else if (isEscape(ch)) {\n                final int unescaped = readEscape();\n                if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                    token.content.append((char) ch).append((char) reader.getLastChar());\n                } else {\n                    token.content.append((char) unescaped);\n                }\n            } else {\n                token.content.append((char) ch);\n            }\n            ch = reader.read();\n        }\n    }",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (!isDelimiter(ch) && !readEndOfLine(ch) && !isEndOfFile(ch)) {\n        if (isEscape(ch)) {\n            final int unescaped = readEscape();\n            if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                token.content.append((char) ch).append((char) reader.getLastChar());\n            } else {\n                token.content.append((char) unescaped);\n            }\n        } else {\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n    if (isDelimiter(ch)) {\n        token.type = TOKEN;\n    } else if (readEndOfLine(ch)) {\n        token.type = EORECORD;\n    } else if (isEndOfFile(ch)) {\n        token.type = EOF;\n        token.isReady = true; // There is data at EOF\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (!isEndOfFile(ch) && !readEndOfLine(ch) && !isDelimiter(ch) && !isEscape(ch)) {\n        if (isEscape(ch)) {\n            final int unescaped = readEscape();\n            if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                token.content.append((char) ch).append((char) reader.getLastChar());\n            } else {\n                token.content.append((char) unescaped);\n            }\n        } else {\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n    if (isEndOfFile(ch)) {\n        token.type = EOF;\n        token.isReady = true; // There is data at EOF\n    } else if (readEndOfLine(ch)) {\n        token.type = EORECORD;\n    } else {\n        token.type = TOKEN;\n    }\n    return token;\n}",
      "private Token parseSimpleToken(final Token token, int ch) throws IOException  {\n    while (true) {\n        if (isDelimiter(ch)) {\n            token.type = TOKEN;\n            return token;\n        } else if (readEndOfLine(ch)) {\n            token.type = EORECORD;\n            return token;\n        } else if (isEndOfFile(ch)) {\n            token.type = EOF;\n            token.isReady = true; // There is data at EOF\n            return token;\n        } else if (isEscape(ch)) {\n            final int unescaped = readEscape();\n            if (unescaped == END_OF_STREAM) { // unexpected char after escape\n                token.content.append((char) ch).append((char) reader.getLastChar());\n            } else {\n                token.content.append((char) unescaped);\n            }\n        } else {\n            token.content.append((char) ch);\n        }\n        ch = reader.read();\n    }\n}"
    ],
    [
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = dimension - 1; i >= 0; i--) \n    {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] c = new int[dimension];\n    for (int i = dimension - 1; i >= 0; i--) \n    {\n        c[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return c;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = dimension - 1; i >= 0; i--) \n    {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] c = new int[dimension];\n    for (int i = dimension - 1; i >= 0; i--) \n    {\n        c[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return c;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = dimension - 1; i >= 0; i--) {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = dimension - 1; i >= 0; i--) \n    {\n        counts[i] = index / uniCounterOffset[i];\n        index = index % uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = dimension - 1; i >= 0; i--) {\n        counts[i] = index / uniCounterOffset[i];\n        index = index % uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = dimension - 1; i >= 0; i--) \n    {\n        counts[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return counts;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) \n    {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] c = new int[dimension];\n    for (int i = dimension - 1; i >= 0; i--) \n    {\n        c[i] = index / uniCounterOffset[i];\n        index %= uniCounterOffset[i];\n    }\n    return c;\n}",
      "public int[] getCounts(int index) throws OutOfRangeException  {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize - 1);\n    }\n    int[] counts = new int[dimension];\n    for (int i = dimension - 1; i >= 0; i--) {\n        counts[i] = index / uniCounterOffset[i];\n        index = index % uniCounterOffset[i];\n    }\n    return counts;\n}"
    ],
    [
      "public JsonPointer last()  {\n    JsonPointer h = _head;\n    if (h == null) {\n        if (this != EMPTY) {\n            h = _constructHead();\n        }\n        _head = h;\n    }\n    return h;\n}",
      "public JsonPointer last()  {\n    JsonPointer h = _head;\n    if (h == null) {\n        if (this != EMPTY) {\n            h = _constructHead();\n        }\n        _head = h;\n    }\n    return h;\n}",
      "public JsonPointer last()  {\n    JsonPointer h = _head;\n    if (h == null) {\n        if (this != EMPTY) {\n            h = _constructHead();\n        }\n        _head = h;\n    }\n    return h;\n}",
      "public JsonPointer last()  {\n    JsonPointer p = this;\n    while (p._nextSegment != null) {\n        p = p._nextSegment;\n    }\n    return p;\n}",
      "public JsonPointer last()  {\n    JsonPointer h = _head;\n    if (h == null) {\n        if (this != EMPTY) {\n            h = _constructHead();\n        }\n        _head = h;\n    }\n    return h;\n}",
      "public JsonPointer last()  {\n    JsonPointer p = this;\n    while (p._nextSegment != null) {\n        p = p._nextSegment;\n    }\n    return p;\n}",
      "public JsonPointer last()  {\n    JsonPointer next = this;\n    while (next._nextSegment != null) {\n        next = next._nextSegment;\n    }\n    return next;\n}",
      "public JsonPointer last()  {\n    JsonPointer next = this;\n    while (next._nextSegment != null) {\n        next = next._nextSegment;\n    }\n    return next;\n}",
      "public JsonPointer last()  {\n    JsonPointer curr = this;\n    while (curr._nextSegment != null) {\n        curr = curr._nextSegment;\n    }\n    return curr;\n}",
      "public JsonPointer last()  {\n    JsonPointer last = _last;\n    if (last == null) {\n        if (this != EMPTY) {\n            last = _constructLast();\n        }\n        _last = last;\n    }\n    return last;\n}"
    ],
    [
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) \n    {\n        digest.update(buffer, 0, read);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) \n    {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read;\n    while ((read = data.read(buffer, 0, STREAM_BUFFER_LENGTH)) > -1) {\n        digest.update(buffer, 0, read);\n    }\n    return digest;\n}",
      "public static MessageDigest updateDigest(final MessageDigest digest, final InputStream data) throws IOException  {\n    final byte[] buffer = new byte[STREAM_BUFFER_LENGTH];\n    int read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n\n    while (read > -1) \n    {\n        digest.update(buffer, 0, read);\n        read = data.read(buffer, 0, STREAM_BUFFER_LENGTH);\n    }\n\n    return digest;\n}"
    ],
    [
      "public static <T> T clone(final T obj)  if (obj instanceof Cloneable) {\n        try {\n            return (T) MethodUtils.invokeMethod(obj, \"clone\", (Object[]) null);\n        } catch (final NoSuchMethodException ex) {\n            // ignored\n        } catch (final IllegalAccessException ex) {\n            // ignored\n        } catch (final InvocationTargetException ex) {\n            throw new CloneFailedException(\"Unable to clone object\", ex.getCause());\n        }\n    }\n    return null;\n    }",
      "public static <T> T clone(final T obj)  {\n    if (obj instanceof Cloneable) {\n        try {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\", (Class[]) null);\n            if (!Modifier.isPublic(cloneMethod.getModifiers())) {\n                cloneMethod.setAccessible(true);\n            }\n            return (T) cloneMethod.invoke(obj, (Object[]) null);\n        } catch (final NoSuchMethodException ex) {\n            // ignore, no valid clone method\n        } catch (final IllegalAccessException ex) {\n            // ignore, no valid clone method\n        } catch (final InvocationTargetException ex) {\n            final Throwable cause = ex.getCause();\n            if (cause instanceof CloneFailedException) {\n                throw (CloneFailedException) cause;\n            }\n            // ignored\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n        if (obj == null) {\n            return null;\n        }\n        try {\n            if (obj instanceof Cloneable) {\n                final Object result = MethodUtils.invokeMethod(obj, \"clone\", (Object[]) null);\n                if (result != null) {\n                    @SuppressWarnings(\"unchecked\") // generic array creation\n                    final T typedResult = (T) result;\n                    return typedResult;\n                }\n            }\n        } catch (final NoSuchMethodException ex) {\n            // ignore\n        } catch (final IllegalAccessException ex) {\n            // ignore\n        } catch (final InvocationTargetException ex) {\n            throw new CloneFailedException(\"Unable to clone object\", ex.getCause());\n        }\n        throw new CloneFailedException(\"Object does not implement Cloneable\");\n    }",
      "public static <T> T clone(final T obj)  if (obj instanceof Cloneable) {\n        try {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\", (Class<?>[]) null);\n            if (!Modifier.isPublic(cloneMethod.getModifiers())) {\n                cloneMethod.setAccessible(true);\n            }\n            return (T) cloneMethod.invoke(obj, (Object[]) null);\n        } catch (final NoSuchMethodException ex) {\n            throw new CloneFailedException(\"Cloneable type has no clone method\", ex);\n        } catch (final IllegalAccessException ex) {\n            throw new CloneFailedException(\"Cannot clone Cloneable type\", ex);\n        } catch (final InvocationTargetException ex) {\n            throw new CloneFailedException(\"Exception cloning Cloneable type\", ex.getCause());\n        }\n    }\n    return null;\n    }",
      "public static <T> T clone(final T obj)  {\n    if (obj instanceof Cloneable) {\n        try {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\", (Class<?>[]) null);\n            if (!Modifier.isPublic(cloneMethod.getModifiers())) {\n                cloneMethod.setAccessible(true);\n            }\n            return (T) cloneMethod.invoke(obj, (Object[]) null);\n        } catch (final NoSuchMethodException ex) {\n            // ignored, meaning not cloneable\n        } catch (final IllegalAccessException ex) {\n            // ignored, meaning not cloneable\n        } catch (final InvocationTargetException ex) {\n            throw new CloneFailedException(\"Unable to clone object of type \" + obj.getClass().getName(), ex.getCause());\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj instanceof Cloneable) {\n        try {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\", (Class[]) null);\n            if (!Modifier.isPublic(cloneMethod.getModifiers())) {\n                cloneMethod.setAccessible(true);\n            }\n            return (T) cloneMethod.invoke(obj, (Object[]) null);\n        } catch (final NoSuchMethodException e) {\n            // cloning not supported\n        } catch (final IllegalAccessException e) {\n            throw new CloneFailedException(\"Unable to clone object\", e);\n        } catch (final InvocationTargetException e) {\n            throw new CloneFailedException(\"Unable to clone object\", e.getCause());\n        }\n    }\n    return null;\n}\n    //-----------------------------------------------------------------------",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n    if (obj instanceof Cloneable) {\n        try {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\", (Class[]) null);\n            if (!Modifier.isPublic(cloneMethod.getModifiers())) {\n                cloneMethod.setAccessible(true);\n            }\n            return (T) cloneMethod.invoke(obj, (Object[]) null);\n        } catch (final NoSuchMethodException e) {\n            // cloning not supported\n        } catch (final IllegalAccessException e) {\n            throw new CloneFailedException(\"Unable to clone object\", e);\n        } catch (final InvocationTargetException e) {\n            throw new CloneFailedException(\"Unable to clone object\", e.getCause());\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  throws CloneFailedException {\n        if (obj instanceof Cloneable) {\n            try {\n                final Method cloneMethod = obj.getClass().getMethod(\"clone\", (Class<?>[]) null);\n                if (!Modifier.isPublic(cloneMethod.getModifiers())) {\n                    cloneMethod.setAccessible(true);\n                }\n                return (T) cloneMethod.invoke(obj, (Object[]) null);\n            } catch (final NoSuchMethodException ex) {\n                throw new AssertionError(\"Cloneable object does not have a clone method\", ex);\n            } catch (final IllegalAccessException ex) {\n                throw new CloneFailedException(\"Cannot clone object\", ex);\n            } catch (final InvocationTargetException ex) {\n                throw new CloneFailedException(\"Exception cloning object\", ex.getCause());\n            }\n        }\n        return null;\n    }",
      "public static <T> T clone(final T obj)  if (obj instanceof Cloneable) {\n        try {\n            final Method cloneMethod = obj.getClass().getMethod(\"clone\", (Class<?>[]) null);\n            if (!Modifier.isPublic(cloneMethod.getModifiers())) {\n                cloneMethod.setAccessible(true);\n            }\n            return (T) cloneMethod.invoke(obj, (Object[]) null);\n        } catch (final NoSuchMethodException ex) {\n            // ignore, no clone method\n        } catch (final IllegalAccessException ex) {\n            // ignore, can't invoke method\n        } catch (final InvocationTargetException ex) {\n            // ignore, can't invoke method\n        }\n    }\n    return null;\n}",
      "public static <T> T clone(final T obj)  if (obj == null) {\n        return null;\n    }\n    try {\n        return (T) obj.getClass().getMethod(\"clone\").invoke(obj);\n    } catch (final NoSuchMethodException ex) {\n        // cloning not supported\n        return null;\n    } catch (final IllegalAccessException ex) {\n        throw new CloneFailedException(\"Unable to clone object\", ex);\n    } catch (final InvocationTargetException ex) {\n        throw new CloneFailedException(\"Unable to clone object\", ex.getCause());\n    }\n}"
    ],
    [
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  SymbolScope scope = getScopeInFunction(sym);\n  if (scope == null) \n  {\n    return null;\n  }\n\n  for (Symbol parameter : scope.getOwnSymbols().values()) \n  {\n    if (parameter.getName().equals(paramName)) \n    {\n      return parameter;\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) \n    {\n        return null;\n    }\n\n    // Get the parameter node.\n    Node paramNode = scope.getRootNode().getFirstChild().getNext();\n    while (paramNode != null && !paramNode.getString().equals(paramName)) \n    {\n        paramNode = paramNode.getNext();\n    }\n\n    if (paramNode == null) \n    {\n        return null;\n    }\n\n    // Get the symbol for the parameter.\n    return scope.getSlot(paramName);\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n        return null;\n    }\n\n    for (Symbol param : scope.getOwnSymbols().values()) {\n        if (param.getName().equals(paramName)) {\n            return param;\n        }\n    }\n\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n        return null;\n    }\n\n    for (Symbol s : scope.getOwnSymbols().values()) {\n        if (s.getDeclaration().getNode().isName() &&\n            s.getDeclaration().getNode().getString().equals(paramName)) {\n            return s;\n        }\n    }\n\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  SymbolScope scope = getScopeInFunction(sym);\n  if (scope == null) {\n    return null;\n  }\n\n  for (Symbol param : scope.getOwnSymbols().values()) {\n    if (param.getName().equals(paramName)) {\n      return param;\n    }\n  }\n\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  SymbolScope scope = getScopeInFunction(sym);\n  if (scope == null) \n  {\n    return null;\n  }\n\n  for (Symbol param : scope.getOwnSymbols().values()) \n  {\n    if (param.getName().equals(paramName)) \n    {\n      return param;\n    }\n  }\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n        return null;\n    }\n\n    for (Symbol param : scope.getOwnSymbols().values()) {\n        if (param.getName().equals(paramName)) {\n            return param;\n        }\n    }\n\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n    SymbolScope scope = getScopeInFunction(sym);\n    if (scope == null) {\n        return null;\n    }\n\n    for (Symbol parameter : scope.getOwnSlot(paramName)) {\n        return parameter;\n    }\n\n    return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  SymbolScope scope = getScopeInFunction(sym);\n  if (scope == null) {\n    return null;\n  }\n\n  for (Symbol param : scope.getOwnSymbols().values()) {\n    if (param.getName().equals(paramName)) {\n      return param;\n    }\n  }\n\n  return null;\n}",
      "public Symbol getParameterInFunction(Symbol sym, String paramName)  {\n  SymbolScope scope = getScopeInFunction(sym);\n  if (scope == null) \n  {\n    return null;\n  }\n\n  // Get the function node.\n  Node fnNode = scope.getRootNode();\n  if (fnNode == null || !fnNode.isFunction()) \n  {\n    return null;\n  }\n\n  // Get the parameters node.\n  Node paramNode = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n  if (paramNode == null) \n  {\n    return null;\n  }\n\n  // Find the parameter with the given name.\n  for (; paramNode != null; paramNode = paramNode.getNext()) \n  {\n    if (paramNode.getString().equals(paramName)) \n    {\n      // Get the symbol for the parameter.\n      Symbol paramSym = scope.getSlot(paramNode.getString());\n      if (paramSym != null) \n      {\n        return paramSym;\n      }\n    }\n  }\n\n  return null;\n}"
    ],
    [
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    RealMatrix outMatrix = new BlockRealMatrix(nCols, nCols);\n    for (int i = 0; i < nCols; i++) {\n        double meanI = matrix.getColumn(i).getSum() / nRows;\n        for (int j = 0; j <= i; j++) {\n            double meanJ = matrix.getColumn(j).getSum() / nRows;\n            double sum = 0.0;\n            for (int k = 0; k < nRows; k++) {\n                double x = matrix.getEntry(k, i) - meanI;\n                double y = matrix.getEntry(k, j) - meanJ;\n                sum += x * y;\n            }\n            double cov = sum / (nRows - biasCorrected);\n            outMatrix.setEntry(i, j, cov);\n            outMatrix.setEntry(j, i, cov);\n        }\n    }\n    return outMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    RealMatrix outMatrix = new BlockRealMatrix(nCols, nCols);\n    for (int i = 0; i < nCols; i++) {\n        double mean = matrix.getColumnVector(i).getL1Norm() / nRows;\n        for (int j = 0; j < i; j++) {\n            double entry = matrix.getColumnVector(i).getL1Norm() * matrix.getColumnVector(j).getL1Norm() /\n                   (nRows * nRows);\n            outMatrix.setEntry(i, j, entry);\n            outMatrix.setEntry(j, i, entry);\n        }\n    }\n    return outMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    RealMatrix outMatrix = new BlockRealMatrix(nCols, nCols);\n    for (int i = 0; i < nCols; i++) {\n        double mean = matrix.getColumnVector(i).getL1Norm() / nRows;\n        for (int j = 0; j < i; j++) {\n            double entry = matrix.getColumnVector(i).getL1Norm() * matrix.getColumnVector(j).getL1Norm() / (nRows * nRows);\n            outMatrix.setEntry(i, j, entry);\n            outMatrix.setEntry(j, i, entry);\n        }\n        outMatrix.setEntry(i, i, matrix.getColumnVector(i).getL1Norm() * matrix.getColumnVector(i).getL1Norm() / (nRows * nRows));\n    }\n    return outMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Check if the matrix has sufficient data\n    checkSufficientData(matrix);\n\n    // Get the number of rows and columns\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n\n    // Create a new matrix to store the covariance matrix\n    RealMatrix covarianceMatrix = new BlockRealMatrix(nCols, nCols);\n\n    // Compute the covariance matrix\n    for (int i = 0; i < nCols; i++) {\n        for (int j = 0; j <= i; j++) {\n            double sumX = 0.0;\n            double sumY = 0.0;\n            double sumXY = 0.0;\n            for (int k = 0; k < nRows; k++) {\n                double x = matrix.getEntry(k, i);\n                double y = matrix.getEntry(k, j);\n                sumX += x;\n                sumY += y;\n                sumXY += x * y;\n            }\n            double n = nRows;\n            double cov = (sumXY - sumX * sumY / n) / (n - biasCorrected);\n            covarianceMatrix.setEntry(i, j, cov);\n            covarianceMatrix.setEntry(j, i, cov);\n        }\n    }\n\n    return covarianceMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    RealMatrix outMatrix = new BlockRealMatrix(nCols, nCols);\n    for (int i = 0; i < nCols; i++) {\n        double mean = matrix.getColumnVector(i).getL1Norm() / nRows;\n        for (int j = 0; j < i; j++) {\n            double entry = 0d;\n            for (int k = 0; k < nRows; k++) {\n                double x = matrix.getEntry(k, i) - mean;\n                double y = matrix.getEntry(k, j) - mean;\n                entry += x * y;\n            }\n            entry /= (nRows - 1);\n            outMatrix.setEntry(i, j, entry);\n            outMatrix.setEntry(j, i, entry);\n        }\n        outMatrix.setEntry(i, i, 0d);\n    }\n    return outMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    RealMatrix outMatrix = new BlockRealMatrix(nCols, nCols);\n    for (int i = 0; i < nCols; i++) {\n        double meanI = matrix.getColumn(i).getSum() / nRows;\n        for (int j = 0; j <= i; j++) {\n            double meanJ = matrix.getColumn(j).getSum() / nRows;\n            double sum = 0.0;\n            for (int k = 0; k < nRows; k++) {\n                double x = matrix.getEntry(k, i) - meanI;\n                double y = matrix.getEntry(k, j) - meanJ;\n                sum += x * y;\n            }\n            double cov = sum / (nRows - biasCorrected);\n            outMatrix.setEntry(i, j, cov);\n            outMatrix.setEntry(j, i, cov);\n        }\n    }\n    return outMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // check sufficient data\n    checkSufficientData(matrix);\n\n    // compute covariance matrix\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    RealMatrix outMatrix = new BlockRealMatrix(nCols, nCols);\n    for (int i = 0; i < nCols; i++) {\n        double sum = 0.0;\n        for (int j = 0; j < nRows; j++) {\n            sum += matrix.getEntry(j, i);\n        }\n        double mean = sum / nRows;\n        double sumSquares = 0.0;\n        for (int j = 0; j < nRows; j++) {\n            double value = matrix.getEntry(j, i) - mean;\n            sumSquares += value * value;\n        }\n        double variance = sumSquares / (nRows - biasCorrected);\n        outMatrix.setEntry(i, i, variance);\n        for (int j = 0; j < i; j++) {\n            double entry = 0.0;\n            for (int k = 0; k < nRows; k++) {\n                entry += (matrix.getEntry(k, i) - mean) * (matrix.getEntry(k, j) - mean);\n            }\n            entry /= (nRows - biasCorrected);\n            outMatrix.setEntry(i, j, entry);\n            outMatrix.setEntry(j, i, entry);\n        }\n    }\n    return outMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    RealMatrix outMatrix = new BlockRealMatrix(nCols, nCols);\n    for (int i = 0; i < nCols; i++) {\n        for (int j = 0; j < i; j++) {\n            double sum = 0.0;\n            for (int k = 0; k < nRows; k++) {\n                double entry = matrix.getEntry(k, i) * matrix.getEntry(k, j);\n                sum += entry;\n            }\n            double mean = sum / (nRows - biasCorrected);\n            outMatrix.setEntry(i, j, mean);\n            outMatrix.setEntry(j, i, mean);\n        }\n    }\n    return outMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    checkSufficientData(matrix);\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n    RealMatrix outMatrix = new BlockRealMatrix(nCols, nCols);\n    for (int i = 0; i < nCols; i++) {\n        double meanI = matrix.getColumn(i).getMean();\n        for (int j = 0; j < i; j++) {\n            double meanJ = matrix.getColumn(j).getMean();\n            double sum = 0.0;\n            for (int k = 0; k < nRows; k++) {\n                double x = matrix.getEntry(k, i) - meanI;\n                double y = matrix.getEntry(k, j) - meanJ;\n                sum += x * y;\n            }\n            double covIJ = sum / (nRows - biasCorrected);\n            outMatrix.setEntry(i, j, covIJ);\n            outMatrix.setEntry(j, i, covIJ);\n        }\n        double varI = matrix.getColumn(i).getVariance();\n        outMatrix.setEntry(i, i, varI);\n    }\n    return outMatrix;\n}",
      "protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected)\n    throws MathIllegalArgumentException  {\n    // Check if the matrix has at least one column and two rows\n    checkSufficientData(matrix);\n\n    // Get the number of rows and columns in the matrix\n    int nRows = matrix.getRowDimension();\n    int nCols = matrix.getColumnDimension();\n\n    // Create a new matrix to store the covariance values\n    RealMatrix covarianceMatrix = new Array2DRowRealMatrix(nCols, nCols);\n\n    // Compute the covariance values\n    for (int i = 0; i < nCols; i++) {\n        for (int j = 0; j <= i; j++) {\n            double sum = 0.0;\n            for (int k = 0; k < nRows; k++) {\n                sum += matrix.getEntry(k, i) * matrix.getEntry(k, j);\n            }\n            double meanI = matrix.getColumnVector(i).getL1Norm() / nRows;\n            double meanJ = matrix.getColumnVector(j).getL1Norm() / nRows;\n            double cov = sum / nRows - meanI * meanJ;\n            covarianceMatrix.setEntry(i, j, cov);\n            covarianceMatrix.setEntry(j, i, cov);\n        }\n    }\n\n    // Return the covariance matrix\n    return covarianceMatrix;\n}"
    ],
    [
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) \n    {\n        throw new IllegalArgumentException(\"Count must be between 0 and 63\");\n    }\n    if (ensureCache(count)) \n    {\n        return -1;\n    }\n    long bits = bitsCached & MASKS[count];\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return bits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) \n    {\n        throw new IllegalArgumentException(\"count must be between 0 and 63\");\n    }\n    if (ensureCache(count)) \n    {\n        return -1;\n    }\n    long bits = bitsOut;\n    bitsCachedSize -= count;\n    if (bitsCachedSize < 0) \n    {\n        bits >>>= -bitsCachedSize;\n        bitsCachedSize = 0;\n    }\n    return bits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count <= 0 || count > 63) \n    {\n        throw new IllegalArgumentException(\"Count must be between 1 and 63\");\n    }\n\n    if (ensureCache(count)) \n    {\n        return -1;\n    }\n\n    long bitsOut = bitsCached & MASKS[count];\n    bitsCached >>= count;\n    bitsCachedSize -= count;\n\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IllegalArgumentException(\"count must be between 0 and 63\");\n    }\n    if (ensureCache(count)) {\n        return -1;\n    }\n    long bits = bitsCached & MASKS[count];\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return bits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IllegalArgumentException(\"Count must be between 0 and 63\");\n    }\n    if (ensureCache(count)) {\n        return -1;\n    }\n    long bitsOut = bitsCached & MASKS[count];\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) \n    {\n        throw new IllegalArgumentException(\"count must be between 0 and 63\");\n    }\n\n    if (ensureCache(count)) \n    {\n        return -1;\n    }\n\n    long bits = bitsOut;\n    bitsCachedSize -= count;\n\n    if (bitsCachedSize > 0) \n    {\n        bits |= (bitsCached >>> bitsCachedSize);\n    }\n\n    if (byteOrder == ByteOrder.LITTLE_ENDIAN) \n    {\n        bits = bits << (64 - count);\n    }\n\n    return bits >>> (64 - count);\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IllegalArgumentException(\"count must be between 0 and 63\");\n    }\n    if (ensureCache(count)) {\n        return -1;\n    }\n    long bitsOut = bitsCached & MASKS[count];\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count <= 0 || count > 63) \n    {\n        throw new IllegalArgumentException(\"Count must be between 1 and 63\");\n    }\n    \n    if (ensureCache(count)) \n    {\n        return -1;\n    }\n    \n    long bits = bitsCached & MASKS[count];\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    \n    return bits;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) \n    {\n        throw new IllegalArgumentException(\"count must be between 0 and 63\");\n    }\n    if (ensureCache(count)) \n    {\n        return -1;\n    }\n    long bitsOut = bitsCached & MASKS[count];\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return bitsOut;\n}",
      "public long readBits(final int count) throws IOException  {\n    if (count < 0 || count > 63) {\n        throw new IllegalArgumentException(\"count must be between 0 and 63\");\n    }\n    if (ensureCache(count)) {\n        return -1;\n    }\n    long bitsOut = bitsCached & MASKS[count];\n    bitsCached >>>= count;\n    bitsCachedSize -= count;\n    return bitsOut;\n}"
    ],
    [
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) \n    {\n        for (int j = 0; j < n; j++) \n        {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) \n    {\n        for (int j = 0; j < n; j++) \n        {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) \n    {\n        for (int j = 0; j < n; j++) \n        {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) \n    {\n        for (int j = 0; j < n; j++) \n        {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) \n    {\n        for (int j = 0; j < n; j++) \n        {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}",
      "public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)  {\n    final int m = data.length;\n    final int n = v.getDimension();\n    final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, n);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n        }\n    }\n    return out;\n}"
    ],
    [
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) \n  {\n    return true;\n  }\n  Node parent = target.getParent();\n  if (parent == null) \n  {\n    return false;\n  }\n  if (parent.isLabel()) \n  {\n    return parent.getFirstChild().getString().equals(label);\n  }\n  return matchLabel(parent, label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) \n    {\n        return true;\n    }\n    Node parent = target.getParent();\n    if (parent.isLabel()) \n    {\n        return parent.getFirstChild().getString().equals(label);\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  if (target.isLabel()) {\n    return label.equals(target.getFirstChild().getString());\n  }\n  if (target.isDo()) {\n    return isContinueTarget(target.getFirstChild(), target.getParent(), label);\n  }\n  if (target.isFor() || target.isWhile()) {\n    return isContinueTarget(target.getLastChild(), target.getParent(), label);\n  }\n  if (target.isSwitch()) {\n    return isBreakTarget(target.getLastChild(), label);\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    Node parent = target.getParent();\n    if (parent == null) {\n        return false;\n    }\n    if (parent.isLabel()) {\n        return parent.getFirstChild().getString().equals(label);\n    }\n    return matchLabel(parent, label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node parent = target.getParent();\n  if (parent == null) {\n    return false;\n  }\n  if (parent.isLabel()) {\n    return parent.getFirstChild().getString().equals(label);\n  }\n  return matchLabel(parent, label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) {\n    return true;\n  }\n  Node parent = target.getParent();\n  if (parent.isLabel()) {\n    return parent.getFirstChild().getString().equals(label);\n  }\n  return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    while (target != null) {\n        if (target.isLabel()) {\n            return target.getFirstChild().getString().equals(label);\n        }\n        target = target.getParent();\n    }\n    return false;\n}",
      "private static boolean matchLabel(Node target, String label)  {\n    if (label == null) {\n        return true;\n    }\n    if (!target.isLabel()) {\n        return false;\n    }\n    Node labelName = target.getFirstChild();\n    return labelName.getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) \n  {\n    return true;\n  }\n  if (!target.isLabel()) \n  {\n    return false;\n  }\n  Node labelName = target.getFirstChild();\n  return labelName.getString().equals(label);\n}",
      "private static boolean matchLabel(Node target, String label)  {\n  if (label == null) \n  {\n    return true;\n  }\n  Node parent = target.getParent();\n  if (parent == null) \n  {\n    return false;\n  }\n  if (parent.isLabel()) \n  {\n    return parent.getFirstChild().getString().equals(label);\n  }\n  return matchLabel(parent, label);\n}"
    ],
    [
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getSeriesURLGenerator(series);\n    if (generator == null) \n    {\n        generator = getBaseURLGenerator();\n    }\n    return generator.generateURL(getDataset(), series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getSeriesURLGenerator(series);\n    if (generator == null) \n    {\n        generator = getBaseURLGenerator();\n    }\n    return generator.generateURL(getDataset(), series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getSeriesURLGenerator(series);\n    if (generator == null) \n    {\n        generator = getBaseURLGenerator();\n    }\n    return generator.generateURL(getDataset(), series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYZDataset dataset = (XYZDataset) getPlot().getDataset();\n    XYURLGenerator generator = getSeriesURLGenerator(series);\n    if (generator == null) {\n        generator = getBaseURLGenerator();\n    }\n    if (generator == null) {\n        return null;\n    }\n    return generator.generateURL(dataset, series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYZDataset dataset = (XYZDataset) getPlot().getDataset();\n    if (dataset == null) {\n        return null;\n    }\n    XYZURLGenerator generator = getURLGenerator(series, item, false);\n    if (generator == null) {\n        return null;\n    }\n    return generator.generateURL(dataset, series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getSeriesURLGenerator(series);\n    if (generator == null) {\n        generator = this.baseURLGenerator;\n    }\n    return generator.generateURL(dataset, series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getSeriesURLGenerator(series);\n    if (generator == null) {\n        generator = this.baseURLGenerator;\n    }\n    return generator.generateURL(getDataset(), series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getSeriesURLGenerator(series);\n    if (generator == null) \n    {\n        generator = this.baseURLGenerator;\n    }\n    return generator.generateURL(getDataset(), series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getSeriesURLGenerator(series);\n    if (generator == null) {\n        generator = getBaseURLGenerator();\n    }\n    return generator.generateURL(getDataset(), series, item);\n}",
      "public String getURL(int series, int item)  {\n    XYURLGenerator generator = getSeriesURLGenerator(series);\n    if (generator == null) \n    {\n        generator = this.baseURLGenerator;\n    }\n    return generator.generateURL(dataset, series, item);\n}"
    ],
    [
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len < 1 || len > 2) {\n        throw new IllegalArgumentException(\"Invalid index: \" + str);\n    }\n    char c = str.charAt(0);\n    if (c < '0' || c > '9') {\n        throw new IllegalArgumentException(\"Invalid index: \" + str);\n    }\n    int index = c - '0';\n    if (len == 2) {\n        c = str.charAt(1);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Invalid index: \" + str);\n        }\n        index = (index * 10) + (c - '0');\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    int index = 0;\n    char c = str.charAt(index++);\n    if (c == '-') {\n        if (index == len) {\n            return -1;\n        }\n        c = str.charAt(index++);\n    }\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    while (index < len) {\n        c = str.charAt(index++);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    return Integer.parseInt(str);\n}\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c == '-') {\n        if (len == 1) {\n            return -1;\n        }\n        return _parseIndex(str.substring(1));\n    }\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    int index = c - '0';\n    for (int i = 1; i < len; ++i) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n        index = (index * 10) + (c - '0');\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len < 1 || len > 10) {\n        throw new IllegalArgumentException(\"Invalid index: \" + str);\n    }\n    int index = 0;\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c > '9' || c < '0') {\n            throw new IllegalArgumentException(\"Invalid index: \" + str);\n        }\n        index = (index * 10) + (c - '0');\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c == '-') {\n        if (len == 1) {\n            return -1;\n        }\n        return parseInt(str.substring(1));\n    }\n    return parseInt(str);\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len < 1 || len > 10) {\n        throw new IllegalArgumentException(\"Invalid index: \" + str);\n    }\n    int i = 0;\n    int index = 0;\n    while (i < len) {\n        char c = str.charAt(i++);\n        if (c < '0' || c > '9') {\n            throw new IllegalArgumentException(\"Invalid index: \" + str);\n        }\n        index = (index * 10) + (c - '0');\n    }\n    return index;\n}\n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c == '-') {\n        if (len == 1) {\n            return -1;\n        }\n        return _parseIndex(str.substring(1));\n    }\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    int num = c - '0';\n    for (int i = 1; i < len; ++i) {\n        c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n        num = (num * 10) + (c - '0');\n    }\n    return num;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    int index = 0;\n    char c = str.charAt(index++);\n    if (c == '-') {\n        if (index == len) {\n            return -1;\n        }\n        c = str.charAt(index++);\n    }\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    int num = c - '0';\n    while (index < len) {\n        c = str.charAt(index++);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n        num = (num * 10) + (c - '0');\n    }\n    return num;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    int i = 0;\n    char c = str.charAt(i++);\n    if (c == '-') {\n        if (i == len) {\n            return -1;\n        }\n        c = str.charAt(i++);\n    }\n    if (c < '0' || c > '9') {\n        return -1;\n    }\n    int index = c - '0';\n    while (i < len) {\n        c = str.charAt(i++);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n        index = (index * 10) + (c - '0');\n    }\n    return index;\n}",
      "private final static int _parseIndex(String str)  {\n    int len = str.length();\n    if (len == 0) {\n        return -1;\n    }\n    char c = str.charAt(0);\n    if (c == '-') {\n        if (len == 1) {\n            return -1;\n        }\n        return parseInt(str.substring(1));\n    }\n    return parseInt(str);\n}\n    /*\n    /**********************************************************\n    /* Public API\n    /**********************************************************"
    ],
    [
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) \n    {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) \n    {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    Object[] index = getNatural(c.size());\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    Object[] out = new Object[k];\n    for (int i = 0; i < k; i++) \n    {\n        out[i] = c.toArray()[index[i]];\n    }\n\n    return out;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) \n    {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) \n    {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    Object[] index = getNatural(c.size());\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    return MathArrays.copyOf(index, k);\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) \n    {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) \n    {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    int[] index = getNatural(c.size());\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    Object[] out = new Object[k];\n    Iterator<?> iter = c.iterator();\n    for (int i = 0; i < k; i++) \n    {\n        out[i] = iter.next();\n    }\n\n    return out;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    int[] index = getNatural(c.size());\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    Object[] out = new Object[k];\n    for (int i = 0; i < k; i++) {\n        out[i] = c.toArray()[index[i]];\n    }\n\n    return out;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) \n    {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N, k, c.size(), true);\n    }\n    if (k <= 0) \n    {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE, k);\n    }\n\n    int[] index = getNatural(c.size());\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    Object[] out = new Object[k];\n    Iterator<?> it = c.iterator();\n    for (int i = 0; i < k; i++) \n    {\n        out[i] = it.next();\n    }\n    return out;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) \n    {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) \n    {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    int[] index = getNatural(c.size());\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Create a new array containing the first \"k\" entries of \"index\".\n    Object[] out = new Object[k];\n    Iterator<?> iter = c.iterator();\n    for (int i = 0; i < k; i++) \n    {\n        out[i] = iter.next();\n    }\n\n    return out;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    Object[] sample = new Object[k];\n    int[] index = getNatural(c.size());\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Copy the first \"k\" entries of \"index\" into \"sample\".\n    for (int i = 0; i < k; i++) {\n        sample[i] = c.toArray()[index[i]];\n    }\n\n    return sample;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    int[] index = getNatural(c.size());\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    Object[] out = new Object[k];\n    for (int i = 0; i < k; i++) {\n        out[i] = c.toArray()[index[i]];\n    }\n\n    return out;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) \n    {\n        throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) \n    {\n        throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,\n                                               k);\n    }\n\n    int[] index = getNatural(c.size());\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Return a new array containing the first \"k\" entries of \"index\".\n    Object[] out = new Object[k];\n    for (int i = 0; i < k; i++) \n    {\n        out[i] = c.toArray()[index[i]];\n    }\n    return out;\n}",
      "public Object[] nextSample(Collection<?> c, int k) throws NumberIsTooLargeException, NotStrictlyPositiveException  {\n    if (k > c.size()) {\n        throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,\n                                            k, c.size(), true);\n    }\n    if (k <= 0) {\n        throw new NotStrictlyPositiveException(LocalizedFormats.SAMPLE_SIZE,\n                                               k);\n    }\n\n    int[] index = getNatural(c.size());\n    MathArrays.shuffle(index, getRandomGenerator());\n\n    // Create a new array containing the first \"k\" entries of \"index\".\n    Object[] out = new Object[k];\n    Iterator<?> iter = c.iterator();\n    for (int i = 0; i < k; i++) {\n        out[i] = iter.next();\n    }\n\n    return out;\n}"
    ],
    [
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n        Node callNode = Node.newString(Token.CALL, methodName);\n        callNode.setSourceInformationFrom(srcref);\n        callNode.addChildToBack(argumentNode);\n        return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = Node.newString(Token.CALL, methodName);\n    callNode.addChildToFront(argumentNode);\n    callNode.setSourceInformationFrom(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = NodeUtil.newCallNode(NodeUtil.newQName(compiler, methodName), argumentNode);\n    callNode.useSourceInfoIfMissingFrom(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = NodeUtil.newCallNode(\n            NodeUtil.newQName(compiler, methodName), argumentNode);\n    callNode.setSourceInformation(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n        Node callNode = Node.newString(Token.CALL, methodName);\n        callNode.setSourceInformation(srcref);\n        callNode.addChildToBack(argumentNode);\n        return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = Node.newString(Token.CALL, methodName);\n    callNode.setSourceInformation(srcref);\n    callNode.addChildToBack(argumentNode);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = Node.newString(Token.CALL, methodName);\n    callNode.addChildToBack(argumentNode);\n    callNode.useSourceInfoIfMissingFromForTree(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n        Node callNode = Node.newString(Token.CALL, methodName);\n        callNode.setSourceInformation(srcref);\n        callNode.addChildToBack(argumentNode);\n        return callNode;\n    }",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = NodeUtil.newCallNode(NodeUtil.newQName(compiler, methodName), argumentNode);\n    callNode.useSourceInfoIfMissingFrom(srcref);\n    return callNode;\n}",
      "protected final Node buildCallNode(String methodName, Node argumentNode,\n                                       Node srcref)  {\n    Node callNode = NodeUtil.newCallNode(NodeUtil.newQName(compiler, methodName), argumentNode);\n    callNode.useSourceInfoIfMissingFromForTree(srcref);\n    return callNode;\n}"
    ],
    [
      "private int[] sortedIndices(final double[] doubles)  {\n    final List<Pair<Double, Integer>> list = new ArrayList<>();\n    for (int i = 0; i < doubles.length; i++) {\n        list.add(new Pair<>(doubles[i], i));\n    }\n    Collections.sort(list, new Comparator<Pair<Double, Integer>>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    List<Pair<Double, Integer>> list = new ArrayList<>();\n    for (int i = 0; i < doubles.length; i++) \n    {\n        list.add(new Pair<>(doubles[i], i));\n    }\n    Collections.sort(list, new Comparator<Pair<Double, Integer>>() \n    {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    List<Pair<Double, Integer>> list = new ArrayList<>();\n    for (int i = 0; i < doubles.length; i++) {\n        list.add(new Pair<>(doubles[i], i));\n    }\n\n    // Sort.\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n    final List<Pair<Double, Integer>> list = new ArrayList<Pair<Double, Integer>>(len);\n    for (int i = 0; i < len; i++) {\n        list.add(new Pair<Double, Integer>(doubles[i], i));\n    }\n\n    // Sort.\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    List<Pair<Double, Integer>> list = new ArrayList<>();\n    for (int i = 0; i < doubles.length; i++) \n    {\n        list.add(new Pair<>(doubles[i], i));\n    }\n\n    Collections.sort(list, new Comparator<Pair<Double, Integer>>() \n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    // Create a list of pairs where each pair contains a value and its index.\n    List<Pair<Double, Integer>> list = new ArrayList<>();\n    for (int i = 0; i < doubles.length; i++) {\n        list.add(new Pair<>(doubles[i], i));\n    }\n\n    // Sort the list by value.\n    Collections.sort(list, new Comparator<Pair<Double, Integer>>() {\n}\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    // Create a list of pairs.\n    final List<Pair<Double, Integer>> list = new ArrayList<Pair<Double, Integer>>(doubles.length);\n    for (int i = 0; i < doubles.length; i++) {\n        list.add(new Pair<Double, Integer>(doubles[i], i));\n    }\n\n    // Sort the list.\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n    final List<Pair<Double, Integer>> list = new ArrayList<Pair<Double, Integer>>(len);\n    for (int i = 0; i < len; i++) {\n        list.add(new Pair<Double, Integer>(doubles[i], i));\n    }\n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    // Create a list of pairs, where each pair consists of a fitness value and its index.\n    List<Pair<Double, Integer>> list = new ArrayList<>();\n    for (int i = 0; i < doubles.length; i++) \n    {\n        list.add(new Pair<>(doubles[i], i));\n    }\n\n    // Sort the list of pairs.\n    Collections.sort(list, new Comparator<Pair<Double, Integer>>() \n}",
      "private int[] sortedIndices(final double[] doubles)  {\n    final int len = doubles.length;\n    final List<Pair<Double, Integer>> list = new ArrayList<>(len);\n    for (int i = 0; i < len; i++) {\n        list.add(new Pair<>(doubles[i], i));\n    }\n    final Comparator<Pair<Double, Integer>> comp\n            = MathArrays.OrderDirection.INCREASING == dir ?\n}"
    ],
    [
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        cachedQt = MatrixUtils.createRealMatrix(m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            final double[] hvI = householderVectors[i];\n            for (int j = 0; j < m; ++j) \n            {\n                cachedQt.setEntry(j, i, hvI[j]);\n            }\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        cachedQt = MatrixUtils.createRealMatrix(m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            final double[] hvI = householderVectors[i];\n            for (int j = 0; j < m; ++j) \n            {\n                cachedQt.setEntry(j, i, hvI[j]);\n            }\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = matrix.getRowDimension();\n        cachedQt = MatrixUtils.createRealMatrix(m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            final double[] hvI = householderVectors[i];\n            for (int j = 0; j < m; ++j) \n            {\n                cachedQt.setEntry(j, i, hvI[j]);\n            }\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        cachedQt = MatrixUtils.createRealMatrix(m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            final double[] hvI = householderVectors[i];\n            for (int j = 0; j < m; ++j) \n            {\n                cachedQt.setEntry(j, i, hvI[j]);\n            }\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = matrix.getRowDimension();\n        cachedQt = MatrixUtils.createRealMatrix(m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            final double[] hvI = householderVectors[i];\n            for (int j = 0; j < m; ++j) \n            {\n                cachedQt.setEntry(j, i, hvI[j]);\n            }\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = matrix.getRowDimension();\n        cachedQt = MatrixUtils.createRealMatrix(m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            final double[] hvI = householderVectors[i];\n            for (int j = 0; j < m; ++j) \n            {\n                cachedQt.setEntry(j, i, hvI[j]);\n            }\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        cachedQt = MatrixUtils.createRealMatrix(m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            final double[] hvI = householderVectors[i];\n            for (int j = 0; j < m; ++j) \n            {\n                cachedQt.setEntry(j, i, hvI[j]);\n            }\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        cachedQt = MatrixUtils.createRealMatrix(m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            final double[] hvI = householderVectors[i];\n            for (int j = 0; j < m; ++j) \n            {\n                cachedQt.setEntry(j, i, hvI[j]);\n            }\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = householderVectors.length;\n        cachedQt = MatrixUtils.createRealMatrix(m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            final double[] hvI = householderVectors[i];\n            for (int j = 0; j < m; ++j) \n            {\n                cachedQt.setEntry(i, j, hvI[j]);\n            }\n        }\n    }\n    return cachedQt;\n}",
      "public RealMatrix getQT()  {\n    if (cachedQt == null) \n    {\n        final int m = matrix.getRowDimension();\n        cachedQt = MatrixUtils.createRealMatrix(m, m);\n        for (int i = 0; i < m; ++i) \n        {\n            final double[] hvI = householderVectors[i];\n            for (int j = 0; j < m; ++j) \n            {\n                cachedQt.setEntry(j, i, hvI[j]);\n            }\n        }\n    }\n    return cachedQt;\n}"
    ],
    [
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable currentGroup = this.keyToGroupMap.get(key);\n    if (currentGroup == null) \n    {\n        currentGroup = this.defaultGroup;\n    }\n    return currentGroup;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable currentGroup = this.keyToGroupMap.get(key);\n    if (currentGroup == null) \n    {\n        currentGroup = this.defaultGroup;\n    }\n    return currentGroup;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable currentGroup = this.keyToGroupMap.get(key);\n    if (currentGroup == null) \n    {\n        currentGroup = this.defaultGroup;\n    }\n    return currentGroup;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable currentGroup = this.keyToGroupMap.get(key);\n    if (currentGroup == null) \n    {\n        currentGroup = this.defaultGroup;\n    }\n    return currentGroup;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = this.keyToGroupMap.get(key);\n    if (group == null) \n    {\n        group = this.defaultGroup;\n    }\n    return group;\n}",
      "public Comparable getGroup(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable currentGroup = this.keyToGroupMap.get(key);\n    if (currentGroup == null) \n    {\n        currentGroup = this.defaultGroup;\n    }\n    return currentGroup;\n}"
    ],
    [
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n        if (set == null) {\n            throw new NullPointerException(\"Set must not be null\");\n        }\n        if (transformer == null) {\n            throw new NullPointerException(\"Transformer must not be null\");\n        }\n        final Set<E> decoratedSet = new HashSet<E>(set.size());\n        for (final E item : set) {\n            decoratedSet.add(transformer.transform(item));\n        }\n        return new TransformedSet<E>(decoratedSet, transformer);\n    }",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    final Set<E> decorated = new HashSet<E>(set.size());\n    for (final E element : set) {\n        decorated.add(transformer.transform(element));\n    }\n    return new TransformedSet<E>(decorated, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    final Set<E> decoratedSet = new HashSet<E>(set.size());\n    for (final E item : set) {\n        decoratedSet.add(transformer.transform(item));\n    }\n    return new TransformedSet<E>(decoratedSet, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    final Set<E> transformedSet = new HashSet<E>(set.size());\n    for (final E item : set) {\n        transformedSet.add(transformer.transform(item));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    final Set<E> decoratedSet = new HashSet<E>(set.size());\n    for (final E item : set) {\n        decoratedSet.add(transformer.transform(item));\n    }\n    return new TransformedSet<E>(decoratedSet, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n        if (set == null) {\n            throw new NullPointerException(\"Set must not be null\");\n        }\n        if (transformer == null) {\n            throw new NullPointerException(\"Transformer must not be null\");\n        }\n        final Set<E> transformedSet = new HashSet<E>();\n        for (final E item : set) {\n            transformedSet.add(transformer.transform(item));\n        }\n        return transformedSet;\n    }",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    final Set<E> transformedSet = new HashSet<E>(set.size());\n    for (final E item : set) {\n        transformedSet.add(transformer.transform(item));\n    }\n    return transformedSet;\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    final Set<E> decoratedSet = new HashSet<E>(set);\n    for (final Iterator<E> it = decoratedSet.iterator(); it.hasNext();) {\n        it.set(transformer.transform(it.next()));\n    }\n    return new TransformedSet<E>(decoratedSet, transformer);\n}",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n        if (set == null) {\n            throw new NullPointerException(\"Set must not be null\");\n        }\n        if (transformer == null) {\n            throw new NullPointerException(\"Transformer must not be null\");\n        }\n        final Set<E> transformedSet = new HashSet<E>(set.size());\n        for (final E element : set) {\n            transformedSet.add(transformer.transform(element));\n        }\n        return transformedSet;\n    }",
      "public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer)  {\n    if (set == null) {\n        throw new NullPointerException(\"Set must not be null\");\n    }\n    if (transformer == null) {\n        throw new NullPointerException(\"Transformer must not be null\");\n    }\n    final Set<E> decoratedSet = new HashSet<E>(set.size());\n    for (final E item : set) {\n        decoratedSet.add(transformer.transform(item));\n    }\n    return new TransformedSet<E>(decoratedSet, transformer);\n}"
    ],
    [
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        char[] old = buffer;\n        buffer = new char[capacity * 2];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final int newLen = (buffer.length * 3) / 2 + 1;\n        final char[] newBuf = new char[Math.max(newLen, capacity)];\n        System.arraycopy(buffer, 0, newBuf, 0, size);\n        buffer = newBuf;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        final int newLen = (buffer.length * 3) / 2;\n        final char[] newBuf = new char[capacity > newLen ? capacity : newLen];\n        System.arraycopy(buffer, 0, newBuf, 0, size);\n        buffer = newBuf;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        char[] newBuf = new char[capacity];\n        System.arraycopy(buffer, 0, newBuf, 0, size);\n        buffer = newBuf;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final char[] old = buffer;\n        buffer = new char[capacity];\n        System.arraycopy(old, 0, buffer, 0, size);\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) {\n        char[] newBuf = new char[capacity];\n        System.arraycopy(buffer, 0, newBuf, 0, size);\n        buffer = newBuf;\n    }\n    return this;\n}",
      "public StrBuilder ensureCapacity(final int capacity)  {\n    if (capacity > buffer.length) \n    {\n        final int newLen = (buffer.length * 3) / 2;\n        final char[] newBuf = new char[capacity > newLen ? capacity : newLen];\n        System.arraycopy(buffer, 0, newBuf, 0, size);\n        buffer = newBuf;\n    }\n    return this;\n}"
    ],
    [
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double lower = Double.POSITIVE_INFINITY;\n    double upper = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getRowCount();\n    for (int s = 0; s < seriesCount; s++) {\n        double total = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int c = 0; c < categoryCount; c++) {\n            Number number = dataset.getValue(s, c);\n            if (number != null) {\n                double value = number.doubleValue();\n                total += value;\n                lower = Math.min(lower, total);\n                upper = Math.max(upper, total);\n            }\n        }\n    }\n    if (lower > upper) {\n        return null;\n    }\n    else {\n        return new Range(lower, upper);\n    }\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                total += value;\n            }\n        }\n        if (total < min) {\n            min = total;\n        }\n        if (total > max) {\n            max = total;\n        }\n    }\n    if (min <= max) {\n        result = new Range(min, max);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getRowCount();\n    for (int s = 0; s < seriesCount; s++) {\n        double total = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int c = 0; c < categoryCount; c++) {\n            Number value = dataset.getValue(s, c);\n            if (value != null) {\n                total += value.doubleValue();\n                min = Math.min(min, total);\n                max = Math.max(max, total);\n            }\n        }\n    }\n    return new Range(min, max);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getRowCount();\n    for (int s = 0; s < seriesCount; s++) {\n        double runningTotal = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int c = 0; c < categoryCount; c++) {\n            Number value = dataset.getValue(s, c);\n            if (value != null) {\n                runningTotal += value.doubleValue();\n                min = Math.min(min, runningTotal);\n                max = Math.max(max, runningTotal);\n            }\n        }\n    }\n    if (min <= max) {\n        result = new Range(min, max);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getRowCount();\n    for (int s = 0; s < seriesCount; s++) {\n        double runningTotal = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int c = 0; c < categoryCount; c++) {\n            Number number = dataset.getValue(s, c);\n            if (number != null) {\n                double value = number.doubleValue();\n                runningTotal += value;\n                min = Math.min(min, runningTotal);\n                max = Math.max(max, runningTotal);\n            }\n        }\n    }\n    if (min <= max) {\n        result = new Range(min, max);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    double minimum = Double.POSITIVE_INFINITY;\n    double maximum = Double.NEGATIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                double value = number.doubleValue();\n                total += value;\n                minimum = Math.min(minimum, total);\n                maximum = Math.max(maximum, total);\n            }\n        }\n    }\n    if (minimum <= maximum) {\n        result = new Range(minimum, maximum);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int rowCount = dataset.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        double runningTotal = 0.0;\n        int columnCount = dataset.getColumnCount();\n        for (int c = 0; c < columnCount; c++) {\n            Number n = dataset.getValue(r, c);\n            if (n != null) {\n                runningTotal += n.doubleValue();\n                min = Math.min(min, runningTotal);\n                max = Math.max(max, runningTotal);\n            }\n        }\n    }\n    return new Range(min, max);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int rowCount = dataset.getRowCount();\n    for (int r = 0; r < rowCount; r++) {\n        double runningTotal = 0.0;\n        int columnCount = dataset.getColumnCount();\n        for (int c = 0; c < columnCount; c++) {\n            Number value = dataset.getValue(r, c);\n            if (value != null) {\n                runningTotal += value.doubleValue();\n                min = Math.min(min, runningTotal);\n                max = Math.max(max, runningTotal);\n            }\n        }\n    }\n    return new Range(min, max);\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    Range result = null;\n    double min = Double.POSITIVE_INFINITY;\n    double max = Double.NEGATIVE_INFINITY;\n    int categoryCount = dataset.getColumnCount();\n    for (int item = 0; item < categoryCount; item++) {\n        double total = 0.0;\n        int seriesCount = dataset.getRowCount();\n        for (int series = 0; series < seriesCount; series++) {\n            Number number = dataset.getValue(series, item);\n            if (number != null) {\n                total += number.doubleValue();\n            }\n        }\n        min = Math.min(min, total);\n        max = Math.max(max, total);\n    }\n    if (min <= max) {\n        result = new Range(min, max);\n    }\n    return result;\n}",
      "public static Range findCumulativeRangeBounds(CategoryDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double lower = Double.POSITIVE_INFINITY;\n    double upper = Double.NEGATIVE_INFINITY;\n    int seriesCount = dataset.getRowCount();\n    for (int s = 0; s < seriesCount; s++) {\n        double total = 0.0;\n        int categoryCount = dataset.getColumnCount();\n        for (int c = 0; c < categoryCount; c++) {\n            Number number = dataset.getValue(s, c);\n            if (number != null) {\n                double value = number.doubleValue();\n                total = total + value;\n                lower = Math.min(lower, total);\n                upper = Math.max(upper, total);\n            }\n        }\n    }\n    if (lower > upper) {\n        return null;\n    }\n    else {\n        return new Range(lower, upper);\n    }\n}"
    ],
    [
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset < 0) {\n        minutesOffset = -minutesOffset;\n    }\n    return new FixedDateTimeZone(hoursOffset * DateTimeConstants.MILLIS_PER_HOUR + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE, \"Offset\" + hoursOffset + \":\" + minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes must be zero or positive if hours is negative\");\n    }\n    if (minutesOffset > 0 && hoursOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be zero or negative if hours is positive\");\n    }\n    return new FixedDateTimeZone(hoursOffset, minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    return new FixedDateTimeZone(hoursOffset, minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour value out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute value out of range: \" + minutesOffset);\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes must be zero or negative when hours is negative\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be zero or positive when hours is positive\");\n    }\n    int totalOffset = hoursOffset * 60 + minutesOffset;\n    return new FixedDateTimeZone(totalOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes must be zero or positive if hours is positive\");\n    }\n    if (minutesOffset > 0 && hoursOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be zero or negative if hours is negative\");\n    }\n    int offsetMillis = hoursOffset * DateTimeConstants.MILLIS_PER_HOUR + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE;\n    return new FixedDateTimeZone(\"UTC+\" + hoursOffset + \":\" + (minutesOffset < 0 ? \"-\" : \"\") + Math.abs(minutesOffset), offsetMillis);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour value out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute value out of range: \" + minutesOffset);\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes must be zero or positive if hours are negative\");\n    }\n    if (minutesOffset > 0 && hoursOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be zero or negative if hours are positive\");\n    }\n    return new FixedDateTimeZone(hoursOffset * DateTimeConstants.MILLIS_PER_HOUR + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE, \"Offset\" + hoursOffset + \":\" + minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (hoursOffset < 0) {\n        if (minutesOffset > 0) {\n            minutesOffset = -minutesOffset;\n            hoursOffset++;\n        }\n    } else if (hoursOffset > 0) {\n        if (minutesOffset < 0) {\n            minutesOffset = 60 + minutesOffset;\n            hoursOffset--;\n        }\n    }\n    return new FixedDateTimeZone(hoursOffset * DateTimeConstants.MILLIS_PER_HOUR + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE, \"FixedOffset\", hoursOffset + \":\" + (minutesOffset < 10 ? \"0\" : \"\") + minutesOffset);\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    if (minutesOffset > 0 && hoursOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be positive when hours are negative\");\n    }\n    return new FixedDateTimeZone(hoursOffset * DateTimeConstants.MILLIS_PER_HOUR + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE, \"UTC\", \"UTC\");\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hour out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minute out of range: \" + minutesOffset);\n    }\n    if (hoursOffset < 0 && minutesOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes must be zero or negative when hours are negative\");\n    }\n    if (hoursOffset > 0 && minutesOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes must be zero or positive when hours are positive\");\n    }\n    return new FixedDateTimeZone(hoursOffset * DateTimeConstants.MILLIS_PER_HOUR + minutesOffset * DateTimeConstants.MILLIS_PER_MINUTE, \"UTC\");\n}",
      "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException  {\n    if (hoursOffset < -23 || hoursOffset > 23) {\n        throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n    }\n    if (minutesOffset < -59 || minutesOffset > 59) {\n        throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n    }\n    if (minutesOffset < 0 && hoursOffset > 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be negative when hours are positive\");\n    }\n    if (minutesOffset > 0 && hoursOffset < 0) {\n        throw new IllegalArgumentException(\"Minutes cannot be positive when hours are negative\");\n    }\n    int offset = hoursOffset * 60 + minutesOffset;\n    return new FixedDateTimeZone(\"FixedOffset[\" + offset + \"]\", offset);\n}"
    ],
    [
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = StringUtil.borrowBuilder();\n    char last = 0;\n    int balance = 0;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (c == open) \n        {\n            balance++;\n        } \n        else if (c == close) \n        {\n            balance--;\n            if (balance == 0) \n            {\n                break;\n            }\n        } \n        else if (c == ESC) \n        {\n            if (last == ESC) \n            {\n                out.append(c);\n            } \n            else \n            {\n                // escape the next character\n                c = consume();\n            }\n        }\n        out.append(c);\n        last = c;\n    }\n    return StringUtil.releaseBuilder(out);\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    int depth = 0;\n    while (!isEmpty())\n    {\n        char c = consume();\n        if (c == open)\n        {\n            depth++;\n        }\n        else if (c == close)\n        {\n            depth--;\n            if (depth == 0)\n            {\n                break;\n            }\n        }\n        sb.append(c);\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    String data = consumeTo(String.valueOf(open));\n    int balance = 1;\n    while (balance > 0) \n    {\n        if (matchConsume(String.valueOf(open)))\n            balance++;\n        else if (matchConsume(String.valueOf(close)))\n            balance--;\n        else if (isEmpty())\n            break;\n        else\n            data += charAt(pos++);\n    }\n    return data;\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = StringUtil.borrowBuilder();\n    int depth = 1;\n    char last = 0;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (c == open) \n        {\n            depth++;\n        } \n        else if (c == close) \n        {\n            depth--;\n            if (depth == 0) \n            {\n                break;\n            }\n        } \n        else if (c == ESC) \n        {\n            if (last == ESC) \n            {\n                out.append(c);\n            } \n            else \n            {\n                out.append(consume());\n            }\n        } \n        else \n        {\n            out.append(c);\n        }\n        last = c;\n    }\n    return StringUtil.releaseBuilder(out);\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder out = new StringBuilder();\n    int balance = 0;\n    boolean escaped = false;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (escaped) \n        {\n            out.append(c);\n            escaped = false;\n        } \n        else if (c == '\\\\') \n        {\n            escaped = true;\n        } \n        else if (c == open) \n        {\n            balance++;\n            out.append(c);\n        } \n        else if (c == close) \n        {\n            if (balance == 0) \n            {\n                break;\n            } \n            else \n            {\n                balance--;\n                out.append(c);\n            }\n        } \n        else \n        {\n            out.append(c);\n        }\n    }\n    return out.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    String data = consumeTo(String.valueOf(open));\n    int depth = 1;\n    while (depth > 0)\n    {\n        if (matchConsume(String.valueOf(open)))\n            depth++;\n        else if (matchConsume(String.valueOf(close)))\n            depth--;\n        else\n            data += consume();\n    }\n    return data;\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    int balance = 0;\n    while (!isEmpty())\n    {\n        char c = consume();\n        if (c == open)\n            balance++;\n        else if (c == close)\n            balance--;\n        sb.append(c);\n        if (balance == 0)\n            break;\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    String data = consumeTo(String.valueOf(open));\n    int balance = 1;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (c == open) \n        {\n            balance++;\n        } \n        else if (c == close) \n        {\n            balance--;\n            if (balance == 0) \n            {\n                break;\n            }\n        } \n        else if (c == ESC) \n        {\n            consume(); // consume escape\n        }\n    }\n    return data;\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    int balance = 1;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (c == open) \n        {\n            balance++;\n        } \n        else if (c == close) \n        {\n            balance--;\n            if (balance == 0) \n            {\n                break;\n            }\n        } \n        sb.append(c);\n    }\n    return sb.toString();\n}",
      "public String chompBalanced(char open, char close)  {\n    StringBuilder sb = new StringBuilder();\n    int depth = 0;\n    while (!isEmpty()) \n    {\n        char c = consume();\n        if (c == open) \n        {\n            depth++;\n        } \n        else if (c == close) \n        {\n            depth--;\n        }\n        sb.append(c);\n        if (depth == 0 && peek() == close) \n        {\n            consume();\n            break;\n        }\n    }\n    return sb.toString();\n}"
    ],
    [
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // check that the data has been loaded\n        if (beta == null) {\n            throw new NullPointerException(\"Data has not been loaded\");\n        }\n\n        // get the number of parameters\n        final int p = beta.getDimension();\n\n        // get the QR decomposition of the X matrix\n        final QRDecomposition qr = new QRDecomposition(getX());\n\n        // get the upper triangular matrix R\n        final RealMatrix R = qr.getR();\n\n        // get the inverse of the upper triangular matrix R\n        final RealMatrix Rinv = R.getInverse();\n\n        // get the transpose of the X matrix\n        final RealMatrix XT = getX().transpose();\n\n        // get the transpose of the inverse of the upper triangular matrix R\n        final RealMatrix RinvT = Rinv.transpose();\n\n        // calculate the variance-covariance matrix of the beta vector\n        final RealMatrix betaVariance = XT.operate(RinvT).operate(XT).transpose();\n\n        // return the result\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Get the inverse of the covariance matrix.\n        RealMatrix OI = getOmegaInverse();\n\n        // Create a matrix to hold the top p rows of R.\n        RealMatrix R = getR().getSubMatrix(0, getBeta().getDimension() - 1, 0, getBeta().getDimension() - 1);\n\n        // Compute the variance-covariance matrix.\n        return R.transpose().multiply(OI).multiply(R);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix QT = getQT();\n        RealMatrix R = getR();\n        RealMatrix Rinv = R.getInverse();\n        RealMatrix QTRinv = QT.multiply(Rinv);\n        return QTRinv.multiply(QTRinv.transpose());\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        if (betaVariance == null) {\n            RealMatrix R = getR();\n            int p = getBeta().getDimension();\n            RealMatrix Rp = R.getSubMatrix(0, p - 1, 0, p - 1);\n            RealMatrix RpT = Rp.transpose();\n            RealMatrix RpTRp = RpT.multiply(Rp);\n            betaVariance = RpTRp.getInverse();\n        }\n        return betaVariance;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n    // Get the inverse of the covariance matrix.\n    RealMatrix OI = getOmegaInverse();\n\n    // Get the top p rows of R.\n    RealMatrix R = getR().getSubMatrix(0, getBeta().getDimension() - 1, 0, getBeta().getDimension() - 1);\n\n    // Compute R<sup>T</sup>R.\n    RealMatrix RTR = R.transpose().multiply(R);\n\n    // Compute (R<sup>T</sup>R)<sup>-1</sup>.\n    RealMatrix RTRInverse = new LUDecomposition(RTR).getSolver().getInverse();\n\n    // Compute (R<sup>T</sup>R)<sup>-1</sup>R<sup>T</sup>X<sup>T</sup>X<sup>-1</sup>.\n    RealMatrix RTRRTRT = RTRInverse.multiply(R.transpose()).multiply(getX().transpose()).multiply(OI);\n\n    // Compute Var(b) = (R<sup>T</sup>R)<sup>-1</sup>R<sup>T</sup>X<sup>T</sup>X<sup>-1</sup>R<sup>T</sup>.\n    return RTRRTRT.multiply(R.transpose());\n}",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTOIX = XT.multiply(getOmegaInverse()).multiply(getX());\n        RealMatrix inverse = new LUDecomposition(XTOIX).getSolver().getInverse();\n        return inverse;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n    if (getX().getColumnDimension() != getBeta().getDimension()) {\n        throw new IllegalStateException(\"Number of columns in X must be equal to the dimension of beta\");\n    }\n    if (getX().getRowDimension() != getY().getDimension()) {\n        throw new IllegalStateException(\"Number of rows in X must be equal to the dimension of y\");\n    }\n    if (getX().getRowDimension() != getOmegaInverse().getRowDimension()) {\n        throw new IllegalStateException(\"Number of rows in X must be equal to the dimension of OmegaInverse\");\n    }\n    if (getX().getColumnDimension() != getOmegaInverse().getColumnDimension()) {\n        throw new IllegalStateException(\"Number of columns in X must be equal to the dimension of OmegaInverse\");\n    }\n    RealMatrix XT = getX().transpose();\n    RealMatrix XTOIX = XT.multiply(getOmegaInverse()).multiply(getX());\n    RealMatrix inverse = new LUDecomposition(XTOIX).getSolver().getInverse();\n    return inverse.multiply(XT).multiply(getOmegaInverse()).operate(XT).multiply(getOmegaInverse());\n}",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        // Check that data has been loaded.\n        if (getX() == null || getY() == null) {\n            throw new NullPointerException(\"No data has been loaded.\");\n        }\n\n        // Get the number of parameters.\n        final int p = getBeta().getDimension();\n\n        // Get the QR decomposition.\n        final QRDecomposition qr = new QRDecomposition(getX());\n\n        // Get the R matrix.\n        final RealMatrix R = qr.getR();\n\n        // Get the R^T matrix.\n        final RealMatrix Rt = R.transpose();\n\n        // Get the R^T R matrix.\n        final RealMatrix RtR = Rt.multiply(R);\n\n        // Get the inverse of R^T R matrix.\n        final RealMatrix RtRinv = RtR.getInverse();\n\n        // Get the Q matrix.\n        final RealMatrix Q = qr.getQ();\n\n        // Get the Q^T matrix.\n        final RealMatrix Qt = Q.transpose();\n\n        // Get the Q^T R^T R Q matrix.\n        final RealMatrix QtRtRQ = Qt.multiply(RtR).multiply(Q);\n\n        // Get the Q^T R^T R Q matrix minus the identity matrix.\n        final RealMatrix QtRtRQMinusI = QtRtRQ.subtract(MatrixUtils.createRealIdentityMatrix(p));\n\n        // Get the variance-covariance matrix.\n        final RealMatrix betaVar = QtRtRQMinusI.multiply(RtRinv);\n\n        return betaVar;\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        if (beta == null) {\n            throw new NullPointerException(\"Beta has not been computed yet.\");\n        }\n\n        RealMatrix XT = getX().transpose();\n        RealMatrix XTX = XT.multiply(getX());\n        RealMatrix R = getR();\n        RealMatrix RTR = R.transpose().multiply(R);\n        RealMatrix inverse = new LUDecomposition(RTR).getSolver().getInverse();\n        return inverse.multiply(XTX).multiply(XT);\n    }",
      "@Override\n    protected RealMatrix calculateBetaVariance()  {\n        if (getX() == null || getY() == null) \n        {\n            throw new NullPointerException(\"No data has been loaded\");\n        }\n        // Compute transpose(X)X.\n        final RealMatrix xT = getX().transpose();\n        final RealMatrix xTx = xT.multiply(getX());\n\n        // Compute the beta variance-covariance matrix.\n        final DecompositionSolver solver\n            = new QRDecomposition(xTx, threshold).getSolver();\n        return solver.getInverse();\n    }"
    ],
    [
      "private static String printOffset(int offset)  {\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        int minutes = (offset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n        StringBuilder buf = new StringBuilder(6);\n        if (hours < 0) {\n            buf.append('-');\n            hours = -hours;\n        } else {\n            buf.append('+');\n        }\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        if (minutes != 0) {\n            buf.append(':');\n            FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        }\n        return buf.toString();\n    }",
      "private static String printOffset(int offset)  {\n        StringBuilder buf = new StringBuilder(6);\n        if (offset < 0) {\n            buf.append('-');\n            offset = -offset;\n        } else {\n            buf.append('+');\n        }\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        int minutes = (offset % DateTimeConstants.MILLIS_PER_HOUR) / DateTimeConstants.MILLIS_PER_MINUTE;\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        return buf.toString();\n    }",
      "private static String printOffset(int offset)  {\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        int minutes = (offset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n        StringBuilder buf = new StringBuilder();\n        if (hours < 0) {\n            buf.append('-');\n            hours = -hours;\n        } else {\n            buf.append('+');\n        }\n        buf.append(hours);\n        if (minutes != 0) {\n            buf.append(':');\n            if (minutes < 10) {\n                buf.append('0');\n            }\n            buf.append(minutes);\n        }\n        return buf.toString();\n    }",
      "private static String printOffset(int offset)  {\n    int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (offset % DateTimeConstants.MILLIS_PER_HOUR) / DateTimeConstants.MILLIS_PER_MINUTE;\n    StringBuilder buf = new StringBuilder(6);\n    if (hours < 0) {\n        buf.append('-');\n        hours = -hours;\n    } else {\n        buf.append('+');\n    }\n    FormatUtils.appendPaddedInteger(buf, hours, 2);\n    if (minutes != 0) {\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n    }\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        int minutes = (offset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n        return (offset < 0 ? \"-\" : \"+\") + (hours < 10 ? \"0\" : \"\") + hours + \":\" + (minutes < 10 ? \"0\" : \"\") + minutes;\n    }",
      "private static String printOffset(int offset)  {\n    int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (offset - (hours * DateTimeConstants.MILLIS_PER_HOUR)) / DateTimeConstants.MILLIS_PER_MINUTE;\n    StringBuilder buf = new StringBuilder(6);\n    if (hours < 0) {\n        buf.append('-');\n        hours = -hours;\n    } else {\n        buf.append('+');\n    }\n    buf.append(hours);\n    buf.append(':');\n    if (minutes < 10) {\n        buf.append('0');\n    }\n    buf.append(minutes);\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    if (offset == 0) \n    {\n        return \"Z\";\n    }\n    StringBuilder buf = new StringBuilder(6);\n    if (offset < 0) \n    {\n        buf.append('-');\n        offset = -offset;\n    } \n    else \n    {\n        buf.append('+');\n    }\n    int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n    FormatUtils.appendPaddedInteger(buf, hours, 2);\n    int minutes = offset % DateTimeConstants.MILLIS_PER_HOUR;\n    minutes /= DateTimeConstants.MILLIS_PER_MINUTE;\n    if (minutes != 0) \n    {\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n    }\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (offset % DateTimeConstants.MILLIS_PER_HOUR) / DateTimeConstants.MILLIS_PER_MINUTE;\n    int seconds = (offset % DateTimeConstants.MILLIS_PER_MINUTE) / DateTimeConstants.MILLIS_PER_SECOND;\n    StringBuilder buf = new StringBuilder();\n    if (hours < 0) {\n        buf.append('-');\n        hours = -hours;\n    } else {\n        buf.append('+');\n    }\n    buf.append(hours);\n    if (minutes != 0 || seconds != 0) {\n        buf.append(':');\n        if (minutes < 10) {\n            buf.append('0');\n        }\n        buf.append(minutes);\n        if (seconds != 0) {\n            buf.append(':');\n            if (seconds < 10) {\n                buf.append('0');\n            }\n            buf.append(seconds);\n        }\n    }\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n    int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n    int minutes = (offset % DateTimeConstants.MILLIS_PER_HOUR) / DateTimeConstants.MILLIS_PER_MINUTE;\n    int seconds = (offset % DateTimeConstants.MILLIS_PER_MINUTE) / DateTimeConstants.MILLIS_PER_SECOND;\n    StringBuilder buf = new StringBuilder();\n    if (hours < 0) {\n        buf.append('-');\n        hours = -hours;\n    } else {\n        buf.append('+');\n    }\n    buf.append(hours);\n    if (minutes != 0 || seconds != 0) {\n        buf.append(':');\n        buf.append(String.format(\"%02d\", minutes));\n        if (seconds != 0) {\n            buf.append(':');\n            buf.append(String.format(\"%02d\", seconds));\n        }\n    }\n    return buf.toString();\n}",
      "private static String printOffset(int offset)  {\n        int hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\n        int minutes = (offset % DateTimeConstants.MILLIS_PER_HOUR) / DateTimeConstants.MILLIS_PER_MINUTE;\n        StringBuilder buf = new StringBuilder(6);\n        if (hours < 0) {\n            buf.append('-');\n            hours = -hours;\n        } else {\n            buf.append('+');\n        }\n        FormatUtils.appendPaddedInteger(buf, hours, 2);\n        buf.append(':');\n        FormatUtils.appendPaddedInteger(buf, minutes, 2);\n        return buf.toString();\n    }"
    ],
    [
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = getGroup(key);\n    int index = getGroupIndex(group);\n    return index;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = getGroup(key);\n    return getGroupIndex(group);\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = -1;\n    Comparable group = (Comparable) this.keyToGroupMap.get(key);\n    if (group != null) {\n        result = this.groups.indexOf(group) + 1;\n    }\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = -1;\n    Comparable group = getGroup(key);\n    if (group != null) \n    {\n        result = getGroupIndex(group);\n    }\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = this.keys.indexOf(key);\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = this.keyToGroupMap.indexOf(key);\n    if (result < 0) \n    {\n        result = -1;\n    }\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = getGroup(key);\n    int groupIndex = getGroupIndex(group);\n    return groupIndex;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    Comparable group = getGroup(key);\n    int result = getGroupIndex(group);\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    int result = -1;\n    Comparable group = getGroup(key);\n    if (group != null) {\n        result = getGroupIndex(group);\n    }\n    return result;\n}",
      "public int getIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.keyToGroupMap.getGroupIndex(key);\n}"
    ],
    [
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> flowSlots = new HashMap<>();\n    for (StaticSlot<JSType> slot : functionScope.getAllSymbols()) {\n        if (!slot.isDeclaredInFunctionScope() || !slot.isLocal()) {\n            flowSlots.put(slot.getName(), slot);\n        }\n    }\n    return flowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> flowSlots = new HashMap<>();\n    for (StaticSlot<JSType> slot : functionScope.getAllSymbols()) {\n      if (!dirtySymbols.contains(slot.getName())) {\n        flowSlots.put(slot.getName(), slot);\n      }\n    }\n    return flowSlots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    for (StaticSlot<JSType> slot : getSymbols().values()) {\n      if (!isDirty(slot.getName())) {\n        slots.put(slot.getName(), slot);\n      }\n    }\n    return slots;\n  }",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    for (LinkedFlowSlot slot = this; slot != null; slot = slot.parent) {\n        slots.put(slot.getName(), slot);\n    }\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> flowSlots = new HashMap<>();\n    LinkedFlowSlot slot = this;\n    while (slot != null) \n    {\n        for (StaticSlot<JSType> symbol : slot.symbols.values()) \n        {\n            flowSlots.put(symbol.getName(), symbol);\n        }\n        slot = slot.parent;\n    }\n    return flowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    for (StaticSlot<JSType> slot : functionScope.getAllSymbols()) {\n        if (!dirtySymbols.contains(slot.getName())) {\n            slots.put(slot.getName(), slot);\n        }\n    }\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    for (Map.Entry<String, StaticSlot<JSType>> entry : functionScope.getAllSymbols().entrySet()) {\n        if (!entry.getValue().isDeclared()) {\n            continue;\n        }\n        slots.put(entry.getKey(), entry.getValue());\n    }\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    for (StaticSlot<JSType> slot : getSymbols().values()) \n    {\n        if (!slot.isDeclared()) \n        {\n            slots.put(slot.getName(), slot);\n        }\n    }\n    return slots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> flowSlots = new HashMap<>();\n    LinkedFlowSlot slot = this;\n    while (slot != null) {\n        for (StaticSlot<JSType> symbol : slot.getSymbols()) {\n            flowSlots.put(symbol.getName(), symbol);\n        }\n        slot = slot.getParent();\n    }\n    return flowSlots;\n}",
      "private Map<String, StaticSlot<JSType>> allFlowSlots()  {\n    Map<String, StaticSlot<JSType>> slots = new HashMap<>();\n    for (LinkedFlowSlot slot = this; slot != null; slot = slot.parent) \n    {\n        slots.putAll(slot.symbols);\n    }\n    return slots;\n}"
    ],
    [
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) \n    {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) \n    {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) \n    {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) \n    {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) \n    {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) \n    {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) \n    {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) \n    {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) \n    {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) \n    {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) \n    {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) \n    {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}",
      "public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException  {\n    if (columnData == null) {\n        throw new NullArgumentException();\n    }\n    final int nRows = columnData.length;\n    if (nRows == 0) {\n        throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n    }\n    final RealMatrix m = createRealMatrix(nRows, 1);\n    for (int i = 0; i < nRows; ++i) {\n        m.setEntry(i, 0, columnData[i]);\n    }\n    return m;\n}"
    ],
    [
      "public static double atanh(double a)  {\n    if (a == 1.0) \n    {\n        return Double.POSITIVE_INFINITY;\n    }\n    else if (a == -1.0) \n    {\n        return Double.NEGATIVE_INFINITY;\n    }\n    else \n    {\n        return 0.5 * FastMath.log((1 + a) / (1 - a));\n    }\n}",
      "public static double atanh(double a)  {\n    if (a < 0) {\n        return -atanh(-a);\n    } else if (a == 1) {\n        return Double.POSITIVE_INFINITY;\n    } else if (a == 0) {\n        return 0;\n    } else {\n        double hiPrec[] = new double[2];\n        expm1(a, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        /* Numerator */\n        double na = ya;\n        double nb = yb;\n\n        /* Denominator */\n        double da = 1.0 + ya;\n        double db = -(da - 1.0 - ya);\n        double temp = da + yb;\n        db += -(temp - da - yb);\n        da = temp;\n\n        temp = da * HEX_40000000;\n        double daa = da + temp - temp;\n        double dab = da - daa;\n\n        // ratio = na/da\n        double ratio = na/da;\n        temp = ratio * HEX_40000000;\n        double ratioa = ratio + temp - temp;\n        double ratiob = ratio - ratioa;\n\n        // Correct for rounding in division\n        ratiob += (na - daa*ratioa - daa*ratiob - dab*ratioa - dab*ratiob) / da;\n\n        // Account for nb\n        ratiob += nb / da;\n        // Account for db\n        ratiob += -db * na / da / da;\n\n        double result = ratioa + ratiob;\n\n        return result;\n    }\n}",
      "public static double atanh(double a)  {\n    if (a == 1.0) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (a == -1.0) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (a == 0.0) {\n        return 0.0;\n    }\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n    double result = log1p(2 * a) / 2;\n    if (negative) {\n        result = -result;\n    }\n    return result;\n}",
      "public static double atanh(double a)  {\n    if (a < 0) {\n        return -atanh(-a);\n    }\n    if (a == 1) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (a == 0) {\n        return 0;\n    }\n    double x = a;\n    double y = 0;\n    double z = 1;\n    while (true) {\n        double xx = x * x;\n        double yy = y * y;\n        double zz = z * z;\n        double xy = x * y;\n        double yz = y * z;\n        double zx = z * x;\n        double xxxy = xx * xy;\n        double yyzz = yy * yz;\n        double zzxx = zz * zx;\n        double xxyyzz = xxyy * zz;\n        double xyzzxx = xy * zzxx;\n        double yzzxxxy = yzz * xxyy;\n        double zzxxxyy = zzxx * xy;\n        double xxyyzzxx = xxyyzz * xx;\n        double xyzzxxxyy = xyzzxx * yy;\n        double zzxxxyyyzz = zzxxxyy * zz;\n        double xyzzxxxyyyzz = xyzzxxxyy * zz;\n        double xyzzxxxyyyzzxx = xyzzxxxyyyzz * xx;\n        double xyzzxxxyyyzzxy = xyzzxxxyyyzz * xy;\n        double xyzzxxxyyyzzxyy = xyzzxxxyyyzz * xy;\n        double xyzzxxxyyyzzxyyy = xyzzxxxyyyzz * xy;\n        double xyzzxxxyyyzzxyyyz = xyzzxxxyyyzz * xy;\n        double xyzzxxxyyyzzxyyyzz = xyzzxxxyyyzz * xy;\n        double xyzzxxxyyyzzxyyyzzx = xyzzxxxyyyzz * xx;\n}\n}",
      "public static double atanh(double a)  {\n    if (a == 1.0) \n    {\n        return INFINITY;\n    } \n    else if (a == -1.0) \n    {\n        return -INFINITY;\n    } \n    else \n    {\n        return 0.5 * log((1 + a) / (1 - a));\n    }\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) \n    {\n        negative = true;\n        a = -a;\n    }\n\n    if (a == 1.0) \n    {\n        return Double.POSITIVE_INFINITY;\n    } \n    else if (a == -1.0) \n    {\n        return Double.NEGATIVE_INFINITY;\n    } \n    else \n    {\n        double result = log1p(2 * a) / 2;\n        if (negative) \n        {\n            result = -result;\n        }\n        return result;\n    }\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n    if (a == 1) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (a == 0) {\n        return 0;\n    }\n    double result = FastMath.log((1 + a) / (1 - a));\n    if (negative) {\n        result = -result;\n    }\n    return result;\n}",
      "public static double atanh(double a)  {\n    if (a < 0) \n    {\n        return -atanh(-a);\n    }\n    else if (a >= 1) \n    {\n        return Double.POSITIVE_INFINITY;\n    }\n    else if (a <= -1) \n    {\n        return Double.NEGATIVE_INFINITY;\n    }\n    else \n    {\n        double result = 0.5 * FastMath.log((1 + a) / (1 - a));\n        return result;\n    }\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) \n    {\n        negative = true;\n        a = -a;\n    }\n\n    double result;\n    if (a >= 0.5) \n    {\n        double hiPrec[] = new double[2];\n        // atanh(x) = (log(1 + x) - log(1 - x)) / 2\n        log(1.0 + a, 0.0, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        double temp = ya * HEX_40000000;\n        double yaa = ya + temp - temp;\n        double yab = ya - yaa;\n\n        // recip = 1/y\n        double recip = 1.0/ya;\n        temp = recip * HEX_40000000;\n        double recipa = recip + temp - temp;\n        double recipb = recip - recipa;\n\n        // Correct for rounding in division\n        recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n        // Account for yb\n        recipb += -yb * recip * recip;\n\n        recipa = -recipa;\n        recipb = -recipb;\n\n        // y = y + 1/y\n        temp = ya + recipa;\n        yb += -(temp - ya - recipa);\n        ya = temp;\n        temp = ya + recipb;\n        yb += -(temp - ya - recipb);\n        ya = temp;\n\n        result = ya + yb;\n        result *= 0.5;\n    } \n    else \n    {\n        double hiPrec[] = new double[2];\n        // atanh(x) = log(1 + 2x) / 2\n        log(1.0 + 2.0 * a, 0.0, hiPrec);\n        double ya = hiPrec[0] + hiPrec[1];\n}\n}",
      "public static double atanh(double a)  {\n    boolean negative = false;\n    if (a < 0) {\n        negative = true;\n        a = -a;\n    }\n\n    if (a >= 1.0) {\n        return Double.POSITIVE_INFINITY;\n    }\n    if (a <= -1.0) {\n        return Double.NEGATIVE_INFINITY;\n    }\n    if (a == 0.0) {\n        return a;\n    }\n\n    double result;\n    if (a > 0.5) {\n        double hiPrec[] = new double[2];\n        // atanh(x) = log((1 + x) / (1 - x)) / 2\n        log((1 + a) / (1 - a), 0.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        // y = y + 1/y\n        double temp = ya + 1.0;\n        yb += -(temp - ya - 1.0);\n        ya = temp;\n        temp = ya + yb;\n        yb += -(temp - ya - yb);\n        ya = temp;\n\n        result = ya + yb;\n        result *= 0.5;\n    } else {\n        double hiPrec[] = new double[2];\n        // atanh(x) = log((1 + x) / (1 - x)) / 2\n        log((1 + a) / (1 - a), 0.0, hiPrec);\n\n        double ya = hiPrec[0] + hiPrec[1];\n        double yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n        // y = y - 1/y\n        double temp = ya - 1.0;\n        yb += -(temp - ya + 1.0);\n        ya = temp;\n        temp = ya + yb;\n        yb += -(temp - ya - yb);\n        ya = temp;\n\n        result = ya + yb;\n        result *= 0.5;\n    }\n}"
    ],
    [
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE_SUM, normalizedSum);\n    }\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isInfinite(values[i])) {\n            throw new MathArithmeticException(LocalizedFormats.INFINITE_ARRAY_ELEMENT);\n        }\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_ARRAY_SUM);\n    }\n    double[] normalized = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalized[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalized[i] = values[i];\n        }\n    }\n    return normalized;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE_SUM, normalizedSum);\n        }\n        double sum = 0.0;\n        boolean hasNaN = false;\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                hasNaN = true;\n            } else {\n                sum += values[i];\n            }\n        }\n        if (Double.isInfinite(sum) || sum == 0.0) {\n            throw new MathArithmeticException(LocalizedFormats.NORMALIZE_ZERO_SUM);\n        }\n        if (hasNaN) {\n            return Arrays.copyOf(values, values.length);\n        }\n        double[] result = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n        return result;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        double sum = 0.0;\n        boolean hasNaN = false;\n        for (double value : values) {\n            if (Double.isNaN(value)) {\n                hasNaN = true;\n            } else {\n                sum += value;\n            }\n        }\n        if (hasNaN) {\n            // Copy the NaNs to the output array.\n            double[] result = new double[values.length];\n            System.arraycopy(values, 0, result, 0, values.length);\n            return result;\n        }\n        if (Double.isInfinite(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE_SUM, normalizedSum);\n        }\n        if (Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN_SUM, normalizedSum);\n        }\n        if (sum == 0.0) {\n            throw new MathArithmeticException(LocalizedFormats.NORMALIZE_ZERO_SUM);\n        }\n        double[] result = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n        return result;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE_SUM, normalizedSum);\n    }\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            continue;\n        }\n        if (Double.isInfinite(values[i])) {\n            throw new MathArithmeticException(LocalizedFormats.NORMALIZE_INFINITE_ELEMENT);\n        }\n        sum += values[i];\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.NORMALIZE_ZERO_SUM);\n    }\n    double[] normalized = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isNaN(values[i])) {\n            normalized[i] = Double.NaN;\n        } else {\n            normalized[i] = values[i] * normalizedSum / sum;\n        }\n    }\n    return normalized;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = 0;\n    for (double value : values) {\n        if (Double.isInfinite(value)) {\n            throw new MathArithmeticException(LocalizedFormats.INFINITE_ARRAY_ELEMENT);\n        }\n        if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE_SUM, normalizedSum);\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_ARRAY_SUM);\n    }\n    double[] normalizedValues = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalizedValues[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalizedValues[i] = Double.NaN;\n        }\n    }\n    return normalizedValues;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        double sum = 0;\n        boolean hasNaN = false;\n        for (int i = 0; i < values.length; i++) {\n            if (Double.isNaN(values[i])) {\n                hasNaN = true;\n            } else {\n                sum += values[i];\n            }\n        }\n        if (hasNaN) {\n            return values.clone();\n        }\n        if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE_SUM, normalizedSum);\n        }\n        if (sum == 0) {\n            throw new MathArithmeticException(LocalizedFormats.NORMALIZE_ZERO_SUM);\n        }\n        double[] result = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            result[i] = values[i] * normalizedSum / sum;\n        }\n        return result;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    double sum = 0;\n    for (int i = 0; i < values.length; i++) {\n        if (Double.isInfinite(values[i])) {\n            throw new MathArithmeticException(LocalizedFormats.INFINITE_ELEMENT_IN_ARRAY);\n        }\n        if (!Double.isNaN(values[i])) {\n            sum += values[i];\n        }\n    }\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE_OR_NAN_SUM, normalizedSum);\n    }\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.NORMALIZE_ZERO_SUM);\n    }\n    double[] normalized = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        if (!Double.isNaN(values[i])) {\n            normalized[i] = values[i] * normalizedSum / sum;\n        } else {\n            normalized[i] = Double.NaN;\n        }\n    }\n    return normalized;\n}",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        if (Double.isNaN(normalizedSum) || Double.isInfinite(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE_SUM, normalizedSum);\n        }\n\n        double sum = 0.0;\n        int count = 0;\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                sum += values[i];\n                count++;\n            }\n        }\n\n        if (count == 0) {\n            throw new MathArithmeticException(LocalizedFormats.NO_NON_NaN_ELEMENTS_IN_ARRAY);\n        }\n\n        if (Double.isInfinite(sum)) {\n            throw new MathArithmeticException(LocalizedFormats.NORMALIZE_INFINITE_SUM, sum);\n        }\n\n        if (sum == 0.0) {\n            throw new MathArithmeticException(LocalizedFormats.NORMALIZE_ZERO_SUM);\n        }\n\n        double[] result = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            if (!Double.isNaN(values[i])) {\n                result[i] = values[i] * normalizedSum / sum;\n            } else {\n                result[i] = values[i];\n            }\n        }\n\n        return result;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n        double sum = 0.0;\n        boolean hasNaN = false;\n        for (double value : values) {\n            if (Double.isNaN(value)) {\n                hasNaN = true;\n            } else {\n                sum += value;\n            }\n        }\n        if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE_SUM, normalizedSum);\n        }\n        if (Double.isInfinite(sum) || sum == 0.0) {\n            throw new MathArithmeticException(LocalizedFormats.NORMALIZE_ZERO_SUM);\n        }\n        if (hasNaN) {\n            return Arrays.copyOf(values, values.length);\n        }\n        double[] normalized = new double[values.length];\n        for (int i = 0; i < values.length; i++) {\n            normalized[i] = values[i] * normalizedSum / sum;\n        }\n        return normalized;\n    }",
      "public static double[] normalizeArray(double[] values, double normalizedSum)\n         throws MathIllegalArgumentException, MathArithmeticException  {\n    if (Double.isInfinite(normalizedSum) || Double.isNaN(normalizedSum)) {\n        throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE_SUM, normalizedSum);\n    }\n\n    double sum = 0;\n    for (double value : values) {\n        if (Double.isInfinite(value)) {\n            throw new MathArithmeticException(LocalizedFormats.INFINITE_ARRAY_ELEMENT);\n        } else if (!Double.isNaN(value)) {\n            sum += value;\n        }\n    }\n\n    if (sum == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_ARRAY_SUM);\n    }\n\n    double[] result = new double[values.length];\n    for (int i = 0; i < values.length; i++) {\n        double value = values[i];\n        if (!Double.isNaN(value)) {\n            result[i] = value * normalizedSum / sum;\n        } else {\n            result[i] = value;\n        }\n    }\n\n    return result;\n}"
    ],
    [
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}",
      "public static String capitalize(final String str, final char... delimiters)  {\n    final int delimLen = delimiters == null ? -1 : delimiters.length;\n    if (StringUtils.isEmpty(str) || delimLen == 0) {\n        return str;\n    }\n    final char[] buffer = str.toCharArray();\n    boolean capitalizeNext = true;\n    for (int i = 0; i < buffer.length; i++) {\n        final char ch = buffer[i];\n        if (isDelimiter(ch, delimiters)) {\n            capitalizeNext = true;\n        } else if (capitalizeNext) {\n            buffer[i] = Character.toTitleCase(ch);\n            capitalizeNext = false;\n        }\n    }\n    return new String(buffer);\n}"
    ],
    [
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    if (instant == null) \n    {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) \n    {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } \n    else if (bucket.getZone() != null) \n    {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone != null) \n    {\n        instant.setZone(iZone);\n    }\n    return new MutableDateTime(instant);\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    if (text == null) \n    {\n        throw new IllegalArgumentException(\"Text must not be null\");\n    }\n    \n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    \n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) \n    {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } \n    else if (bucket.getZone() != null) \n    {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone != null) \n    {\n        instant.setZone(iZone);\n    }\n    return new MutableDateTime(instant);\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    if (instant == null) \n    {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    \n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    \n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) \n    {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } \n    else if (bucket.getZone() != null) \n    {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone != null) \n    {\n        instant.setZone(iZone);\n    }\n    return new MutableDateTime(instant);\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    if (text == null) \n    {\n        throw new IllegalArgumentException(\"Text must not be null\");\n    }\n    \n    long instantMillis = 0;\n    Chronology chrono = iChrono;\n    int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    \n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instantMillis = bucket.computeMillis(false, text);\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) \n    {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } \n    else if (bucket.getZone() != null) \n    {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    MutableDateTime dt = new MutableDateTime(instantMillis, chrono);\n    if (iZone != null) \n    {\n        dt.setZone(iZone);\n    }\n    return dt;\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) \n    {\n        if (newPos >= text.length()) \n        {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) \n            {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } \n            else if (bucket.getZone() != null) \n            {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) \n            {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } \n    else \n    {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            MutableDateTime dt = new MutableDateTime(millis, chrono);\n            if (iZone != null) {\n                dt.setZone(iZone);\n            }\n            return dt;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    if (instant == null) \n    {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    \n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    \n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) \n    {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } \n    else if (bucket.getZone() != null) \n    {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone != null) \n    {\n        instant.setZone(iZone);\n    }\n    return new MutableDateTime(instant);\n}",
      "public MutableDateTime parseMutableDateTime(String text)  {\n    DateTimeParser parser = requireParser();\n    if (instant == null) \n    {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n        instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(false, text));\n    if (iOffsetParsed && bucket.getOffsetInteger() != null) \n    {\n        int parsedOffset = bucket.getOffsetInteger();\n        DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n        chrono = chrono.withZone(parsedZone);\n    } \n    else if (bucket.getZone() != null) \n    {\n        chrono = chrono.withZone(bucket.getZone());\n    }\n    instant.setChronology(chrono);\n    if (iZone != null) \n    {\n        instant.setZone(iZone);\n    }\n    return new MutableDateTime(instant);\n}"
    ],
    [
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealVector XTOIXI = new LUDecomposition(XTOIX).getSolver().getInverse().operate(getX().transpose());\n        return XTOIXI.operate(OI.operate(getY()));\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealVector XTOIX_inv = new LUDecomposition(XTOIX).getSolver().getInverse().operate(getX().transpose().multiply(OI).operate(getY()));\n        return XTOIX_inv;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealVector XTOIX_inv = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealMatrix XTOIX_inv_X = XTOIX_inv.multiply(getX());\n        RealVector XTOIX_inv_y = XTOIX_inv.operate(getY());\n        return XTOIX_inv_X.operate(XTOIX_inv_y);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealVector XTOIXI = new LUDecomposition(XTOIX).getSolver().getInverse().operate(getX().transpose().multiply(OI).operate(getY()));\n        return XTOIXI;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealVector XTOIXI = new LUDecomposition(XTOIX).getSolver().getInverse().operate(getX().transpose());\n        return XTOIXI.operate(OI.operate(getY()));\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealVector XTOIXI = new LUDecomposition(XTOIX).getSolver().getInverse().operate(getX().transpose().multiply(OI).operate(getY()));\n        return XTOIXI;\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealVector XTOIXI = XTOIX.operate(getY());\n        return OI.operate(XTOIXI);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXinv = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealMatrix XTOIXinvXTOI = XTOIXinv.multiply(getX().transpose()).multiply(OI);\n        RealVector y = getY();\n        return XTOIXinvXTOI.operate(y);\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealVector XTOIXI = new LUDecomposition(XTOIX).getSolver().getInverse().operate(getX().transpose());\n        return XTOIXI.operate(OI.operate(getY()));\n    }",
      "@Override\n    protected RealVector calculateBeta()  {\n        RealMatrix OI = getOmegaInverse();\n        RealMatrix XTOIX = getX().transpose().multiply(OI).multiply(getX());\n        RealMatrix XTOIXinv = new LUDecomposition(XTOIX).getSolver().getInverse();\n        RealMatrix XTOIXinvX = XTOIXinv.multiply(getX().transpose());\n        RealVector XTOIXinvy = XTOIXinv.operate(getY());\n        return XTOIXinvX.operate(XTOIXinvy);\n    }"
    ],
    [
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    for (Element element : this.children()) \n    {\n        if (element.id().equals(id)) \n        {\n            return element;\n        }\n        Element found = element.getElementById(id);\n        if (found != null) \n        {\n            return found;\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = id.trim();\n\n    for (Element element : this.getDescendants()) \n    {\n        if (element.id().equals(id)) \n        {\n            return element;\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    for (Element element : getAllElements()) {\n        if (element.id().equals(id)) {\n            return element;\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    if (id == null || id.isEmpty()) {\n        return null;\n    }\n    for (Element element : children) {\n        if (element.id().equals(id)) {\n            return element;\n        }\n        Element found = element.getElementById(id);\n        if (found != null) {\n            return found;\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    id = id.trim();\n\n    return Collector.collect(new Evaluator.Id(id), this).first();\n}",
      "public Element getElementById(String id)  {\n        if (id == null || id.length() == 0)\n            return null;\n        for (Element element : this.getDescendants())\n        {\n            if (element.id().equals(id))\n                return element;\n        }\n        return null;\n    }",
      "public Element getElementById(String id)  {\n        Validate.notEmpty(id);\n        return Collector.findFirst(new Evaluator.Id(id), this);\n    }",
      "public Element getElementById(String id)  {\n    Validate.notEmpty(id);\n    for (Element el : this.getDescendants()) {\n        if (el.id().equals(id)) {\n            return el;\n        }\n    }\n    return null;\n}",
      "public Element getElementById(String id)  {\n        Validate.notEmpty(id);\n        for (Element element : this.getDescendants()) \n        {\n            if (element.id().equals(id)) \n            {\n                return element;\n            }\n        }\n        return null;\n    }",
      "public Element getElementById(String id)  {\n        Validate.notEmpty(id);\n        id = id.trim();\n\n        return Collector.collect(new Evaluator.Id(id), this).first();\n    }"
    ],
    [
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder sb = new StringBuilder();\n    int patternIndex = 0;\n    int customIndex = 0;\n    while (patternIndex < pattern.length()) {\n        char c = pattern.charAt(patternIndex);\n        if (c == '\\'') {\n            sb.append(c);\n            int end = pattern.indexOf('\\'', patternIndex + 1);\n            if (end == -1) {\n                throw new IllegalArgumentException(\"Unterminated quote in pattern \\\"\" + pattern + \"\\\"\");\n            }\n            sb.append(pattern, patternIndex + 1, end);\n            sb.append(c);\n            patternIndex = end + 1;\n        } else if (c == '{') {\n            sb.append(c);\n            int end = pattern.indexOf('}', patternIndex + 1);\n            if (end == -1) {\n                throw new IllegalArgumentException(\"Unterminated format in pattern \\\"\" + pattern + \"\\\"\");\n            }\n            String key = pattern.substring(patternIndex + 1, end);\n            if (customPatterns != null) {\n                while (customIndex < customPatterns.size()) {\n                    String customPattern = customPatterns.get(customIndex);\n                    if (customPattern.startsWith(\"{\") && customPattern.endsWith(\"}\")) {\n                        String customKey = customPattern.substring(1, customPattern.length() - 1);\n                        if (customKey.equals(key)) {\n                            sb.append(customPattern);\n                            break;\n                        }\n                    }\n                    customIndex++;\n                }\n            }\n            sb.append(c);\n            patternIndex = end + 1;\n        } else {\n            sb.append(c);\n            patternIndex++;\n        }\n    }\n    return sb.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n        int patternLength = pattern.length();\n        int customPatternsSize = customPatterns.size();\n        StringBuilder result = new StringBuilder(patternLength + customPatternsSize * 10);\n        int index = 0;\n        int customIndex = 0;\n        while (index < patternLength) {\n            char ch = pattern.charAt(index++);\n            if (ch == '\\'') {\n                if (index < patternLength && pattern.charAt(index) == '\\'') {\n                    // '' is treated as escaped '\n                    ch = pattern.charAt(index++);\n                } else {\n                    result.append('\\'');\n                    while (index < patternLength && pattern.charAt(index) != '\\'') {\n                        ch = pattern.charAt(index++);\n                        result.append(ch);\n                    }\n                    if (index < patternLength) {\n                        ch = pattern.charAt(index++);\n                    }\n                }\n            } else if (ch == '{') {\n                result.append(ch);\n                while (index < patternLength && pattern.charAt(index) != '}') {\n                    ch = pattern.charAt(index++);\n                    result.append(ch);\n                }\n                if (index < patternLength) {\n                    ch = pattern.charAt(index++);\n                }\n                if (ch == '}') {\n                    if (customIndex < customPatternsSize) {\n                        result.append(customPatterns.get(customIndex++));\n                    }\n                } else {\n                    result.append(ch);\n                }\n            } else {\n                result.append(ch);\n            }\n        }\n        return result.toString();\n    }",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    int patternLength = pattern.length();\n    StringBuilder result = new StringBuilder(patternLength * 2);\n    int patternIndex = 0;\n    int customIndex = 0;\n    while (patternIndex < patternLength) \n    {\n        char c = pattern.charAt(patternIndex++);\n        if (c == '\\'' && patternIndex < patternLength) \n        {\n            char next = pattern.charAt(patternIndex++);\n            if (next == '\\'') \n            {\n                result.append(c);\n                result.append(next);\n            } \n            else \n            {\n                result.append(c);\n                result.append(next);\n                while (patternIndex < patternLength) \n                {\n                    c = pattern.charAt(patternIndex++);\n                    if (c == '\\'' && patternIndex < patternLength) \n                    {\n                        next = pattern.charAt(patternIndex++);\n                        if (next == '\\'') \n                        {\n                            result.append(c);\n                            result.append(next);\n                        } \n                        else \n                        {\n                            result.append(c);\n                            result.append(next);\n                            break;\n                        }\n                    } \n                    else \n                    {\n                        result.append(c);\n                        break;\n                    }\n                }\n            }\n        } \n        else \n        {\n            result.append(c);\n            if (customIndex < customPatterns.size()) \n            {\n                result.append(customPatterns.get(customIndex++));\n            }\n        }\n    }\n    return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n        final StringBuilder sb = new StringBuilder();\n        int i = 0;\n        int customIndex = 0;\n        while (i < pattern.length()) {\n            char c = pattern.charAt(i);\n            if (c == '\\'') {\n                sb.append(c);\n                while (i + 1 < pattern.length() && pattern.charAt(i + 1) == c) {\n                    sb.append(c);\n                    i++;\n                }\n            } else if (c == '{') {\n                sb.append(c);\n                while (i + 1 < pattern.length() && pattern.charAt(i + 1) != '}') {\n                    sb.append(pattern.charAt(i + 1));\n                    i++;\n                }\n                if (i + 1 < pattern.length() && pattern.charAt(i + 1) == '}') {\n                    sb.append(pattern.charAt(i + 1));\n                    i++;\n                }\n            } else if (c == '[') {\n                sb.append(c);\n                while (i + 1 < pattern.length() && pattern.charAt(i + 1) != ']') {\n                    sb.append(pattern.charAt(i + 1));\n                    i++;\n                }\n                if (i + 1 < pattern.length() && pattern.charAt(i + 1) == ']') {\n                    sb.append(pattern.charAt(i + 1));\n                    i++;\n                }\n            } else if (c == '|') {\n                sb.append(c);\n                while (i + 1 < pattern.length() && pattern.charAt(i + 1) != '|') {\n                    sb.append(pattern.charAt(i + 1));\n                    i++;\n                }\n                if (i + 1 < pattern.length() && pattern.charAt(i + 1) == '|') {\n                    sb.append(pattern.charAt(i + 1));\n}\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder sb = new StringBuilder();\n    int i = 0;\n    int customIndex = 0;\n    while (i < pattern.length()) \n    {\n        if (pattern.charAt(i) == START_FMT) \n        {\n            if (customIndex < customPatterns.size()) \n            {\n                sb.append(customPatterns.get(customIndex));\n            }\n            customIndex++;\n            i++;\n            while (i < pattern.length() && pattern.charAt(i) != END_FE) \n            {\n                i++;\n            }\n        } \n        else \n        {\n            sb.append(pattern.charAt(i));\n        }\n        i++;\n    }\n    return sb.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n        final StringBuilder result = new StringBuilder();\n        int patternIndex = 0;\n        int customIndex = 0;\n        int customEnd = 0;\n        int customStart = 0;\n        int customLen = 0;\n        int customCount = 0;\n        int patternLen = pattern.length();\n        while (patternIndex < patternLen) \n        {\n            char c = pattern.charAt(patternIndex);\n            if (c == '\\'') \n            {\n                result.append(c);\n                do \n                {\n                    result.append(pattern.charAt(patternIndex++));\n                } while (patternIndex < patternLen && pattern.charAt(patternIndex) != '\\'');\n                result.append(pattern.charAt(patternIndex++));\n            } \n            else \n            {\n                if (customIndex < customPatterns.size()) \n                {\n                    customStart = customPatterns.get(customIndex).indexOf('{');\n                    customEnd = customPatterns.get(customIndex).indexOf('}');\n                    customLen = customEnd - customStart;\n                    customCount = customLen - 1;\n                }\n                if (customIndex < customPatterns.size() && patternIndex + customLen <= patternLen &&\n                        pattern.substring(patternIndex, patternIndex + customLen).equals(customPatterns.get(customIndex).substring(customStart, customEnd + 1))) \n                {\n                    result.append(customPatterns.get(customIndex).substring(0, customStart));\n                    for (int i = 0; i < customCount; i++) \n                    {\n                        result.append('{').append(i).append('}');\n                    }\n                    result.append(customPatterns.get(customIndex).substring(customEnd + 1));\n                    patternIndex += customLen;\n                    customIndex++;\n                } \n                else \n                {\n                    result.append(c);\n                    patternIndex++;\n                }\n            }\n        }\n        return result.toString();\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n        final StringBuilder sb = new StringBuilder();\n        int patternIndex = 0;\n        int customIndex = 0;\n        int customStart = -1;\n        int customEnd = -1;\n        int customCount = 0;\n        while (patternIndex < pattern.length()) \n        {\n            final char c = pattern.charAt(patternIndex);\n            if (c == '\\'') \n            {\n                if (patternIndex + 1 < pattern.length() && pattern.charAt(patternIndex + 1) == '\\'') \n                {\n                    sb.append('\\'');\n                    patternIndex += 2;\n                    continue;\n                }\n                if (customStart == -1) \n                {\n                    sb.append(pattern.substring(patternIndex));\n                    break;\n                }\n                sb.append(pattern.substring(patternIndex, customStart));\n                sb.append(customPatterns.get(customIndex));\n                sb.append(pattern.substring(customEnd + 1));\n                patternIndex = customEnd + 1;\n                customIndex++;\n                customStart = -1;\n                customEnd = -1;\n                customCount++;\n                continue;\n            }\n            if (customStart == -1) \n            {\n                customStart = patternIndex;\n            }\n            customEnd = patternIndex;\n            patternIndex++;\n        }\n        return sb.toString();\n    }",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n        int pos = 0;\n        int formatCount = 0;\n        final StringBuilder result = new StringBuilder();\n\n        while (pos < pattern.length()) {\n            char c = pattern.charAt(pos++);\n            if (c == '\\'') {\n                if (pos < pattern.length() && pattern.charAt(pos) == '\\'') {\n                    // '' is treated as escaped '\n                    c = pattern.charAt(pos++);\n                    result.append(c);\n                } else {\n                    result.append(c);\n                    while (pos < pattern.length()) {\n                        c = pattern.charAt(pos++);\n                        if (c == '\\'') {\n                            if (pos < pattern.length() && pattern.charAt(pos) == '\\'') {\n                                // '' is treated as escaped '\n                                c = pattern.charAt(pos++);\n                                result.append(c);\n                            } else {\n                                break;\n                            }\n                        }\n                        result.append(c);\n                    }\n                }\n            } else if (c == '{') {\n                result.append(c);\n                int end = pattern.indexOf('}', pos);\n                if (end == -1) {\n                    throw new IllegalArgumentException(\"Unmatched brace in pattern \\\"\" + pattern + \"\\\"\");\n                }\n                String token = pattern.substring(pos, end);\n                pos = end + 1;\n                int colon = token.indexOf(':');\n                String key;\n                String style = null;\n                if (colon >= 0) {\n                    key = token.substring(0, colon);\n                    style = token.substring(colon + 1);\n                } else {\n                    key = token;\n                }\n                int index = Integer.parseInt(key);\n                if (index >= formatCount) {\n                    formatCount = index + 1;\n                }\n}\n}",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n        final StringBuilder result = new StringBuilder();\n        int formatCount = 0;\n        int i = 0;\n        while (i < pattern.length()) {\n            char c = pattern.charAt(i);\n            if (c == START_FMT) {\n                result.append(c);\n                int end = pattern.indexOf(END_FE, i);\n                if (end == -1) {\n                    throw new IllegalArgumentException(\"Unterminated format element at position \" + i);\n                }\n                String format = pattern.substring(i + 1, end);\n                if (format.startsWith(QUOTE_PREFIX)) {\n                    result.append(format.substring(1));\n                } else {\n                    int idx = Integer.parseInt(format);\n                    if (idx >= customPatterns.size()) {\n                        throw new IllegalArgumentException(\"No custom pattern at index \" + idx);\n                    }\n                    result.append(customPatterns.get(idx));\n                }\n                result.append(END_FE);\n                i = end + 1;\n            } else {\n                result.append(c);\n                i++;\n            }\n        }\n        return result.toString();\n    }",
      "private String insertFormats(final String pattern, final ArrayList<String> customPatterns)  {\n    final StringBuilder result = new StringBuilder();\n    int patternIndex = 0;\n    int customIndex = 0;\n    while (patternIndex < pattern.length()) \n    {\n        char c = pattern.charAt(patternIndex);\n        if (c == '\\'') \n        {\n            if (patternIndex + 1 < pattern.length() && pattern.charAt(patternIndex + 1) == '\\'') \n            {\n                // '' is treated as escaped '\n                patternIndex++;\n                result.append(c);\n            } \n            else \n            {\n                result.append(c);\n                boolean inLiteral = true;\n                while (inLiteral) \n                {\n                    patternIndex++;\n                    c = pattern.charAt(patternIndex);\n                    if (c == '\\'') \n                    {\n                        if (patternIndex + 1 < pattern.length() && pattern.charAt(patternIndex + 1) == '\\'') \n                        {\n                            // '' is treated as escaped '\n                            patternIndex++;\n                            result.append(c);\n                        } \n                        else \n                        {\n                            inLiteral = false;\n                        }\n                    } \n                    else \n                    {\n                        result.append(c);\n                    }\n                }\n            }\n        } \n        else \n        {\n            result.append(c);\n            if (customIndex < customPatterns.size() && patternIndex == customPatterns.get(customIndex).length()) \n            {\n                result.append(customPatterns.get(customIndex));\n                customIndex++;\n            }\n        }\n        patternIndex++;\n    }\n    return result.toString();\n}"
    ],
    [
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public InstantConverter removeInstantConverter(InstantConverter converter)\n            throws SecurityException  {\n        checkAlterInstantConverters();\n        if (converter == null) {\n            return null;\n        }\n        InstantConverter[] removed = new InstantConverter[1];\n        iInstantConverters = iInstantConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type arg1 = fromArgs[i];\n      Type arg2 = toArgs[i];\n\n      if (arg1 instanceof TypeVariable<?>) {\n        arg1 = typeVarMap.get(((TypeVariable<?>) arg1).getName());\n      }\n\n      if (arg2 instanceof TypeVariable<?>) {\n        arg2 = typeVarMap.get(((TypeVariable<?>) arg2).getName());\n      }\n\n      if (!typeEquals(arg1, arg2, typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type argFrom = fromArgs[i];\n      Type argTo = toArgs[i];\n\n      if (argFrom instanceof TypeVariable<?>) {\n        argFrom = typeVarMap.get(((TypeVariable<?>)argFrom).getName());\n      }\n\n      if (argTo instanceof TypeVariable<?>) {\n        argTo = typeVarMap.get(((TypeVariable<?>)argTo).getName());\n      }\n\n      if (!typeEquals(argFrom, argTo, typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type fa = fromArgs[i];\n      Type ta = toArgs[i];\n\n      if (fa instanceof TypeVariable) {\n        TypeVariable<?> tv = (TypeVariable<?>) fa;\n        fa = typeVarMap.get(tv.getName());\n      }\n\n      if (ta instanceof TypeVariable) {\n        TypeVariable<?> tv = (TypeVariable<?>) ta;\n        ta = typeVarMap.get(tv.getName());\n      }\n\n      if (!typeEquals(fa, ta, typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type argFrom = fromArgs[i];\n      Type argTo = toArgs[i];\n\n      if (argFrom instanceof TypeVariable<?>) {\n        argFrom = typeVarMap.get(((TypeVariable<?>) argFrom).getName());\n      }\n\n      if (argTo instanceof TypeVariable<?>) {\n        argTo = typeVarMap.get(((TypeVariable<?>) argTo).getName());\n      }\n\n      if (!typeEquals(argFrom, argTo, typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!isAssignableFrom(resolveTypeVar(fromArgs[i], typeVarMap),\n          resolveTypeVar(toArgs[i], typeVarMap), typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    Type fromRaw = from.getRawType();\n    Type toRaw = to.getRawType();\n    if (!fromRaw.equals(toRaw)) {\n      return false;\n    }\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    if (fromArgs.length != toArgs.length) {\n      return false;\n    }\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type argFrom = fromArgs[i];\n      Type argTo = toArgs[i];\n      if (argFrom instanceof TypeVariable<?>) {\n        argFrom = typeVarMap.get(((TypeVariable<?>)argFrom).getName());\n      }\n      if (argTo instanceof TypeVariable<?>) {\n        argTo = typeVarMap.get(((TypeVariable<?>)argTo).getName());\n      }\n      if (!typeEquals(argFrom, argTo, typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    Type fromRaw = from.getRawType();\n    Type toRaw = to.getRawType();\n    if (!fromRaw.equals(toRaw)) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    if (from.getRawType() != to.getRawType()) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n\n    for (int i = 0; i < fromArgs.length; i++) {\n      if (!typeEquals(fromArgs[i], toArgs[i], typeVarMap)) {\n        return false;\n      }\n    }\n\n    return true;\n}",
      "private static boolean typeEquals(ParameterizedType from,\n      ParameterizedType to, Map<String, Type> typeVarMap)  {\n    Type fromRaw = from.getRawType();\n    Type toRaw = to.getRawType();\n    if (!fromRaw.equals(toRaw)) {\n      return false;\n    }\n\n    Type[] fromArgs = from.getActualTypeArguments();\n    Type[] toArgs = to.getActualTypeArguments();\n    for (int i = 0; i < fromArgs.length; i++) {\n      Type argFrom = fromArgs[i];\n      Type argTo = toArgs[i];\n\n      if (argFrom instanceof TypeVariable<?>) {\n        argFrom = typeVarMap.get(((TypeVariable<?>)argFrom).getName());\n      }\n      if (argTo instanceof TypeVariable<?>) {\n        argTo = typeVarMap.get(((TypeVariable<?>)argTo).getName());\n      }\n\n      if (!typeEquals(argFrom, argTo, typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }"
    ],
    [
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PeriodConverter addPeriodConverter(PeriodConverter converter)\n            throws SecurityException  {\n        checkAlterPeriodConverters();\n        if (converter == null) {\n            return null;\n        }\n        PeriodConverter[] removed = new PeriodConverter[1];\n        iPeriodConverters = iPeriodConverters.add(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}",
      "public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator)  {\n    if (iterator == null) \n    {\n        throw new NullPointerException(\"Iterator must not be null\");\n    }\n    if (iterator instanceof UnmodifiableIterator<?>) \n    {\n        @SuppressWarnings(\"unchecked\") // safe cast\n        final UnmodifiableIterator<E> it = (UnmodifiableIterator<E>) iterator;\n        return it;\n    }\n    return new UnmodifiableIterator<E>(iterator);\n}"
    ],
    [
      "public N getPartitionSuperNode(N node)  {\n  int color = getNodeColor(node);\n  if (color == -1) {\n    return null;\n  }\n  for (N superNode : superNodes) {\n    if (getNodeColor(superNode) == color) {\n      return superNode;\n    }\n  }\n  return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    int color = getPartition(node);\n    for (N otherNode : nodes) {\n        if (getPartition(otherNode) == color) {\n            return otherNode;\n        }\n    }\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    int partition = getPartition(node);\n    for (N superNode : partitionNodes.get(partition)) \n    {\n        if (getPartition(superNode) == partition) \n        {\n            return superNode;\n        }\n    }\n    return node;\n}",
      "public N getPartitionSuperNode(N node)  {\n    int partition = getColoring().get(node);\n    for (N superNode : getPartitionSuperNodes()) {\n        if (getColoring().get(superNode) == partition) {\n            return superNode;\n        }\n    }\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    // Find the partition\n    int partition = getPartition(node);\n    // Find the first node that represents the partition\n    for (N n : getNodes()) \n    {\n        if (getPartition(n) == partition) \n        {\n            return n;\n        }\n    }\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    // Find the partition for the node\n    int partition = getPartition(node);\n    // Find the node that represents that partition\n    for (N partitionNode : partitionNodes) {\n        if (getPartition(partitionNode) == partition) {\n            return partitionNode;\n        }\n    }\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n  Set<N> partition = getPartition(node);\n  for (N partitionNode : partition) \n  {\n    if (getPartition(partitionNode).equals(partition)) \n    {\n      return partitionNode;\n    }\n  }\n  return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n    if (node == null) \n    {\n        return null;\n    }\n    N partition = getPartition(node);\n    if (partition == null) \n    {\n        return null;\n    }\n    if (partitionSuperNodes.containsKey(partition)) \n    {\n        return partitionSuperNodes.get(partition);\n    }\n    partitionSuperNodes.put(partition, node);\n    return node;\n}",
      "public N getPartitionSuperNode(N node)  {\n    int color = getPartition(node);\n    for (N node2 : getNodes()) {\n        if (getPartition(node2) == color) {\n            return node2;\n        }\n    }\n    return null;\n}",
      "public N getPartitionSuperNode(N node)  {\n  int color = getPartition(node);\n  for (N node2 : nodes) {\n    if (getPartition(node2) == color) {\n      return node2;\n    }\n  }\n  return null;\n}"
    ],
    [
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) {\n        if (Double.isNaN(ranks[i].getValue())) {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}",
      "private List<Integer> getNanPositions(IntDoublePair[] ranks)  {\n    List<Integer> nanPositions = new ArrayList<Integer>();\n    for (int i = 0; i < ranks.length; i++) \n    {\n        if (Double.isNaN(ranks[i].getValue())) \n        {\n            nanPositions.add(i);\n        }\n    }\n    return nanPositions;\n}"
    ],
    [
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n    }",
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += weights[i] * f.value(points[i]);\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n        double result = 0;\n        for (int i = 0; i < points.length; i++) {\n            result += weights[i] * f.value(points[i]);\n        }\n        return result;\n    }",
      "public double integrate(UnivariateFunction f)  {\n        double sum = 0;\n        for (int i = 0; i < points.length; i++) {\n            sum += weights[i] * f.value(points[i]);\n        }\n        return sum;\n    }",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  throws MathIllegalArgumentException {\n    if (points.length != weights.length) {\n        throw new MathIllegalArgumentException(\n            \"The number of points and weights must be the same.\");\n    }\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double result = 0;\n    for (int i = 0; i < points.length; i++) {\n        result += weights[i] * f.value(points[i]);\n    }\n    return result;\n}",
      "public double integrate(UnivariateFunction f)  {\n    double sum = 0;\n    for (int i = 0; i < points.length; i++) {\n        sum += weights[i] * f.value(points[i]);\n    }\n    return sum;\n}"
    ],
    [
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(paint1, paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(paint1, paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) \n    {\n        throw new IllegalArgumentException(\"Null map argument.\");\n    }\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(paint1, paint2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        throw new IllegalArgumentException(\"Null 'map1' argument.\");\n    }\n    if (map2 == null) {\n        throw new IllegalArgumentException(\"Null 'map2' argument.\");\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(paint1, paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) \n    {\n        throw new IllegalArgumentException(\"Null map argument.\");\n    }\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(paint1, paint2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null) {\n        throw new IllegalArgumentException(\"Null 'map1' argument.\");\n    }\n    if (map2 == null) {\n        throw new IllegalArgumentException(\"Null 'map2' argument.\");\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(paint1, paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(paint1, paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) \n    {\n        throw new IllegalArgumentException(\"Null map argument.\");\n    }\n    if (map1.size() != map2.size()) \n    {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) \n    {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(paint1, paint2)) \n        {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == null || map2 == null) {\n        throw new IllegalArgumentException(\"Null map argument.\");\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint paint1 = (Paint) map1.get(key);\n        Paint paint2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(paint1, paint2)) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalPaintMaps(Map map1, Map map2)  {\n    if (map1 == map2) {\n        return true;\n    }\n    if (map1.size() != map2.size()) {\n        return false;\n    }\n    Set keys = map1.keySet();\n    Iterator iterator = keys.iterator();\n    while (iterator.hasNext()) {\n        Comparable key = (Comparable) iterator.next();\n        Paint p1 = (Paint) map1.get(key);\n        Paint p2 = (Paint) map2.get(key);\n        if (!PaintUtilities.equal(p1, p2)) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (!expr.isString()) {\n        return expr;\n    }\n    String str = expr.getString();\n    if (str.length() < 5) {\n        return expr;\n    }\n    // Replace short strings with short-encoding\n    // e.g. \"abc\" -> \"a1b2c\"\n    String encoded = \"\";\n    for (int i = 0; i < str.length(); i++) {\n        char c = str.charAt(i);\n        int ascii = (int) c;\n        if (ascii < 10) {\n            encoded += \"0\" + ascii;\n        } else {\n            encoded += ascii;\n        }\n    }\n    Node encodedExpr = IR.string(encoded);\n    parent.replaceChild(expr, encodedExpr);\n    t.reportCodeChange();\n    return encodedExpr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  if (expr.isString() && !expr.getString().isEmpty()) {\n    String encoded = encodeString(expr.getString());\n    Node replacement = Node.newString(encoded);\n    parent.replaceChild(expr, replacement);\n    t.reportCodeChange();\n    return replacement;\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  if (expr.isString() && expr.getString().length() > MAX_STRING_LENGTH) {\n    String encodedString = encodeString(expr.getString());\n    Node encodedStringNode = IR.string(encodedString);\n    parent.replaceChild(expr, encodedStringNode);\n    reportCodeChange();\n    return encodedStringNode;\n  }\n\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (!expr.isString()) \n    {\n        return expr;\n    }\n\n    String str = expr.getString();\n    if (str.length() < 5) \n    {\n        return expr;\n    }\n\n    // TODO(user): Consider using a more sophisticated encoding.\n    String encodedStr = str.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\");\n    Node encodedExpr = IR.string(encodedStr);\n    parent.replaceChild(expr, encodedExpr);\n    reportChange();\n    return encodedExpr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  if (!expr.isString() || !isConstantName(expr, knownConstants)) {\n      return expr;\n    }\n\n    String str = expr.getString();\n    if (str.length() < 3) {\n      return expr;\n    }\n\n    String encoded = encodeString(str);\n    if (encoded.length() >= str.length()) {\n      return expr;\n    }\n\n    Node encodedNode = Node.newString(encoded);\n    parent.replaceChild(expr, encodedNode);\n    t.reportCodeChange();\n    return encodedNode;\n  }",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (!expr.isString()) \n    {\n        return expr;\n    }\n\n    String str = expr.getString();\n    if (str.length() < 4) \n    {\n        return expr;\n    }\n\n    // Replace the string with a short encoded string expression.\n    Node replacement = IR.string(encodeString(str));\n    parent.replaceChild(expr, replacement);\n    reportCodeChange();\n    return replacement;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  if (expr.isString() && expr.getString().length() > 0) {\n    String str = expr.getString();\n    if (str.length() <= 3) {\n      return expr;\n    }\n    String encoded = encodeString(str);\n    if (encoded.length() < str.length()) {\n      Node replacement = NodeUtil.newQualifiedNameNode(\n          compiler.getCodingConvention().getGlobalObject(),\n          \"$str\" + encoded);\n      parent.replaceChild(expr, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n  }\n  return expr;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (!expr.isString()) {\n        return expr;\n    }\n    String str = expr.getString();\n    if (str.length() < 4) {\n        return expr;\n    }\n    String encoded = encodeString(str);\n    if (encoded == null) {\n        return expr;\n    }\n    Node replacement = IR.string(encoded);\n    parent.replaceChild(expr, replacement);\n    t.reportCodeChange();\n    return replacement;\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (!expr.isString() || !expr.getString().contains(\" \")) \n    {\n        return expr;\n    }\n    String str = expr.getString();\n    int length = str.length();\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"\\\"\");\n    for (int i = 0; i < length; i++) \n    {\n        char c = str.charAt(i);\n        if (c == '\\\\') \n        {\n            sb.append(\"\\\\\\\\\");\n        } \n        else if (c == '\\\"') \n        {\n            sb.append(\"\\\\\\\"\");\n        } \n        else if (c == '\\n') \n        {\n            sb.append(\"\\\\n\");\n        } \n        else if (c == '\\r') \n        {\n            sb.append(\"\\\\r\");\n        } \n        else if (c == '\\t') \n        {\n            sb.append(\"\\\\t\");\n        } \n        else \n        {\n            sb.append(c);\n        }\n    }\n    sb.append(\"\\\"\");\n    return IR.string(sb.toString());\n}",
      "private Node replaceExpression(NodeTraversal t, Node expr, Node parent)  {\n    if (!expr.isString() || !parent.isCall() || !parent.getFirstChild().isName()) {\n        return expr;\n    }\n\n    String str = expr.getString();\n    if (str.length() > MAX_STRING_LENGTH) {\n        return expr;\n    }\n\n    String encodedStr = encodeString(str);\n    Node encodedStrNode = IR.string(encodedStr);\n    parent.replaceChild(expr, encodedStrNode);\n    reportCodeChange();\n    return encodedStrNode;\n}"
    ],
    [
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}",
      "public double[] getCoefficients()  {\n    double[] out = new double[a.length];\n    System.arraycopy(a, 0, out, 0, a.length);\n    return out;\n}"
    ],
    [
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo info = node.getJSDocInfo();\n    if (info != null) {\n      String desc = info.getDescription();\n      if (desc != null) {\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo info = node.getJSDocInfo();\n  if (info != null) {\n    String desc = info.getDescription();\n    if (desc != null) {\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo jsDoc = node.getJSDocInfo();\n    if (jsDoc != null) {\n      String desc = jsDoc.getDescription();\n      if (desc != null) {\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo jsDocInfo = node.getJSDocInfo();\n  if (jsDocInfo != null) {\n    String desc = jsDocInfo.getDescription();\n    if (desc != null) {\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo info = node.getJSDocInfo();\n    if (info != null) {\n      String desc = info.getDescription();\n      if (desc != null) {\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo jsDocInfo = node.getJSDocInfo();\n    if (jsDocInfo != null) {\n      String desc = jsDocInfo.getDescription();\n      if (desc != null) {\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo info = node.getJSDocInfo();\n    if (info != null) {\n      String desc = info.getDescription();\n      if (desc != null) {\n        if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n          builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n          builder.setIsHidden(true);\n        } else {\n          builder.setDesc(desc);\n        }\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n  JSDocInfo jsDocInfo = node.getJSDocInfo();\n  if (jsDocInfo != null) {\n    String desc = jsDocInfo.getDescription();\n    if (desc != null) {\n      if (desc.startsWith(HIDDEN_DESC_PREFIX)) {\n        builder.setDesc(desc.substring(HIDDEN_DESC_PREFIX.length()).trim());\n        builder.setIsHidden(true);\n      } else {\n        builder.setDesc(desc);\n      }\n      return true;\n    }\n  }\n  return false;\n}",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo info = node.getJSDocInfo();\n    if (info != null) {\n      String desc = info.getDescription();\n      if (desc != null) {\n        builder.setDesc(desc);\n        return true;\n      }\n    }\n    return false;\n  }",
      "private boolean maybeInitMetaDataFromJsDoc(Builder builder, Node node)  throws MalformedException {\n    JSDocInfo info = node.getJSDocInfo();\n    if (info != null) {\n      String desc = info.getDescription();\n      if (desc != null) {\n        builder.setDesc(desc);\n        return true;\n      }\n    }\n    return false;\n  }"
    ],
    [
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}",
      "private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments)  {\n    int assignedDifferently = 0;\n    int pointIndex = 0;\n    for (final T p : points) {\n        int clusterIndex = getNearestCluster(clusters, p);\n        if (clusterIndex != assignments[pointIndex]) {\n            assignedDifferently++;\n        }\n\n        Cluster<T> cluster = clusters.get(clusterIndex);\n        cluster.addPoint(p);\n        assignments[pointIndex++] = clusterIndex;\n    }\n\n    return assignedDifferently;\n}"
    ],
    [
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DATA_FOR_COVARIANCE_ESTIMATION);\n    }\n    double meanX = 0;\n    double meanY = 0;\n    double sumXX = 0;\n    double sumXY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        meanX += xArray[i];\n        meanY += yArray[i];\n    }\n    meanX /= xArray.length;\n    meanY /= yArray.length;\n    for (int i = 0; i < xArray.length; i++) {\n        sumXX += (xArray[i] - meanX) * (xArray[i] - meanX);\n        sumXY += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    return biasCorrected ? sumXY / (xArray.length - 1) : sumXY / xArray.length;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DATA_FOR_INTERVAL,\n                xArray.length);\n    }\n    double meanX = 0;\n    double meanY = 0;\n    double sumXX = 0;\n    double sumXY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        meanX += xArray[i];\n        meanY += yArray[i];\n    }\n    meanX /= xArray.length;\n    meanY /= yArray.length;\n    for (int i = 0; i < xArray.length; i++) {\n        sumXX += Math.pow(xArray[i] - meanX, 2);\n        sumXY += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    double cov = sumXY / (xArray.length - 1);\n    if (biasCorrected) {\n        cov /= xArray.length;\n    }\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH,\n                                             xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                                             xArray.length);\n    }\n    double meanX = 0;\n    double meanY = 0;\n    double sumXX = 0;\n    double sumXY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        meanX += xArray[i];\n        meanY += yArray[i];\n    }\n    meanX /= xArray.length;\n    meanY /= yArray.length;\n    for (int i = 0; i < xArray.length; i++) {\n        sumXX += (xArray[i] - meanX) * (xArray[i] - meanX);\n        sumXY += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    if (biasCorrected) {\n        return sumXY / (xArray.length - 1);\n    } else {\n        return sumXY / xArray.length;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    MathUtils.checkNotNull(xArray);\n    MathUtils.checkNotNull(yArray);\n    MathUtils.checkSameLength(xArray, yArray);\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA_FOR_COVARIANCE_ESTIMATION);\n    }\n    double sumX = 0;\n    double sumY = 0;\n    double sumXX = 0;\n    double sumXY = 0;\n    double sumYY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        sumX += xArray[i];\n        sumY += yArray[i];\n        sumXX += xArray[i] * xArray[i];\n        sumXY += xArray[i] * yArray[i];\n        sumYY += yArray[i] * yArray[i];\n    }\n    final double meanX = sumX / xArray.length;\n    final double meanY = sumY / yArray.length;\n    final double n = xArray.length;\n    final double cov = sumXY / n - meanX * meanY;\n    return biasCorrected ? cov : cov * (n / (n - 1));\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n        if (xArray.length != yArray.length) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.DIMENSIONS_MISMATCH,\n                xArray.length, yArray.length);\n        }\n        if (xArray.length < 2) {\n            throw new MathIllegalArgumentException(\n                LocalizedFormats.INSUFFICIENT_DATA,\n                xArray.length);\n        }\n        double meanX = 0;\n        double meanY = 0;\n        double sumXX = 0;\n        double sumXY = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            meanX += xArray[i];\n            meanY += yArray[i];\n        }\n        meanX /= xArray.length;\n        meanY /= yArray.length;\n        for (int i = 0; i < xArray.length; i++) {\n            sumXX += (xArray[i] - meanX) * (xArray[i] - meanX);\n            sumXY += (xArray[i] - meanX) * (yArray[i] - meanY);\n        }\n        double cov = sumXY / (xArray.length - biasCorrected);\n        return cov;\n    }",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n        if (xArray.length != yArray.length) {\n            throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH,\n                                                 xArray.length, yArray.length);\n        }\n        if (xArray.length < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA_FOR_COVARIANCE_ESTIMATION);\n        }\n        double sumX = 0;\n        double sumY = 0;\n        double sumXX = 0;\n        double sumXY = 0;\n        double sumYY = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            sumX += xArray[i];\n            sumY += yArray[i];\n            sumXX += xArray[i] * xArray[i];\n            sumXY += xArray[i] * yArray[i];\n            sumYY += yArray[i] * yArray[i];\n        }\n        double n = xArray.length;\n        double meanX = sumX / n;\n        double meanY = sumY / n;\n        double cov = sumXY / n - meanX * meanY;\n        if (biasCorrected) {\n            cov /= (n - 1);\n        }\n        return cov;\n    }",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    MathUtils.checkNotNull(xArray);\n    MathUtils.checkNotNull(yArray);\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH,\n                                              xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA_FOR_COVARIANCE_ESTIMATION);\n    }\n    double meanX = 0;\n    double meanY = 0;\n    double sumXX = 0;\n    double sumXY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        meanX += xArray[i];\n        meanY += yArray[i];\n    }\n    meanX /= xArray.length;\n    meanY /= yArray.length;\n    for (int i = 0; i < xArray.length; i++) {\n        sumXX += (xArray[i] - meanX) * (xArray[i] - meanX);\n        sumXY += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    if (biasCorrected) {\n        return sumXY / (xArray.length - 1);\n    } else {\n        return sumXY / xArray.length;\n    }\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n        MathUtils.checkNotNull(xArray);\n        MathUtils.checkNotNull(yArray);\n        if (xArray.length != yArray.length) {\n            throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH,\n                                                 xArray.length, yArray.length);\n        }\n        if (xArray.length < 2) {\n            throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                                                 xArray.length);\n        }\n        double meanX = 0;\n        double meanY = 0;\n        double sumXX = 0;\n        double sumXY = 0;\n        for (int i = 0; i < xArray.length; i++) {\n            meanX += xArray[i];\n            meanY += yArray[i];\n        }\n        meanX /= xArray.length;\n        meanY /= yArray.length;\n        for (int i = 0; i < xArray.length; i++) {\n            sumXX += Math.pow(xArray[i] - meanX, 2);\n            sumXY += (xArray[i] - meanX) * (yArray[i] - meanY);\n        }\n        if (biasCorrected) {\n            return sumXY / (xArray.length - 1);\n        } else {\n            return sumXY / xArray.length;\n        }\n    }",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    MathUtils.checkNotNull(xArray);\n    MathUtils.checkNotNull(yArray);\n    MathUtils.checkArgument(xArray.length == yArray.length);\n    MathUtils.checkArgument(xArray.length > 1);\n\n    double meanX = 0;\n    double meanY = 0;\n    double sumXX = 0;\n    double sumXY = 0;\n\n    for (int i = 0; i < xArray.length; i++) {\n        meanX += xArray[i];\n        meanY += yArray[i];\n    }\n    meanX /= xArray.length;\n    meanY /= yArray.length;\n\n    for (int i = 0; i < xArray.length; i++) {\n        sumXX += Math.pow(xArray[i] - meanX, 2);\n        sumXY += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n\n    double cov = sumXY / (xArray.length - biasCorrected);\n\n    return cov;\n}",
      "public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n        throws MathIllegalArgumentException  {\n    MathUtils.checkNotNull(xArray);\n    MathUtils.checkNotNull(yArray);\n    if (xArray.length != yArray.length) {\n        throw new MathIllegalArgumentException(LocalizedFormats.DIMENSIONS_MISMATCH,\n                                              xArray.length, yArray.length);\n    }\n    if (xArray.length < 2) {\n        throw new MathIllegalArgumentException(LocalizedFormats.INSUFFICIENT_DATA,\n                                              xArray.length);\n    }\n    double meanX = 0;\n    double meanY = 0;\n    double sumXX = 0;\n    double sumXY = 0;\n    for (int i = 0; i < xArray.length; i++) {\n        meanX += xArray[i];\n        meanY += yArray[i];\n    }\n    meanX /= xArray.length;\n    meanY /= yArray.length;\n    for (int i = 0; i < xArray.length; i++) {\n        sumXX += (xArray[i] - meanX) * (xArray[i] - meanX);\n        sumXY += (xArray[i] - meanX) * (yArray[i] - meanY);\n    }\n    return biasCorrected ? sumXY / (xArray.length - 1) : sumXY / xArray.length;\n}"
    ],
    [
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) \n        {\n            break;\n        }\n        skipped += x;\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) {\n                return;\n            }\n            skipped += x;\n        }\n        bytesRead += skipped;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) \n    {\n        long skipped = 0;\n        while (skipped < value) \n        {\n            final long rem = value - skipped;\n            final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) \n            {\n                break;\n            }\n            skipped += x;\n        }\n        bytesRead += skipped;\n    }\n    else \n    {\n        throw new IllegalArgumentException();\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) {\n                return;\n            }\n            skipped += x;\n        }\n        bytesRead += skipped;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) \n        {\n            break;\n        }\n        skipped += x;\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) \n        {\n            break;\n        }\n        skipped += x;\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) {\n        long skipped = 0;\n        while (skipped < value) {\n            final long rem = value - skipped;\n            final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) {\n                return;\n            }\n            skipped += x;\n        }\n        count(skipped);\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) \n    {\n        long skipped = 0;\n        while (skipped < value) \n        {\n            final long rem = value - skipped;\n            final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) \n            {\n                break;\n            }\n            skipped += x;\n        }\n        bytesRead += skipped;\n    }\n}",
      "private void realSkip(final long value) throws IOException  {\n    long skipped = 0;\n    while (skipped < value) \n    {\n        final long rem = value - skipped;\n        final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n        if (x == -1) \n        {\n            break;\n        }\n        skipped += x;\n    }\n    bytesRead += skipped;\n}",
      "private void realSkip(final long value) throws IOException  {\n    if (value >= 0) \n    {\n        long skipped = 0;\n        while (skipped < value) \n        {\n            final long rem = value - skipped;\n            final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n            if (x == -1) \n            {\n                break;\n            }\n            skipped += x;\n        }\n        bytesRead += skipped;\n    }\n}"
    ],
    [
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}",
      "public static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException  {\n    if (target == null) \n    {\n        throw new IllegalArgumentException(\"target object must not be null\");\n    }\n    final Class<?> cls = target.getClass();\n    final Field field = getDeclaredField(cls, fieldName, forceAccess);\n    if (field == null) \n    {\n        throw new IllegalArgumentException(\"Cannot locate declared field \" + cls.getName() + \".\" + fieldName);\n    }\n    // already forced access above, don't repeat it here:\n    return readField(field, target);\n}"
    ],
    [
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        sb.append(part);\n    }\n    String content = sb.toString();\n    return fingerprint(content);\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        sb.append(part);\n    }\n    String content = sb.toString();\n    long fingerprint = FP.fingerprint(content);\n    return Long.toHexString(fingerprint).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        sb.append(part);\n    }\n    String content = sb.toString();\n    long fingerprint = FP.fingerprint(content);\n    return Long.toHexString(fingerprint).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n        StringBuilder sb = new StringBuilder();\n        for (CharSequence part : messageParts) \n        {\n            sb.append(part.toString());\n        }\n        String content = sb.toString();\n        return String.format(\"%016X\", FP.fingerprint(content));\n    }",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n      StringBuilder sb = new StringBuilder();\n      for (CharSequence part : messageParts) \n      {\n        sb.append(part);\n      }\n      String tcValue = sb.toString();\n      return String.valueOf(MessageId.generateId(tcValue));\n    }",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        sb.append(part);\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(MessageId.generateId(tcValue, meaning));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        sb.append(part);\n    }\n    String content = sb.toString();\n    long fingerprint = FP.fingerprint(content);\n    return Long.toHexString(fingerprint).toUpperCase();\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        sb.append(part);\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(MessageId.generateId(tcValue));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n    StringBuilder sb = new StringBuilder();\n    for (CharSequence part : messageParts) {\n        sb.append(part);\n    }\n    String tcValue = sb.toString();\n    return String.valueOf(\n        MessageId.generateId(tcValue, meaning));\n}",
      "private static String fingerprint(List<CharSequence> messageParts)  {\n        StringBuilder sb = new StringBuilder();\n        for (CharSequence part : messageParts) {\n            sb.append(part);\n        }\n        return String.valueOf(FP.fingerprint(sb.toString()));\n    }"
    ],
    [
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        if (raf.length() < minDistanceFromEnd + sig.length) {\n            return false;\n        }\n        long distanceFromEnd = maxDistanceFromEnd;\n        while (distanceFromEnd >= minDistanceFromEnd) {\n            raf.seek(raf.length() - distanceFromEnd);\n            final byte[] buffer = new byte[sig.length];\n            raf.readFully(buffer);\n            if (Arrays.equals(sig, buffer)) {\n                return true;\n            }\n            distanceFromEnd--;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    long distanceFromEnd = minDistanceFromEnd;\n    while (distanceFromEnd <= maxDistanceFromEnd) {\n        long seekTo = getFilePointer() - distanceFromEnd;\n        if (seekTo < 0) {\n            seekTo = 0;\n        }\n        seek(seekTo);\n        if (read(signatureBuffer, 0, sig.length) == sig.length) {\n            if (Arrays.equals(signatureBuffer, sig)) {\n                return true;\n            }\n        }\n        distanceFromEnd <<= 1;\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    if (minDistanceFromEnd > maxDistanceFromEnd) {\n        return false;\n    }\n    final long distance = maxDistanceFromEnd - minDistanceFromEnd;\n    final long maxToRead = Math.min(distance, BUFFER_SIZE);\n    final byte[] buffer = new byte[(int)maxToRead];\n    long bytesRead = 0;\n    long position = file.length() - minDistanceFromEnd;\n    while (bytesRead < maxToRead) {\n        final int read = file.read(buffer, (int)bytesRead, (int)(maxToRead - bytesRead));\n        if (read <= 0) {\n            break;\n        }\n        bytesRead += read;\n    }\n    position -= bytesRead;\n    for (int i = (int)bytesRead - sig.length; i >= 0; i--) {\n        boolean match = true;\n        for (int j = 0; j < sig.length; j++) {\n            if (buffer[i + j] != sig[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            file.seek(position + i);\n            return true;\n        }\n    }\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        final long maxDistance = Math.min(maxDistanceFromEnd, file.length());\n        if (maxDistance < minDistanceFromEnd) {\n            return false;\n        }\n        long distance = maxDistance - minDistanceFromEnd;\n        long seekTo = file.length() - distance;\n        if (seekTo < 0) {\n            seekTo = 0;\n        }\n        file.seek(seekTo);\n        final byte[] buffer = new byte[sig.length];\n        while (distance > 0) {\n            final int read = file.read(buffer);\n            if (read < sig.length) {\n                return false;\n            }\n            for (int i = 0; i < sig.length; i++) {\n                if (buffer[i] != sig[i]) {\n                    break;\n                }\n                if (i == sig.length - 1) {\n                    return true;\n                }\n            }\n            distance -= read;\n            seekTo -= read;\n            if (seekTo < 0) {\n                seekTo = 0;\n            }\n            file.seek(seekTo);\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        if (minDistanceFromEnd > maxDistanceFromEnd) {\n            throw new IllegalArgumentException(\"minDistanceFromEnd > maxDistanceFromEnd\");\n        }\n        if (minDistanceFromEnd < 0 || maxDistanceFromEnd < 0) {\n            throw new IllegalArgumentException(\"minDistanceFromEnd or maxDistanceFromEnd < 0\");\n        }\n        if (sig == null || sig.length == 0) {\n            throw new IllegalArgumentException(\"sig is null or empty\");\n        }\n\n        final long minDistance = Math.min(minDistanceFromEnd, maxDistanceFromEnd);\n        final long maxDistance = Math.max(minDistanceFromEnd, maxDistanceFromEnd);\n\n        final long startPos = raf.length() - maxDistance;\n        final long endPos = Math.max(startPos, raf.length() - minDistance);\n\n        raf.seek(startPos);\n        long pos = startPos;\n\n        while (pos <= endPos) {\n            final int read = raf.read(tmpBuf, 0, sig.length);\n            if (read == sig.length) {\n                for (int i = 0; i < sig.length; i++) {\n                    if (tmpBuf[i] != sig[i]) {\n                        break;\n                    }\n                    if (i == sig.length - 1) {\n                        raf.seek(pos);\n                        return true;\n                    }\n                }\n            }\n            pos++;\n            raf.seek(pos);\n        }\n\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        final long minDistance = Math.max(minDistanceFromEnd, 0);\n        final long maxDistance = Math.min(maxDistanceFromEnd, getFilePointer());\n        if (maxDistance < minDistance) {\n            return false;\n        }\n        final long distanceToRead = maxDistance - minDistance;\n        final byte[] buffer = new byte[(int)distanceToRead];\n        seek(minDistance);\n        readFully(buffer);\n        final int sigOffset = lastIndexOf(buffer, sig);\n        if (sigOffset >= 0) {\n            seek(minDistance + sigOffset);\n            return true;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        if (minDistanceFromEnd > maxDistanceFromEnd) {\n            return false;\n        }\n        final long distanceFromEnd = minDistanceFromEnd + (maxDistanceFromEnd - minDistanceFromEnd) / 2;\n        final long position = raf.length() - distanceFromEnd;\n        raf.seek(position);\n        final byte[] buffer = new byte[sig.length];\n        raf.readFully(buffer);\n        if (Arrays.equals(sig, buffer)) {\n            return true;\n        }\n        return tryToLocateSignature(minDistanceFromEnd, distanceFromEnd - 1, sig)\n            || tryToLocateSignature(distanceFromEnd + 1, maxDistanceFromEnd, sig);\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    if (raf == null) {\n        throw new IllegalStateException(\"No archive opened\");\n    }\n    if (sig == null || sig.length == 0) {\n        throw new IllegalArgumentException(\"Signature must not be null or empty\");\n    }\n    if (minDistanceFromEnd < 0 || maxDistanceFromEnd < 0) {\n        throw new IllegalArgumentException(\"Distances must not be negative\");\n    }\n    if (minDistanceFromEnd > maxDistanceFromEnd) {\n        throw new IllegalArgumentException(\"Min distance must not be greater than max distance\");\n    }\n    if (minDistanceFromEnd > raf.length()) {\n        throw new IllegalArgumentException(\"Min distance must not be greater than archive size\");\n    }\n    if (maxDistanceFromEnd > raf.length()) {\n        throw new IllegalArgumentException(\"Max distance must not be greater than archive size\");\n    }\n    if (raf.length() < sig.length) {\n        throw new IllegalArgumentException(\"Archive size must be greater than or equal to signature size\");\n    }\n\n    final long startPos = raf.length() - sig.length;\n    final long endPos = Math.max(0, raf.length() - maxDistanceFromEnd);\n    long pos = Math.min(startPos, endPos + minDistanceFromEnd);\n\n    while (pos >= endPos) {\n        raf.seek(pos);\n        final byte[] buffer = new byte[sig.length];\n        raf.readFully(buffer);\n        if (Arrays.equals(buffer, sig)) {\n            return true;\n        }\n        pos--;\n    }\n\n    return false;\n}",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n        long distanceFromEnd = minDistanceFromEnd;\n        while (distanceFromEnd <= maxDistanceFromEnd) {\n            if (seek(length - distanceFromEnd) == length - distanceFromEnd) {\n                if (read(sig, 0, sig.length) == sig.length) {\n                    return true;\n                }\n            }\n            distanceFromEnd += 1024;\n        }\n        return false;\n    }",
      "private boolean tryToLocateSignature(final long minDistanceFromEnd,\n                                         final long maxDistanceFromEnd,\n                                         final byte[] sig) throws IOException  {\n    final long maxDistance = Math.min(maxDistanceFromEnd, file.length());\n    final long minDistance = Math.max(minDistanceFromEnd, 0);\n    final long distance = maxDistance - minDistance;\n\n    if (distance < sig.length) {\n        return false;\n    }\n\n    final byte[] buffer = new byte[sig.length];\n    long pos = file.length() - sig.length;\n\n    while (pos >= minDistance) {\n        file.seek(pos);\n        file.read(buffer);\n        if (Arrays.equals(buffer, sig)) {\n            file.seek(pos);\n            return true;\n        }\n        pos--;\n    }\n\n    return false;\n}"
    ],
    [
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}",
      "public RectangleEdge getDomainAxisEdge(int index)  {\n    AxisLocation location = getDomainAxisLocation(index);\n    RectangleEdge result = Plot.resolveDomainAxisLocation(location,\n            this.orientation);\n    if (result == null) \n    {\n        result = RectangleEdge.opposite(getDomainAxisEdge(0));\n    }\n    return result;\n}"
    ],
    [
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter removePartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.remove(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new MergedStream(_context, _originalStream, _bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return _originalStream;\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new MergedStream(_ctxt, _originalStream, _bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return new MergedStream(_ctxt, _originalStream, _bufferedData, _bufferedStart, _bufferedLength);\n}",
      "public InputStream getDataStream()  {\n    if (_originalStream == null) {\n        return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength);\n    }\n    return _originalStream;\n}"
    ],
    [
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = getSectionKey(section);\n    if (key == null) {\n        key = new Integer(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section >= 0 && section < getSectionCount()) \n    {\n        key = getSectionKey(section);\n    }\n    if (key == null) \n    {\n        key = new Integer(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section >= 0 && section < getSectionCount()) {\n        key = getSectionKey(section);\n    }\n    if (key == null) {\n        key = new Integer(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = null;\n    if (section >= 0 && section < getSectionCount()) {\n        key = getSectionKey(section);\n    }\n    if (key == null) {\n        key = new Integer(section);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = getSectionKey(section);\n    if (key == null) {\n        key = \"Section \" + section;\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.sectionKeys.get(section);\n    if (key == null) {\n        key = new DefaultKeyedValue(\"Section \" + section);\n        this.sectionKeys.set(section, key);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.sectionKeys.get(section);\n    if (key == null) {\n        key = new DefaultKeyedValue(Integer.toString(section), null);\n        this.sectionKeys.set(section, key);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.sectionKeys.get(section);\n    if (key == null) {\n        key = \"Section \" + section;\n        this.sectionKeys.set(section, key);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.sectionKeys.get(section);\n    if (key == null) {\n        key = new DefaultKeyedValue(\"Section \" + section);\n        this.sectionKeys.set(section, key);\n    }\n    return key;\n}",
      "protected Comparable getSectionKey(int section)  {\n    Comparable key = this.sectionKeys.get(section);\n    if (key == null) {\n        key = new DefaultKeyedValue(Integer.toString(section), null);\n        this.sectionKeys.set(section, key);\n    }\n    return key;\n}"
    ],
    [
      "@Override\n        public boolean isNaN()  {\n            if (!_closed) {\n                JsonNode n = currentNode();\n                if (n instanceof NumericNode) {\n                    return ((NumericNode) n).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (!_closed) {\n                JsonNode n = currentNode();\n                if (n instanceof NumericNode) {\n                    return ((NumericNode) n).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (!_closed) {\n                JsonNode n = currentNode();\n                if (n instanceof NumericNode) {\n                    return ((NumericNode) n).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (!_closed) {\n                JsonNode n = currentNode();\n                if (n instanceof NumericNode) {\n                    return ((NumericNode) n).isNaN();\n                }\n            }\n            return false;\n        }\n        /*\n        /**********************************************************\n        /* Public API, access to token information, numeric\n        /**********************************************************\n         */",
      "@Override\n        public boolean isNaN()  {\n            if (!_closed) {\n                JsonNode n = currentNode();\n                if (n instanceof NumericNode) {\n                    return ((NumericNode) n).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (!_closed) {\n                JsonNode n = currentNode();\n                if (n instanceof NumericNode) {\n                    return ((NumericNode) n).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (!_closed) {\n                JsonNode n = currentNode();\n                if (n instanceof NumericNode) {\n                    return ((NumericNode) n).isNaN();\n                }\n            }\n            return false;\n        }\n        /*\n        /**********************************************************\n        /* Public API, access to token information, numeric\n        /**********************************************************\n         */",
      "@Override\n        public boolean isNaN()  {\n            if (!_closed) {\n                JsonNode n = currentNode();\n                if (n instanceof NumericNode) {\n                    return ((NumericNode) n).isNaN();\n                }\n            }\n            return false;\n        }",
      "@Override\n        public boolean isNaN()  {\n            if (!_closed) {\n                JsonNode n = currentNode();\n                if (n instanceof NumericNode) {\n                    return ((NumericNode) n).isNaN();\n                }\n            }\n            return false;\n        }\n        /*\n        /**********************************************************\n        /* Public API, access to token information, numeric\n        /**********************************************************\n         */",
      "@Override\n        public boolean isNaN()  {\n            if (!_closed) {\n                JsonNode n = currentNode();\n                if (n instanceof NumericNode) {\n                    return ((NumericNode) n).isNaN();\n                }\n            }\n            return false;\n        }"
    ],
    [
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}",
      "private static boolean startsWith(final CharSequence str, final CharSequence prefix, final boolean ignoreCase)  {\n    if (str == null || prefix == null) {\n        return str == null && prefix == null;\n    }\n    if (prefix.length() > str.length()) {\n        return false;\n    }\n    return CharSequenceUtils.regionMatches(str, ignoreCase, 0, prefix, 0, prefix.length());\n}"
    ],
    [
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    String result;\n    if (p == PEEKED_STRING) {\n        result = new String(buffer, pos, peekedStringLength);\n        pos += peekedStringLength;\n    } else if (p == PEEKED_LONG) {\n        result = Long.toString(peekedLong);\n    } else if (p == PEEKED_NUMBER) {\n        result = peekedString;\n        if (result == null) {\n            result = new String(buffer, pos, peekedNumberLength);\n            pos += peekedNumberLength;\n        }\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n        if (p == PEEKED_UNQUOTED) {\n            result = nextUnquotedValue();\n        } else {\n            result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n\n    String result;\n    if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = peekedString;\n        peekedString = null;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n\n    String result;\n    if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED || p == PEEKED_UNQUOTED) {\n        if (p == PEEKED_UNQUOTED) {\n            result = nextUnquotedValue();\n        } else {\n            result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    } else if (p == PEEKED_NUMBER) {\n        result = peekedString;\n        peekedString = null;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n\n    String result;\n    if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } \n    else if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = peekedString;\n        peekedString = null;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) {\n        result = nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n        result = nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n        result = nextQuotedValue('\"');\n    } else if (p == PEEKED_NUMBER) {\n        result = peekedString;\n        peekedString = null;\n    } else {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n\n    String result;\n    if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = peekedString;\n        peekedString = null;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = peekedString;\n        peekedString = null;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n    } \n    else if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = peekedString;\n        peekedString = null;\n        peeked = PEEKED_NONE;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public String nextString() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        result = peekedString;\n        peekedString = null;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}"
    ],
    [
      "public static String abbreviate(final String str, int offset, final int maxWidth)  if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - maxWidth + 3;\n    }\n    if (offset <= 4) {\n        return str.substring(0, maxWidth - 3) + \"...\";\n    }\n    if (maxWidth < 7) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width with offset is 7\");\n    }\n    if (offset < 7) {\n        return \"...\" + str.substring(str.length() - maxWidth + 7);\n    }\n    return \"...\" + str.substring(offset - 3, maxWidth - 3) + \"...\";\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final StringBuffer buffer = new StringBuffer(maxWidth);\n    buffer.append(str.substring(0, offset));\n    buffer.append(\"...\");\n    buffer.append(str.substring(str.length() - (maxWidth - 3)));\n    return buffer.toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n        if (str == null) {\n            return null;\n        }\n\n        if (maxWidth < 4) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n        }\n\n        if (str.length() <= maxWidth) {\n            return str;\n        }\n\n        if (offset > str.length()) {\n            offset = str.length();\n        }\n\n        if (str.length() - offset < maxWidth - 3) {\n            offset = str.length() - (maxWidth - 3);\n        }\n\n        final String leftPart = str.substring(0, offset);\n        final int leftWidth = leftPart.length();\n        final String rightPart = str.substring(offset);\n        final int rightWidth = rightPart.length();\n\n        if (leftWidth + 3 > maxWidth) {\n            final int half = maxWidth / 2;\n            if (leftWidth > half) {\n                leftPart = leftPart.substring(0, half) + \"...\";\n            }\n            if (maxWidth - 3 - leftWidth >= rightWidth) {\n                rightPart = \"...\" + rightPart.substring(rightWidth - (maxWidth - 3 - leftWidth));\n            } else {\n                rightPart = \"...\" + rightPart.substring(rightWidth - (maxWidth - 3));\n            }\n        } else {\n            rightPart = \"...\" + rightPart.substring(3 - leftWidth);\n        }\n\n        return leftPart + rightPart;\n    }",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n\n    final String leftPart = str.substring(0, offset);\n    final int leftWidth = leftPart.length();\n    final String rightPart = str.substring(offset);\n    final int rightWidth = rightPart.length();\n\n    if (leftWidth + 3 > maxWidth) {\n        return leftPart.substring(0, maxWidth - 3) + \"...\";\n    }\n\n    if (leftWidth + rightWidth + 3 > maxWidth) {\n        return leftPart + \"...\" + rightPart.substring(rightWidth - (maxWidth - leftWidth - 3));\n    }\n\n    return leftPart + \"...\" + rightPart;\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n        if (str == null) {\n            return null;\n        }\n        if (maxWidth < 4) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n        }\n        if (str.length() <= maxWidth) {\n            return str;\n        }\n        if (offset > str.length()) {\n            offset = str.length();\n        }\n        if (str.length() - offset < maxWidth - 3) {\n            offset = str.length() - maxWidth + 3;\n        }\n        final StringBuffer buffer = new StringBuffer(maxWidth);\n        buffer.append(str.substring(0, offset));\n        buffer.append(\"...\");\n        buffer.append(str.substring(str.length() - maxWidth + 4));\n        return buffer.toString();\n    }",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n\n    final StringBuffer buffer = new StringBuffer(maxWidth);\n\n    buffer.append(str.substring(0, offset));\n    buffer.append(\"...\");\n    buffer.append(str.substring(str.length() - (maxWidth - 3)));\n\n    return buffer.toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n        if (str == null) {\n            return null;\n        }\n\n        if (maxWidth < 4) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n        }\n\n        if (str.length() <= maxWidth) {\n            return str;\n        }\n\n        if (offset > str.length()) {\n            offset = str.length();\n        }\n\n        final String leftPart = str.substring(offset);\n        final int spaceIndex = leftPart.indexOf(' ');\n        if (spaceIndex == -1) {\n            return str.substring(0, maxWidth - 3) + \"...\";\n        }\n\n        if (spaceIndex > maxWidth - 5) {\n            return str.substring(0, maxWidth - 3) + \"...\";\n        }\n\n        return str.substring(0, offset + spaceIndex) + \"...\";\n    }",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n\n    final StringBuffer buffer = new StringBuffer(maxWidth);\n\n    buffer.append(str.substring(0, offset));\n    buffer.append(\"...\");\n    buffer.append(str.substring(str.length() - (maxWidth - 3)));\n\n    return buffer.toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n    if (str == null) {\n        return null;\n    }\n    if (maxWidth < 4) {\n        throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n    }\n    if (str.length() <= maxWidth) {\n        return str;\n    }\n    if (offset > str.length()) {\n        offset = str.length();\n    }\n    if (str.length() - offset < maxWidth - 3) {\n        offset = str.length() - (maxWidth - 3);\n    }\n    final StringBuffer buffer = new StringBuffer(maxWidth);\n    buffer.append(str.substring(0, offset));\n    buffer.append(\"...\");\n    buffer.append(str.substring(str.length() - (maxWidth - 3)));\n    return buffer.toString();\n}",
      "public static String abbreviate(final String str, int offset, final int maxWidth)  {\n        if (str == null) {\n            return null;\n        }\n\n        if (maxWidth < 4) {\n            throw new IllegalArgumentException(\"Minimum abbreviation width is 4\");\n        }\n\n        if (str.length() <= maxWidth) {\n            return str;\n        }\n\n        if (offset > str.length()) {\n            offset = str.length();\n        }\n\n        if (str.length() - offset < maxWidth - 3) {\n            offset = str.length() - (maxWidth - 3);\n        }\n\n        final String leftPart = str.substring(0, offset);\n        final int leftWidth = leftPart.length();\n        if (leftWidth + 3 > maxWidth) {\n            return leftPart.substring(0, maxWidth - 3) + \"...\";\n        }\n\n        final String rightPart = str.substring(offset);\n        final int rightWidth = rightPart.length();\n        final int toAppend = maxWidth - leftWidth - 3;\n        if (toAppend < rightWidth) {\n            return leftPart + \"...\" + rightPart.substring(rightWidth - toAppend);\n        }\n        return leftPart + \"...\" + rightPart;\n    }"
    ],
    [
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
      "private boolean equalShapes(Shape[] s1, Shape[] s2)  {\n    if (s1 == null) {\n        return (s2 == null);\n    }\n    if (s2 == null) {\n        return false;\n    }\n    if (s1.length != s2.length) {\n        return false;\n    }\n    for (int i = 0; i < s1.length; i++) {\n        if (!s1[i].equals(s2[i])) {\n            return false;\n        }\n    }\n    return true;\n}"
    ],
    [
      "private int getNameId(String symbolName)  {\n  if (!symbolNameMap.containsKey(symbolName)) \n  {\n    symbolNameMap.put(symbolName, symbolNameMap.size());\n  }\n  return symbolNameMap.get(symbolName);\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (!symbolName.isEmpty()) \n  {\n    Integer index = symbolMap.get(symbolName);\n    if (index != null) \n    {\n      return index;\n    } \n    else \n    {\n      int newIndex = symbolMap.size();\n      symbolMap.put(symbolName, newIndex);\n      return newIndex;\n    }\n  }\n  return 0;\n}",
      "private int getNameId(String symbolName)  {\n    if (!symbolNameMap.containsKey(symbolName))\n    {\n        symbolNameMap.put(symbolName, symbolNameMap.size());\n    }\n    return symbolNameMap.get(symbolName);\n}",
      "private int getNameId(String symbolName)  {\n  if (symbolName != lastSymbolName) \n  {\n    lastSymbolName = symbolName;\n    Integer index = symbolNameMap.get(symbolName);\n    if (index != null) \n    {\n      lastSymbolNameIndex = index;\n    } \n    else \n    {\n      lastSymbolNameIndex = symbolNameMap.size();\n      symbolNameMap.put(symbolName, lastSymbolNameIndex);\n    }\n  }\n  return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (!nameMap.containsKey(symbolName)) \n  {\n    nameMap.put(symbolName, nameMap.size());\n  }\n  return nameMap.get(symbolName);\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n    if (symbolName != lastSymbolName) \n    {\n        lastSymbolName = symbolName;\n        Integer index = symbolNameMap.get(symbolName);\n        if (index != null) \n        {\n            lastSymbolNameIndex = index;\n        } \n        else \n        {\n            lastSymbolNameIndex = symbolNameMap.size();\n            symbolNameMap.put(symbolName, lastSymbolNameIndex);\n        }\n    }\n    return lastSymbolNameIndex;\n}",
      "private int getNameId(String symbolName)  {\n  if (!nameMap.containsKey(symbolName)) \n  {\n    nameMap.put(symbolName, nameMap.size());\n  }\n  return nameMap.get(symbolName);\n}"
    ],
    [
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) \n    {\n        result = (double) peekedLong;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    if (p == PEEKED_NUMBER) \n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } \n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) \n    {\n        if (p == PEEKED_UNQUOTED) \n        {\n            peekedString = nextUnquotedValue();\n        } \n        else \n        {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        try \n        {\n            result = Double.parseDouble(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } \n        catch (NumberFormatException ignored) \n        {\n            // Fall back to parse as a double below.\n        }\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) \n    {\n        result = (double) peekedLong;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    if (p == PEEKED_NUMBER) \n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } \n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) \n    {\n        if (p == PEEKED_UNQUOTED) \n        {\n            peekedString = nextUnquotedValue();\n        } \n        else \n        {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        try \n        {\n            result = Double.parseDouble(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } \n        catch (NumberFormatException ignored) \n        {\n            // Fall back to parse as a double below.\n        }\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) \n    {\n        result = (double) peekedLong;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    if (p == PEEKED_NUMBER) \n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } \n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) \n    {\n        if (p == PEEKED_UNQUOTED) \n        {\n            peekedString = nextUnquotedValue();\n        } \n        else \n        {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        try \n        {\n            result = Double.parseDouble(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } \n        catch (NumberFormatException ignored) \n        {\n            // Fall back to parse as a double below.\n        }\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) \n    {\n        result = (double) peekedLong;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    if (p == PEEKED_NUMBER) \n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } \n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) \n    {\n        if (p == PEEKED_UNQUOTED) \n        {\n            peekedString = nextUnquotedValue();\n        } \n        else \n        {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        try \n        {\n            result = Double.parseDouble(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } \n        catch (NumberFormatException ignored) \n        {\n            // Fall back to parse as a double below.\n        }\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n        result = (double) peekedLong;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n        if (p == PEEKED_UNQUOTED) {\n            peekedString = nextUnquotedValue();\n        } else {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        try {\n            result = Double.parseDouble(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n            // Fall back to parse as a double below.\n        }\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n        result = (double) peekedLong;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n        if (p == PEEKED_UNQUOTED) {\n            peekedString = nextUnquotedValue();\n        } else {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        try {\n            result = Double.parseDouble(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n            // Fall back to parse as a double below.\n        }\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n        result = (double) peekedLong;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n        if (p == PEEKED_UNQUOTED) {\n            peekedString = nextUnquotedValue();\n        } else {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        try {\n            result = Double.parseDouble(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n            // Fall back to parse as a double below.\n        }\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n        result = (double) peekedLong;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n        if (p == PEEKED_UNQUOTED) {\n            peekedString = nextUnquotedValue();\n        } else {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        try {\n            result = Double.parseDouble(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n            // Fall back to parse as a double below.\n        }\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) {\n        result = (double) peekedLong;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n\n    if (p == PEEKED_NUMBER) {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) {\n        if (p == PEEKED_UNQUOTED) {\n            peekedString = nextUnquotedValue();\n        } else {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        try {\n            result = Double.parseDouble(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } catch (NumberFormatException ignored) {\n            // Fall back to parse as a double below.\n        }\n    } else {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n\n    peeked = PEEKED_BUFFERED;\n    result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}",
      "public double nextDouble() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    double result;\n    if (p == PEEKED_LONG) \n    {\n        result = (double) peekedLong;\n        peeked = PEEKED_NONE;\n        pathIndices[stackSize - 1]++;\n        return result;\n    }\n    if (p == PEEKED_NUMBER) \n    {\n        peekedString = new String(buffer, pos, peekedNumberLength);\n        pos += peekedNumberLength;\n    } \n    else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED || p == PEEKED_UNQUOTED) \n    {\n        if (p == PEEKED_UNQUOTED) \n        {\n            peekedString = nextUnquotedValue();\n        } \n        else \n        {\n            peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n        }\n        try \n        {\n            result = Double.parseDouble(peekedString);\n            peeked = PEEKED_NONE;\n            pathIndices[stackSize - 1]++;\n            return result;\n        } \n        catch (NumberFormatException ignored) \n        {\n            throw new IllegalStateException(\"Expected a double but was \" + peekedString + locationString());\n        }\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a double but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_BUFFERED;\n    result = Double.parseDouble(peekedString);\n    peekedString = null;\n    peeked = PEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n}"
    ],
    [
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLength = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLength);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null || repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLength = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLength);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLength = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLength);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}\n    //-----------------------------------------------------------------------\n    // Padding\n    //-----------------------------------------------------------------------",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null || repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    if (repeat == 1 || len == 1) {\n        return str;\n    }\n    final int newLen = len * repeat;\n    final StringBuilder buf = new StringBuilder(newLen);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null || repeat <= 0) {\n        return null;\n    }\n    final int len = str.length();\n    if (repeat == 1 || len == 0) {\n        return str;\n    }\n    final int newLen = len * repeat;\n    switch (len) {\n        case 1:\n            return repeat(str.charAt(0), repeat);\n        case 2:\n            final char ch0 = str.charAt(0);\n            final char ch1 = str.charAt(1);\n            final char[] output2 = new char[newLen];\n            for (int i = 0; i < newLen; i += 2) {\n                output2[i] = ch0;\n                output2[i + 1] = ch1;\n            }\n            return new String(output2);\n        default:\n            final StringBuilder buf = new StringBuilder(newLen);\n            for (int i = 0; i < repeat; i++) {\n                buf.append(str);\n            }\n            return buf.toString();\n    }\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLen = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLen);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null || repeat <= 0) {\n        return null;\n    }\n    final int len = str.length();\n    final int pads = repeat * len;\n    final StringBuilder buf = new StringBuilder(pads);\n    for (int i = 0; i < pads; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLen = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLen);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}\n    //-----------------------------------------------------------------------\n    // Padding\n    //-----------------------------------------------------------------------",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null || repeat <= 0) {\n        return null;\n    }\n    final int len = str.length();\n    final int pads = repeat * len;\n    final StringBuilder buf = new StringBuilder(pads);\n    for (int i = 0; i < pads; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}",
      "public static String repeat(final String str, final int repeat)  {\n    if (str == null) {\n        return null;\n    }\n    if (repeat <= 0) {\n        return EMPTY;\n    }\n    final int len = str.length();\n    final int bufLength = len * repeat;\n    final StringBuilder buf = new StringBuilder(bufLength);\n    for (int i = 0; i < repeat; i++) {\n        buf.append(str);\n    }\n    return buf.toString();\n}"
    ],
    [
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return clazz.newInstance();\n    }\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return clazz.newInstance();\n    }\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return clazz.newInstance();\n    }\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return clazz.newInstance();\n    }\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return clazz.newInstance();\n    }\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return clazz.newInstance();\n    }\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return clazz.newInstance();\n    }\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return clazz.newInstance();\n    }\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return clazz.newInstance();\n    }\n    return new UnrecognizedExtraField();\n}",
      "public static ZipExtraField createExtraField(final ZipShort headerId)\n        throws InstantiationException, IllegalAccessException  {\n    final Class<?> clazz = implementations.get(headerId);\n    if (clazz != null) {\n        return clazz.newInstance();\n    }\n    return new UnrecognizedExtraField();\n}"
    ],
    [
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) \n    {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) \n    {\n        if (chars.contains(c)) \n        {\n            count++;\n        }\n    }\n    return count;\n}",
      "public static int count(final String str, final String... set)  {\n    if (StringUtils.isEmpty(str) || deepEmpty(set)) {\n        return 0;\n    }\n    final CharSet chars = CharSet.getInstance(set);\n    int count = 0;\n    for (final char c : str.toCharArray()) {\n        if (chars.contains(c)) {\n            count++;\n        }\n    }\n    return count;\n}"
    ],
    [
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iterator = map.keySet().iterator();\n    while (iterator.hasNext()) {\n        Integer key = (Integer) iterator.next();\n        Collection markers = (Collection) map.get(key);\n        clone.put(key, (Collection) markers.clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) map.clone();\n    Iterator iterator = clone.keySet().iterator();\n    while (iterator.hasNext()) {\n        Integer key = (Integer) iterator.next();\n        Collection values = (Collection) clone.get(key);\n        Collection cloneValues = (Collection) values.clone();\n        clone.put(key, cloneValues);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) map.clone();\n    Iterator iterator = clone.entrySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Integer key = (Integer) entry.getKey();\n        Collection values = (Collection) entry.getValue();\n        Collection cloneValues = (Collection) values.clone();\n        iterator.remove();\n        clone.put(key, cloneValues);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) map.clone();\n    Iterator iterator = clone.keySet().iterator();\n    while (iterator.hasNext()) {\n        Integer key = (Integer) iterator.next();\n        Collection markers = (Collection) clone.get(key);\n        clone.put(key, (Collection) markers.clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    for (Iterator iterator = map.entrySet().iterator(); iterator.hasNext();) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Integer key = (Integer) entry.getKey();\n        Collection values = (Collection) entry.getValue();\n        Collection cloneValues = (Collection) values.clone();\n        clone.put(key, cloneValues);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iterator = map.keySet().iterator();\n    while (iterator.hasNext()) {\n        Integer key = (Integer) iterator.next();\n        Collection markers = (Collection) map.get(key);\n        Collection clonedMarkers = (Collection) markers.clone();\n        clone.put(key, clonedMarkers);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    for (Iterator iterator = map.keySet().iterator(); iterator.hasNext();) \n    {\n        Integer key = (Integer) iterator.next();\n        Collection values = (Collection) map.get(key);\n        Collection cloneValues = (Collection) values.clone();\n        clone.put(key, cloneValues);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) map.clone();\n    Iterator iterator = clone.entrySet().iterator();\n    while (iterator.hasNext()) \n    {\n        Map.Entry entry = (Map.Entry) iterator.next();\n        Integer key = (Integer) entry.getKey();\n        Collection values = (Collection) entry.getValue();\n        Collection cloneValues = (Collection) values.clone();\n        clone.put(key, cloneValues);\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = (Map) map.clone();\n    Iterator iterator = clone.keySet().iterator();\n    while (iterator.hasNext()) {\n        Integer key = (Integer) iterator.next();\n        Collection markers = (Collection) clone.get(key);\n        clone.put(key, (Collection) markers.clone());\n    }\n    return clone;\n}",
      "private Map cloneMarkerMap(Map map) throws CloneNotSupportedException  {\n    Map clone = new HashMap();\n    Iterator iterator = map.keySet().iterator();\n    while (iterator.hasNext()) {\n        Integer key = (Integer) iterator.next();\n        Collection values = (Collection) map.get(key);\n        if (values != null) {\n            Collection clonedValues = (Collection) values.clone();\n            iterator = clonedValues.iterator();\n            while (iterator.hasNext()) {\n                Marker m = (Marker) iterator.next();\n                m.addChangeListener(this);\n            }\n            clone.put(key, clonedValues);\n        }\n    }\n    return clone;\n}"
    ],
    [
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}",
      "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data)  {\n    final boolean lastIsUnparseableHolder = data.length > 0\n        && data[data.length - 1] instanceof UnparseableExtraFieldData;\n    final int regularExtraFieldCount =\n        lastIsUnparseableHolder ? data.length - 1 : data.length;\n\n    int sum = WORD * regularExtraFieldCount;\n    for (final ZipExtraField element : data) {\n        sum += element.getCentralDirectoryLength().getValue();\n    }\n\n    final byte[] result = new byte[sum];\n    int start = 0;\n    for (int i = 0; i < regularExtraFieldCount; i++) {\n        System.arraycopy(data[i].getHeaderId().getBytes(),\n                         0, result, start, 2);\n        System.arraycopy(data[i].getCentralDirectoryLength().getBytes(),\n                         0, result, start + 2, 2);\n        start += WORD;\n        final byte[] central = data[i].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n            start += central.length;\n        }\n    }\n    if (lastIsUnparseableHolder) {\n        final byte[] central = data[data.length - 1].getCentralDirectoryData();\n        if (central != null) {\n            System.arraycopy(central, 0, result, start, central.length);\n        }\n    }\n    return result;\n}"
    ],
    [
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        if (coll != null) {\n            boolean result = false;\n            final Iterator<? extends E> i = coll.iterator();\n            while (i.hasNext()) {\n                final Object obj = i.next();\n                if (!contains(obj)) {\n                    decorated().add(obj);\n                    setOrder.add(index, obj);\n                    result = true;\n                }\n            }\n            return result;\n        } else {\n            // let the decorated list handle the case of null argument\n            return decorated().addAll(index, null);\n        }\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (contains(e)) {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        if (changed) {\n            setOrder.addAll(index, toAdd);\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        if (coll != null) {\n            boolean result = false;\n            final Iterator<? extends E> i = coll.iterator();\n            while (i.hasNext()) {\n                final Object obj = i.next();\n                if (contains(obj)) {\n                    continue;\n                }\n                decorated().add(index, obj);\n                result = true;\n            }\n            return result;\n        } else {\n            // let the decorated list handle the case of null argument\n            return decorated().addAll(index, null);\n        }\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // Check if the collection is null\n        if (coll == null) {\n            return false;\n        }\n\n        // Check if the index is valid\n        if (index < 0 || index > size()) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size());\n        }\n\n        // Check if the collection is already a List\n        if (coll instanceof List) {\n            List<? extends E> list = (List<? extends E>) coll;\n            return addAll(index, list);\n        }\n\n        // Check if the collection is a Set\n        if (coll instanceof Set) {\n            Set<? extends E> set = (Set<? extends E>) coll;\n            return addAll(index, set);\n        }\n\n        // Check if the collection is a Bag\n        if (coll instanceof Bag) {\n            Bag<? extends E> bag = (Bag<? extends E>) coll;\n            return addAll(index, bag);\n        }\n\n        // Check if the collection is a SortedBag\n        if (coll instanceof SortedBag) {\n            SortedBag<? extends E> sortedBag = (SortedBag<? extends E>) coll;\n            return addAll(index, sortedBag);\n        }\n\n        // Check if the collection is a ListOrderedSet\n        if (coll instanceof ListOrderedSet) {\n            ListOrderedSet<? extends E> listOrderedSet = (ListOrderedSet<? extends E>) coll;\n            return addAll(index, listOrderedSet);\n        }\n\n        // Check if the collection is a PredicatedCollection\n        if (coll instanceof PredicatedCollection) {\n            PredicatedCollection<? extends E> predicatedCollection = (PredicatedCollection<? extends E>) coll;\n            return addAll(index, predicatedCollection);\n        }\n\n        // Check if the collection is a CollectionBag\n        if (coll instanceof CollectionBag) {\n            CollectionBag<? extends E> collectionBag = (CollectionBag<? extends E>) coll;\n            return addAll(index, collectionBag);\n        }\n\n        // Check if the collection is a CollectionSortedBag\n        if (coll instanceof CollectionSortedBag) {\n}\n}",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        if (coll != null) {\n            boolean result = false;\n            final Iterator<? extends E> i = coll.iterator();\n            while (i.hasNext()) {\n                final Object obj = i.next();\n                if (!contains(obj)) {\n                    decorated().add(obj);\n                    setOrder.add(index, obj);\n                    result = true;\n                }\n            }\n            return result;\n        } else {\n            // let the decorated bag handle the case of null argument\n            return decorated().addAll(null);\n        }\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        if (coll != null) {\n            boolean result = false;\n            final Iterator<? extends E> i = coll.iterator();\n            while (i.hasNext()) {\n                final Object obj = i.next();\n                if (contains(obj)) {\n                    continue;\n                }\n                decorated().add(obj);\n                setOrder.add(index, obj);\n                result = true;\n            }\n            return result;\n        } else {\n            // let the decorated bag handle the case of null argument\n            return decorated().addAll(null);\n        }\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        if (coll != null) {\n            boolean result = false;\n            final Iterator<? extends E> i = coll.iterator();\n            while (i.hasNext()) {\n                final Object obj = i.next();\n                if (contains(obj)) {\n                    continue;\n                }\n                decorated().add(obj);\n                setOrder.add(index, obj);\n                result = true;\n            }\n            return result;\n        } else {\n            // let the decorated bag handle the case of null argument\n            return decorated().addAll(index, null);\n        }\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        boolean changed = false;\n        // collect all elements to be added for performance reasons\n        final List<E> toAdd = new ArrayList<E>();\n        for (final E e : coll) {\n            if (contains(e)) {\n                continue;\n            }\n            decorated().add(e);\n            toAdd.add(e);\n            changed = true;\n        }\n        if (changed) {\n            setOrder.addAll(index, toAdd);\n        }\n        return changed;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  {\n        // Check if the collection is empty\n        if (coll.isEmpty()) {\n            return false;\n        }\n\n        // Check if the collection is already in this list\n        if (containsAll(coll)) {\n            return false;\n        }\n\n        // Add the collection to the list\n        final Iterator<? extends E> i = coll.iterator();\n        while (i.hasNext()) {\n            final E item = i.next();\n            if (!contains(item)) {\n                add(index, item);\n                index++;\n            }\n        }\n        return true;\n    }",
      "@Override\n    public boolean addAll(final int index, final Collection<? extends E> coll)  throws UnsupportedOperationException {\n        if (coll == null) {\n            throw new NullPointerException(\"The collection to add cannot be null\");\n        }\n        if (index < 0 || index > size()) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size());\n        }\n        if (coll instanceof SortedSet) {\n            final SortedSet<? extends E> sortedSet = (SortedSet<? extends E>) coll;\n            final Iterator<? extends E> it = sortedSet.iterator();\n            boolean changed = false;\n            while (it.hasNext()) {\n                final E item = it.next();\n                if (!contains(item)) {\n                    add(index++, item);\n                    changed = true;\n                }\n            }\n            return changed;\n        } else {\n            final Iterator<? extends E> it = coll.iterator();\n            boolean changed = false;\n            while (it.hasNext()) {\n                final E item = it.next();\n                if (!contains(item)) {\n                    add(index++, item);\n                    changed = true;\n                }\n            }\n            return changed;\n        }\n    }"
    ],
    [
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}",
      "private double eval(UnivariateFunction f, double x)  throws TooManyEvaluationsException {\n    return f.value(x);\n}"
    ],
    [
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}",
      "public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints)  {\n    List<LinearConstraint> normalizedConstraints = new ArrayList<LinearConstraint>();\n    for (LinearConstraint constraint : originalConstraints) \n    {\n        normalizedConstraints.add(normalize(constraint));\n    }\n    return normalizedConstraints;\n}"
    ],
    [
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return this.compareTo(bin) == 0 || this.compareTo(bin) == -1 || this.compareTo(bin) == 1;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return (this.lowerBound <= bin.upperBound) && (this.upperBound >= bin.lowerBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return this.compareTo(bin) == 0 || this.compareTo(bin) == -1 || this.compareTo(bin) == 1;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return (this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return (this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return (this.lowerBound <= bin.upperBound && this.upperBound >= bin.lowerBound);\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    if (this.lowerBound > bin.upperBound) \n    {\n        return false;\n    }\n    if (this.upperBound < bin.lowerBound) \n    {\n        return false;\n    }\n    return true;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return this.compareTo(bin) == 0 || this.compareTo(bin) == -1 || this.compareTo(bin) == 1;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return this.compareTo(bin) == 0 || this.compareTo(bin) == -1 || this.compareTo(bin) == 1;\n}",
      "public boolean overlapsWith(SimpleHistogramBin bin)  {\n    if (bin == null) \n    {\n        throw new IllegalArgumentException(\"Null 'bin' argument.\");\n    }\n    return (this.lowerBound <= bin.upperBound && \n            this.upperBound >= bin.lowerBound);\n}"
    ],
    [
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    char[] chars = str.toCharArray();\n    char lastCharType = Character.getType(chars[0]);\n    while (i < chars.length) {\n        char thisCharType = Character.getType(chars[i]);\n        if (camelCase && thisCharType == Character.LOWERCASE_LETTER && lastCharType == Character.UPPERCASE_LETTER) {\n            if (i > start) {\n                list.add(str.substring(start, i));\n                start = i;\n            }\n        } else {\n            if (thisCharType != lastCharType) {\n                if (thisCharType == Character.LOWERCASE_LETTER && lastCharType == Character.UPPERCASE_LETTER && i > start) {\n                    list.add(str.substring(start, i - 1));\n                    start = i - 1;\n                } else {\n                    list.add(str.substring(start, i));\n                    start = i;\n                }\n            }\n        }\n        lastCharType = thisCharType;\n        i++;\n    }\n    list.add(str.substring(start, i));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    char lastCharType = Character.getType(str.charAt(0));\n    while (i < len) {\n        char charType = Character.getType(str.charAt(i));\n        if (charType == Character.UPPERCASE_LETTER && camelCase &&\n                lastCharType == Character.LOWERCASE_LETTER) {\n            if (i > start) {\n                list.add(str.substring(start, i));\n                start = i;\n            }\n        }\n        lastCharType = charType;\n        if (charType == Character.LOWERCASE_LETTER || charType == Character.UPPERCASE_LETTER ||\n                charType == Character.TITLECASE_LETTER) {\n            if (charType != Character.LOWERCASE_LETTER || !camelCase) {\n                if (i > start) {\n                    list.add(str.substring(start, i));\n                    start = i;\n                }\n            }\n        } else {\n            if (i > start) {\n                list.add(str.substring(start, i));\n                start = i;\n            }\n            list.add(Character.toString(str.charAt(i)));\n            start = i + 1;\n        }\n        i++;\n    }\n    if (i > start) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    char lastCharType = Character.getType(str.charAt(0));\n    while (i < len) {\n        char thisCharType = Character.getType(str.charAt(i));\n        if (thisCharType != lastCharType) {\n            if (camelCase && thisCharType == Character.LOWERCASE_LETTER && lastCharType == Character.UPPERCASE_LETTER) {\n                if (i > start) {\n                    list.add(str.substring(start, i - 1));\n                    start = i - 1;\n                }\n            } else {\n                list.add(str.substring(start, i));\n                start = i;\n            }\n            lastCharType = thisCharType;\n        }\n        i++;\n    }\n    list.add(str.substring(start, i));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    char lastCharType = Character.getType(str.charAt(0));\n    while (i < len) {\n        char charType = Character.getType(str.charAt(i));\n        if (charType == Character.UPPERCASE_LETTER && camelCase &&\n                lastCharType == Character.LOWERCASE_LETTER) {\n            if (i > start) {\n                list.add(str.substring(start, i));\n                start = i;\n            }\n        } else if (charType != lastCharType) {\n            lastCharType = charType;\n            if (charType == Character.LOWERCASE_LETTER && camelCase &&\n                    lastCharType == Character.UPPERCASE_LETTER) {\n                // we found the end of a camelCase word,\n                // but started with a lowercase letter -\n                // fix the last word\n                int j = list.size() - 1;\n                String last = list.remove(j);\n                list.add(last.substring(0, last.length() - 1));\n                list.add(last.substring(last.length() - 1));\n                start = i;\n            } else {\n                if (camelCase && lastCharType == Character.LOWERCASE_LETTER &&\n                        charType == Character.UPPERCASE_LETTER) {\n                    // we found the start of a camelCase word,\n                    // but ended with a lowercase letter -\n                    // keep the following letters in the same word\n                } else {\n                    list.add(str.substring(start, i));\n                    start = i;\n                }\n            }\n        }\n        i++;\n}\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    char lastCharType = Character.getType(str.charAt(0));\n    while (i < len) {\n        char thisCharType = Character.getType(str.charAt(i));\n        if (thisCharType != lastCharType) {\n            if (camelCase && thisCharType == Character.LOWERCASE_LETTER\n                && lastCharType == Character.UPPERCASE_LETTER) {\n                if (i > start) {\n                    list.add(str.substring(start, i - 1));\n                    start = i - 1;\n                }\n            } else {\n                list.add(str.substring(start, i));\n                start = i;\n            }\n            lastCharType = thisCharType;\n        }\n        i++;\n    }\n    list.add(str.substring(start, i));\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  ",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    char lastCharType = Character.getType(str.charAt(0));\n    while (i < len) {\n        char charType = Character.getType(str.charAt(i));\n        if (charType == Character.UPPERCASE_LETTER && camelCase && i > start && lastCharType == Character.LOWERCASE_LETTER) {\n            list.add(str.substring(start, i));\n            start = i;\n        }\n        lastCharType = charType;\n        if (charType == Character.LOWERCASE_LETTER || charType == Character.UPPERCASE_LETTER || charType == Character.TITLECASE_LETTER) {\n            if (charType != Character.LOWERCASE_LETTER && lastCharType == Character.LOWERCASE_LETTER) {\n                list.add(str.substring(start, i));\n                start = i;\n            }\n        } else {\n            if (lastCharType == Character.LOWERCASE_LETTER || lastCharType == Character.UPPERCASE_LETTER || lastCharType == Character.TITLECASE_LETTER) {\n                list.add(str.substring(start, i));\n                start = i;\n            }\n        }\n        i++;\n    }\n    if (lastCharType == Character.LOWERCASE_LETTER || lastCharType == Character.UPPERCASE_LETTER || lastCharType == Character.TITLECASE_LETTER) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    char lastCharType = Character.getType(str.charAt(0));\n    while (i < len) {\n        char charType = Character.getType(str.charAt(i));\n        if (charType == Character.UPPERCASE_LETTER && camelCase &&\n                lastCharType == Character.LOWERCASE_LETTER) {\n            if (i > start) {\n                list.add(str.substring(start, i));\n                start = i;\n            }\n        }\n        lastCharType = charType;\n        if (charType == Character.LOWERCASE_LETTER || charType == Character.UPPERCASE_LETTER ||\n                charType == Character.TITLECASE_LETTER) {\n            if (charType != Character.LOWERCASE_LETTER || !camelCase) {\n                if (i > start) {\n                    list.add(str.substring(start, i));\n                    start = i;\n                }\n            }\n        } else {\n            if (i > start) {\n                list.add(str.substring(start, i));\n                start = i;\n            }\n            list.add(String.valueOf(str.charAt(i)));\n            start = i + 1;\n        }\n        i++;\n    }\n    if (i > start) {\n        list.add(str.substring(start, i));\n    }\n    return list.toArray(new String[list.size()]);\n}",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  ",
      "private static String[] splitByCharacterType(final String str, final boolean camelCase)  {\n    if (str == null) {\n        return null;\n    }\n    final int len = str.length();\n    if (len == 0) {\n        return ArrayUtils.EMPTY_STRING_ARRAY;\n    }\n    final List<String> list = new ArrayList<String>();\n    int i = 0, start = 0;\n    char lastCharType = Character.getType(str.charAt(0));\n    while (i < len) {\n        char thisCharType = Character.getType(str.charAt(i));\n        if (camelCase && thisCharType == Character.LOWERCASE_LETTER && lastCharType == Character.UPPERCASE_LETTER) {\n            if (i > start) {\n                list.add(str.substring(start, i));\n                start = i;\n            }\n        } else {\n            if (thisCharType != lastCharType) {\n                if (thisCharType == Character.UPPERCASE_LETTER && lastCharType == Character.LOWERCASE_LETTER && i > start) {\n                    list.add(str.substring(start, i - 1));\n                    start = i - 1;\n                } else {\n                    list.add(str.substring(start, i));\n                    start = i;\n                }\n            }\n        }\n        lastCharType = thisCharType;\n        i++;\n    }\n    list.add(str.substring(start, i));\n    return list.toArray(new String[list.size()]);\n}"
    ],
    [
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = ISOChronology.getInstanceUTC();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, Locale.getDefault(), iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = ISOChronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = ISOChronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, Locale.getDefault(), iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = ISOChronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, Locale.getDefault(), iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = ISOChronology.getInstance();\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    \n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
      "public long parseMillis(String text)  {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(null);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, 0);\n    if (newPos >= 0) {\n        if (newPos >= text.length()) {\n            long millis = bucket.computeMillis(true, text);\n            if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                int parsedOffset = bucket.getOffsetInteger();\n                DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                chrono = chrono.withZone(parsedZone);\n            } else if (bucket.getZone() != null) {\n                chrono = chrono.withZone(bucket.getZone());\n            }\n            return millis;\n        }\n    } else {\n        newPos = ~newPos;\n    }\n    throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
    ],
    [
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode pos = new MeasuredNode(n, 0, false);\n    MeasuredNode neg = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false);\n    return new MinimizedCondition(pos, neg);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode pos = new MeasuredNode(n, 0, false);\n    MeasuredNode neg = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false);\n    return new MinimizedCondition(pos, neg);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode pos = new MeasuredNode(n, 0, false);\n    MeasuredNode neg = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false);\n    return new MinimizedCondition(pos, neg);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode pos = new MeasuredNode(n, 0, false);\n    MeasuredNode neg = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false);\n    return new MinimizedCondition(pos, neg);\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode pos = new MeasuredNode(n, 0, false);\n    MeasuredNode neg = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false);\n    return new MinimizedCondition(pos, neg);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    switch (n.getType()) {\n      case Token.NOT: {\n        MinimizedCondition subtree =\n            computeMinimizedCondition(n.getFirstChild().detachFromParent());\n        ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n            subtree.positive.cloneTree().addNot(),\n            subtree.negative.cloneTree());\n        ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n            subtree.negative.negate(),\n            subtree.positive);\n        return new MinimizedCondition(\n            Collections.min(positiveAsts, AST_LENGTH_COMPARATOR),\n            new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false));\n      }\n      case Token.AND:\n      case Token.OR: {\n        int opType = n.getType();\n        int complementType = opType == Token.AND ? Token.OR : Token.AND;\n        MinimizedCondition leftSubtree =\n            computeMinimizedCondition(n.getFirstChild().detachFromParent());\n        MinimizedCondition rightSubtree =\n            computeMinimizedCondition(n.getLastChild().detachFromParent());\n        ImmutableList<MeasuredNode> positiveAsts = ImmutableList.of(\n            MeasuredNode.addNode(new Node(opType).srcref(n),\n                leftSubtree.positive.cloneTree(),\n                rightSubtree.positive.cloneTree()),\n            MeasuredNode.addNode(new Node(complementType).srcref(n),\n                leftSubtree.negative.cloneTree(),\n                rightSubtree.negative.cloneTree()).negate());\n        ImmutableList<MeasuredNode> negativeAsts = ImmutableList.of(\n            MeasuredNode.addNode(new Node(opType).srcref(n),\n                leftSubtree.negative.cloneTree(),\n                rightSubtree.negative.cloneTree()),\n}\n}\n}",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode pos = new MeasuredNode(n, 0, false);\n    MeasuredNode neg = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false);\n    return new MinimizedCondition(pos, neg);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode pos = new MeasuredNode(n, 0, false);\n    MeasuredNode neg = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false);\n    return new MinimizedCondition(pos, neg);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode pos = new MeasuredNode(n, 0, false);\n    MeasuredNode neg = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false);\n    return new MinimizedCondition(pos, neg);\n  }",
      "static MinimizedCondition unoptimized(Node n)  {\n    Preconditions.checkArgument(n.getParent() == null);\n    MeasuredNode pos = new MeasuredNode(n, 0, false);\n    MeasuredNode neg = new MeasuredNode(new Node(Token.SCRIPT), Integer.MAX_VALUE, false);\n    return new MinimizedCondition(pos, neg);\n  }"
    ],
    [
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) \n    {\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) \n    {\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) \n    {\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) \n    {\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) \n    {\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E value : values) {\n        condensed.add(value);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}",
      "public static <E extends Enum<E>> long[] generateBitVectors(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.noNullElements(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) \n    {\n        condensed.add(constant);\n    }\n    final long[] result = new long[(enumClass.getEnumConstants().length - 1) / Long.SIZE + 1];\n    for (final E value : condensed) \n    {\n        result[value.ordinal() / Long.SIZE] |= 1 << (value.ordinal() % Long.SIZE);\n    }\n    ArrayUtils.reverse(result);\n    return result;\n}"
    ],
    [
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }",
      "public PartialConverter addPartialConverter(PartialConverter converter)\n            throws SecurityException  {\n        checkAlterPartialConverters();\n        if (converter == null) {\n            return null;\n        }\n        PartialConverter[] removed = new PartialConverter[1];\n        iPartialConverters = iPartialConverters.add(converter, removed);\n        return removed[0];\n    }"
    ],
    [
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isPropertyScope()) \n    {\n        // We have to search up the property scope chain to find the nearest\n        // lexical scope.\n        int depth = 0;\n        while (scope.isPropertyScope()) \n        {\n            scope = scope.getParentScope();\n            depth++;\n        }\n        return depth + scope.getLexicalScopeDepth();\n    }\n    else if (scope.isDocInfoScope()) \n    {\n        return 0;\n    }\n    else \n    {\n        return scope.getDepth();\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isPropertyScope()) {\n        int depth = 0;\n        for (SymbolScope current = scope; current != null; current = current.getParent()) {\n            if (current.isLexicalScope()) {\n                depth += current.getDepth();\n                break;\n            }\n        }\n        return depth;\n    } else if (scope.isDocInfoScope()) {\n        return 0;\n    } else {\n        return scope.getDepth();\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isDocInfoScope()) \n    {\n        return 0;\n    }\n    if (scope.isPropertyScope()) \n    {\n        return getLexicalScopeDepth(scope.getParentScope()) + 1;\n    }\n    return scope.getDepth();\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isPropertyScope()) {\n        int depth = 0;\n        for (SymbolScope current = scope; current != null; current = current.getParent()) {\n            if (current.isLexicalScope()) {\n                depth += current.getDepth();\n                break;\n            }\n        }\n        return depth;\n    } else if (scope.isDocInfoScope()) {\n        return 0;\n    } else {\n        return scope.getDepth();\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isDocInfoScope()) {\n        return 0;\n    }\n    if (scope.isPropertyScope()) {\n        return scope.getLexicalScopeDepth() + 1;\n    }\n    return scope.getDepth();\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isDocInfoScope()) {\n        return 0;\n    }\n    if (scope.isPropertyScope()) {\n        int depth = 0;\n        while (scope.isPropertyScope()) {\n            scope = scope.getParent();\n            depth++;\n        }\n        return depth + getLexicalScopeDepth(scope);\n    }\n    return scope.getDepth();\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isDocInfoScope()) {\n        return 0;\n    } else if (scope.isPropertyScope()) {\n        return getLexicalScopeDepth(scope.getParentScope()) + 1;\n    } else {\n        return scope.getDepth();\n    }\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isDocInfoScope()) \n    {\n        return 0;\n    }\n    if (scope.isPropertyScope()) \n    {\n        int depth = 0;\n        for (SymbolScope current = scope; current != null; current = current.getParent()) \n        {\n            if (!current.isDocInfoScope()) \n            {\n                depth++;\n            }\n        }\n        return depth;\n    }\n    return scope.getDepth();\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isDocInfoScope()) {\n        return 0;\n    }\n    if (scope.isPropertyScope()) {\n        int depth = 0;\n        for (SymbolScope parent = scope.getParentScope();\n                parent != null && !parent.isDocInfoScope();\n                parent = parent.getParentScope()) {\n            depth++;\n        }\n        return depth + getLexicalScopeDepth(scope.getParentScope());\n    }\n    return getLexicalScopeDepth(scope.getParentScope()) + 1;\n}",
      "private int getLexicalScopeDepth(SymbolScope scope)  {\n    if (scope.isDocInfoScope()) {\n        return 0;\n    }\n    if (scope.isPropertyScope()) {\n        int depth = 0;\n        while (scope != null) {\n            if (scope.isLexicalScope()) {\n                return depth + scope.getDepth();\n            }\n            depth++;\n            scope = scope.getParent();\n        }\n    }\n    return scope.getDepth();\n}"
    ],
    [
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n    final int rows         = rawData.length;\n    final int columns      = rawData[0].length;\n    final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n    final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n    // safety checks\n    for (int i = 0; i < rawData.length; ++i) {\n        final int length = rawData[i].length;\n        if (length != columns) {\n            throw new DimensionMismatchException(columns, length);\n        }\n    }\n\n    // allocate storage blocks, taking care of smaller ones at right and bottom\n    final double[][] blocks = new double[blockRows * blockColumns][];\n    int blockIndex = 0;\n    for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n        final int pStart = iBlock * BLOCK_SIZE;\n        final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n        final int iHeight = pEnd - pStart;\n        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n            final int qStart = jBlock * BLOCK_SIZE;\n            final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n            final int jWidth = qEnd - qStart;\n\n            // allocate new block\n            final double[] block = new double[iHeight * jWidth];\n            blocks[blockIndex] = block;\n\n            // copy data\n            int index = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                index += jWidth;\n            }\n            ++blockIndex;\n        }\n    }\n\n    return blocks;\n}",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
      "public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException  {\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }"
    ],
    [
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n        final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n        for (final E constant : values) {\n            Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n            condensed.add(constant);\n        }\n        long result = 0;\n        for (final E value : condensed) {\n            result |= 1L << value.ordinal();\n        }\n        return result;\n    }",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    long result = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result |= 1L << constant.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    long result = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result |= 1L << constant.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    long result = 0;\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        result |= 1L << constant.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}",
      "public static <E extends Enum<E>> long generateBitVector(final Class<E> enumClass, final Iterable<E> values)  {\n    asEnum(enumClass);\n    Validate.notNull(values);\n    final EnumSet<E> condensed = EnumSet.noneOf(enumClass);\n    for (final E constant : values) {\n        Validate.isTrue(constant != null, NULL_ELEMENTS_NOT_PERMITTED);\n        condensed.add(constant);\n    }\n    long result = 0;\n    for (final E value : condensed) {\n        result |= 1L << value.ordinal();\n    }\n    return result;\n}"
    ],
    [
      "protected static Dfp expInternal(final Dfp a)  {\n        final Dfp zero = a.getField().getZero();\n        final Dfp one = a.getField().getOne();\n        final Dfp two = a.getField().getTwo();\n\n        Dfp y = one;\n        Dfp num = a;\n        Dfp py = new Dfp(y);\n        for (int i = 1; i < 10000; i++) {\n            num = num.multiply(a);\n            num = num.divide(i);\n            y = y.add(num);\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n        final Dfp zero = a.getField().getZero();\n        final Dfp one = a.getField().getOne();\n        final Dfp two = a.getField().getTwo();\n\n        Dfp y = new Dfp(one);\n        Dfp x = new Dfp(a);\n        Dfp py = new Dfp(y);\n        for (int i = 1; i < 10000; i++) {\n            x = x.multiply(a);\n            x = x.divide(i);\n            y = y.add(x);\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp y = a.getField().getOne();\n    Dfp x = new Dfp(a);\n    Dfp py = new Dfp(y);\n    Dfp fact = a.getField().getOne();\n    for (int i = 1; i < 10000; i++) {\n        fact = fact.multiply(a);\n        fact = fact.divide(new Dfp(i));\n        x = x.multiply(a);\n        y = y.add(x.multiply(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n        final Dfp one = a.getField().getOne();\n        final Dfp zero = a.getField().getZero();\n        final Dfp two = a.getField().getTwo();\n\n        Dfp x = a;\n        Dfp y = new Dfp(one);\n        Dfp py = new Dfp(y);\n        for (int i = 1; i < 10000; i++) {\n            Dfp fact = new Dfp(one);\n            for (int j = 1; j <= i; j++) {\n                fact = fact.multiply(new Dfp(j));\n            }\n            x = x.multiply(a);\n            y = y.add(x.divide(fact));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n        final Dfp one = a.getField().getOne();\n        final Dfp two = a.getField().getTwo();\n        final Dfp zero = a.getField().getZero();\n\n        final Dfp y = new Dfp(one);\n        final Dfp py = new Dfp(y);\n        final Dfp x = new Dfp(a);\n\n        for (int i = 1; i < 10000; i++) {\n            Dfp fact = one;\n            for (int j = 1; j <= i; j++) {\n                fact = fact.multiply(new Dfp(j));\n            }\n            x = x.multiply(a);\n            y = y.add(x.divide(fact));\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n        final Dfp one = a.getField().getOne();\n        final Dfp two = a.getField().getTwo();\n        final Dfp zero = a.getField().getZero();\n\n        Dfp y = new Dfp(one);\n        Dfp x = new Dfp(a);\n        Dfp py = new Dfp(y);\n        for (int i = 1; i < 10000; i++) {\n            x = x.multiply(a);\n            x = x.divide(i);\n            y = y.add(x);\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n    Dfp x = a;\n    Dfp y = new Dfp(a.getField().getOne());\n    Dfp py = new Dfp(y);\n    Dfp fact = new Dfp(a.getField().getOne());\n\n    for (int i = 1; i < 10000; i++) {\n        fact = fact.multiply(new Dfp(i));\n        x = x.multiply(a);\n        y = y.add(x.divide(fact));\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n    final Dfp one = a.getField().getOne();\n    final Dfp two = a.getField().getTwo();\n    final Dfp zero = a.getField().getZero();\n    Dfp y = new Dfp(one);\n    Dfp x = new Dfp(a);\n    Dfp py = new Dfp(y);\n    for (int i = 1; i < 10000; i++) {\n        x = x.multiply(a);\n        x = x.divide(new Dfp(i));\n        y = y.add(x);\n        if (y.equals(py)) {\n            break;\n        }\n        py = new Dfp(y);\n    }\n\n    return y;\n\n}",
      "protected static Dfp expInternal(final Dfp a)  {\n        final Dfp one = a.getField().getOne();\n        final Dfp zero = a.getField().getZero();\n        Dfp y = one;\n        Dfp x = a;\n        Dfp py = new Dfp(y);\n        for (int i = 1; i < 10000; i++) {\n            x = x.multiply(a);\n            x = x.divide(i);\n            y = y.add(x);\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }",
      "protected static Dfp expInternal(final Dfp a)  {\n        final Dfp zero = a.getField().getZero();\n        final Dfp one = a.getField().getOne();\n        final Dfp two = a.getField().getTwo();\n\n        Dfp y = one;\n        Dfp num = one;\n        Dfp py = new Dfp(y);\n        for (int i = 1; i < 10000; i++) {\n            num = num.multiply(a);\n            num = num.divide(i);\n            y = y.add(num);\n            if (y.equals(py)) {\n                break;\n            }\n            py = new Dfp(y);\n        }\n\n        return y;\n\n    }"
    ],
    [
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getRealPart() * y.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, 0, new T(inverse * z.getRealPart()), new T(-inverse * y.getRealPart()));\n    } else if (FastMath.abs(y.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, new T(-inverse * z.getRealPart()), 0, new T(inverse * x.getRealPart()));\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + y.getRealPart() * y.getRealPart());\n    return new FieldVector3D<T>(field, new T(inverse * y.getRealPart()), new T(-inverse * x.getRealPart()), 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getRealPart() * y.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, 0, new FieldDouble<T>(field, inverse * z.getRealPart()), new FieldDouble<T>(field, -inverse * y.getRealPart()));\n    } else if (FastMath.abs(y.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, new FieldDouble<T>(field, -inverse * z.getRealPart()), 0, new FieldDouble<T>(field, inverse * x.getRealPart()));\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + y.getRealPart() * y.getRealPart());\n    return new FieldVector3D<T>(field, new FieldDouble<T>(field, inverse * y.getRealPart()), new FieldDouble<T>(field, -inverse * x.getRealPart()), 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getRealPart() * y.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, 0, field.getZero().add(inverse * z), field.getZero().subtract(inverse * y));\n    } else if (FastMath.abs(y.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, field.getZero().subtract(inverse * z), 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + y.getRealPart() * y.getRealPart());\n    return new FieldVector3D<T>(field, inverse * y, field.getZero().subtract(inverse * x), 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getRealPart() * y.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, 0, field.getZero().subtract(inverse * z), field.getZero().subtract(inverse * y));\n    } else if (FastMath.abs(y.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, field.getZero().subtract(inverse * z), 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + y.getRealPart() * y.getRealPart());\n    return new FieldVector3D<T>(field, inverse * y, field.getZero().subtract(inverse * x), 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getRealPart() * y.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, 0, new FieldDouble<T>(field, inverse * z.getRealPart()), new FieldDouble<T>(field, -inverse * y.getRealPart()));\n    } else if (FastMath.abs(y.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, new FieldDouble<T>(field, -inverse * z.getRealPart()), 0, new FieldDouble<T>(field, inverse * x.getRealPart()));\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + y.getRealPart() * y.getRealPart());\n    return new FieldVector3D<T>(field, new FieldDouble<T>(field, inverse * y.getRealPart()), new FieldDouble<T>(field, -inverse * x.getRealPart()), 0);\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getRealPart() * y.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, 0, field.getZero().add(inverse * z), field.getZero().subtract(inverse * y));\n    } else if (FastMath.abs(y.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, field.getZero().subtract(inverse * z), 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + y.getRealPart() * y.getRealPart());\n    return new FieldVector3D<T>(field, inverse * y, field.getZero().subtract(inverse * x), 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getRealPart() * y.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, 0, new FieldDouble<T>(field, inverse * z.getRealPart()), new FieldDouble<T>(field, -inverse * y.getRealPart()));\n    } else if (FastMath.abs(y.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, new FieldDouble<T>(field, -inverse * z.getRealPart()), 0, new FieldDouble<T>(field, inverse * x.getRealPart()));\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + y.getRealPart() * y.getRealPart());\n    return new FieldVector3D<T>(field, new FieldDouble<T>(field, inverse * y.getRealPart()), new FieldDouble<T>(field, -inverse * x.getRealPart()), 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getRealPart() * y.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, 0, new FieldDouble<T>(field, inverse * z.getRealPart()), new FieldDouble<T>(field, -inverse * y.getRealPart()));\n    } else if (FastMath.abs(y.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, new FieldDouble<T>(field, -inverse * z.getRealPart()), 0, new FieldDouble<T>(field, inverse * x.getRealPart()));\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + y.getRealPart() * y.getRealPart());\n    return new FieldVector3D<T>(field, new FieldDouble<T>(field, inverse * y.getRealPart()), new FieldDouble<T>(field, -inverse * x.getRealPart()), 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getRealPart() * y.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, 0, field.getZero().add(inverse * z), field.getZero().subtract(inverse * y));\n    } else if (FastMath.abs(y.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, field.getZero().subtract(inverse * z), 0, inverse * x);\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + y.getRealPart() * y.getRealPart());\n    return new FieldVector3D<T>(field, inverse * y, field.getZero().subtract(inverse * x), 0);\n\n}",
      "public FieldVector3D<T> orthogonal() throws MathArithmeticException  {\n    double threshold = 0.6 * getNorm();\n    if (threshold == 0) {\n        throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n    }\n\n    if (FastMath.abs(x.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(y.getRealPart() * y.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, 0, new FieldDouble<T>(field, inverse * z.getRealPart()), new FieldDouble<T>(field, -inverse * y.getRealPart()));\n    } else if (FastMath.abs(y.getRealPart()) <= threshold) {\n        double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + z.getRealPart() * z.getRealPart());\n        return new FieldVector3D<T>(field, new FieldDouble<T>(field, -inverse * z.getRealPart()), 0, new FieldDouble<T>(field, inverse * x.getRealPart()));\n    }\n    double inverse  = 1 / FastMath.sqrt(x.getRealPart() * x.getRealPart() + y.getRealPart() * y.getRealPart());\n    return new FieldVector3D<T>(field, new FieldDouble<T>(field, inverse * y.getRealPart()), new FieldDouble<T>(field, -inverse * x.getRealPart()), 0);\n\n}"
    ],
    [
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (other.isNaturalOrdering() != this.isNaturalOrdering()) {\n        throw new IllegalArgumentException(\"Comparators must be the same\");\n    }\n    if (other.getComparator() != this.getComparator()) {\n        throw new IllegalArgumentException(\"Comparators must be the same\");\n    }\n    if (other.getMinimum().compareTo(this.getMaximum()) > 0) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    final T min = this.getComparator().compare(other.getMinimum(), this.getMinimum()) > 0 ? other.getMinimum() : this.getMinimum();\n    final T max = this.getComparator().compare(other.getMaximum(), this.getMaximum()) < 0 ? other.getMaximum() : this.getMaximum();\n    return new Range<T>(min, max, this.getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"The range must not be null\");\n    }\n    if (other.compareTo(this) != 0) {\n        throw new IllegalArgumentException(\"The ranges must overlap\");\n    }\n    final T min = getComparator().compare(this.minimum, other.minimum) > 0 ? other.minimum : this.minimum;\n    final T max = getComparator().compare(this.maximum, other.maximum) < 0 ? other.maximum : this.maximum;\n    return new Range<T>(min, max, getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n        if (other == null) {\n            throw new IllegalArgumentException(\"The range must not be null\");\n        }\n        if (other.compareTo(this) != 0) {\n            throw new IllegalArgumentException(\"The range must be overlapping\");\n        }\n        return new Range<T>(getMinimum(), getMaximum(), getComparator());\n    }",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"The Range must not be null\");\n    }\n    if (other.isNaturalOrdering() != this.isNaturalOrdering()) {\n        throw new IllegalArgumentException(\"The two ranges must use the same comparator\");\n    }\n    if (other.getMaximum().compareTo(this.getMinimum()) < 1) {\n        throw new IllegalArgumentException(\"The two ranges do not overlap\");\n    }\n    final T min = this.getComparator().compare(this.getMinimum(), other.getMinimum()) < 0 ? other.getMinimum() : this.getMinimum();\n    final T max = this.getComparator().compare(this.getMaximum(), other.getMaximum()) > 0 ? other.getMaximum() : this.getMaximum();\n    return new Range<T>(min, max, this.getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n        if (other == null) {\n            throw new IllegalArgumentException(\"Range must not be null\");\n        }\n        if (other.getComparator() != getComparator()) {\n            throw new IllegalArgumentException(\"Comparators must be the same\");\n        }\n        if (other.getMaximum().compareTo(getMinimum()) < 1) {\n            throw new IllegalArgumentException(\"Ranges do not overlap\");\n        }\n        final T min = getComparator().compare(getMinimum(), other.getMinimum()) > 0 ? other.getMinimum() : getMinimum();\n        final T max = getComparator().compare(getMaximum(), other.getMaximum()) < 1 ? getMaximum() : other.getMaximum();\n        return new Range<T>(min, max, getComparator());\n    }",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"The range must not be null\");\n    }\n    if (other.getComparator() != getComparator()) {\n        throw new IllegalArgumentException(\"The ranges must use the same comparator\");\n    }\n    if (other.isAfter(maximum) || other.isBefore(minimum)) {\n        throw new IllegalArgumentException(\"The ranges do not overlap\");\n    }\n    T newMin = getComparator().compare(other.minimum, minimum) > 0 ? other.minimum : minimum;\n    T newMax = getComparator().compare(maximum, other.maximum) > 0 ? maximum : other.maximum;\n    return new Range<T>(newMin, newMax, comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"The range must not be null\");\n    }\n    if (!other.isOverlapping(this)) {\n        throw new IllegalArgumentException(\"The range must overlap this range\");\n    }\n    if (other.contains(this)) {\n        return this;\n    }\n    if (this.contains(other)) {\n        return other;\n    }\n    final T min = this.getComparator().compare(this.getMinimum(), other.getMinimum()) < 0 ? other.getMinimum() : this.getMinimum();\n    final T max = this.getComparator().compare(this.getMaximum(), other.getMaximum()) > 0 ? other.getMaximum() : this.getMaximum();\n    return new Range<T>(min, max, this.getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (other.getComparator() != getComparator()) {\n        throw new IllegalArgumentException(\"Comparator must be the same\");\n    }\n    if (other.getMinimum().compareTo(getMaximum()) > 0) {\n        throw new IllegalArgumentException(\"Ranges must overlap\");\n    }\n    final T min = getComparator().compare(other.getMinimum(), getMinimum()) > 0 ? other.getMinimum() : getMinimum();\n    final T max = getComparator().compare(other.getMaximum(), getMaximum()) < 0 ? other.getMaximum() : getMaximum();\n    return new Range<T>(min, max, getComparator());\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Range must not be null\");\n    }\n    if (other.minimum.compareTo(this.maximum) > 0 || other.maximum.compareTo(this.minimum) < 0) {\n        throw new IllegalArgumentException(\"Ranges do not overlap\");\n    }\n    final T min = this.comparator.compare(this.minimum, other.minimum) < 0 ? other.minimum : this.minimum;\n    final T max = this.comparator.compare(this.maximum, other.maximum) < 0 ? this.maximum : other.maximum;\n    return new Range<T>(min, max, this.comparator);\n}",
      "public Range<T> intersectionWith(final Range<T> other)  {\n    if (other == null) {\n        throw new IllegalArgumentException(\"The range must not be null\");\n    }\n    if (other.compareTo(this) != 0) {\n        throw new IllegalArgumentException(\"The ranges must overlap\");\n    }\n    return new Range<T>(getMinimum(), getMaximum(), getComparator());\n}"
    ],
    [
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out,\n            _bufferRecycler.allocUTF8Encoder());\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    OutputStreamWriter w = new OutputStreamWriter(out, \"UTF-8\");\n    return _createGenerator(w, ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    OutputStreamWriter w = new OutputStreamWriter(out, \"UTF-8\");\n    return _createGenerator(w, ctxt);\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, out, _bufferRecycler.allocByteBuffer(JsonGenerator.DEFAULT_WRITE_BUFFER_SIZE));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out, _bufferRecycler.allocByteBuffer(JsonGenerator.DEFAULT_UTF8_ENCODING_BUFFER_SIZE));\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n        // note: this should not get called any more (caller checks, dispatches)\n        if (_generatorFeatures.isEnabled(JsonGenerator.Feature.PRETTY_PRINTING)) {\n            return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out,\n                    _generatorFeatures.isEnabled(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM));\n        }\n        return new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out,\n                _generatorFeatures.isEnabled(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM),\n                _rootValueSeparator.asUnicodeString());\n    }",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    // note: this should not get called any more (caller checks, dispatches)\n    UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt,\n            _generatorFeatures, _objectCodec, out, _bufferRecycler.allocByteBuffer(JsonGenerator.DEFAULT_GENERATOR_BUFFER_SIZE));\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    // note: this should not get called any more (caller checks, dispatches)\n    UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, _generatorFeatures,\n            _objectCodec, out, _bufferRecycler.allocUTF8Encoder());\n    if (_maximumNonEscapedChar > 0) {\n        gen.setHighestNonEscapedChar(_maximumNonEscapedChar);\n    }\n    if (_characterEscapes != null) {\n        gen.setCharacterEscapes(_characterEscapes);\n    }\n    SerializableString rootSep = _rootValueSeparator;\n    if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\n        gen.setRootValueSeparator(rootSep);\n    }\n    return gen;\n}",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n        UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out,\n                _bufferRecycler.allocUTF8Encoder(), _maximumNonEscapedChar, _characterEscapes,\n                _rootValueSeparator);\n        return gen;\n    }",
      "protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException  {\n    OutputStreamWriter writer = new OutputStreamWriter(out, \"UTF-8\");\n    return _createGenerator(writer, ctxt);\n}"
    ],
    [
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation) o1, (Annotation) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) {\n        return annotationMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}",
      "private static boolean memberEquals(final Class<?> type, final Object o1, final Object o2)  {\n    if (type.isAnnotation()) \n    {\n        return annotationArrayMemberEquals((Annotation[]) o1, (Annotation[]) o2);\n    }\n    if (type.equals(Byte.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Short.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Integer.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Character.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Long.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Float.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Double.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    if (type.equals(Boolean.TYPE)) \n    {\n        return o1.equals(o2);\n    }\n    return o1.equals(o2);\n}"
    ],
    [
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type instanceof NoResolvedType) {\n        return type;\n    }\n    if (type instanceof UnionType) {\n        UnionType unionType = (UnionType) type;\n        Set<JSType> filteredTypes = new HashSet<>();\n        for (JSType unionTypeElement : unionType.getAlternates()) {\n            JSType filteredType = filterNoResolvedType(unionTypeElement);\n            if (filteredType != null) {\n                filteredTypes.add(filteredType);\n            }\n        }\n        if (filteredTypes.size() == 0) {\n            return null;\n        } else if (filteredTypes.size() == 1) {\n            return filteredTypes.iterator().next();\n        } else {\n            return new UnionType(filteredTypes);\n        }\n    }\n    return null;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type instanceof NoResolvedType) \n    {\n        return type;\n    } \n    else \n    {\n        return getNativeType(NO_RESOLVED_TYPE);\n    }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnionType()) {\n        UnionType unionType = type.toMaybeUnionType();\n        Set<JSType> types = new HashSet<>();\n        for (JSType t : unionType.getAlternates()) {\n            if (!t.isNoResolvedType()) {\n                types.add(t);\n            }\n        }\n        if (types.size() == 0) {\n            return registry.getNativeType(NO_RESOLVED_TYPE);\n        } else if (types.size() == 1) {\n            return types.iterator().next();\n        } else {\n            return registry.createUnionType(types);\n        }\n    } else {\n        return type;\n    }\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) \n    {\n        return type;\n    }\n    if (type.isUnionType()) \n    {\n        UnionType unionType = type.toMaybeUnionType();\n        boolean hasNoResolvedType = false;\n        for (JSType alt : unionType.getAlternates()) \n        {\n            if (alt.isNoResolvedType()) \n            {\n                hasNoResolvedType = true;\n                break;\n            }\n        }\n        if (hasNoResolvedType) \n        {\n            return getNativeType(NO_RESOLVED_TYPE);\n        }\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type instanceof NoResolvedType) \n    {\n        return type;\n    }\n    else if (type instanceof FunctionType) \n    {\n        FunctionType functionType = (FunctionType) type;\n        JSType returnType = functionType.getReturnType();\n        JSType returnTypeFiltered = filterNoResolvedType(returnType);\n        if (returnType != returnTypeFiltered) \n        {\n            return functionType.getReturnType();\n        }\n        JSType receiverType = functionType.getTypeOfThis();\n        JSType receiverTypeFiltered = filterNoResolvedType(receiverType);\n        if (receiverType != receiverTypeFiltered) \n        {\n            return functionType.getTypeOfThis();\n        }\n        List<JSType> parameters = functionType.getParameterTypes();\n        List<JSType> parametersFiltered = new ArrayList<JSType>();\n        for (JSType parameter : parameters) \n        {\n            JSType parameterFiltered = filterNoResolvedType(parameter);\n            parametersFiltered.add(parameterFiltered);\n        }\n        if (!parameters.equals(parametersFiltered)) \n        {\n            return functionType.getParameterTypes();\n        }\n        JSType templateType = functionType.getTemplateTypeMap().getUnfilledTemplateTypes();\n        JSType templateTypeFiltered = filterNoResolvedType(templateType);\n        if (templateType != templateTypeFiltered) \n        {\n            return functionType.getTemplateTypeMap().getUnfilledTemplateTypes();\n        }\n        return functionType;\n    }\n    else if (type instanceof TemplatizedType) \n    {\n        TemplatizedType templatizedType = (TemplatizedType) type;\n        JSType baseType = templatizedType.getReferencedType();\n        JSType baseTypeFiltered = filterNoResolvedType(baseType);\n        if (baseType != baseTypeFiltered) \n        {\n            return templatizedType.getReferencedType();\n        }\n}\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isNoResolvedType()) \n    {\n        return type;\n    }\n    if (type.isUnionType()) \n    {\n        UnionType unionType = type.toMaybeUnionType();\n        boolean foundNoResolvedType = false;\n        for (JSType alternate : unionType.getAlternates()) \n        {\n            if (alternate.isNoResolvedType()) \n            {\n                foundNoResolvedType = true;\n                break;\n            }\n        }\n        if (foundNoResolvedType) \n        {\n            List<JSType> filteredAlternates = Lists.newArrayList();\n            for (JSType alternate : unionType.getAlternates()) \n            {\n                if (!alternate.isNoResolvedType()) \n                {\n                    filteredAlternates.add(alternate);\n                }\n            }\n            if (filteredAlternates.isEmpty()) \n            {\n                return getNativeType(NO_TYPE);\n            }\n            return createUnionType(filteredAlternates);\n        }\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnionType()) {\n        UnionType unionType = type.toMaybeUnionType();\n        if (unionType.hasAnyTypeFromDisallowedPackage()) {\n            return getNativeType(NO_RESOLVED_TYPE);\n        }\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type instanceof NoResolvedType) {\n        return type;\n    }\n    if (type instanceof FunctionType) {\n        FunctionType functionType = (FunctionType) type;\n        if (functionType.getInstanceType() instanceof NoResolvedType) {\n            return functionType.getInstanceType();\n        }\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type instanceof NoResolvedType) \n    {\n        return getNativeType(NO_RESOLVED_TYPE);\n    }\n    return type;\n}",
      "static JSType filterNoResolvedType(JSType type)  {\n    if (type.isUnionType()) {\n        UnionType unionType = type.toMaybeUnionType();\n        Set<JSType> filteredTypes = new HashSet<>();\n        for (JSType alternate : unionType.getAlternates()) {\n            if (!alternate.isNoResolvedType()) {\n                filteredTypes.add(alternate);\n            }\n        }\n        return registry.createUnionType(filteredTypes);\n    }\n    return type;\n}"
    ],
    [
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  ",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      if (node.isName()) {\n        inferNameInScope(informed, node, restrictedType);\n      } else {\n        inferSlotTypeInScope(informed, node, restrictedType);\n      }\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  ",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      declareNameInScope(informed, node, restrictedType);\n      return informed;\n    }\n    return blindScope;\n  }",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  ",
      "private FlowScope maybeRestrictName(\n      FlowScope blindScope, Node node, JSType originalType, JSType restrictedType)  {\n    if (restrictedType != null && restrictedType != originalType) {\n      FlowScope informed = blindScope.createChildFlowScope();\n      if (node instanceof Name) {\n        declareNameInScope(informed, node, restrictedType);\n      } else if (node instanceof GetProp) {\n        declareNameInScope(informed, node, restrictedType);\n      } else if (node instanceof GetElem) {\n        declareNameInScope(informed, node, restrictedType);\n      } else if (node instanceof Assign) {\n        declareNameInScope(informed, node, restrictedType);\n      } else if (node instanceof AssignAdd) {\n        declareNameInScope(informed, node, restrictedType);\n      } else if (node instanceof AssignSub) {\n        declareNameInScope(informed, node, restrictedType);\n      } else if (node instanceof AssignMul) {\n        declareNameInScope(informed, node, restrictedType);\n      } else if (node instanceof AssignDiv) {\n        declareNameInScope(informed, node, restrictedType);\n      } else if (node instanceof AssignMod) {\n        declareNameInScope(informed, node, restrictedType);\n      } else if (node instanceof AssignBitwiseOr) {\n        declareNameInScope(informed, node, restrictedType);\n      } else if (node instanceof AssignBitwiseAnd) {\n        declareNameInScope(informed, node, restrictedType);\n      } else if (node instanceof AssignBitwiseXor) {\n        declareNameInScope(informed, node, restrictedType);\n      } else if (node instanceof AssignLeftShift) {\n        declareNameInScope(informed, node, restrictedType);\n      } else if (node instanceof AssignRightShift) {\n        declareNameInScope(informed, node, restrictedType);\n      } else if (node instanceof AssignUnsignedRightShift) {\n        declareNameInScope(informed, node, restrictedType);\n      } else if (node instanceof AssignAnd) {\n}\n}\n}"
    ],
    [
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    Node typeParameters = null;\n    Node thisType = null;\n    Node parametersType = null;\n    Node resultType = null;\n\n    skipEOLs();\n    if (match(JsDocToken.LT)) {\n        typeParameters = parseTypeParameters(next());\n        if (typeParameters == null) {\n            return null;\n        }\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    skipEOLs();\n    if (match(JsDocToken.THIS)) {\n        next();\n        skipEOLs();\n        if (!match(JsDocToken.COLON)) {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n        }\n\n        skipEOLs();\n        next();\n        thisType = parseTypeName(next());\n        if (thisType == null) {\n            return null;\n        }\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    parametersType = parseParametersType(next());\n    if (parametersType == null) {\n        return null;\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    skipEOLs();\n    resultType = parseResultType(next());\n    if (resultType == null) {\n        return null;\n    }\n\n    functionType.addChildToFront(resultType);\n    if (thisType != null) {\n        functionType.addChildToFront(thisType);\n    }\n    if (typeParameters != null) {\n        functionType.addChildToFront(typeParameters);\n    }\n    functionType.addChildToFront(parametersType);\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.THIS)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n\n    next();\n    skipEOLs();\n    Node typeName = parseTypeName(next());\n    if (typeName == null) {\n      return null;\n    }\n\n    functionType.addChildToBack(typeName);\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n    }\n\n    next();\n    skipEOLs();\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n      return null;\n    }\n\n    functionType.addChildToBack(parametersType);\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    next();\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    }\n\n    functionType.addChildToBack(resultType);\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n    skipEOLs();\n    if (!match(JsDocToken.STRING) || !\"function\".equals(stream.getString())) {\n        return null;\n    }\n\n    token = next();\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.STRING) && !\"this\".equals(stream.getString())) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n\n    token = next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n\n    token = next();\n    skipEOLs();\n    Node typeName = parseTypeName(token);\n    if (typeName == null) {\n        return null;\n    }\n\n    token = next();\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n    }\n\n    token = next();\n    skipEOLs();\n    Node parametersType = parseParametersType(token);\n    if (parametersType == null) {\n        return null;\n    }\n\n    token = next();\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    next();\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n        return null;\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    functionType.addChildToBack(typeName);\n    functionType.addChildToBack(parametersType);\n    functionType.addChildToBack(resultType);\n\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    skipEOLs();\n    if (!match(JsDocToken.STRING) || !\"function\".equals(stream.getString())) {\n      return null;\n    }\n    next();\n\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n\n    skipEOLs();\n    if (!match(JsDocToken.STRING) || !\"this\".equals(stream.getString())) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n\n    skipEOLs();\n    Node typeName = parseTypeName(next());\n    if (typeName == null) {\n      return null;\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n    }\n    next();\n\n    skipEOLs();\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n      return null;\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n      return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n      return null;\n    }\n\n    Node functionType = newNode(Token.FUNCTION_TYPE);\n    functionType.addChildToBack(typeName);\n    functionType.addChildToBack(parametersType);\n    functionType.addChildToBack(resultType);\n\n    return functionType;\n  }",
      "private Node parseFunctionType(JsDocToken token)  {\n  Node functionType = newNode(Token.FUNCTION);\n  skipEOLs();\n  if (!match(JsDocToken.STRING) || !\"function\".equals(stream.getString())) \n  {\n    return null;\n  }\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.LP)) \n  {\n    return null;\n  }\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.THIS)) \n  {\n    return null;\n  }\n  next();\n  skipEOLs();\n  if (!match(JsDocToken.COLON)) \n  {\n    return null;\n  }\n  next();\n  skipEOLs();\n  Node typeName = parseTypeName(next());\n  if (typeName == null) \n  {\n    return null;\n  }\n  functionType.addChildToBack(typeName);\n  skipEOLs();\n  if (!match(JsDocToken.COMMA)) \n  {\n    return null;\n  }\n  next();\n  skipEOLs();\n  Node parametersType = parseParametersType(next());\n  if (parametersType == null) \n  {\n    return null;\n  }\n  functionType.addChildToBack(parametersType);\n  skipEOLs();\n  if (!match(JsDocToken.RP)) \n  {\n    return null;\n  }\n  next();\n  skipEOLs();\n  Node resultType = parseResultType(next());\n  if (resultType == null) \n  {\n    return null;\n  }\n  functionType.addChildToBack(resultType);\n  return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    skipEOLs();\n    if (!match(JsDocToken.STRING) || !\"function\".equals(stream.getString())) {\n        return null;\n    }\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.LP)) {\n        return null;\n    }\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.THIS)) {\n        return null;\n    }\n    next();\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) {\n        return null;\n    }\n    next();\n    skipEOLs();\n    Node typeName = parseTypeName(next());\n    if (typeName == null) {\n        return null;\n    }\n    functionType.addChildToBack(typeName);\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) {\n        return null;\n    }\n    next();\n    skipEOLs();\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) {\n        return null;\n    }\n    functionType.addChildToBack(parametersType);\n    skipEOLs();\n    if (!match(JsDocToken.RP)) {\n        return null;\n    }\n    next();\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) {\n        return null;\n    }\n    functionType.addChildToBack(resultType);\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    Node functionType = newNode(Token.FUNCTION);\n    skipEOLs();\n    if (!match(JsDocToken.STRING) || !\"function\".equals(stream.getString())) \n    {\n        return null;\n    }\n\n    token = next();\n    skipEOLs();\n    if (!match(JsDocToken.LP)) \n    {\n        return null;\n    }\n\n    token = next();\n    skipEOLs();\n    if (match(JsDocToken.THIS)) \n    {\n        token = next();\n        skipEOLs();\n        if (!match(JsDocToken.COLON)) \n        {\n            return null;\n        }\n\n        token = next();\n        skipEOLs();\n        Node thisType = parseTypeName(next());\n        if (thisType == null) \n        {\n            return null;\n        }\n\n        functionType.addChildToBack(thisType);\n        skipEOLs();\n        if (!match(JsDocToken.COMMA)) \n        {\n            return null;\n        }\n\n        token = next();\n        skipEOLs();\n    }\n\n    Node parametersType = parseParametersType(token);\n    if (parametersType == null) \n    {\n        return null;\n    }\n\n    functionType.addChildToBack(parametersType);\n    skipEOLs();\n    if (!match(JsDocToken.RP)) \n    {\n        return null;\n    }\n\n    token = next();\n    skipEOLs();\n    Node resultType = parseResultType(token);\n    if (resultType == null) \n    {\n        return null;\n    }\n\n    functionType.addChildToBack(resultType);\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    skipEOLs();\n    if (!match(JsDocToken.STRING) || !\"function\".equals(stream.getString())) \n    {\n        return null;\n    }\n    next();\n\n    skipEOLs();\n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n    next();\n\n    skipEOLs();\n    if (!match(JsDocToken.THIS)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.this\");\n    }\n    next();\n\n    skipEOLs();\n    if (!match(JsDocToken.COLON)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n    }\n    next();\n\n    skipEOLs();\n    Node typeName = parseTypeName(next());\n    if (typeName == null) \n    {\n        return null;\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.COMMA)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n    }\n    next();\n\n    skipEOLs();\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) \n    {\n        return null;\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n    next();\n\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) \n    {\n        return null;\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    functionType.addChildToBack(typeName);\n    functionType.addChildToBack(parametersType);\n    functionType.addChildToBack(resultType);\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    skipEOLs();\n    if (!match(JsDocToken.STRING) || !\"function\".equals(stream.getString())) \n    {\n        return null;\n    }\n\n    token = next();\n    skipEOLs();\n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    token = next();\n    skipEOLs();\n    if (match(JsDocToken.THIS)) \n    {\n        token = next();\n        skipEOLs();\n        if (!match(JsDocToken.COLON)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n        }\n\n        token = next();\n        skipEOLs();\n        Node thisType = parseTypeName(next());\n        if (thisType == null) \n        {\n            return null;\n        }\n\n        skipEOLs();\n        if (!match(JsDocToken.COMMA)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n        }\n\n        token = next();\n        skipEOLs();\n    }\n\n    Node paramsType = parseParametersType(token);\n    if (paramsType == null) \n    {\n        return null;\n    }\n\n    skipEOLs();\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    token = next();\n    skipEOLs();\n    Node resultType = parseResultType(token);\n    if (resultType == null) \n    {\n        return null;\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    functionType.addChildToBack(paramsType);\n    functionType.addChildToBack(resultType);\n    return functionType;\n}",
      "private Node parseFunctionType(JsDocToken token)  {\n    skipEOLs();\n    if (!match(JsDocToken.STRING) || !\"function\".equals(stream.getString())) \n    {\n        return null;\n    }\n\n    token = next();\n    skipEOLs();\n    if (!match(JsDocToken.LP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.lp\");\n    }\n\n    Node functionType = newNode(Token.FUNCTION);\n    skipEOLs();\n    if (match(JsDocToken.THIS)) \n    {\n        skipEOLs();\n        if (!match(JsDocToken.COLON)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.colon\");\n        }\n\n        token = next();\n        skipEOLs();\n        Node thisType = parseTypeName(next());\n        if (thisType == null) \n        {\n            return null;\n        }\n\n        functionType.addChildToFront(thisType);\n        skipEOLs();\n        if (!match(JsDocToken.COMMA)) \n        {\n            return reportTypeSyntaxWarning(\"msg.jsdoc.missing.comma\");\n        }\n\n        token = next();\n        skipEOLs();\n    }\n\n    Node parametersType = parseParametersType(next());\n    if (parametersType == null) \n    {\n        return null;\n    }\n\n    functionType.addChildToBack(parametersType);\n    skipEOLs();\n    if (!match(JsDocToken.RP)) \n    {\n        return reportTypeSyntaxWarning(\"msg.jsdoc.missing.rp\");\n    }\n\n    token = next();\n    skipEOLs();\n    Node resultType = parseResultType(next());\n    if (resultType == null) \n    {\n        return null;\n    }\n\n    functionType.addChildToBack(resultType);\n    return functionType;\n}"
    ],
    [
      "public static String deleteWhitespace(final String str)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final char[] chars = str.toCharArray();\n    final StringBuilder buf = new StringBuilder(chars.length);\n    for (int i = 0; i < chars.length; i++) {\n        if (!Character.isWhitespace(chars[i])) {\n            buf.append(chars[i]);\n        }\n    }\n    return buf.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chars = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chars[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chars, 0, count);\n}\n    //-----------------------------------------------------------------------",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final StringBuilder buffer = new StringBuilder(sz);\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            buffer.append(str.charAt(i));\n        }\n    }\n    return buffer.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final StringBuilder buffer = new StringBuilder(sz);\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            buffer.append(str.charAt(i));\n        }\n    }\n    return buffer.toString();\n}\n    //-----------------------------------------------------------------------",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chars = str.toCharArray();\n    final StringBuilder buf = new StringBuilder(sz);\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(chars[i])) {\n            buf.append(chars[i]);\n        }\n    }\n    return buf.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chars = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chars[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chars, 0, count);\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final char[] chars = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chars[count++] = str.charAt(i);\n        }\n    }\n    if (count == sz) {\n        return str;\n    }\n    return new String(chars, 0, count);\n}\n    //-----------------------------------------------------------------------",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final char[] chars = str.toCharArray();\n    final int len = chars.length;\n    final StringBuilder buf = new StringBuilder(len);\n    for (int i = 0; i < len; i++) {\n        if (!Character.isWhitespace(chars[i])) {\n            buf.append(chars[i]);\n        }\n    }\n    return buf.toString();\n}\n    //-----------------------------------------------------------------------",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null) {\n        return null;\n    }\n    final int sz = str.length();\n    final StringBuilder buf = new StringBuilder(sz);\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            buf.append(str.charAt(i));\n        }\n    }\n    return buf.toString();\n}",
      "public static String deleteWhitespace(final String str)  {\n    if (str == null || str.length() == 0) {\n        return str;\n    }\n    final int sz = str.length();\n    final char[] chars = new char[sz];\n    int count = 0;\n    for (int i = 0; i < sz; i++) {\n        if (!Character.isWhitespace(str.charAt(i))) {\n            chars[count++] = str.charAt(i);\n        }\n    }\n    return count == sz ? str : new String(chars, 0, count);\n}\n    //-----------------------------------------------------------------------"
    ],
    [
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n    \n    SummaryStatistics firstStatistic = statistics.iterator().next();\n    StatisticalSummaryValues aggregateValues = new StatisticalSummaryValues(\n        firstStatistic.getMean(),\n        firstStatistic.getVariance(),\n        firstStatistic.getN(),\n        firstStatistic.getMax(),\n        firstStatistic.getMin(),\n        firstStatistic.getSum()\n    );\n    \n    for (SummaryStatistics stat : statistics) \n    {\n        aggregateValues.add(stat.getMean(), stat.getVariance(), stat.getN(), stat.getMax(), stat.getMin(), stat.getSum());\n    }\n    \n    return aggregateValues;\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    SummaryStatistics aggregateStatistics = new SummaryStatistics();\n    for (SummaryStatistics stat : statistics) \n    {\n        aggregateStatistics.addValue(stat.getMean());\n        aggregateStatistics.addValue(stat.getVariance());\n        aggregateStatistics.addValue(stat.getN());\n        aggregateStatistics.addValue(stat.getMax());\n        aggregateStatistics.addValue(stat.getMin());\n        aggregateStatistics.addValue(stat.getSum());\n    }\n\n    double mean = aggregateStatistics.getMean();\n    double variance = aggregateStatistics.getVariance();\n    double n = aggregateStatistics.getN();\n    double max = aggregateStatistics.getMax();\n    double min = aggregateStatistics.getMin();\n    double sum = aggregateStatistics.getSum();\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) {\n        return null;\n    }\n\n    SummaryStatistics.SummaryStatisticsBuilder builder = new SummaryStatistics.SummaryStatisticsBuilder();\n\n    for (SummaryStatistics stat : statistics) {\n        builder.add(stat);\n    }\n\n    return builder.build();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    SummaryStatistics firstStat = statistics.iterator().next();\n    double mean = 0.0;\n    double variance = 0.0;\n    double n = 0.0;\n    double max = Double.MIN_VALUE;\n    double min = Double.MAX_VALUE;\n    double sum = 0.0;\n\n    for (SummaryStatistics stat : statistics) \n    {\n        mean += stat.getMean() * stat.getN();\n        variance += stat.getVariance() * stat.getN();\n        n += stat.getN();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        sum += stat.getSum();\n    }\n\n    mean /= n;\n    variance /= n;\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    double mean = 0;\n    double variance = 0;\n    double n = 0;\n    double max = Double.MIN_VALUE;\n    double min = Double.MAX_VALUE;\n    double sum = 0;\n\n    for (SummaryStatistics stat : statistics) \n    {\n        mean += stat.getMean() * stat.getN();\n        variance += stat.getVariance() * stat.getN();\n        n += stat.getN();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        sum += stat.getSum();\n    }\n\n    mean /= n;\n    variance /= n;\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n    \n    SummaryStatistics aggregateStatistics = new SummaryStatistics();\n    \n    for (SummaryStatistics stat : statistics) \n    {\n        aggregateStatistics.addValue(stat.getMean());\n        aggregateStatistics.addValue(stat.getVariance());\n        aggregateStatistics.addValue(stat.getN());\n        aggregateStatistics.addValue(stat.getMax());\n        aggregateStatistics.addValue(stat.getMin());\n        aggregateStatistics.addValue(stat.getSum());\n    }\n    \n    double mean = aggregateStatistics.getMean();\n    double variance = aggregateStatistics.getVariance();\n    double n = aggregateStatistics.getN();\n    double max = aggregateStatistics.getMax();\n    double min = aggregateStatistics.getMin();\n    double sum = aggregateStatistics.getSum();\n    \n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    SummaryStatistics combined = new AggregatingSummaryStatistics();\n\n    for (SummaryStatistics stat : statistics) \n    {\n        combined.add(stat);\n    }\n\n    return combined.getSummary();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    SummaryStatistics.Builder builder = new SummaryStatistics.Builder();\n\n    for (SummaryStatistics stat : statistics) \n    {\n        builder.add(stat);\n    }\n\n    return builder.build();\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    SummaryStatistics firstStat = statistics.iterator().next();\n    double mean = 0.0;\n    double variance = 0.0;\n    double n = 0.0;\n    double max = Double.MIN_VALUE;\n    double min = Double.MAX_VALUE;\n    double sum = 0.0;\n\n    for (SummaryStatistics stat : statistics) \n    {\n        mean += stat.getMean() * stat.getN();\n        variance += stat.getVariance() * stat.getN();\n        n += stat.getN();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        sum += stat.getSum();\n    }\n\n    mean /= n;\n    variance /= n;\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}",
      "public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics)  {\n    if (statistics == null || statistics.isEmpty()) \n    {\n        return null;\n    }\n\n    double mean = 0.0;\n    double variance = 0.0;\n    double n = 0.0;\n    double max = Double.MIN_VALUE;\n    double min = Double.MAX_VALUE;\n    double sum = 0.0;\n\n    for (SummaryStatistics stat : statistics) \n    {\n        mean += stat.getMean() * stat.getN();\n        variance += stat.getVariance() * stat.getN();\n        n += stat.getN();\n        max = Math.max(max, stat.getMax());\n        min = Math.min(min, stat.getMin());\n        sum += stat.getSum();\n    }\n\n    mean /= n;\n    variance /= n;\n\n    return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n}"
    ],
    [
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            double diff = sample1[i] - sample2[i];\n            result += diff * diff - meanDifference * meanDifference;\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i];\n        result += diff * diff - meanDifference * meanDifference;\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            double diff = sample1[i] - sample2[i];\n            result += diff * diff - meanDifference * meanDifference;\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            double diff = sample1[i] - sample2[i];\n            result += diff * diff - meanDifference * meanDifference;\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            double diff = sample1[i] - sample2[i];\n            result += diff * diff - meanDifference * meanDifference;\n        }\n        return result / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    double sumSquareDifference = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i];\n        sumSquareDifference += diff * diff;\n    }\n    return sumSquareDifference / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n    int n = sample1.length;\n    if (n != sample2.length) {\n        throw new DimensionMismatchException(n, sample2.length);\n    }\n    if (n < 2) {\n        throw new NumberIsTooSmallException(n, 2, true);\n    }\n    double result = 0;\n    for (int i = 0; i < n; i++) {\n        double diff = sample1[i] - sample2[i];\n        result += diff * diff - meanDifference * meanDifference;\n    }\n    return result / (n - 1);\n}",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double sumSquareDifference = 0;\n        for (int i = 0; i < n; i++) {\n            double diff = sample1[i] - sample2[i];\n            sumSquareDifference += diff * diff;\n        }\n        return sumSquareDifference / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double sumSquareDifference = 0;\n        for (int i = 0; i < n; i++) {\n            double difference = sample1[i] - sample2[i];\n            sumSquareDifference += difference * difference;\n        }\n        return sumSquareDifference / (n - 1);\n    }",
      "public static double varianceDifference(final double[] sample1,\n            final double[] sample2, double meanDifference) throws DimensionMismatchException,\n            NumberIsTooSmallException  {\n        int n = sample1.length;\n        if (n != sample2.length) {\n            throw new DimensionMismatchException(n, sample2.length);\n        }\n        if (n < 2) {\n            throw new NumberIsTooSmallException(n, 2, true);\n        }\n        double result = 0;\n        for (int i = 0; i < n; i++) {\n            double diff = sample1[i] - sample2[i];\n            result += diff * diff - meanDifference * meanDifference;\n        }\n        return result / (n - 1);\n    }"
    ],
    [
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int categoryCount = dataset.getCategoryCount();\n    for (int i = 0; i < categoryCount; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() > 0) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int categoryCount = dataset.getCategoryCount();\n    for (int i = 0; i < categoryCount; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() >= 0.0) {\n            total = total + value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int categoryCount = dataset.getCategoryCount();\n    for (int i = 0; i < categoryCount; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            double v = value.doubleValue();\n            if (v > 0) {\n                total = total + v;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int categoryCount = dataset.getCategoryCount();\n    for (int i = 0; i < categoryCount; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null && value.doubleValue() > 0.0) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int categoryCount = dataset.getCategoryCount();\n    for (int i = 0; i < categoryCount; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int categoryCount = dataset.getCategoryCount();\n    for (int category = 0; category < categoryCount; category++) \n    {\n        Number value = dataset.getValue(category);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) {\n        Number value = dataset.getValue(i);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int categoryCount = dataset.getCategoryCount();\n    for (int i = 0; i < categoryCount; i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) \n    {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int itemCount = dataset.getItemCount();\n    for (int i = 0; i < itemCount; i++) \n    {\n        Number value = dataset.getValue(i);\n        if (value != null) \n        {\n            double v = value.doubleValue();\n            if (v > 0.0) \n            {\n                total += v;\n            }\n        }\n    }\n    return total;\n}",
      "public static double calculatePieDatasetTotal(PieDataset dataset)  {\n    if (dataset == null) {\n        throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n    }\n    double total = 0.0;\n    int categoryCount = dataset.getCategoryCount();\n    for (int category = 0; category < categoryCount; category++) {\n        Number value = dataset.getValue(category);\n        if (value != null) {\n            total += value.doubleValue();\n        }\n    }\n    return total;\n}"
    ],
    [
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED) {\n    return nextUnquotedValue();\n  } else if (p == PEEKED_SINGLE_QUOTED) {\n    return nextQuotedValue('\\'');\n  } else if (p == PEEKED_DOUBLE_QUOTED) {\n    return nextQuotedValue('\"');\n  } else if (p == PEEKED_BUFFERED) {\n    return peekedString;\n  } else if (p == PEEKED_LONG) {\n    return Long.toString(peekedLong);\n  } else if (p == PEEKED_NUMBER) {\n    return new String(buffer, pos, peekedNumberLength);\n  } else {\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathNames[stackSize - 1] = peekedString;\n  peekedString = null;\n  return result;\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) {\n        return nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n        return nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n        return nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n        return peekedString;\n    } else {\n        throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = peekedString;\n    peekedString = null;\n    return peekedString;\n}",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED) \n  {\n    return nextUnquotedValue();\n  } \n  else if (p == PEEKED_SINGLE_QUOTED) \n  {\n    return nextQuotedValue('\\'');\n  } \n  else if (p == PEEKED_DOUBLE_QUOTED) \n  {\n    return nextQuotedValue('\"');\n  } \n  else if (p == PEEKED_BUFFERED) \n  {\n    return peekedString;\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathNames[stackSize - 1] = peekedString;\n  peekedString = null;\n  return pathNames[stackSize - 1];\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) {\n        peeked = PEEKED_NONE;\n        return nextUnquotedValue();\n    } else if (p == PEEKED_SINGLE_QUOTED) {\n        peeked = PEEKED_NONE;\n        return nextQuotedValue('\\'');\n    } else if (p == PEEKED_DOUBLE_QUOTED) {\n        peeked = PEEKED_NONE;\n        return nextQuotedValue('\"');\n    } else if (p == PEEKED_BUFFERED) {\n        peeked = PEEKED_NONE;\n        return peekedString;\n    } else if (p == PEEKED_LONG || p == PEEKED_NUMBER) {\n        throw new IllegalStateException(\"Expected a property name but was \" + peek() + locationString());\n    } else {\n        throw new IllegalStateException(\"Expected a property name but was \" + peek() + locationString());\n    }\n}",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED) \n  {\n    return nextUnquotedValue();\n  } \n  else if (p == PEEKED_SINGLE_QUOTED) \n  {\n    return nextQuotedValue('\\'');\n  } \n  else if (p == PEEKED_DOUBLE_QUOTED) \n  {\n    return nextQuotedValue('\"');\n  } \n  else if (p == PEEKED_BUFFERED) \n  {\n    return peekedString;\n  } \n  else if (p == PEEKED_LONG) \n  {\n    return Long.toString(peekedLong);\n  } \n  else if (p == PEEKED_NUMBER) \n  {\n    return new String(buffer, pos, peekedNumberLength);\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathNames[stackSize - 1] = peekedString;\n  peekedString = null;\n  return result;\n}",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED) \n  {\n    return nextUnquotedValue();\n  } \n  else if (p == PEEKED_SINGLE_QUOTED) \n  {\n    return nextQuotedValue('\\'');\n  } \n  else if (p == PEEKED_DOUBLE_QUOTED) \n  {\n    return nextQuotedValue('\"');\n  } \n  else if (p == PEEKED_BUFFERED) \n  {\n    return peekedString;\n  } \n  else if (p == PEEKED_LONG) \n  {\n    return Long.toString(peekedLong);\n  } \n  else if (p == PEEKED_NUMBER) \n  {\n    return new String(buffer, pos, peekedNumberLength);\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathNames[stackSize - 1] = peekedString;\n  peekedString = null;\n  return result;\n}",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED) \n  {\n    return nextUnquotedValue();\n  } \n  else if (p == PEEKED_SINGLE_QUOTED) \n  {\n    return nextQuotedValue('\\'');\n  } \n  else if (p == PEEKED_DOUBLE_QUOTED) \n  {\n    return nextQuotedValue('\"');\n  } \n  else if (p == PEEKED_BUFFERED) \n  {\n    return peekedString;\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathNames[stackSize - 1] = peekedString;\n  peekedString = null;\n  return result;\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    String result;\n    if (p == PEEKED_UNQUOTED) \n    {\n        result = nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        result = nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        result = nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_BUFFERED) \n    {\n        result = peekedString;\n        peekedString = null;\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = result;\n    return result;\n}",
      "public String nextName() throws IOException  {\n  int p = peeked;\n  if (p == PEEKED_NONE) \n  {\n    p = doPeek();\n  }\n  if (p == PEEKED_UNQUOTED) \n  {\n    return nextUnquotedValue();\n  } \n  else if (p == PEEKED_SINGLE_QUOTED) \n  {\n    return nextQuotedValue('\\'');\n  } \n  else if (p == PEEKED_DOUBLE_QUOTED) \n  {\n    return nextQuotedValue('\"');\n  } \n  else if (p == PEEKED_BUFFERED) \n  {\n    return peekedString;\n  } \n  else if (p == PEEKED_LONG) \n  {\n    return Long.toString(peekedLong);\n  } \n  else if (p == PEEKED_NUMBER) \n  {\n    return new String(buffer, pos, peekedNumberLength);\n  } \n  else \n  {\n    throw new IllegalStateException(\"Expected a property name but was \" + peek() + locationString());\n  }\n  peeked = PEEKED_NONE;\n  pathNames[stackSize - 1] = peekedString;\n  peekedString = null;\n  return result;\n}",
      "public String nextName() throws IOException  {\n    int p = peeked;\n    if (p == PEEKED_NONE) \n    {\n        p = doPeek();\n    }\n    if (p == PEEKED_UNQUOTED) \n    {\n        return nextUnquotedValue();\n    } \n    else if (p == PEEKED_SINGLE_QUOTED) \n    {\n        return nextQuotedValue('\\'');\n    } \n    else if (p == PEEKED_DOUBLE_QUOTED) \n    {\n        return nextQuotedValue('\"');\n    } \n    else if (p == PEEKED_BUFFERED) \n    {\n        return peekedString;\n    } \n    else if (p == PEEKED_LONG) \n    {\n        return Long.toString(peekedLong);\n    } \n    else if (p == PEEKED_NUMBER) \n    {\n        return new String(buffer, pos, peekedNumberLength);\n    } \n    else \n    {\n        throw new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n    }\n    peeked = PEEKED_NONE;\n    pathNames[stackSize - 1] = peekedString;\n    peekedString = null;\n    return pathNames[stackSize - 1];\n}"
    ],
    [
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}",
      "public static int[] toPrimitive(final Integer[] array, final int valueForNull)  {\n    if (array == null) \n    {\n        return null;\n    } \n    else if (array.length == 0) \n    {\n        return EMPTY_INT_ARRAY;\n    }\n    final int[] result = new int[array.length];\n    for (int i = 0; i < array.length; i++) \n    {\n        final Integer b = array[i];\n        result[i] = (b == null ? valueForNull : b.intValue());\n    }\n    return result;\n}"
    ],
    [
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) \n    {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) \n    {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    return currentCompressedChunk.read(b, off, len);\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) \n    {\n        return -1;\n    }\n    return currentCompressedChunk.read(b, off, len);\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    return currentCompressedChunk.read(b, off, len);\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) \n    {\n        return -1;\n    }\n    return currentCompressedChunk.read(b, off, len);\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) \n    {\n        if (endReached) \n        {\n            return -1;\n        }\n        fill();\n    }\n\n    if (currentCompressedChunk == null) \n    {\n        return -1;\n    }\n\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) \n    {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n        return readOnce(b, off, len);\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    int read = currentCompressedChunk.read(b, off, len);\n    if (read == -1) {\n        currentCompressedChunk.close();\n        currentCompressedChunk = null;\n    }\n    return read;\n}",
      "private int readOnce(final byte[] b, final int off, final int len) throws IOException  {\n    if (currentCompressedChunk == null) {\n        return -1;\n    }\n    return currentCompressedChunk.read(b, off, len);\n}"
    ],
    [
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node callOrNewOrDotCall = site.getNode();\n    if (callOrNewOrDotCall.isCall() || callOrNewOrDotCall.isNew()) {\n        return callOrNewOrDotCall.getChildAtIndex(argIndex + 1);\n    } else if (callOrNewOrDotCall.isDotCall()) {\n        return callOrNewOrDotCall.getLastChild();\n    } else {\n        throw new IllegalArgumentException(\"Unexpected node type: \" + callOrNewOrDotCall);\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.getNode();\n    if (call.isCall() || call.isNew()) {\n        return call.getChildAtIndex(argIndex + 1);\n    } else if (call.isGetProp()) {\n        return call.getLastChild();\n    } else {\n        return null;\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.getNode();\n    if (call.isNew()) {\n      return call.getFirstChild().getNext();\n    } else if (call.isCall()) {\n      return NodeUtil.getArgumentForCallOrNewOrDotCall(call, argIndex);\n    } else if (call.isGetElem()) {\n      return NodeUtil.getArgumentForCallOrNewOrDotCall(call, argIndex);\n    } else if (call.isGetProp()) {\n      return NodeUtil.getArgumentForCallOrNewOrDotCall(call, argIndex);\n    } else {\n      throw new IllegalStateException(\"Unexpected node type: \" + call);\n    }\n  }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node call = site.node;\n    Node arg = call.getFirstChild().getNext();\n    for (int i = 0; i < argIndex; i++) {\n        arg = arg.getNext();\n    }\n    return arg;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node callOrNewOrDotCall = site.getNode();\n    if (callOrNewOrDotCall.isNew()) {\n      callOrNewOrDotCall = callOrNewOrDotCall.getFirstChild();\n    }\n    Node arg = callOrNewOrDotCall.getFirstChild().getNext();\n    for (int i = 0; i < argIndex; i++) {\n      arg = arg.getNext();\n    }\n    return arg;\n  }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node callNode = site.getNode();\n    if (callNode.isCall() || callNode.isNew()) {\n        Node args = callNode.getLastChild();\n        if (args != null) {\n            return args.getChildAtIndex(argIndex);\n        }\n    } else if (callNode.isGetElem()) {\n        Node parent = callNode.getParent();\n        if (parent != null && parent.isCall()) {\n            Node args = parent.getLastChild();\n            if (args != null) {\n                return args.getChildAtIndex(argIndex);\n            }\n        }\n    } else if (callNode.isDot()) {\n        Node parent = callNode.getParent();\n        if (parent != null && parent.isCall()) {\n            Node args = parent.getLastChild();\n            if (args != null) {\n                return args.getChildAtIndex(argIndex);\n            }\n        }\n    }\n    return null;\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node callOrNewOrDotCall = site.getNode();\n    Node parent = callOrNewOrDotCall.getParent();\n    if (callOrNewOrDotCall.isNew()) {\n        // new Foo(a, b, c)\n        return callOrNewOrDotCall.getFirstChild().getNext();\n    } else if (callOrNewOrDotCall.isCall() || callOrNewOrDotCall.isDotCall()) {\n        // Foo(a, b, c)\n        // Foo.bar(a, b, c)\n        if (argIndex < 0) {\n            return null;\n        }\n        Node params = callOrNewOrDotCall.getLastChild();\n        Node arg = params.getFirstChild();\n        for (int i = 0; i < argIndex; i++) {\n            if (arg == null) {\n                return null;\n            }\n            arg = arg.getNext();\n        }\n        return arg;\n    } else {\n        throw new IllegalArgumentException(\n                \"Unexpected node type: \" + callOrNewOrDotCall.getToken());\n    }\n}",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node callNode = site.getNode();\n    if (callNode.isCall() || callNode.isNew()) {\n      Node args = callNode.getLastChild();\n      if (args != null && args.isArrayLit()) {\n        return args.getChildAtIndex(argIndex);\n      }\n    } else if (callNode.isDot() || callNode.isGetElem()) {\n      Node arg = callNode.getNext();\n      if (arg != null && argIndex == 0) {\n        return arg;\n      }\n    }\n    return null;\n  }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node callNode = site.getNode();\n    if (callNode.isNew()) {\n      return callNode.getFirstChild().getNext();\n    } else if (callNode.isCall() || callNode.isDotCall()) {\n      Node args = callNode.getLastChild();\n      return args.getChildAtIndex(argIndex);\n    } else {\n      throw new IllegalStateException(\"Unexpected node type: \" + callNode);\n    }\n  }",
      "private static Node getArgumentForCallOrNewOrDotCall(UseSite site,\n        final int argIndex)  {\n    Node callOrNewOrDotCall = site.getNode();\n    if (callOrNewOrDotCall.isNew()) {\n      callOrNewOrDotCall = callOrNewOrDotCall.getFirstChild();\n    }\n    return callOrNewOrDotCall.getChildAtIndex(argIndex + 1);\n  }"
    ],
    [
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) \n    {\n        JSDocInfo info = type.getJSDocInfo();\n        if (info != null && info.isDeprecated()) \n        {\n            if (info.getDeprecationReason() != null) \n            {\n                return info.getDeprecationReason();\n            }\n\n            return \"\";\n        }\n    }\n\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) \n    {\n        JSDocInfo info = type.getJSDocInfo();\n        if (info != null && info.isDeprecated()) \n        {\n            if (info.getDeprecationReason() != null) \n            {\n                return info.getDeprecationReason();\n            }\n\n            return \"\";\n        }\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type != null) \n  {\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) \n    {\n      if (info.getDeprecationReason() != null) \n      {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n  }\n  return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) \n    {\n        JSDocInfo info = type.getJSDocInfo();\n        if (info != null && info.isDeprecated()) \n        {\n            if (info.getDeprecationReason() != null) \n            {\n                return info.getDeprecationReason();\n            }\n\n            return \"\";\n        }\n    }\n\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type == null) {\n        return null;\n    }\n    ObjectType objType = ObjectType.cast(type);\n    if (objType == null) {\n        return null;\n    }\n    JSDocInfo info = objType.getJSDocInfo();\n    if (info == null) {\n        return null;\n    }\n    if (info.isDeprecated()) {\n        if (info.getDeprecationReason() != null) {\n            return info.getDeprecationReason();\n        }\n        return \"\";\n    }\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) \n    {\n        JSDocInfo info = type.getJSDocInfo();\n        if (info != null && info.isDeprecated()) \n        {\n            if (info.getDeprecationReason() != null) \n            {\n                return info.getDeprecationReason();\n            }\n\n            return \"\";\n        }\n    }\n\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) {\n        JSDocInfo info = type.getJSDocInfo();\n        if (info != null && info.isDeprecated()) {\n            if (info.getDeprecationReason() != null) {\n                return info.getDeprecationReason();\n            }\n\n            return \"\";\n        }\n    }\n\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    if (type != null) {\n        JSDocInfo info = type.getJSDocInfo();\n        if (info != null && info.isDeprecated()) {\n            if (info.getDeprecationReason() != null) {\n                return info.getDeprecationReason();\n            }\n\n            return \"\";\n        }\n    }\n\n    return null;\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n  if (type == null) {\n    return null;\n  }\n  ObjectType objType = ObjectType.cast(type);\n  if (objType == null) {\n    return null;\n  }\n  JSDocInfo info = objType.getJSDocInfo();\n  if (info == null) {\n    return null;\n  }\n  if (!info.isDeprecated()) {\n    return null;\n  }\n  if (info.getDeprecationReason() == null) {\n    return \"\";\n  }\n  return info.getDeprecationReason();\n}",
      "private static String getTypeDeprecationInfo(JSType type)  {\n    ObjectType objType = ObjectType.cast(type);\n    if (objType != null) \n    {\n        JSDocInfo info = objType.getJSDocInfo();\n        if (info != null && info.isDeprecated()) \n        {\n            if (info.getDeprecationReason() != null) \n            {\n                return info.getDeprecationReason();\n            }\n\n            return \"\";\n        }\n    }\n    return null;\n}"
    ],
    [
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = (String) cachedTimeZoneDisplay.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cachedTimeZoneDisplay.put(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = (String) timeZoneDisplayCache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        timeZoneDisplayCache.put(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = (String) cache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cache.put(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = (String) cachedTimeZoneDisplay.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cachedTimeZoneDisplay.put(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cache.put(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = (String)cache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cache.put(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = getSharedInstance(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        putSharedInstance(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n        final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n        String value = cache.timeZoneDisplayCache.get(key);\n        if (value == null) {\n            value = tz.getDisplayName(daylight, style, locale);\n            cache.timeZoneDisplayCache.put(key, value);\n        }\n        return value;\n    }",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    final TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = (String) cachedTimeZoneDisplayStrings.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cachedTimeZoneDisplayStrings.put(key, value);\n    }\n    return value;\n}",
      "static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale)  {\n    TimeZoneDisplayKey key = new TimeZoneDisplayKey(tz, daylight, style, locale);\n    String value = cache.get(key);\n    if (value == null) {\n        value = tz.getDisplayName(daylight, style, locale);\n        cache.put(key, value);\n    }\n    return value;\n}"
    ],
    [
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) \n    {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    if (key == null) {\n        throw new IllegalArgumentException(\"Null 'key' argument.\");\n    }\n    return this.columnKeys.indexOf(key);\n}",
      "public int getColumnIndex(Comparable key)  {\n    return this.columnKeys.indexOf(key);\n}"
    ],
    [
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lowerBound - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upperBound + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lowerBound + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > upperBound - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lowerBound - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upperBound + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lowerBound + tolerance || point > upperBound - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lowerBound - tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point > upperBound + tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point < lowerBound + tolerance || point > upperBound - tolerance) {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lowerBound - tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point > upperBound + tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point < lowerBound + tolerance || point > upperBound - tolerance) {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point <= lowerBound + tolerance) {\n        return Location.INSIDE;\n    } else if (point >= upperBound - tolerance) {\n        return Location.OUTSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lowerBound - tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point > upperBound + tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point < lowerBound + tolerance || point > upperBound - tolerance) {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point <= lowerBound + tolerance) {\n        return Location.INSIDE;\n    } else if (point >= upperBound - tolerance) {\n        return Location.OUTSIDE;\n    } else {\n        return Location.BOUNDARY;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lowerBound - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upperBound + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lowerBound + tolerance || point > upperBound - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lowerBound - tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point > upperBound + tolerance) {\n        return Location.OUTSIDE;\n    }\n    if (point < lowerBound + tolerance || point > upperBound - tolerance) {\n        return Location.BOUNDARY;\n    }\n    return Location.INSIDE;\n}",
      "public Location checkPoint(final double point, final double tolerance)  {\n    if (point < lowerBound - tolerance) {\n        return Location.OUTSIDE;\n    } else if (point > upperBound + tolerance) {\n        return Location.OUTSIDE;\n    } else if (point < lowerBound + tolerance) {\n        return Location.BOUNDARY;\n    } else if (point > upperBound - tolerance) {\n        return Location.BOUNDARY;\n    } else {\n        return Location.INSIDE;\n    }\n}"
    ],
    [
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}",
      "public static TickUnitSource createLogTickUnits(Locale locale)  {\n    TickUnits units = new TickUnits();\n    NumberFormat numberFormat = NumberFormat.getNumberInstance(locale);\n    units.add(new NumberTickUnit(1, numberFormat, 2));\n    units.add(new NumberTickUnit(2, numberFormat, 2));\n    units.add(new NumberTickUnit(5, numberFormat, 5));\n    units.add(new NumberTickUnit(10, numberFormat, 2));\n    units.add(new NumberTickUnit(20, numberFormat, 2));\n    units.add(new NumberTickUnit(50, numberFormat, 5));\n    units.add(new NumberTickUnit(100, numberFormat, 2));\n    units.add(new NumberTickUnit(200, numberFormat, 2));\n    units.add(new NumberTickUnit(500, numberFormat, 5));\n    units.add(new NumberTickUnit(1000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000, numberFormat, 2));\n    units.add(new NumberTickUnit(20000, numberFormat, 2));\n    units.add(new NumberTickUnit(50000, numberFormat, 5));\n    units.add(new NumberTickUnit(100000, numberFormat, 2));\n    units.add(new NumberTickUnit(200000, numberFormat, 2));\n    units.add(new NumberTickUnit(500000, numberFormat, 5));\n    units.add(new NumberTickUnit(1000000, numberFormat, 2));\n    units.add(new NumberTickUnit(2000000, numberFormat, 2));\n    units.add(new NumberTickUnit(5000000, numberFormat, 5));\n    units.add(new NumberTickUnit(10000000, numberFormat, 2));\n}"
    ],
    [
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int maxIndex = -1;\n    double maxValue = Double.NEGATIVE_INFINITY;\n    for (int i = 0; i < tableau.getWidth(); i++) \n    {\n        double value = tableau.getEntry(0, i);\n        if (value < maxValue) \n        {\n            maxValue = value;\n            maxIndex = i;\n        }\n    }\n    return maxIndex;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double maxCoefficient = Double.MIN_VALUE;\n    Integer pivotColumn = null;\n    for (int i = 0; i < tableau.getWidth(); i++) \n    {\n        double coefficient = tableau.getEntry(0, i);\n        if (coefficient < maxCoefficient) \n        {\n            maxCoefficient = coefficient;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double minCoefficient = Double.MAX_VALUE;\n    Integer pivotColumn = null;\n    for (int i = 0; i < tableau.getWidth(); i++) \n    {\n        double coefficient = tableau.getEntry(0, i);\n        if (coefficient < minCoefficient) \n        {\n            minCoefficient = coefficient;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double max = Double.NEGATIVE_INFINITY;\n    Integer col = null;\n    for (int i = 0; i < tableau.getWidth(); i++) \n    {\n        double value = tableau.getEntry(0, i);\n        if (value < max) \n        {\n            max = value;\n            col = i;\n        }\n    }\n    return col;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double maxCoefficient = Double.MIN_VALUE;\n    Integer pivotColumn = null;\n    for (int i = 0; i < tableau.getWidth(); i++) \n    {\n        double coefficient = tableau.getEntry(0, i);\n        if (coefficient < maxCoefficient) \n        {\n            maxCoefficient = coefficient;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int maxCol = -1;\n    double maxVal = Double.NEGATIVE_INFINITY;\n    for (int i = 0; i < tableau.getWidth(); i++) \n    {\n        double val = tableau.getEntry(0, i);\n        if (val < maxVal) \n        {\n            maxVal = val;\n            maxCol = i;\n        }\n    }\n    return maxCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double min = Double.MAX_VALUE;\n    Integer pivotCol = null;\n    for (int i = 0; i < tableau.getWidth(); i++) \n    {\n        double coeff = tableau.getEntry(0, i);\n        if (coeff < min) \n        {\n            min = coeff;\n            pivotCol = i;\n        }\n    }\n    return pivotCol;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    int col = 0;\n    double maxCoefficient = Double.MIN_VALUE;\n    for (int i = 0; i < tableau.getWidth(); i++) \n    {\n        double coefficient = tableau.getEntry(0, i);\n        if (coefficient < maxCoefficient) \n        {\n            maxCoefficient = coefficient;\n            col = i;\n        }\n    }\n    return col;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double maxCoefficient = Double.NEGATIVE_INFINITY;\n    Integer pivotColumn = null;\n    for (int i = 0; i < tableau.getWidth(); i++) \n    {\n        double coefficient = tableau.getEntry(0, i);\n        if (coefficient < maxCoefficient) \n        {\n            maxCoefficient = coefficient;\n            pivotColumn = i;\n        }\n    }\n    return pivotColumn;\n}",
      "private Integer getPivotColumn(SimplexTableau tableau)  {\n    double min = Double.MAX_VALUE;\n    Integer col = null;\n    for (int i = 0; i < tableau.getWidth(); i++) \n    {\n        double val = tableau.getEntry(0, i);\n        if (val < min) \n        {\n            min = val;\n            col = i;\n        }\n    }\n    return col;\n}"
    ]
  ]
}